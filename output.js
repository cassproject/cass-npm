if (global.XMLHttpRequest === undefined)
	var XMLHttpRequest = require("xmlhttprequest").XMLHttpRequest;
else
	var XMLHttpRequest = global.XMLHttpRequest;

var request = require("request");
var isNodeJs = {};
require("text-encoding");
if (global.forge === undefined)
	if (typeof __webpack_require__ === 'function')
		var forge = require("forge");
	else
		var forge = require("node-forge");
else
	var forge = global.forge;
var base64 = require('base64-arraybuffer');
var FormData = require('form-data');
var antlr4 = require('antlr4/index');
var pemJwk = require('pem-jwk');

var crypto = null;
if (crypto === undefined)
try {
  crypto = {subtle:require('crypto').webcrypto};
} catch (err) {
  crypto = {subtle:null};
}

if (global.window === undefined)
	var window = {
		crypto: crypto
	};
else
	var window = global.window;
if (global.Worker === undefined)
	var Worker = null;
else
	var Worker = global.Worker;
if (global.document === undefined)
	var document = {};
else
	var document = global.document;
if (global.view === undefined)
	var view = {};
else
	var view = global.view;
if (global.localStorage === undefined)
	var localStorage = {};
else
	var localStorage = global.localStorage;

var esprima = require('esprima');
var results = [];

if (document && document.getElementsByTagName)
{
	var scripts = document.getElementsByTagName("script");
	window.scriptPath = scripts[scripts.length-1].src.substr(0,scripts[scripts.length-1].src.lastIndexOf("/"))+"/";
}

function generateUUID(){
    var d = new Date().getTime();
    if(window && window.performance && typeof window.performance.now === "function"){
        d += performance.now();; //use high-precision timer if available
    }
    var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        var r = (d + Math.random()*16)%16 | 0;
        d = Math.floor(d/16);
        return (c=='x' ? r : (r&0x3|0x8)).toString(16);
    });
    return uuid;
}

function base64ToBlob(base64Data, contentType) {
    contentType = contentType || '';
    var sliceSize = 1024;
    var byteCharacters = forge.util.decode64(base64Data);
    var bytesLength = byteCharacters.length;
    var slicesCount = Math.ceil(bytesLength / sliceSize);
    var byteArrays = new Array(slicesCount);

    for (var sliceIndex = 0; sliceIndex < slicesCount; ++sliceIndex) {
        var begin = sliceIndex * sliceSize;
        var end = Math.min(begin + sliceSize, bytesLength);

        var bytes = new Array(end - begin);
        for (var offset = begin, i = 0 ; offset < end; ++i, ++offset) {
            bytes[i] = byteCharacters[offset].charCodeAt(0);
        }
        byteArrays[sliceIndex] = new Uint8Array(bytes);
    }
    return new Blob(byteArrays, { type: contentType });
}

function stringToFile(string,filename,contentType){
	return new File([string],filename,{type:contentType});
}

function ecKeys(obj){return Object.keys(obj);}

function ab2str(buf) {
	return new TextDecoder("utf-8").decode(buf);
}

function str2ab(str) {
	return new TextEncoder("utf-8").encode(str).buffer;
}

function ecLog(str){
if (console)
	if (console.log)
	{
		console.log(str);
		return;
	}
else
	if (print)
		print(str);
}
/*
 *  Copyright 2011 Alexandru Craciun, Eyal Kaspi
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
/**** Functionality in Java, but not in JS ********
 * methods added to JS prototypes
 */

var stjs={};

stjs.NOT_IMPLEMENTED = function(){
	throw "This method is not implemented in Javascript.";
};

stjs.JavalikeEquals = function(value){
	if (value == null)
		return false;
	if (value.valueOf)
		return this.valueOf() === value.valueOf();
	return this === value;
};

stjs.JavalikeGetClass = function(){
	return this.constructor;
};

/* String */
if (!String.prototype.equals) {
	String.prototype.equals=stjs.JavalikeEquals;
}
if (!String.prototype.getBytes) {
	String.prototype.getBytes=stjs.NOT_IMPLEMENTED;
}
if (!String.prototype.getChars) {
	String.prototype.getChars=stjs.NOT_IMPLEMENTED;
}
if (!String.prototype.contentEquals){
	String.prototype.contentEquals=stjs.NOT_IMPLEMENTED;
}
if (!String.prototype.startsWith) {
	String.prototype.startsWith=function(start, from){
		var f = from != null ? from : 0;
		return this.substring(f, f + start.length) == start;
	}
}
if (!String.prototype.endsWith) {
	String.prototype.endsWith=function(end){
		if (end == null)
			return false;
		if (this.length < end.length)
			return false;
		return this.substring(this.length - end.length, this.length) == end;
	}
}
if (!String.prototype.trim) {
	stjs.trimLeftRegExp = /^\s+/;
	stjs.trimRightRegExp = /\s+$/;
	String.prototype.trim = function() {
		return this.replace(stjs.trimLeftRegExp, "").replace(stjs.trimRightRegExp, "");
	}
}
if (!String.prototype.matches){
	String.prototype.matches=function(regexp){
		return this.match("^" + regexp + "$") != null;
	}
}
if (!String.prototype.compareTo){
	String.prototype.compareTo=function(other){
		if (other == null)
			return 1;
		if (this < other)
			return -1;
		if (this == other)
			return 0;
		return 1;
	}
}

if (!String.prototype.compareToIgnoreCase){
	String.prototype.compareToIgnoreCase=function(other){
		if (other == null)
			return 1;
		return this.toLowerCase().compareTo(other.toLowerCase());
	}
}

if (!String.prototype.equalsIgnoreCase){
	String.prototype.equalsIgnoreCase=function(other){
		if (other == null)
			return false;
		return this.toLowerCase() === other.toLowerCase();
	}
}

if (!String.prototype.codePointAt){
	String.prototype.codePointAt=String.prototype.charCodeAt;
}

if (!String.prototype.codePointBefore){
	String.prototype.codePointBefore=stjs.NOT_IMPLEMENTED;
}
if (!String.prototype.codePointCount){
	String.prototype.codePointCount=stjs.NOT_IMPLEMENTED;
}

if (!String.prototype.replaceAll){
	String.prototype.replaceAll=function(regexp, replace){
		return this.replace(new RegExp(regexp, "g"), replace);
	}
}

if (!String.prototype.replaceFirst){
	String.prototype.replaceFirst=function(regexp, replace){
		return this.replace(new RegExp(regexp), replace);
	}
}

if (!String.prototype.regionMatches){
	String.prototype.regionMatches=function(ignoreCase, toffset, other, ooffset, len){
		if (arguments.length == 4){
			len=arguments[3];
			ooffset=arguments[2];
			other=arguments[1];
			toffset=arguments[0];
			ignoreCase=false;
		}
		if (toffset < 0 || ooffset < 0 || other == null || toffset + len > this.length || ooffset + len > other.length)
			return false;
		var s1 = this.substring(toffset, toffset + len);
		var s2 = other.substring(ooffset, ooffset + len);
		return ignoreCase ? s1.equalsIgnoreCase(s2) : s1 === s2;
	}
}

if(!String.prototype.contains){
	String.prototype.contains=function(it){
		return this.indexOf(it)>=0;
	};
}

if(!String.prototype.getClass){
	String.prototype.getClass=stjs.JavalikeGetClass;
}


//force valueof to match the Java's behavior
String.valueOf=function(value){
	return new String(value);
};

/* Number */
var Byte=Number;
var Double=Number;
var Float=Number;
var Integer=Number;
var Long=Number;
var Short=Number;

/* type conversion - approximative as Javascript only has integers and doubles */
if (!Number.prototype.intValue) {
	Number.prototype.intValue=function(){
		return parseInt(this);
	}
}
if (!Number.prototype.shortValue) {
	Number.prototype.shortValue=function(){
		return parseInt(this);
	}
}
if (!Number.prototype.longValue) {
	Number.prototype.longValue=function(){
		return parseInt(this);
	}
}
if (!Number.prototype.byteValue) {
	Number.prototype.byteValue=function(){
		return parseInt(this);
	}
}

if (!Number.prototype.floatValue) {
	Number.prototype.floatValue=function(){
		return parseFloat(this);
	}
}

if (!Number.prototype.doubleValue) {
	Number.prototype.doubleValue=function(){
		return parseFloat(this);
	}
}

if (!Number.parseInt) {
	Number.parseInt = parseInt;
}
if (!Number.parseShort) {
	Number.parseShort = parseInt;
}
if (!Number.parseLong) {
	Number.parseLong = parseInt;
}
if (!Number.parseByte) {
	Number.parseByte = parseInt;
}

if (!Number.parseDouble) {
	Number.parseDouble = parseFloat;
}

if (!Number.parseFloat) {
	Number.parseFloat = parseFloat;
}

if (!Number.isNaN) {
	Number.isNaN = isNaN;
}

if (!Number.prototype.isNaN) {
	Number.prototype.isNaN = function() {
		return isNaN(this);
	}
}
if (!Number.prototype.equals) {
	Number.prototype.equals=stjs.JavalikeEquals;
}
if(!Number.prototype.getClass){
	Number.prototype.getClass=stjs.JavalikeGetClass;
}

//force valueof to match approximately the Java's behavior (for Integer.valueOf it returns in fact a double)
Number.valueOf=function(value){
	return new Number(value).valueOf();
}

/* Boolean */
if (!Boolean.prototype.equals) {
	Boolean.prototype.equals=stjs.JavalikeEquals;
}
if(!Boolean.prototype.getClass){
	Boolean.prototype.getClass=stjs.JavalikeGetClass;
}

//force valueof to match the Java's behavior
Boolean.valueOf=function(value){
	return new Boolean(value).valueOf();
}



/************* STJS helper functions ***************/
stjs.global=this;
stjs.skipCopy = {"prototype":true, "constructor": true, "$typeDescription":true, "$inherit" : true};

stjs.ns=function(path){
	var p = path.split(".");
	var obj = stjs.global;
	for(var i = 0; i < p.length; ++i){
		var part = p[i];
		obj = obj[part] = obj[part] || {};
	}
	return obj;
};

stjs.copyProps=function(from, to){
	for(var key in from){
		if (!stjs.skipCopy[key])
			to[key]	= from[key];
	}
	return to;
};

stjs.copyInexistentProps=function(from, to){
	for(var key in from){
		if (!stjs.skipCopy[key] && !to[key])
			to[key]	= from[key];
	}
	return to;
};

stjs.extend=function(_constructor, _super, _implements, _initializer, _typeDescription, _annotations){
	if(typeof(_typeDescription) !== "object"){
		// stjs 1.3+ always passes an non-null object to _typeDescription => The code calling stjs.extend
		// was generated with version 1.2 or earlier, so let's call the 1.2 version of stjs.extend
		return stjs.extend12.apply(this, arguments);
	}

	_constructor.$inherit=[];

	if(_super != null){
		// I is used as a no-op constructor that has the same prototype as _super
		// we do this because we cannot predict the result of calling new _super()
		// without parameters (it might throw an exception).
		// Basically, the following 3 lines are a safe equivalent for
		// _constructor.prototype = new _super();
		var I = function(){};
		I.prototype	= _super.prototype;
		_constructor.prototype	= new I();

		// copy static properties for super
		// assign every method from proto instance
		stjs.copyProps(_super, _constructor);
		stjs.copyProps(_super.$typeDescription, _typeDescription);
		stjs.copyProps(_super.$annotations, _annotations);

		//add the super class to inherit array
		_constructor.$inherit.push(_super);
	}

	// copy static properties and default methods from interfaces
	for(var a = 0; a < _implements.length; ++a){
		if (!_implements[a]) continue;
		stjs.copyProps(_implements[a], _constructor);
		stjs.copyInexistentProps(_implements[a].prototype, _constructor.prototype);
		_constructor.$inherit.push(_implements[a]);
	}

	// remember the correct constructor
	_constructor.prototype.constructor	= _constructor;

	// run the initializer to assign all static and instance variables/functions
	if(_initializer != null){
		_initializer(_constructor, _constructor.prototype);
	}

	_constructor.$typeDescription = _typeDescription;
	_constructor.$annotations = _annotations;

	// add the default equals method if it is not present yet, and we don't have a superclass
	if(_super == null){
		if(!_constructor.prototype.equals) {
			_constructor.prototype.equals = stjs.JavalikeEquals;
		}
		if(!_constructor.prototype.getClass) {
			_constructor.prototype.getClass = stjs.JavalikeGetClass;
		}
	}

	// build package and assign
	return	_constructor;
};

/**
 * 1.2 and earlier version of stjs.extend. Included for backwards compatibility
 */
stjs.extend12=function( _constructor,  _super, _implements){
	var I = function(){};
	I.prototype	= _super.prototype;
	_constructor.prototype	= new I();

	//copy static properties for super and interfaces
	// assign every method from proto instance
	for(var a = 1; a < arguments.length; ++a){
		stjs.copyProps(arguments[a], _constructor);
	}
	// remember the correct constructor
	_constructor.prototype.constructor	= _constructor;

	// add the default equals method if we don't have a superclass. Code generated with version 1.2 will
	// override this method is equals() is present in the original java code.
	// this was not part of the original 1.2 version of extends, however forward compatibility
	// with 1.3 requires it
	if(_super == null){
		_constructor.prototype.equals = stjs.JavalikeEquals;
		_constructor.prototype.getClass = stjs.JavalikeGetClass;
	}

	// build package and assign
	return	_constructor;
};

/**
 * return type's annotations
 */
stjs.getAnnotations = function(clz) {
	return clz.$annotations;
};

stjs.getTypeAnnotation = function(clz, annType) {
	var ann = clz.$annotations._;
	return ann ? ann[annType]: null;
};

stjs.getMemberAnnotation = function(clz, memberName, annType) {
	var ann = clz.$annotations.memberName;
	return ann ? ann[annType]: null;
};

stjs.getParameterAnnotation = function(clz, methodName, idx, annType) {
	var ann = clz.$annotations[methodName + "$" + idx];
	return ann ? ann[annType]: null;
};

/**
 * checks if the child is an instanceof parent. it checks recursively if "parent" is the child itself or it's found somewhere in the $inherit array
 */
stjs.isInstanceOf=function(child, parent){
	if (child == null)
		return false;
	if (child === parent)
		return true;
	if (!child.$inherit)
		return false;
	for(var i = 0; i < child.$inherit.length; ++i){
		if (stjs.isInstanceOf(child.$inherit[i], parent)) {
			return true;
		}
	}
	return false;
}

stjs.enumEntry=function(idx, name){
	this._name = name;
	this._ordinal = idx;
};

stjs.enumEntry.prototype.name=function(){
	return this._name;
};
stjs.enumEntry.prototype.ordinal=function(){
	return this._ordinal;
};
stjs.enumEntry.prototype.toString=function(){
	return this._name;
};
stjs.enumEntry.prototype.equals=stjs.JavalikeEquals;

stjs.enumeration=function(){
	var i;
	var e = {};
	e._values = [];
	for(i = 0; i < arguments.length; ++i){
		e[arguments[i]] = new stjs.enumEntry(i, arguments[i]);
		e._values[i] = e[arguments[i]];
	}
	e.values = function(){return this._values;};
	e.valueOf=function(label){
		return this[label];
	}
	return e;
};


/**
 * if true the execution of generated main methods is disabled.
 * this is useful when executing unit tests, to no have the main methods executing before the tests
 */
stjs.mainCallDisabled = false;

stjs.exception=function(err){
	return err;
};

stjs.isEnum=function(obj){
	return obj != null && obj.constructor == stjs.enumEntry;
};

if (typeof Math.trunc === "function") {
	stjs.trunc = Math.trunc;
} else {
	stjs.trunc=function(n) {
		if (n == null)
			return null;
		return n >= 0 ? Math.floor(n) : Math.ceil(n);
	}
}

stjs.converters = {
	Date : function(s, type) {
		var a = /^(\d{4})-(\d{2})-(\d{2}) (\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)$/
				.exec(s);
		if (a) {
			return new Date(+a[1], +a[2] - 1, +a[3], +a[4], +a[5], +a[6]);
		}
		return null;
	},

	Enum : function(s, type){
		return eval(type.arguments[0])[s];
	}
};


stjs.serializers = {
	Date : function(d, type) {
		function pad(n){
			return n < 10 ? "0" + n : "" + n;
		}
		if (d) {
			return "" + d.getFullYear() + "-" + pad(d.getMonth()+1) + "-" + pad(d.getDate()) + " " + pad(d.getHours()) + ":" + pad(d.getMinutes()) + ":" + pad(d.getSeconds());
		}
		return null;
	},

	Enum : function(e, type){
		return e != null ? e.toString() : null;
	}
};

/**
 * Used to be able to send method references and lambdas that capture 'this' as callbacks.
 * This method has a bunch of different usage patterns:
 *
 * bind(instance, "methodName"):
 *     Used when translating a capturing method reference (eg: instance::methodName), or when translating
 *
 * bind(this, function):
 *     Used when translating a lambda that uses 'this' explicitly or implicitly (eg: () -> this.doSomething(3))
 *
 * bind(this, function, specialTHISparamPosition)
 *     Used when translating a lambda that uses the special all-caps 'THIS' parameter
 *
 * bind("methodName")
 *     Used when translating a non-static method reference (eg: TypeName::methodName, where methodName is non-static)
 */
stjs.bind=function(obj, method, thisParamPos) {
	var useFirstParamAsContext = false;
	if(method == null) {
		// the bind("methodName") is the only usage where the method argument can be null
		method = obj;
		obj = null;
		useFirstParamAsContext = true;
	}
	var addThisToParameters = thisParamPos != null;

	var f = function(){
		var args = arguments;
		if (addThisToParameters) {
			Array.prototype.splice.call(args, thisParamPos, 0, this);
		}
		if(useFirstParamAsContext){
			obj = Array.prototype.shift.call(args);
		}

		if (typeof method === "string") {
			return obj[method].apply(obj, args);

		} else {
			return method.apply(obj, args);
		}
	};
	return f;
};


/** *********** global ************** */
function exception(err){
	return err;
}

function isEnum(obj){
	return obj != null && obj.constructor == stjs.enumEntry;
}

/******* parsing *************/

/**
 * parse a json string using the type definition to build a typed object hierarchy
 */
stjs.parseJSON = (function () {
	  var number
	      = '(?:-?\\b(?:0|[1-9][0-9]*)(?:\\.[0-9]+)?(?:[eE][+-]?[0-9]+)?\\b)';
	  var oneChar = '(?:[^\\0-\\x08\\x0a-\\x1f\"\\\\]'
	      + '|\\\\(?:[\"/\\\\bfnrt]|u[0-9A-Fa-f]{4}))';
	  var string = '(?:\"' + oneChar + '*\")';

	  // Will match a value in a well-formed JSON file.
	  // If the input is not well-formed, may match strangely, but not in an unsafe
	  // way.
	  // Since this only matches value tokens, it does not match whitespace, colons,
	  // or commas.
	  var jsonToken = new RegExp(
	      '(?:false|true|null|[\\{\\}\\[\\]]'
	      + '|' + number
	      + '|' + string
	      + ')', 'g');

	  // Matches escape sequences in a string literal
	  var escapeSequence = new RegExp('\\\\(?:([^u])|u(.{4}))', 'g');

	  // Decodes escape sequences in object literals
	  var escapes = {
	    '"': '"',
	    '/': '/',
	    '\\': '\\',
	    'b': '\b',
	    'f': '\f',
	    'n': '\n',
	    'r': '\r',
	    't': '\t'
	  };
	  function unescapeOne(_, ch, hex) {
	    return ch ? escapes[ch] : String.fromCharCode(parseInt(hex, 16));
	  }

	  var constructors = {};

	  function constr(name, param){
		  var c = constructors[name];
		  if (!c)
			  constructors[name] = c = eval(name);
		  return new c(param);
	  }

	  function convert(type, json){
		  if (!type)
			  return json;
		  var cv = stjs.converters[type.name || type];
		  if (cv)
			  return cv(json, type);
		  //hopefully the type has a string constructor
		 return constr(type, json);
	  }

	  function builder(type){
		  if (!type)
			  return {};
			if (typeof type == "function")
				return new type();
			if (type.name) {
				if (type.name == "Map")
					return {};
				if (type.name == "Array")
					return [];
				return constr(type.name);
			}
			return constr(type);
	  }

	  // A non-falsy value that coerces to the empty string when used as a key.
	  var EMPTY_STRING = new String('');
	  var SLASH = '\\';

	  // Constructor to use based on an open token.
	  var firstTokenCtors = { '{': Object, '[': Array };

	  var hop = Object.hasOwnProperty;

	  function nextMatch(str){
		  var m = jsonToken.exec(str);
		  return m != null ? m[0] : null;
	  }
	  return function (json, type) {
	    // Split into tokens
	    // Construct the object to return
	    var result;
	    var tok = nextMatch(json);
	    var topLevelPrimitive = false;
	    if ('{' === tok) {
	      result = builder(type, null);
	    } else if ('[' === tok) {
	      result = [];
	    } else {
	      // The RFC only allows arrays or objects at the top level, but the JSON.parse
	      // defined by the EcmaScript 5 draft does allow strings, booleans, numbers, and null
	      // at the top level.
	      result = [];
	      topLevelPrimitive = true;
	    }

	    // If undefined, the key in an object key/value record to use for the next
	    // value parsed.
	    var key;
	    // Loop over remaining tokens maintaining a stack of uncompleted objects and
	    // arrays.
	    var stack = [result];
	    var stack2 = [type];
	    for (tok = nextMatch(json); tok != null; tok = nextMatch(json)) {

	      var cont;
	      switch (tok.charCodeAt(0)) {
	        default:  // sign or digit
	          cont = stack[0];
	          cont[key || cont.length] = +(tok);
	          key = void 0;
	          break;
	        case 0x22:  // '"'
	          tok = tok.substring(1, tok.length - 1);
	          if (tok.indexOf(SLASH) !== -1) {
	            tok = tok.replace(escapeSequence, unescapeOne);
	          }
	          cont = stack[0];
	          if (!key) {
	            if (cont instanceof Array) {
	              key = cont.length;
	            } else {
	              key = tok || EMPTY_STRING;  // Use as key for next value seen.
	              stack2[0] = cont.constructor.$typeDescription ? cont.constructor.$typeDescription[key] : stack2[1].arguments[1];
	              break;
	            }
	          }
	          cont[key] = convert(stack2[0],tok);
	          key = void 0;
	          break;
	        case 0x5b:  // '['
	          cont = stack[0];
	          stack.unshift(cont[key || cont.length] = []);
	          stack2.unshift(stack2[0].arguments[0]);
	          //put the element type desc
	          key = void 0;
	          break;
	        case 0x5d:  // ']'
	          stack.shift();
	          stack2.shift();
	          break;
	        case 0x66:  // 'f'
	          cont = stack[0];
	          cont[key || cont.length] = false;
	          key = void 0;
	          break;
	        case 0x6e:  // 'n'
	          cont = stack[0];
	          cont[key || cont.length] = null;
	          key = void 0;
	          break;
	        case 0x74:  // 't'
	          cont = stack[0];
	          cont[key || cont.length] = true;
	          key = void 0;
	          break;
	        case 0x7b:  // '{'
	          cont = stack[0];
	          stack.unshift(cont[key || cont.length] = builder(stack2[0]));
	          stack2.unshift(null);
	          key = void 0;
	          break;
	        case 0x7d:  // '}'
	          stack.shift();
	          stack2.shift();
	          break;
	      }
	    }
	    // Fail if we've got an uncompleted object.
	    if (topLevelPrimitive) {
	      if (stack.length !== 1) { throw new Error(); }
	      result = result[0];
	    } else {
	      if (stack.length) { throw new Error(); }
	    }

	    return result;
	  };
})();




stjs.isArray=function( obj ) {
    return stjs.toString.call(obj) === "[object Array]";
};

/**
 * cls can by the type of the return.
 * If it's an array it can be either the type of an element or the type definition of the field.
 * TODO - for other collections and classes is not done yet
 */
stjs.typefy=function(obj, cls){
	if (stjs.isArray(obj)){
		var result = [];
		for(var idx = 0; idx < obj.length; idx++){
			result.push(stjs.typefy(obj[idx], elementType(cls)));
		}
		return result;
	}
	 var constructors = {};
	 function constr(name, param){
		  var c = constructors[name];
		  if (!c)
			  constructors[name] = c = eval(name);
		  return new c(param);
	  }

	 function elementType(type){
		 if (typeof type == "function")
			 return type;
		 if (type.arguments) {
			 return eval(type.arguments[0]);
		 }
		 if (typeof type == "string")
			 return eval(type);
		 return Object;
	  }


	function convert(type, json){
		  if (!type)
			  return json;
		  var cv = stjs.converters[type.name || type];
		  if (cv)
			  return cv(json, type);
		  //hopefully the type has a string constructor
		 return constr(type, json);
	  }

	 function builder(type){
		  if (!type)
			  return {};
			if (typeof type == "function")
				return new type();
			if (type.name) {
				if (type.name == "Map")
					return {};
				if (type.name == "Array")
					return [];
				return constr(type.name);
			}
			return constr(type);
	  }

	  if (obj == null)
		  return null;

	  var ret = new cls();
	  for(var key in obj){
		  var prop = obj[key];
		  if (prop == null)
			  continue;
		  var td = cls.$typeDescription[key];
		  if (!td) {
			  ret[key] = prop;
			  continue;
		  }
		  if (typeof prop == "string")
			ret[key] = convert(td, prop);
		  else if (typeof prop == "object") {
				if (typeof td == "string") {
					td = eval(td);
		  		}
				ret[key] = stjs.typefy(prop, td);
			}
	  }
	  return ret;
};
stjs.hydrate=stjs.typefy

stjs.stringify=function(obj, cls){
	 if (obj == null)
		  return null;

	 var ret = {};
	  for(var key in obj){
		  var td = cls.$typeDescription[key];
		  var prop = obj[key];
		  var ser = td != null ? stjs.serializers[td.name || td] : null;

		  if (typeof prop == "function")
			  continue;

		  if (!td || !ser) {
			  ret[key] = prop;
			  continue;
		  }
		  if (typeof prop != "string")
			  if (ser)
				  ret[key] = ser(prop, td);
			  else
				  ret[key] = stjs.typefy(prop, td);
	  }
	  return ret;
};
/************* STJS asserts ***************/
stjs.assertHandler = function(position, code, msg) {
	throw msg + " at " + position;
};

stjs.STJSAssert = {};

stjs.STJSAssert.setAssertHandler = function(a) {
	stjs.assertHandler = a;
}

stjs.STJSAssert.assertArgEquals = function(position, code, expectedValue, testValue) {
	if (expectedValue != testValue && stjs.assertHandler)
		stjs.assertHandler(position, code, "Wrong argument. Expected: " + expectedValue + ", got:" + testValue);
}

stjs.STJSAssert.assertArgNotNull = function(position, code, testValue) {
	if (testValue == null && stjs.assertHandler)
		stjs.assertHandler(position, code, "Wrong argument. Null value");
}

stjs.STJSAssert.assertArgTrue = function(position, code, condition) {
	if (!condition && stjs.assertHandler)
		stjs.assertHandler(position, code, "Wrong argument. Condition is false");
}

stjs.STJSAssert.assertStateEquals = function(position, code, expectedValue, testValue) {
	if (expectedValue != testValue && stjs.assertHandler)
		stjs.assertHandler(position, code, "Wrong state. Expected: " + expectedValue + ", got:" + testValue);
}

stjs.STJSAssert.assertStateNotNull = function(position, code, testValue) {
	if (testValue == null && stjs.assertHandler)
		stjs.assertHandler(position, code, "Wrong state. Null value");
}

stjs.STJSAssert.assertStateTrue = function(position, code, condition) {
	if (!condition && stjs.assertHandler)
		stjs.assertHandler(position, code, "Wrong state. Condition is false");
}
/** exception **/
var Throwable = function(message, cause){
	Error.call(this);
	if(typeof Error.captureStackTrace === 'function'){
		// nice way to capture the stack trace for chrome
		Error.captureStackTrace(this, arguments.callee);
	} else {
		// alternate way to capture the stack trace for other browsers
		try{
			throw new Error();
		}catch(e){
			this.stack = e.stack;
		}
	}
	if (typeof message === "string"){
		this.detailMessage  = message;
		this.message = message;
		this.cause = cause;
	} else {
		this.cause = message;
	}
};
stjs.extend(Throwable, Error, [], function(constructor, prototype){
	prototype.detailMessage = null;
	prototype.cause = null;
	prototype.getMessage = function() {
        return this.detailMessage;
    };

	prototype.getLocalizedMessage = function() {
        return this.getMessage();
    };

	prototype.getCause = function() {
        return (this.cause==this ? null : this.cause);
    };

	prototype.toString = function() {
	        var s = "Exception";//TODO should get the exception's type name here
	        var message = this.getLocalizedMessage();
	        return (message != null) ? (s + ": " + message) : s;
	 };

	 prototype.getStackTrace = function() {
		 return this.stack;
	 };

	 prototype.printStackTrace = function(){
		 console.error(this.getStackTrace());
	 };
}, {});

var Exception = function(message, cause){
	Throwable.call(this, message, cause);
};
stjs.extend(Exception, Throwable, [], function(constructor, prototype){
}, {});

var RuntimeException = function(message, cause){
	Exception.call(this, message, cause);
};
stjs.extend(RuntimeException, Exception, [], function(constructor, prototype){
}, {});

var Iterator = function() {};
Iterator = stjs.extend(Iterator, null, [], function(constructor, prototype) {
    prototype.hasNext = function() {};
    prototype.next = function() {};
    prototype.remove = function() {};
}, {}, {});

var Iterable = function() {};
Iterable = stjs.extend(Iterable, null, [], function(constructor, prototype) {
    prototype.iterator = function() {};
}, {}, {});

/** stjs field manipulation */
stjs.setField=function(obj, field, value, returnOldValue){
	if (stjs.setFieldHandler)
		return stjs.setFieldHandler(obj, field, value, returnOldValue);
	var toReturn = returnOldValue ? obj[field] : value;
	obj[field] = value;
	return toReturn;
};

stjs.getField=function(obj, field){
	if (stjs.getFieldHandler)
		return stjs.getFieldHandler(obj, field);
	return obj[field];
};


var Callback5 = function() {};
Callback5 = stjs.extend(Callback5, null, [], function(constructor, prototype) {
    prototype.$invoke = function(p1, p2, p3, p4, p5) {};
}, {}, {});
/**
 *  A hypergraph, consisting of a set of vertices of type <code>V</code> and a
 *  set of hyperedges of type <code>E</code> which connect the vertices. This is
 *  the base interface for all JUNG graph types.
 *  <p>
 *  This interface permits, but does not enforce, any of the following common
 *  variations of graphs:
 *  <ul>
 *  <li/>hyperedges (edges which connect a set of vertices of any size)
 *  <li/>edges (these have have exactly two endpoints, which may or may not be
 *  distinct)
 *  <li/>self-loops (edges which connect exactly one vertex)
 *  <li>directed and undirected edges
 *  <li>vertices and edges with attributes (for example, weighted edges)
 *  <li>vertices and edges with different constraints or properties (for example,
 *  bipartite or multimodal graphs)
 *  <li>parallel edges (multiple edges which connect a single set of vertices)
 *  <li>internal representations as matrices or as adjacency lists or adjacency
 *  maps
 *  </ul>
 *  Extensions or implementations of this interface may enforce or disallow any
 *  or all of these variations.
 *  <p>
 *  <b>Notes</b>:
 *  <ul>
 *  <li/>The collections returned by <code>Hypergraph</code> instances should be
 *  treated in general as if read-only. While they are not contractually
 *  guaranteed (or required) to be immutable, this interface does not define the
 *  outcome if they are mutated. Mutations should be done via
 *  <code>{add,remove}{Edge,Vertex}</code>, or in the constructor.
 *  <li/>
 *  </ul>
 * 
 *  @author Joshua O'Madadhain
 *          <p>
 *          Ported to Javascript by:
 *  @author Fritz Ray (fritz.ray@eduworks.com)
 *  @author Tom Buskirk (tom.buskirk@eduworks.com)
 *  @class Hypergraph
 *  @module com.eduworks.ec
 */
var Hypergraph = function() {};
Hypergraph = stjs.extend(Hypergraph, null, [], function(constructor, prototype) {
    /**
     *  Returns a view of all edges in this graph. In general, this obeys the
     *  <code>Array</code> contract, and therefore makes no guarantees about the
     *  ordering of the vertices within the set.
     * 
     *  @return a <code>Array</code> view of all edges in this graph
     *  @method getEdges
     */
    prototype.getEdges = function() {};
    /**
     *  Returns a view of all vertices in this graph. In general, this obeys the
     *  <code>Array</code> contract, and therefore makes no guarantees about the
     *  ordering of the vertices within the set.
     * 
     *  @return a <code>Array</code> view of all vertices in this graph
     *  @method getVerticies
     */
    prototype.getVertices = function() {};
    /**
     *  Returns true if this graph's vertex collection contains
     *  <code>vertex</code>. Equivalent to
     *  <code>getVertices().contains(vertex)</code>.
     * 
     *  @param vertex the vertex whose presence is being queried
     *  @return true iff this graph contains a vertex <code>vertex</code>
     *  @method containsVertex
     */
    prototype.containsVertex = function(vertex) {};
    /**
     *  Returns true if this graph's edge collection contains <code>edge</code>.
     *  Equivalent to <code>getEdges().contains(edge)</code>.
     * 
     *  @param edge the edge whose presence is being queried
     *  @return true iff this graph contains an edge <code>edge</code>
     *  @method containsEdge
     */
    prototype.containsEdge = function(edge) {};
    /**
     *  Returns the number of edges in this graph.
     * 
     *  @return the number of edges in this graph
     *  @method getEdgeCount
     */
    prototype.getEdgeCount = function() {};
    /**
     *  Returns the number of vertices in this graph.
     * 
     *  @return the number of vertices in this graph
     *  @method getVertexCount
     */
    prototype.getVertexCount = function() {};
    /**
     *  Returns the collection of vertices which are connected to
     *  <code>vertex</code> via any edges in this graph. If <code>vertex</code>
     *  is connected to itself with a self-loop, then it will be included in the
     *  collection returned.
     * 
     *  @param vertex the vertex whose neighbors are to be returned
     *  @return the collection of vertices which are connected to
     *  <code>vertex</code>, or <code>null</code> if <code>vertex</code>
     *  is not present
     *  @method getNeighbors
     */
    prototype.getNeighbors = function(vertex) {};
    /**
     *  Returns the collection of edges in this graph which are connected to
     *  <code>vertex</code>.
     * 
     *  @param vertex the vertex whose incident edges are to be returned
     *  @return the collection of edges which are connected to
     *  <code>vertex</code>, or <code>null</code> if <code>vertex</code>
     *  is not present
     *  @method getIncidentEdges
     */
    prototype.getIncidentEdges = function(vertex) {};
    /**
     *  Returns the collection of vertices in this graph which are connected to
     *  <code>edge</code>. Note that for some graph types there are guarantees
     *  about the size of this collection (i.e., some graphs contain edges that
     *  have exactly two endpoints, which may or may not be distinct).
     *  Implementations for those graph types may provide alternate methods that
     *  provide more convenient access to the vertices.
     * 
     *  @param edge the edge whose incident vertices are to be returned
     *  @return the collection of vertices which are connected to
     *  <code>edge</code>, or <code>null</code> if <code>edge</code> is
     *  not present
     *  @method getIncidentVertices
     */
    prototype.getIncidentVertices = function(edge) {};
    /**
     *  Returns an edge that connects this vertex to <code>v</code>. If this edge
     *  is not uniquely defined (that is, if the graph contains more than one
     *  edge connecting <code>v1</code> to <code>v2</code>), any of these edges
     *  may be returned. <code>findEdgeSet(v1, v2)</code> may be used to return
     *  all such edges. Returns null if either of the following is true:
     *  <ul>
     *  <li/><code>v2</code> is not connected to <code>v1</code>
     *  <li/>either <code>v1</code> or <code>v2</code> are not present in this
     *  graph
     *  </ul>
     *  <p>
     *  <b>Note</b>: for purposes of this method, <code>v1</code> is only
     *  considered to be connected to <code>v2</code> via a given <i>directed</i>
     *  edge <code>e</code> if
     *  <code>v1 == e.getSource() && v2 == e.getDest()</code> evaluates to
     *  <code>true</code>. (<code>v1</code> and <code>v2</code> are connected by
     *  an undirected edge <code>u</code> if <code>u</code> is incident to both
     *  <code>v1</code> and <code>v2</code>.)
     * 
     *  @param v1 between this
     *  @param v2 and that
     *  @return an edge that connects <code>v1</code> to <code>v2</code>, or
     *  <code>null</code> if no such edge exists (or either vertex is not
     *  present)
     *  @method findEdge
     *  @see Hypergraph#findEdgeSet(Object, Object)
     */
    prototype.findEdge = function(v1, v2) {};
    /**
     *  Returns all edges that connects this vertex to <code>v</code>. If this
     *  edge is not uniquely defined (that is, if the graph contains more than
     *  one edge connecting <code>v1</code> to <code>v2</code>), any of these
     *  edges may be returned. <code>findEdgeSet(v1, v2)</code> may be used to
     *  return all such edges. Returns null if <code>v2</code> is not connected
     *  to <code>v1</code>. <br/>
     *  Returns an empty collection if either <code>v1</code> or <code>v2</code>
     *  are not present in this graph.
     *  <p>
     *  <p>
     *  <b>Note</b>: for purposes of this method, <code>v1</code> is only
     *  considered to be connected to <code>v2</code> via a given <i>directed</i>
     *  edge <code>d</code> if
     *  <code>v1 == d.getSource() && v2 == d.getDest()</code> evaluates to
     *  <code>true</code>. (<code>v1</code> and <code>v2</code> are connected by
     *  an undirected edge <code>u</code> if <code>u</code> is incident to both
     *  <code>v1</code> and <code>v2</code>.)
     * 
     *  @param v1 between this
     *  @param v2 and that
     *  @return a collection containing all edges that connect <code>v1</code> to
     *  <code>v2</code>, or <code>null</code> if either vertex is not
     *  present
     *  @method findEdgeSet
     *  @see Hypergraph#findEdge(Object, Object)
     */
    prototype.findEdgeSet = function(v1, v2) {};
    /**
     *  Adds <code>vertex</code> to this graph. Fails if <code>vertex</code> is
     *  null or already in the graph.
     * 
     *  @param vertex the vertex to add
     *  @return <code>true</code> if the add is successful, and
     *  <code>false</code> otherwise
     *  @throws IllegalArgumentException if <code>vertex</code> is <code>null</code>
     *  @method addVertex
     */
    prototype.addVertex = function(vertex) {};
    /**
     *  Adds <code>edge</code> to this graph. Fails under the following
     *  circumstances:
     *  <ul>
     *  <li/><code>edge</code> is already an element of the graph
     *  <li/>either <code>edge</code> or <code>vertices</code> is
     *  <code>null</code>
     *  <li/><code>vertices</code> has the wrong number of vertices for the graph
     *  type
     *  <li/><code>vertices</code> are already connected by another edge in this
     *  graph, and this graph does not accept parallel edges
     *  </ul>
     * 
     *  @param edge
     *  @param vertices
     *  @return <code>true</code> if the add is successful, and
     *  <code>false</code> otherwise
     *  @throws IllegalArgumentException if <code>edge</code> or <code>vertices</code> is null, or if
     *                                   a different vertex set in this graph is already connected by
     *                                   <code>edge</code>, or if <code>vertices</code> are not a
     *                                   legal vertex set for <code>edge</code>
     *  @method addHyperEdge
     */
    prototype.addHyperEdge = function(edge, vertices) {};
    /**
     *  Removes <code>vertex</code> from this graph. As a side effect, removes
     *  any edges <code>e</code> incident to <code>vertex</code> if the removal
     *  of <code>vertex</code> would cause <code>e</code> to be incident to an
     *  illegal number of vertices. (Thus, for example, incident hyperedges are
     *  not removed, but incident edges--which must be connected to a vertex at
     *  both endpoints--are removed.)
     *  <p>
     *  <p>
     *  Fails under the following circumstances:
     *  <ul>
     *  <li/><code>vertex</code> is not an element of this graph
     *  <li/><code>vertex</code> is <code>null</code>
     *  </ul>
     * 
     *  @param vertex the vertex to remove
     *  @return <code>true</code> if the removal is successful,
     *  <code>false</code> otherwise
     *  @method removeVertex
     */
    prototype.removeVertex = function(vertex) {};
    /**
     *  Removes <code>edge</code> from this graph. Fails if <code>edge</code> is
     *  null, or is otherwise not an element of this graph.
     * 
     *  @param edge the edge to remove
     *  @return <code>true</code> if the removal is successful,
     *  <code>false</code> otherwise
     *  @method removeEdge
     */
    prototype.removeEdge = function(edge) {};
    /**
     *  Returns <code>true</code> if <code>v1</code> and <code>v2</code> share an
     *  incident edge. Equivalent to <code>getNeighbors(v1).contains(v2)</code>.
     * 
     *  @param v1 the first vertex to test
     *  @param v2 the second vertex to test
     *  @return <code>true</code> if <code>v1</code> and <code>v2</code> share an
     *  incident edge
     *  @method isNeighbor
     */
    prototype.isNeighbor = function(v1, v2) {};
    /**
     *  Returns <code>true</code> if <code>vertex</code> and <code>edge</code>
     *  are incident to each other. Equivalent to
     *  <code>getIncidentEdges(vertex).contains(edge)</code> and to
     *  <code>getIncidentVertices(edge).contains(vertex)</code>.
     * 
     *  @param vertex
     *  @param edge
     *  @return <code>true</code> if <code>vertex</code> and <code>edge</code>
     *  are incident to each other
     *  @method isIncident
     */
    prototype.isIncident = function(vertex, edge) {};
    /**
     *  Returns the number of edges incident to <code>vertex</code>. Special
     *  cases of interest:
     *  <ul>
     *  <li/>Incident self-loops are counted once.
     *  <li>If there is only one edge that connects this vertex to each of its
     *  neighbors (and vice versa), then the value returned will also be equal to
     *  the number of neighbors that this vertex has (that is, the output of
     *  <code>getNeighborCount</code>).
     *  <li>If the graph is directed, then the value returned will be the sum of
     *  this vertex's indegree (the number of edges whose destination is this
     *  vertex) and its outdegree (the number of edges whose source is this
     *  vertex), minus the number of incident self-loops (to avoid
     *  double-counting).
     *  </ul>
     *  <p>
     *  Equivalent to <code>getIncidentEdges(vertex).size()</code>.
     * 
     *  @param vertex the vertex whose degree is to be returned
     *  @return the degree of this node
     *  @method degree
     *  @see Hypergraph#getNeighborCount(Object)
     */
    prototype.degree = function(vertex) {};
    /**
     *  Returns the number of vertices that are adjacent to <code>vertex</code>
     *  (that is, the number of vertices that are incident to edges in
     *  <code>vertex</code>'s incident edge set).
     *  <p>
     *  <p>
     *  Equivalent to <code>getNeighbors(vertex).size()</code>.
     * 
     *  @param vertex the vertex whose neighbor count is to be returned
     *  @return the number of neighboring vertices
     *  @method getNeighborCount
     */
    prototype.getNeighborCount = function(vertex) {};
    /**
     *  Returns the number of vertices that are incident to <code>edge</code>.
     *  For hyperedges, this can be any nonnegative integer; for edges this must
     *  be 2 (or 1 if self-loops are permitted).
     *  <p>
     *  <p>
     *  Equivalent to <code>getIncidentVertices(edge).size()</code>.
     * 
     *  @param edge the edge whose incident vertex count is to be returned
     *  @return the number of vertices that are incident to <code>edge</code>.
     *  @method getIncidentCount
     */
    prototype.getIncidentCount = function(edge) {};
    /**
     *  Returns the edge type of <code>edge</code> in this graph.
     * 
     *  @param edge
     *  @return the <code>EdgeType</code> of <code>edge</code>, or
     *  <code>null</code> if <code>edge</code> has no defined type
     *  @method getEdgeType
     */
    prototype.getEdgeType = function(edge) {};
    /**
     *  Returns the default edge type for this graph.
     * 
     *  @return the default edge type for this graph
     *  @method getDefaultEdgeType
     */
    prototype.getDefaultEdgeType = function() {};
    /**
     *  Returns the collection of edges in this graph which are of type
     *  <code>edge_type</code>.
     * 
     *  @param edge_type the type of edges to be returned
     *  @return the collection of edges which are of type <code>edge_type</code>,
     *  or <code>null</code> if the graph does not accept edges of this
     *  type
     *  @method getEdgesOfType
     *  @see EdgeType
     */
    prototype.getEdgesOfType = function(edge_type) {};
    /**
     *  Returns the number of edges of type <code>edge_type</code> in this graph.
     * 
     *  @param edge_type the type of edge for which the count is to be returned
     *  @return the number of edges of type <code>edge_type</code> in this graph
     *  @method getEdgeCountOfType
     */
    prototype.getEdgeCountOfType = function(edge_type) {};
    /**
     *  Returns a <code>Array</code> view of the incoming edges incident to
     *  <code>vertex</code> in this graph.
     * 
     *  @param vertex the vertex whose incoming edges are to be returned
     *  @return a <code>Array</code> view of the incoming edges incident to
     *  <code>vertex</code> in this graph
     *  @method getInEdges
     */
    prototype.getInEdges = function(vertex) {};
    /**
     *  Returns a <code>Array</code> view of the outgoing edges incident to
     *  <code>vertex</code> in this graph.
     * 
     *  @param vertex the vertex whose outgoing edges are to be returned
     *  @return a <code>Array</code> view of the outgoing edges incident to
     *  <code>vertex</code> in this graph
     *  @method getOutEdges
     */
    prototype.getOutEdges = function(vertex) {};
    /**
     *  Returns the number of incoming edges incident to <code>vertex</code>.
     *  Equivalent to <code>getInEdges(vertex).size()</code>.
     * 
     *  @param vertex the vertex whose indegree is to be calculated
     *  @return the number of incoming edges incident to <code>vertex</code>
     *  @method inDegree
     */
    prototype.inDegree = function(vertex) {};
    /**
     *  Returns the number of outgoing edges incident to <code>vertex</code>.
     *  Equivalent to <code>getOutEdges(vertex).size()</code>.
     * 
     *  @param vertex the vertex whose outdegree is to be calculated
     *  @return the number of outgoing edges incident to <code>vertex</code>
     *  @method outDegree
     */
    prototype.outDegree = function(vertex) {};
    /**
     *  If <code>directed_edge</code> is a directed edge in this graph, returns
     *  the source; otherwise returns <code>null</code>. The source of a directed
     *  edge <code>d</code> is defined to be the vertex for which <code>d</code>
     *  is an outgoing edge. <code>directed_edge</code> is guaranteed to be a
     *  directed edge if its <code>EdgeType</code> is <code>DIRECTED</code>.
     * 
     *  @param directed_edge
     *  @return the source of <code>directed_edge</code> if it is a directed edge
     *  in this graph, or <code>null</code> otherwise
     *  @method getSource
     */
    prototype.getSource = function(directed_edge) {};
    /**
     *  If <code>directed_edge</code> is a directed edge in this graph, returns
     *  the destination; otherwise returns <code>null</code>. The destination of
     *  a directed edge <code>d</code> is defined to be the vertex incident to
     *  <code>d</code> for which <code>d</code> is an incoming edge.
     *  <code>directed_edge</code> is guaranteed to be a directed edge if its
     *  <code>EdgeType</code> is <code>DIRECTED</code>.
     * 
     *  @param directed_edge
     *  @return the destination of <code>directed_edge</code> if it is a directed
     *  edge in this graph, or <code>null</code> otherwise
     *  @method getDest
     */
    prototype.getDest = function(directed_edge) {};
    /**
     *  Returns a <code>Array</code> view of the predecessors of
     *  <code>vertex</code> in this graph. A predecessor of <code>vertex</code>
     *  is defined as a vertex <code>v</code> which is connected to
     *  <code>vertex</code> by an edge <code>e</code>, where <code>e</code> is an
     *  outgoing edge of <code>v</code> and an incoming edge of
     *  <code>vertex</code>.
     * 
     *  @param vertex the vertex whose predecessors are to be returned
     *  @return a <code>Array</code> view of the predecessors of
     *  <code>vertex</code> in this graph
     *  @method getPredecessors
     */
    prototype.getPredecessors = function(vertex) {};
    /**
     *  Returns a <code>Array</code> view of the successors of
     *  <code>vertex</code> in this graph. A successor of <code>vertex</code> is
     *  defined as a vertex <code>v</code> which is connected to
     *  <code>vertex</code> by an edge <code>e</code>, where <code>e</code> is an
     *  incoming edge of <code>v</code> and an outgoing edge of
     *  <code>vertex</code>.
     * 
     *  @param vertex the vertex whose predecessors are to be returned
     *  @return a <code>Array</code> view of the successors of
     *  <code>vertex</code> in this graph
     *  @method getSuccessors
     */
    prototype.getSuccessors = function(vertex) {};
}, {}, {});
var EcDate = function() {};
EcDate = stjs.extend(EcDate, null, [], function(constructor, prototype) {
    /**
     *  Returns an ISO 8601 TimeDate String from a Date object.
     *  @param {Date} obj Date Object
     *  @memberOf EcDate
     *  @static
     *  @return
     */
    constructor.toISOString = function(obj) {
        return ((obj)["toISOString"])();
    };
}, {}, {});
/**
 *  Array Helper Functions
 * 
 *  @author fritz.ray@eduworks.com
 *  @class EcArray
 *  @module com.eduworks.ec
 */
var EcArray = function() {};
EcArray = stjs.extend(EcArray, null, [], function(constructor, prototype) {
    /**
     *  Returns true if the result is an array.
     * 
     *  @param {any} o Object to test.
     *  @return true iff the object is an array.
     *  @static
     *  @method isArray
     *  @memberOf EcArray
     */
    constructor.isArray = function(o) {
        return Object.prototype.toString.call(o) == "[object Array]";
    };
    /**
     *  Removes values IFF the values == one another.
     * 
     *  @param a {Array} Array to remove duplicates from.
     *  @static
     *  @method removeDuplicates
     *  @memberOf EcArray
     */
    constructor.removeDuplicates = function(a) {
        for (var i = 0; i < a.length; i++) 
            for (var j = i; j < a.length; j++) {
                if (j == i) 
                    continue;
                if (a[i] == a[j]) 
                    a.splice(j, 1);
            }
    };
    /**
     *  Adds a value if the array does not have the value already.
     * 
     *  @param a {Array} Array to add to.
     *  @param o {Object} Object to add to the array if it isn't in there already.
     *  @static
     *  @method setAdd
     *  @memberOf EcArray
     */
    constructor.setAdd = function(a, o) {
        if (!EcArray.has(a, o)) 
            a.push(o);
    };
    /**
     *  Removes a value from the array.
     * 
     *  @param a {Array} Array to add to.
     *  @param o {Object} Object to add to the array if it isn't in there already.
     *  @static
     *  @method setAdd
     *  @memberOf EcArray
     */
    constructor.setRemove = function(a, o) {
         while (EcArray.has(a, o))
            a.splice(EcArray.indexOf(a, o), 1);
    };
    /**
     *  Returns true if the array has the value already.
     * 
     *  @param a {Array} Array.
     *  @param o {Object} Object to sample for.
     *  @static
     *  @method has
     *  @memberOf EcArray
     */
    constructor.has = function(a, o) {
        if (EcArray.isObject(o)) 
            for (var i = 0; i < a.length; i++) {
                if (a[i] == o) 
                    return true;
                try {
                    if (a[i].equals(o)) 
                        return true;
                }catch (e) {}
            }
         else 
            for (var i = 0; i < a.length; i++) {
                if (a[i] == o) {
                    return true;
                }
            }
        return false;
    };
    /**
     *  Returns true if the result is an object.
     * 
     *  @param {any} o Object to test.
     *  @return true iff the object is an object.
     *  @static
     *  @method isObject
     *  @memberOf EcArray
     */
    constructor.isObject = function(o) {
        if (EcArray.isArray(o)) 
            return false;
        if (o == null) 
            return false;
        return (typeof o) == "object";
    };
    /**
     *  Returns the index of an object or value if the object or value exists in the array. Uses .equals if available.
     * 
     *  @param {Array} a Array to check over.
     *  @param {any}   o Object to check for.
     *  @return Index of the result, -1 if the result isn't in the array.
     *  @static
     *  @method indexOf
     *  @memberOf EcArray
     */
    constructor.indexOf = function(a, o) {
        if (EcArray.isObject(o)) 
            for (var i = 0; i < a.length; i++) {
                if (a[i] == o) 
                    return i;
                try {
                    if (a[i].equals(o)) 
                        return i;
                }catch (e) {}
            }
         else 
            for (var i = 0; i < a.length; i++) {
                if (a[i] == o) {
                    return i;
                }
            }
        return -1;
    };
}, {}, {});
/**
 *  Object to hold a triple, used in graph.
 * 
 *  @author fritz.ray@eduworks.com
 *  @class Triple
 *  @module com.eduworks.ec
 */
var Triple = function() {};
Triple = stjs.extend(Triple, null, [], function(constructor, prototype) {
    /**
     *  Source vertex.
     * 
     *  @property source
     *  @type any
     */
    prototype.source = null;
    /**
     *  Destination vertex.
     * 
     *  @property destination
     *  @type any
     */
    prototype.destination = null;
    /**
     *  Object to hold in the edge.
     * 
     *  @property edge
     *  @type any
     */
    prototype.edge = null;
    /**
     *  Returns true IFF sources, destinations, and edges match.
     * 
     *  @param {Edge} obj
     *  @return {boolean} true IFF <see method definition>
     *  @method equals
     */
    prototype.equals = function(obj) {
        if (Object.prototype.equals.call(this, obj)) 
            return true;
        if (stjs.isInstanceOf(obj.constructor, Triple)) {
            var t = obj;
            if (this.source == t.source && this.destination == t.destination && this.edge == t.edge) 
                return true;
        }
        return false;
    };
}, {}, {});
/**
 *  Wrapper to handle all remote web service invocations.
 * 
 *  @author fritz.ray@eduworks.com
 *  @author devlin.junker@eduworks.com
 *  @class EcRemote
 *  @module com.eduworks.ec
 */
var EcRemote = function() {};
EcRemote = stjs.extend(EcRemote, null, [], function(constructor, prototype) {
    /**
     *  Turn this property off to cause all remote web service calls to be
     *  synchronous. Can be useful for test scripts, blocking calls, etc.
     * 
     *  @property async
     *  @static
     *  @type boolean
     */
    constructor.async = true;
    /**
     *  Timeout for AJAX requests
     * 
     *  @property async
     *  @static
     *  @type boolean
     */
    constructor.timeout = 60 * 1000 * 5;
    /**
     *  POSTs a request to a remote endpoint. Composed of a server endpoint (root
     *  URL) and a service (service path). Sends form data as a multi-part mime
     *  request.
     * 
     *  @param {string}           server Protocol, hostname and path to the remote handler.
     *  @param {string}           service Path to service to invoke.
     *  @param {FormData}         fd Form data to send as multi-part mime.
     *  @param {function(object)} success Method that is invoked if the server
     *                            responds with a success (per jQuery ajax)
     *  @param {function(string)} failure Method that is invoked if the server
     *                            responds with an error (per jQuery ajax) or a non-200/300.
     *  @method postExpectingObject
     *  @static
     */
    constructor.postExpectingObject = function(server, service, fd, success, failure) {
        EcRemote.postInner(server, service, fd, null, EcRemote.getSuccessJSONCallback(success, failure), failure);
    };
    /**
     *  POSTs a request to a remote endpoint. Composed of a server endpoint (root
     *  URL) and a service (service path). Sends form data as a multi-part mime
     *  request.
     * 
     *  @param {string}           server Protocol, hostname and path to the remote handler.
     *  @param {string}           service Path to service to invoke.
     *  @param {FormData}         fd Form data to send as multi-part mime.
     *  @param {function(string)} success Method that is invoked if the server
     *                            responds with a success (per jQuery ajax)
     *  @param {function(string)} failure Method that is invoked if the server
     *                            responds with an error (per jQuery ajax) or a non-200/300.
     *  @method postExpectingString
     *  @static
     */
    constructor.postExpectingString = function(server, service, fd, success, failure) {
        EcRemote.postInner(server, service, fd, null, success, failure);
    };
    /**
     *  POSTs a request to a remote endpoint. Composed of a server endpoint (root
     *  URL) and a service (service path). Sends form data as a multi-part mime
     *  request. Includes headers.
     * 
     *  @param {string}           server Protocol, hostname and path to the remote handler.
     *  @param {string}           service Path to service to invoke.
     *  @param {FormData}         fd Form data to send as multi-part mime.
     *  @param {Object}           headers Headers to attach to the HTTP post.
     *  @param {function(string)} success Method that is invoked if the server
     *                            responds with a success (per jQuery ajax)
     *  @param {function(string)} failure Method that is invoked if the server
     *                            responds with an error (per jQuery ajax) or a non-200/300.
     *  @method postWithHeadersExpectingString
     *  @static
     */
    constructor.postWithHeadersExpectingString = function(server, service, fd, headers, success, failure) {
        EcRemote.postInner(server, service, fd, headers, success, failure);
    };
    constructor.postInner = function(server, service, fd, headers, successCallback, failureCallback) {
        var url = server;
        if (!url.endsWith("/") && service != null && !"".equals(service)) {
            url += "/";
        }
        if (service != null) {
            url += service;
        }
        url = EcRemote.upgradeHttpToHttps(url);
        var xhr = null;
        var theBoundary = null;
        if ((fd)["_streams"] != null) {
            var chunks = (fd)["_streams"];
            var all = "";
            for (var i = 0; i < chunks.length; i++) {
                if ((typeof chunks[i]) == "function") {
                    all = all + "\r\n";
                } else {
                    all = all + chunks[i];
                }
            }
            all = all + "\r\n\r\n--" + (fd)["_boundary"] + "--";
            theBoundary = (fd)["_boundary"];
            fd = all;
        } else {}
        if ((typeof isNodeJs) != "undefined" && EcRemote.async) {
            if (headers == null) 
                headers = new Object();
            (headers)["Content-Type"] = "multipart/form-data; boundary=" + theBoundary;
            var requestObject = new Object();
            (requestObject)["method"] = "POST";
            (requestObject)["url"] = url;
            (requestObject)["headers"] = headers;
            (requestObject)["body"] = fd;
            request(requestObject, function(error, response, body) {
                if (failureCallback != null && error != null) 
                    failureCallback(error);
                 else if (failureCallback != null && (response)["statusCode"] != 200) 
                    failureCallback(body);
                 else if (successCallback != null) 
                    successCallback(body);
            });
            return;
        }
        if ((typeof httpStatus) == "undefined") {
            xhr = new XMLHttpRequest();
            xhr.open("POST", url, EcRemote.async);
            var xhrx = xhr;
            xhr.onreadystatechange = function() {
                if (xhrx.readyState == 4 && xhrx.status == 200) {
                    if (successCallback != null) 
                        successCallback(xhrx.responseText);
                } else if (xhrx.readyState == 4) {
                    if (failureCallback != null) 
                        failureCallback(xhrx.responseText);
                }
            };
            if (theBoundary != null) 
                xhr.setRequestHeader("Content-Type", "multipart/form-data; boundary=" + theBoundary);
        }
        if (xhr != null) 
            if (EcRemote.async) 
                (xhr)["timeout"] = EcRemote.timeout;
        if ((typeof httpStatus) != "undefined") {
            var result = JSON.stringify(httpPost(fd, url, "multipart/form-data; boundary=" + theBoundary, "false", theBoundary));
            if (successCallback != null) 
                successCallback(result);
        } else {
            xhr.send(fd);
        }
    };
    /**
     *  GETs something from a remote endpoint. Composed of a server endpoint
     *  (root URL) and a service (service path).
     * 
     *  @param {string}           server Protocol, hostname and path to the remote handler.
     *  @param {string}           service Path to service to invoke.
     *  @param {function(object)} success Method that is invoked if the server
     *                            responds with a success (per jQuery ajax)
     *  @param {function(string)} failure Method that is invoked if the server
     *                            responds with an error (per jQuery ajax) or a non-200/300.
     *  @method getExpectingObject
     *  @static
     */
    constructor.getExpectingObject = function(server, service, success, failure) {
        EcRemote.getExpectingString(server, service, EcRemote.getSuccessJSONCallback(success, failure), failure);
    };
    /**
     *  GETs something from a remote endpoint. Composed of a server endpoint
     *  (root URL) and a service (service path).
     * 
     *  @param {string}           server Protocol, hostname and path to the remote handler.
     *  @param {string}           service Path to service to invoke.
     *  @param {function(object)} success Method that is invoked if the server
     *                            responds with a success (per jQuery ajax)
     *  @param {function(string)} failure Method that is invoked if the server
     *                            responds with an error (per jQuery ajax) or a non-200/300.
     *  @method getExpectingString
     *  @static
     */
    constructor.getExpectingString = function(server, service, success, failure) {
        var url = EcRemote.urlAppend(server, service);
        url = EcRemote.upgradeHttpToHttps(url);
        var xhr = null;
        if ((typeof httpStatus) == "undefined") {
            xhr = new XMLHttpRequest();
            xhr.open("GET", url, EcRemote.async);
            var xhrx = xhr;
            xhr.onreadystatechange = function() {
                if (xhrx.readyState == 4 && xhrx.status == 200) 
                    if (success != null) 
                        success(xhrx.responseText);
                     else if (xhrx.readyState == 4) 
                        if (failure != null) 
                            failure(xhrx.responseText);
            };
            xhr.onerror = function(e) {
                if (failure != null) {
                    failure(null);
                }
            };
        }
        if ((typeof isNodeJs) != "undefined" && EcRemote.async) {
            var requestObject = new Object();
            (requestObject)["method"] = "GET";
            (requestObject)["url"] = url;
            request(requestObject, function(error, response, body) {
                if (failure != null && error != null) 
                    failure(error);
                 else if (failure != null && (response)["statusCode"] != 200) 
                    failure(body);
                 else if (success != null) 
                    success(body);
            });
            return;
        }
        if (xhr != null) {
            if (EcRemote.async) 
                (xhr)["timeout"] = EcRemote.timeout;
        }
        if ((typeof httpStatus) != "undefined") {
            if (success != null) 
                success(JSON.stringify(httpGet(url)));
        } else {
            xhr.send();
        }
    };
    constructor.urlAppend = function(server, service) {
        var url = server;
        if (!url.endsWith("/") && service != null && service.equals("")) {
            url += "/";
        }
        if (service != null) {
            url += service;
        }
        return url;
    };
    /**
     *  DELETEs something at a remote endpoint. Composed of a server endpoint
     *  (root URL) and a service (service path).
     * 
     *  @param {string}           server Protocol, hostname and path to the remote handler.
     *  @param {string}           service Path to service to invoke.
     *  @param {function(object)} success Method that is invoked if the server
     *                            responds with a success (per jQuery ajax)
     *  @param {function(string)} failure Method that is invoked if the server
     *                            responds with an error (per jQuery ajax) or a non-200/300.
     *  @method _delete
     *  @static
     */
    constructor._delete = function(url, signatureSheet, success, failure) {
        url = EcRemote.upgradeHttpToHttps(url);
        var xhr = null;
        if ((typeof httpStatus) == "undefined") {
            xhr = new XMLHttpRequest();
            xhr.open("DELETE", url, EcRemote.async);
            var xhrx = xhr;
            xhr.onreadystatechange = function() {
                if (xhrx.readyState == 4 && xhrx.status == 200) {
                    if (success != null) 
                        success(xhrx.responseText);
                } else if (xhrx.readyState == 4) {
                    if (failure != null) 
                        failure(xhrx.responseText);
                }
            };
        }
        if ((typeof isNodeJs) != "undefined" && EcRemote.async) {
            var sso = new Object();
            (sso)["signatureSheet"] = signatureSheet;
            var requestObject = new Object();
            (requestObject)["method"] = "DELETE";
            (requestObject)["url"] = url;
            (requestObject)["headers"] = sso;
            request(requestObject, function(error, response, body) {
                if (failure != null && error != null) 
                    failure(error);
                 else if (failure != null && (response)["statusCode"] != 200) 
                    failure(body);
                 else if (success != null) 
                    success(body);
            });
            return;
        }
        if (xhr != null) {
            if (EcRemote.async) 
                (xhr)["timeout"] = EcRemote.timeout;
            xhr.setRequestHeader("signatureSheet", signatureSheet);
        }
        if ((typeof httpStatus) != "undefined") {
            if (success != null) {
                var sso = new Object();
                (sso)["signatureSheet"] = signatureSheet;
                success(httpDelete(url, null, null, null, sso));
            }
        } else {
            xhr.send();
        }
    };
    constructor.upgradeHttpToHttps = function(url) {
        if (window != null) {
            if (window.location != null) {
                if (url.indexOf(window.location.protocol) == -1) {
                    if (window.location.protocol.startsWith("https")) {
                        if (!url.startsWith("https:")) {
                            url = url.replace("http:", "https:");
                        }
                    }
                }
            }
        }
        return url;
    };
    constructor.getSuccessJSONCallback = function(success, failure) {
        return function(s) {
            var o;
            try {
                o = JSON.parse(s);
            }catch (ex) {
                if (ex == null) 
                    failure("An unspecified error occurred during a network request.");
                 else 
                    failure(ex);
                return;
            }
            success(o);
        };
    };
}, {}, {});
var EcBrowserDetection = function() {};
EcBrowserDetection = stjs.extend(EcBrowserDetection, null, [], function(constructor, prototype) {
    constructor.isIeOrEdge = function() {
        if (window == null) 
            return false;
        if (window.navigator == null) 
            return false;
        if (window.navigator.appName == null) 
            return false;
        return window.navigator.appName == "Microsoft Internet Explorer" || (window.navigator.appName == "Netscape" && window.navigator.appVersion.indexOf("Edge") > -1);
    };
}, {}, {});
var EcLocalStorage = function() {};
EcLocalStorage = stjs.extend(EcLocalStorage, null, [], function(constructor, prototype) {
    constructor.removeItem = function(s, key) {
        ((s)["removeItem"])(key);
    };
}, {}, {});
/**
 *  A graph consisting of a set of vertices of type <code>V</code>
 *  set and a set of edges of type <code>E</code>.  Edges of this
 *  graph type have exactly two endpoints; whether these endpoints
 *  must be distinct depends on the implementation.
 *  <p>
 *  This interface permits, but does not enforce, any of the following
 *  common variations of graphs:
 *  <ul>
 *  <li> directed and undirected edges
 *  <li> vertices and edges with attributes (for example, weighted edges)
 *  <li> vertices and edges of different types (for example, bipartite
 *  or multimodal graphs)
 *  <li> parallel edges (multiple edges which connect a single set of vertices)
 *  <li> representations as matrices or as adjacency lists or adjacency maps
 *  </ul>
 *  Extensions or implementations of this interface
 *  may enforce or disallow any or all of these variations.
 *  <p>
 *  <p>Definitions (with respect to a given vertex <code>v</code>):
 *  <ul>
 *  <li/><b>incoming edge</b> of <code>v</code>: an edge that can be traversed
 *  from a neighbor of <code>v</code> to reach <code>v</code>
 *  <li/><b>outgoing edge</b> of <code>v</code>: an edge that can be traversed
 *  from <code>v</code> to reach some neighbor of <code>v</code>
 *  <li/><b>predecessor</b> of <code>v</code>: a vertex at the other end of an
 *  incoming edge of <code>v</code>
 *  <li/><b>successor</b> of <code>v</code>: a vertex at the other end of an
 *  outgoing edge of <code>v</code>
 *  <li/>
 *  </ul>
 * 
 *  @author Joshua O'Madadhain
 *          <p>
 *          Ported to Javascript by:
 *  @author Fritz Ray (fritz.ray@eduworks.com)
 *  @author Tom Buskirk (tom.buskirk@eduworks.com)
 *  @class Graph
 *  @module com.eduworks.ec
 *  @extends Hypergraph
 */
var Graph = function() {};
Graph = stjs.extend(Graph, null, [Hypergraph], function(constructor, prototype) {
    /**
     *  Returns a <code>Collection</code> view of the incoming edges incident to <code>vertex</code>
     *  in this graph.
     * 
     *  @param vertex the vertex whose incoming edges are to be returned
     *  @return a <code>Collection</code> view of the incoming edges incident
     *  to <code>vertex</code> in this graph
     *  @method getInEdges
     */
    prototype.getInEdges = function(vertex) {};
    /**
     *  Returns a <code>Collection</code> view of the outgoing edges incident to <code>vertex</code>
     *  in this graph.
     * 
     *  @param vertex the vertex whose outgoing edges are to be returned
     *  @return a <code>Collection</code> view of the outgoing edges incident
     *  to <code>vertex</code> in this graph
     *  @method getOutEdges
     */
    prototype.getOutEdges = function(vertex) {};
    /**
     *  Returns a <code>Collection</code> view of the predecessors of <code>vertex</code>
     *  in this graph.  A predecessor of <code>vertex</code> is defined as a vertex <code>v</code>
     *  which is connected to
     *  <code>vertex</code> by an edge <code>e</code>, where <code>e</code> is an outgoing edge of
     *  <code>v</code> and an incoming edge of <code>vertex</code>.
     * 
     *  @param vertex the vertex whose predecessors are to be returned
     *  @return a <code>Collection</code> view of the predecessors of
     *  <code>vertex</code> in this graph
     *  @method getPredecessors
     */
    prototype.getPredecessors = function(vertex) {};
    /**
     *  Returns a <code>Collection</code> view of the successors of <code>vertex</code>
     *  in this graph.  A successor of <code>vertex</code> is defined as a vertex <code>v</code>
     *  which is connected to
     *  <code>vertex</code> by an edge <code>e</code>, where <code>e</code> is an incoming edge of
     *  <code>v</code> and an outgoing edge of <code>vertex</code>.
     * 
     *  @param vertex the vertex whose predecessors are to be returned
     *  @return a <code>Collection</code> view of the successors of
     *  <code>vertex</code> in this graph
     *  @method getSuccessors
     */
    prototype.getSuccessors = function(vertex) {};
    /**
     *  Returns the number of incoming edges incident to <code>vertex</code>.
     *  Equivalent to <code>getInEdges(vertex).size()</code>.
     * 
     *  @param vertex the vertex whose indegree is to be calculated
     *  @return the number of incoming edges incident to <code>vertex</code>
     *  @method inDegree
     */
    prototype.inDegree = function(vertex) {};
    /**
     *  Returns the number of outgoing edges incident to <code>vertex</code>.
     *  Equivalent to <code>getOutEdges(vertex).size()</code>.
     * 
     *  @param vertex the vertex whose outdegree is to be calculated
     *  @return the number of outgoing edges incident to <code>vertex</code>
     *  @method outDegree
     */
    prototype.outDegree = function(vertex) {};
    /**
     *  Returns <code>true</code> if <code>v1</code> is a predecessor of <code>v2</code> in this graph.
     *  Equivalent to <code>v1.getPredecessors().contains(v2)</code>.
     * 
     *  @param v1 the first vertex to be queried
     *  @param v2 the second vertex to be queried
     *  @return <code>true</code> if <code>v1</code> is a predecessor of <code>v2</code>, and false otherwise.
     *  @method isPredecessor
     */
    prototype.isPredecessor = function(v1, v2) {};
    /**
     *  Returns <code>true</code> if <code>v1</code> is a successor of <code>v2</code> in this graph.
     *  Equivalent to <code>v1.getSuccessors().contains(v2)</code>.
     * 
     *  @param v1 the first vertex to be queried
     *  @param v2 the second vertex to be queried
     *  @return <code>true</code> if <code>v1</code> is a successor of <code>v2</code>, and false otherwise.
     *  @method isSuccessor
     */
    prototype.isSuccessor = function(v1, v2) {};
    /**
     *  Returns the number of predecessors that <code>vertex</code> has in this graph.
     *  Equivalent to <code>vertex.getPredecessors().size()</code>.
     * 
     *  @param vertex the vertex whose predecessor count is to be returned
     *  @return the number of predecessors that <code>vertex</code> has in this graph
     *  @method getPredecessorCount
     */
    prototype.getPredecessorCount = function(vertex) {};
    /**
     *  Returns the number of successors that <code>vertex</code> has in this graph.
     *  Equivalent to <code>vertex.getSuccessors().size()</code>.
     * 
     *  @param vertex the vertex whose successor count is to be returned
     *  @return the number of successors that <code>vertex</code> has in this graph
     *  @method getSuccessorCount
     */
    prototype.getSuccessorCount = function(vertex) {};
    /**
     *  If <code>directed_edge</code> is a directed edge in this graph, returns the source;
     *  otherwise returns <code>null</code>.
     *  The source of a directed edge <code>d</code> is defined to be the vertex for which
     *  <code>d</code> is an outgoing edge.
     *  <code>directed_edge</code> is guaranteed to be a directed edge if
     *  its <code>EdgeType</code> is <code>DIRECTED</code>.
     * 
     *  @param directed_edge
     *  @return the source of <code>directed_edge</code> if it is a directed edge in this graph, or <code>null</code> otherwise
     *  @method getSource
     */
    prototype.getSource = function(directed_edge) {};
    /**
     *  If <code>directed_edge</code> is a directed edge in this graph, returns the destination;
     *  otherwise returns <code>null</code>.
     *  The destination of a directed edge <code>d</code> is defined to be the vertex
     *  incident to <code>d</code> for which
     *  <code>d</code> is an incoming edge.
     *  <code>directed_edge</code> is guaranteed to be a directed edge if
     *  its <code>EdgeType</code> is <code>DIRECTED</code>.
     * 
     *  @param directed_edge
     *  @return the destination of <code>directed_edge</code> if it is a directed edge in this graph, or <code>null</code> otherwise
     *  @method getDest
     */
    prototype.getDest = function(directed_edge) {};
    /**
     *  Returns <code>true</code> if <code>vertex</code> is the source of <code>edge</code>.
     *  Equivalent to <code>getSource(edge).equals(vertex)</code>.
     * 
     *  @param vertex the vertex to be queried
     *  @param edge   the edge to be queried
     *  @return <code>true</code> iff <code>vertex</code> is the source of <code>edge</code>
     *  @method isSource
     */
    prototype.isSource = function(vertex, edge) {};
    /**
     *  Returns <code>true</code> if <code>vertex</code> is the destination of <code>edge</code>.
     *  Equivalent to <code>getDest(edge).equals(vertex)</code>.
     * 
     *  @param vertex the vertex to be queried
     *  @param edge   the edge to be queried
     *  @return <code>true</code> iff <code>vertex</code> is the destination of <code>edge</code>
     */
    prototype.isDest = function(vertex, edge) {};
    /**
     *  Adds edge <code>e</code> to this graph such that it connects
     *  vertex <code>v1</code> to <code>v2</code>.
     *  Equivalent to <code>addEdge(e, new Pair<V>(v1, v2))</code>.
     *  If this graph does not contain <code>v1</code>, <code>v2</code>,
     *  or both, implementations may choose to either silently add
     *  the vertices to the graph or throw an <code>IllegalArgumentException</code>.
     *  If this graph assigns edge types to its edges, the edge type of
     *  <code>e</code> will be the default for this graph.
     *  See <code>Hypergraph.addEdge()</code> for a listing of possible reasons
     *  for failure.
     * 
     *  @param e  the edge to be added
     *  @param v1 the first vertex to be connected
     *  @param v2 the second vertex to be connected
     *  @return <code>true</code> if the add is successful, <code>false</code> otherwise
     *  @method addEdge
     *  @see Hypergraph#addEdge(Object, Collection)
     *  @see #addEdge(Object, Object, Object, EdgeType)
     */
    prototype.addEdge = function(e, v1, v2) {};
    /**
     *  Returns the vertex at the other end of <code>edge</code> from <code>vertex</code>.
     *  (That is, returns the vertex incident to <code>edge</code> which is not <code>vertex</code>.)
     * 
     *  @param vertex the vertex to be queried
     *  @param edge   the edge to be queried
     *  @return the vertex at the other end of <code>edge</code> from <code>vertex</code>
     *  @method getOpposite
     */
    prototype.getOpposite = function(vertex, edge) {};
}, {}, {});
/**
 *  Object Helper Functions
 * 
 *  @author fritz.ray@eduworks.com
 *  @class EcObject
 *  @module com.eduworks.ec
 */
var EcObject = function() {};
EcObject = stjs.extend(EcObject, null, [], function(constructor, prototype) {
    /**
     *  Returns true if the result is an object.
     * 
     *  @param {any} o Object to test.
     *  @return true iff the object is an object.
     *  @static
     *  @method isArray
     */
    constructor.isObject = function(o) {
        if (EcArray.isArray(o)) 
            return false;
        if (o == null) 
            return false;
        return (typeof o) == "object";
    };
    /**
     *  Returns keys on the object
     * 
     *  @param {any} o Object to test.
     *  @return List of keys
     *  @static
     *  @method keys
     */
    constructor.keys = function(o) {
        return ecKeys(o);
    };
}, {}, {});
/**
 *  Class with static methods to prevent unnecessary overhead with small operations that don't prevent drawing,
 *  but to setTimeout on methods that slow down the browser sufficiently to interfere with drawing.
 *  Uses a framerate timer to determine between the two.
 * 
 *  @class Task
 */
var Task = function() {};
Task = stjs.extend(Task, null, [], function(constructor, prototype) {
    constructor.desiredFps = 2;
    constructor.lastFrame = null;
    constructor.tasks = new Array();
    constructor.delayedFunctions = 0;
    constructor.immediateFunctions = 0;
    constructor.calledFunctions = 0;
    constructor.asyncImmediateFunctions = 0;
    constructor.runningAsyncFunctions = 0;
    constructor.updateFrameHandle = null;
    /**
     *  Updates the framerate timer/counter.
     *  @method updateFrame
     *  @static
     */
    constructor.updateFrame = function() {
        Task.updateFrameHandle = setTimeout(function() {
            Task.lastFrame = Date.now();
            if (Task.calledFunctions - Task.delayedFunctions - Task.immediateFunctions == 0) {
                Task.updateFrameHandle = null;
            } else 
                Task.updateFrame();
        }, 100);
    };
    /**
     *  Invoke a method now or later based on whether some time has passed since we last drew the screen.
     *  @param {function()} c Method to invoke
     *  @return Timeout Handler, can use clearTimeout on it if needed.
     */
    constructor.immediate = function(c) {
        var currentMs = Date.now();
        var nextFrameMs = stjs.trunc(1000 / Task.desiredFps);
        Task.calledFunctions++;
        if (EcRemote.async == true && (Task.lastFrame == null || currentMs > Task.lastFrame + nextFrameMs)) {
            if (Task.updateFrameHandle == null) 
                Task.updateFrame();
            return setTimeout(function() {
                Task.delayedFunctions++;
                c();
            }, 0);
        } else {
            Task.immediateFunctions++;
            c();
        }
        return null;
    };
    /**
     *  Invoke a method at some point in the future, allowing draw methods to occur periodically.
     *  @param {function()} c Method to invoke
     *  @return Timeout Handler, can use clearTimeout on it if needed.
     */
    constructor.asyncImmediate = function(c) {
        Task.tasks.push(c);
        Task.asyncImmediateFunctions++;
        if (Task.runningAsyncFunctions < 20) {
            Task.runningAsyncFunctions++;
            return setTimeout(function() {
                Task.asyncContinue();
            }, 0);
        }
        return null;
    };
    constructor.asyncContinue = function() {
        var keepGoing = function() {
            Task.asyncContinue();
        };
        if (Task.tasks.length > 0) {
            var c = Task.tasks.pop();
            c(keepGoing);
        } else 
            Task.runningAsyncFunctions--;
    };
}, {tasks: {name: "Array", arguments: ["CallbackOrFunction"]}, updateFrameHandle: "Object"}, {});
(function() {
    Task.updateFrame();
})();
/**
 *  A directed implementation of {{#crossLink "Graph"}}Graph{{/crossLink}}. Edges have types. Two vertices may have many edges between them.
 * 
 *  @param <V>
 *  @param <E>
 *  @author fray
 *  @class EcDirectedGraph
 *  @module com.eduworks.ec
 *  @extends Graph
 */
var EcDirectedGraph = function() {
    this.edges = new Array();
    this.verticies = new Array();
};
EcDirectedGraph = stjs.extend(EcDirectedGraph, null, [Graph], function(constructor, prototype) {
    prototype.edges = null;
    prototype.verticies = null;
    prototype.getEdges = function() {
        var results = new Array();
        for (var i = 0; i < this.edges.length; i++) 
            results[i] = this.edges[i].edge;
        return results;
    };
    prototype.getVertices = function() {
        var results = new Array();
        for (var i = 0; i < this.verticies.length; i++) 
            results[i] = this.verticies[i];
        return results;
    };
    prototype.containsVertex = function(vertex) {
        for (var i = 0; i < this.verticies.length; i++) 
            if (vertex.equals(this.verticies[i])) 
                return true;
        return false;
    };
    prototype.containsEdge = function(edge) {
        for (var i = 0; i < this.edges.length; i++) 
            if (edge.equals(this.edges[i].edge)) 
                return true;
        return false;
    };
    prototype.getEdgeCount = function() {
        return this.edges.length;
    };
    prototype.getVertexCount = function() {
        return this.verticies.length;
    };
    prototype.getNeighbors = function(vertex) {
        var results = new Array();
        for (var i = 0; i < this.edges.length; i++) {
            if (vertex.equals(this.edges[i].source)) 
                results.push(this.edges[i].destination);
             else if (vertex.equals(this.edges[i].destination)) 
                results.push(this.edges[i].source);
        }
        EcArray.removeDuplicates(results);
        return results;
    };
    prototype.getIncidentEdges = function(vertex) {
        var results = new Array();
        for (var i = 0; i < this.edges.length; i++) {
            if (vertex.equals(this.edges[i].source)) 
                results.push(this.edges[i].edge);
             else if (vertex.equals(this.edges[i].destination)) 
                results.push(this.edges[i].edge);
        }
        EcArray.removeDuplicates(results);
        return results;
    };
    prototype.getIncidentVertices = function(edge) {
        var results = new Array();
        for (var i = 0; i < this.edges.length; i++) {
            if (edge.equals(this.edges[i].edge)) {
                results.push(this.edges[i].source);
                results.push(this.edges[i].destination);
            }
        }
        EcArray.removeDuplicates(results);
        return results;
    };
    prototype.findEdge = function(v1, v2) {
        for (var i = 0; i < this.edges.length; i++) {
            if (v1.equals(this.edges[i].source) && v2.equals(this.edges[i].destination)) 
                return this.edges[i].edge;
            if (v1.equals(this.edges[i].destination) && v2.equals(this.edges[i].source)) 
                return this.edges[i].edge;
        }
        return null;
    };
    prototype.findEdgeSet = function(v1, v2) {
        var results = new Array();
        for (var i = 0; i < this.edges.length; i++) {
            if (v1.equals(this.edges[i].source) && v2.equals(this.edges[i].destination)) 
                results.push(this.edges[i].edge);
            if (v1.equals(this.edges[i].destination) && v2.equals(this.edges[i].source)) 
                results.push(this.edges[i].edge);
        }
        return results;
    };
    prototype.addVertex = function(vertex) {
        this.verticies.push(vertex);
        return true;
    };
    prototype.addVertexSafely = function(vertex) {
        if (EcArray.has(this.verticies, vertex)) 
            return false;
        this.verticies.push(vertex);
        return true;
    };
    prototype.removeVertex = function(vertex) {
        var indexOf = EcArray.indexOf(this.verticies, vertex);
        if (indexOf != -1) {
            for (var i = 0; i < this.edges.length; i++) {
                if (this.edges[i].source.equals(vertex) || this.edges[i].destination.equals(vertex)) {
                    this.edges.splice(i, 1);
                    i--;
                }
            }
            this.verticies.splice(indexOf, 1);
            return true;
        }
        return false;
    };
    prototype.removeEdge = function(edge) {
        var success = false;
        for (var i = 0; i < this.edges.length; i++) {
            if (this.edges[i].edge.equals(edge)) {
                this.edges.splice(i, 1);
                i--;
                success = true;
            }
        }
        return success;
    };
    prototype.isNeighbor = function(v1, v2) {
        for (var i = 0; i < this.edges.length; i++) {
            if (v1.equals(this.edges[i].source) && v2.equals(this.edges[i].destination)) 
                return true;
             else if (v1.equals(this.edges[i].destination) && v2.equals(this.edges[i].source)) 
                return true;
        }
        return false;
    };
    prototype.isIncident = function(vertex, edge) {
        for (var i = 0; i < this.edges.length; i++) {
            if ((vertex.equals(this.edges[i].source) || vertex.equals(this.edges[i].destination)) && edge.equals(this.edges[i].edge)) 
                return true;
        }
        return false;
    };
    prototype.degree = function(vertex) {
        var count = 0;
        for (var i = 0; i < this.edges.length; i++) {
            if (vertex.equals(this.edges[i].source) || vertex.equals(this.edges[i].destination)) 
                count++;
        }
        return count;
    };
    prototype.getNeighborCount = function(vertex) {
        return this.getNeighbors(vertex).length;
    };
    prototype.getIncidentCount = function(edge) {
        return this.getIncidentVertices(edge).length;
    };
    prototype.getEdgeType = function(edge) {};
    prototype.getDefaultEdgeType = function() {};
    prototype.getEdgesOfType = function(edge_type) {
        var results = new Array();
        for (var i = 0; i < this.edges.length; i++) {
            if (this.getEdgeType(this.edges[i].edge) == edge_type) 
                results.push(this.edges[i].edge);
        }
        return results;
    };
    prototype.getEdgeCountOfType = function(edge_type) {
        return this.getEdgesOfType(edge_type).length;
    };
    prototype.getInEdges = function(vertex) {
        var results = new Array();
        for (var i = 0; i < this.edges.length; i++) {
            if (vertex.equals(this.edges[i].destination)) 
                results.push(this.edges[i].edge);
        }
        EcArray.removeDuplicates(results);
        return results;
    };
    prototype.getOutEdges = function(vertex) {
        var results = new Array();
        for (var i = 0; i < this.edges.length; i++) {
            if (vertex.equals(this.edges[i].source)) 
                results.push(this.edges[i].edge);
        }
        EcArray.removeDuplicates(results);
        return results;
    };
    prototype.inDegree = function(vertex) {
        return this.getInEdges(vertex).length;
    };
    prototype.outDegree = function(vertex) {
        return this.getOutEdges(vertex).length;
    };
    prototype.getSource = function(directed_edge) {
        for (var i = 0; i < this.edges.length; i++) {
            if (directed_edge.equals(this.edges[i].edge)) 
                return this.edges[i].source;
        }
        return null;
    };
    prototype.getDest = function(directed_edge) {
        for (var i = 0; i < this.edges.length; i++) {
            if (directed_edge.equals(this.edges[i].edge)) 
                return this.edges[i].destination;
        }
        return null;
    };
    prototype.getPredecessors = function(vertex) {
        var results = new Array();
        for (var i = 0; i < this.edges.length; i++) {
            if (vertex.equals(this.edges[i].destination)) 
                results.push(this.edges[i].source);
        }
        EcArray.removeDuplicates(results);
        return results;
    };
    prototype.getSuccessors = function(vertex) {
        var results = new Array();
        for (var i = 0; i < this.edges.length; i++) {
            if (vertex.equals(this.edges[i].source)) 
                results.push(this.edges[i].destination);
        }
        EcArray.removeDuplicates(results);
        return results;
    };
    prototype.isPredecessor = function(v1, v2) {
        for (var i = 0; i < this.edges.length; i++) {
            if (v1.equals(this.edges[i].destination)) 
                if (v2.equals(this.edges[i].source)) 
                    return true;
        }
        return false;
    };
    prototype.isSuccessor = function(v1, v2) {
        for (var i = 0; i < this.edges.length; i++) {
            if (v2.equals(this.edges[i].destination)) 
                if (v1.equals(this.edges[i].source)) 
                    return true;
        }
        return false;
    };
    prototype.getPredecessorCount = function(vertex) {
        return this.getPredecessors(vertex).length;
    };
    prototype.getSuccessorCount = function(vertex) {
        return this.getSuccessors(vertex).length;
    };
    prototype.isSource = function(vertex, edge) {
        for (var i = 0; i < this.edges.length; i++) {
            if (edge.equals(this.edges[i].edge)) 
                if (vertex.equals(this.edges[i].source)) 
                    return true;
        }
        return false;
    };
    prototype.isDest = function(vertex, edge) {
        for (var i = 0; i < this.edges.length; i++) {
            if (edge.equals(this.edges[i].edge)) 
                if (vertex.equals(this.edges[i].destination)) 
                    return true;
        }
        return false;
    };
    prototype.addEdge = function(e, v1, v2) {
        this.addVertexSafely(v1);
        this.addVertexSafely(v2);
        var t = new Triple();
        t.source = v1;
        t.destination = v2;
        t.edge = e;
        this.edges.push(t);
        return true;
    };
    prototype.addEdgeUnsafely = function(e, v1, v2) {
        var t = new Triple();
        t.source = v1;
        t.destination = v2;
        t.edge = e;
        this.edges.push(t);
        return true;
    };
    prototype.addEdgeSafely = function(e, v1, v2) {
        this.addVertexSafely(v1);
        this.addVertexSafely(v2);
        var t = new Triple();
        t.source = v1;
        t.destination = v2;
        t.edge = e;
        if (EcArray.has(this.edges, t)) 
            return false;
        this.edges.push(t);
        return true;
    };
    prototype.getOpposite = function(vertex, edge) {
        for (var i = 0; i < this.edges.length; i++) {
            if (edge.equals(this.edges[i].edge)) 
                if (vertex.equals(this.edges[i].destination)) 
                    return this.edges[i].source;
                 else if (vertex.equals(this.edges[i].source)) 
                    return this.edges[i].destination;
        }
        return null;
    };
}, {edges: {name: "Array", arguments: [{name: "Triple", arguments: ["V", "V", "E"]}]}, verticies: {name: "Array", arguments: ["V"]}}, {});
/**
 *  Pattern (probably similar to Promise) that provides fine grained control over asynchronous execution.
 *  Will iterate over all items in an array and perform 'each(item,callback)'.
 *  Every 'each' needs to call the callback. This callback can be passed down through several asynchronous calls.
 *  When all callbacks have been called, 'after(array)' is called.
 * 
 *  @author fritz.ray@eduworks.com
 *  @module com.eduworks.ec
 *  @class EcAsyncHelper
 */
var EcAsyncHelper = function() {};
EcAsyncHelper = stjs.extend(EcAsyncHelper, null, [], function(constructor, prototype) {
    constructor.scriptPath = null;
    constructor.setNull = function(set) {
        return function(s) {
            set(null);
        };
    };
    /**
     *  Counter that counts down when each callback is called. Lots of tricks can be done to cause after to proc in different ways.
     * 
     *  @property counter
     *  @type integer
     */
    prototype.counter = null;
    /**
     *  "Each" method. See class description.
     * 
     *  @param {Array}                   array Array to iterate over.
     *  @param {function(item,callback)} each Method that gets invoked per item in the array.
     *  @param {function(array)}         after Method invoked when all callbacks are called.
     *  @method each
     *  @memberOf EcAsyncHelper
     */
    prototype.each = function(array, each, after) {
        var me = this;
        this.counter = array.length;
        if (array.length == 0) 
            after(array);
        for (var i = 0; i < array.length; i++) {
            if (this.counter > 0) 
                this.execute(array, each, after, me, i);
        }
    };
    /**
     *  "Each" method. Allows for replacing values in the array. See class description.
     * 
     *  @param {Array}                   array Array to iterate over.
     *  @param {function(item,callback)} each Method that gets invoked per item in the array.
     *  @param {function(array)}         after Method invoked when all callbacks are called.
     *  @method each
     *  @memberOf EcAsyncHelper
     */
    prototype.eachSet = function(array, each, after) {
        var me = this;
        this.counter = array.length;
        if (array.length == 0) 
            after(array);
        for (var i = 0; i < array.length; i++) {
            if (this.counter > 0) 
                this.executeSet(array, each, after, me, i);
        }
    };
    prototype.execute = function(array, each, after, me, i) {
        Task.immediate(function() {
            each(array[i], function() {
                me.counter--;
                if (me.counter == 0) 
                    after(array);
            });
        });
    };
    prototype.executeSet = function(array, each, after, me, i) {
        Task.immediate(function() {
            each(array[i], function(result) {
                array[i] = result;
                me.counter--;
                if (me.counter == 0) {
                    var finalArray = new Array();
                    for (var j = 0; j < array.length; j++) 
                        if (array[j] != null) 
                            finalArray.push(array[j]);
                    after(finalArray);
                }
            });
        });
    };
    prototype.failWithCallback = function(failure, callback) {
        return function(s) {
            callback();
            failure(s);
        };
    };
    /**
     *  Stops any remaining objects from being iterated over, if they have not already. Will prevent 'after' from being called.
     * 
     *  @method stop
     *  @memberOf EcAsyncHelper
     */
    prototype.stop = function() {
        this.counter = -1;
    };
    /**
     *  Stops any remaining objects from being iterated over, if they have not already. Will allow 'after' to be called.
     * 
     *  @method stop
     *  @memberOf EcAsyncHelper
     */
    prototype.finish = function() {
        this.counter = 1;
    };
    /**
     *  Is preventing 'after' from being called?
     * 
     *  @return whether it is stopped.
     *  @method isStopped
     *  @memberOf EcAsyncHelper
     */
    prototype.isStopped = function() {
        return this.counter <= -1;
    };
}, {}, {});

var CryptoKey = function() {};
CryptoKey = stjs.extend(CryptoKey, null, [], null, {}, {});
var AlgorithmIdentifier = function() {};
AlgorithmIdentifier = stjs.extend(AlgorithmIdentifier, null, [], function(constructor, prototype) {
    prototype.name = null;
    prototype.modulusLength = 0;
    prototype.length = 0;
    prototype.publicExponent = null;
    prototype.hash = null;
    prototype.iv = null;
    prototype.counter = null;
}, {iv: "ArrayBuffer", counter: "ArrayBuffer"}, {});
var jwk = function() {};
jwk = stjs.extend(jwk, null, [], function(constructor, prototype) {
    prototype.kty = null;
    prototype.k = null;
    prototype.alg = null;
    prototype.ext = null;
}, {}, {});
/**
 *  Helper classes for dealing with RSA Public Keys.
 * 
 *  @author fritz.ray@eduworks.com
 *  @class EcPk
 *  @module com.eduworks.ec
 */
var EcPk = function() {};
EcPk = stjs.extend(EcPk, null, [], function(constructor, prototype) {
    constructor.cache = null;
    prototype.pk = null;
    prototype.defaultPem = null;
    prototype.jwk = null;
    prototype.key = null;
    prototype.signKey = null;
    /**
     *  Decodes a PEM encoded SubjectPublicKeyInfo (PKCS#8) or RSAPublicKey (PKCS#1) formatted RSA Public Key.
     *  (In case you were curious.)
     * 
     *  @param {string} pem PEM as a string.
     *  @return {EcPk} Object used to perform public key operations.
     *  @method fromPem
     *  @static
     */
    constructor.fromPem = function(pem) {
        var pk = (EcPk.cache)[pem];
        if (pk != null) 
            return pk;
        pk = new EcPk();
        try {
            pk.pk = forge.pki.publicKeyFromPem(pem);
        }catch (ex) {
            return null;
        }
        (EcPk.cache)[pem] = pk;
        return pk;
    };
    /**
     *  Compares two public keys, and returns true if their PEM forms match.
     * 
     *  @param {EcPk} obj Object to compare to.
     *  @return {boolean} True if the keys match.
     *  @method equals
     */
    prototype.equals = function(obj) {
        if (stjs.isInstanceOf(obj.constructor, EcPk)) 
            return this.toPem().equals((obj).toPem());
        return Object.prototype.equals.call(this, obj);
    };
    /**
     *  Encodes the public key into a PEM encoded SubjectPublicKeyInfo (PKCS#8) formatted RSA Public Key.
     *  (In case you were curious.)
     * 
     *  @return {string} PEM encoded public key without whitespace.
     *  @method toPem
     */
    prototype.toPem = function() {
        if (this.defaultPem == null) 
            this.defaultPem = forge.pki.publicKeyToPem(this.pk).replaceAll("\r", "").replaceAll("\n", "");
        return this.defaultPem;
    };
    /**
     *  Encodes the public key into a PEM encoded RSAPublicKey (PKCS#1) formatted RSA Public Key.
     *  (In case you were curious.)
     * 
     *  @return {string} PEM encoded public key without whitespace.
     *  @method toPkcs1Pem
     */
    prototype.toPkcs1Pem = function() {
        return forge.pki.publicKeyToRSAPublicKeyPem(this.pk).replaceAll("\r", "").replaceAll("\n", "");
    };
    /**
     *  Encodes the public key into a PEM encoded SubjectPublicKeyInfo (PKCS#8) formatted RSA Public Key.
     *  (In case you were curious.)
     * 
     *  @return {string} PEM encoded public key without whitespace.
     *  @method toPkcs8Pem
     */
    prototype.toPkcs8Pem = function() {
        return forge.pki.publicKeyToPem(this.pk).replaceAll("\r", "").replaceAll("\n", "");
    };
    prototype.toJwk = function() {
        if (this.jwk == null) 
            this.jwk = pemJwk.pem2jwk(forge.pki.publicKeyToPem(this.pk));
        return this.jwk;
    };
    /**
     *  Hashes the public key into an SSH compatible fingerprint.
     * 
     *  @return {string} Public key fingerprint.
     *  @method fingerprint
     */
    prototype.fingerprint = function() {
        var o = new Object();
        (o)["encoding"] = "hex";
        return forge.ssh.getPublicKeyFingerprint(this.pk, o);
    };
    prototype.verify = function(bytes, decode64) {
        return this.pk.verify(bytes, decode64);
    };
}, {cache: "Object", pk: "forge.pk", jwk: "Object", key: "CryptoKey", signKey: "CryptoKey"}, {});
(function() {
    if (EcPk.cache == null) 
        EcPk.cache = new Object();
})();
/**
 *  AES encryption tasks common across all variants of AES.
 *  @class EcAes
 *  @module com.eduworks.ec
 *  @author fritz.ray@eduworks.com
 */
var EcAes = function() {};
EcAes = stjs.extend(EcAes, null, [], function(constructor, prototype) {
    /**
     *  Generates a random secret of length @i
     *  @method newSecret
     *  @static
     *  @param {integer} i Length of secret
     *  @return {string} String representing the new secret, encoded using Base64.
     */
    constructor.newSecret = function(i) {
        return forge.util.encode64(forge.random.getBytesSync(i));
    };
    /**
     *  Generates a random Initialization Vector of length @i
     *  @method newIv
     *  @static
     *  @param {integer} i Length of initialization Vector
     *  @return {string} String representing the new Initialization Vector, encoded using Base64.
     */
    constructor.newIv = function(i) {
        return forge.util.encode64(forge.random.getBytesSync(i));
    };
}, {}, {});
/**
 *  @author Fritz
 *  @class EcCrypto
 */
var EcCrypto = function() {};
EcCrypto = stjs.extend(EcCrypto, null, [], function(constructor, prototype) {
    /**
     *  Turn on (defualt off) caching of decrypted data.
     *  @property caching
     *  @type boolean
     */
    constructor.caching = false;
    constructor.decryptionCache = new Object();
    /**
     *  Calculate MD5 hash of a string.
     *  @param {String} s String to MD5
     *  @return {String} MD5 hash
     *  @static
     *  @method md5
     */
    constructor.md5 = function(s) {
        var m = forge.md.md5.create();
        m.update(s);
        return m.digest().toHex();
    };
    /**
     *  Calculate SHA-256 hash of a string.
     *  @param {String} s String to SHA-256
     *  @return {String} SHA-256 hash
     *  @static
     *  @method sha256
     */
    constructor.sha256 = function(s) {
        var m = forge.md.sha256.create();
        m.update(s, "utf8");
        return m.digest().toHex();
    };
}, {decryptionCache: "Object"}, {});
var EcAesParameters = function(iv) {
    this.iv = forge.util.decode64(iv);
};
EcAesParameters = stjs.extend(EcAesParameters, null, [], function(constructor, prototype) {
    prototype.iv = null;
}, {iv: "forge.payload"}, {});
var SubtleCrypto = function() {};
SubtleCrypto = stjs.extend(SubtleCrypto, null, [], function(constructor, prototype) {
    prototype.encrypt = function(algorithm, key, data) {
        return null;
    };
    prototype.decrypt = function(algorithm, key, data) {
        return null;
    };
    prototype.sign = function(algorithm, key, data) {
        return null;
    };
    prototype.verify = function(algorithm, key, signature, data) {
        return null;
    };
    prototype.generateKey = function(algorithm, extractable, keyUsages) {
        return null;
    };
    prototype.deriveBits = function(algorithm, baseKey, length) {
        return null;
    };
    prototype.importKey = function(format, keyData, algorithm, extractable, keyUsages) {
        return null;
    };
}, {}, {});
/**
 *  Helper classes for dealing with RSA Private Keys.
 * 
 *  @author fritz.ray@eduworks.com
 *  @class EcPpk
 *  @module com.eduworks.ec
 */
var EcPpk = function() {};
EcPpk = stjs.extend(EcPpk, null, [], function(constructor, prototype) {
    constructor.cache = null;
    prototype.defaultPem = null;
    prototype.jwk = null;
    prototype.key = null;
    prototype.signKey = null;
    prototype.ppk = null;
    prototype.defaultPk = null;
    /**
     *  Decodes a PEM encoded PrivateKeyInfo (PKCS#8) or RSAPrivateKey (PKCS#1) formatted RSA Public Key.
     *  (In case you were curious.)
     * 
     *  @param {string} pem PEM as a string.
     *  @return {EcPk} Object used to perform public key operations.
     *  @method fromPem
     *  @static
     */
    constructor.fromPem = function(pem) {
        var pk = (EcPpk.cache)[pem];
        if (pk != null) 
            return pk;
        pk = new EcPpk();
        try {
            pk.ppk = forge.pki.privateKeyFromPem(pem);
        }catch (ex) {
            return null;
        }
        (EcPpk.cache)[pem] = pk;
        return pk;
    };
    /**
     *  Generates an RSA Keypair using web workers.
     * 
     *  @param {function(EcPpk)} callback Method called when the keypair is generated.
     *  @method generateKeyAsync
     *  @static
     */
    constructor.generateKeyAsync = function(callback) {
        var o = new Object();
        (o)["workers"] = -1;
        forge.pki.rsa.generateKeyPair(o, function(err, keypair) {
            var ppk = new EcPpk();
            ppk.ppk = keypair.privateKey;
            callback(ppk);
        });
    };
    /**
     *  Generates an RSA Keypair synchronously. Can take a while.
     * 
     *  @return {EcPpk} Public private keypair.
     *  @method generateKey
     *  @static
     */
    constructor.generateKey = function() {
        var o = new Object();
        (o)["workers"] = -1;
        var keypair = forge.pki.rsa.generateKeyPair(o, null);
        var ppk = new EcPpk();
        ppk.ppk = keypair.privateKey;
        return ppk;
    };
    /**
     *  Returns true iff the PEM forms of the public private keypair match.
     *  Can also match against a public key if the public portion of the keypair match.
     * 
     *  @param {EcPpk|EcPk} Key to compare to.
     *  @return boolean If they match.
     *  @method equals
     */
    prototype.equals = function(obj) {
        if (stjs.isInstanceOf(obj.constructor, EcPpk)) 
            return this.toPem().equals((obj).toPem());
        if (stjs.isInstanceOf(obj.constructor, EcPk)) 
            return this.toPk().toPem().equals((obj).toPem());
        return Object.prototype.equals.call(this, obj);
    };
    /**
     *  Encodes the private key into a PEM encoded RSAPrivateKey (PKCS#1) formatted RSA Public Key.
     *  (In case you were curious.)
     * 
     *  @return {string} PEM encoded public key without whitespace.
     *  @method toPem
     */
    prototype.toPem = function() {
        if (this.defaultPem == null) 
            this.defaultPem = forge.pki.privateKeyToPem(this.ppk).replaceAll("\r", "").replaceAll("\n", "");
        return this.defaultPem;
    };
    /**
     *  Encodes the private key into a PEM encoded RSAPrivateKey (PKCS#1) formatted RSA Public Key.
     *  (In case you were curious.)
     * 
     *  @return {string} PEM encoded public key without whitespace.
     *  @method toPkcs1Pem
     */
    prototype.toPkcs1Pem = function() {
        return forge.pki.privateKeyToPem(this.ppk).replaceAll("\r", "").replaceAll("\n", "");
    };
    /**
     *  Encodes the private key into a PEM encoded PrivateKeyInfo (PKCS#8) formatted RSA Public Key.
     *  (In case you were curious.)
     * 
     *  @return {string} PEM encoded public key without whitespace.
     *  @method toPkcs8Pem
     */
    prototype.toPkcs8Pem = function() {
        return forge.pki.privateKeyInfoToPem(forge.pki.wrapRsaPrivateKey(forge.pki.privateKeyToAsn1(this.ppk))).replaceAll("\r", "").replaceAll("\n", "");
    };
    prototype.toJwk = function() {
        if (this.jwk == null) 
            this.jwk = pemJwk.pem2jwk(forge.pki.privateKeyToPem(this.ppk));
        return this.jwk;
    };
    prototype.toPkcs8 = function() {
        return forge.pki.wrapRsaPrivateKey(forge.pki.privateKeyToAsn1(this.ppk));
    };
    /**
     *  Extracts the public key portion from the public private keypair.
     * 
     *  @return {EcPk} Public Key Helper.
     *  @method toPk
     */
    prototype.toPk = function() {
        if (this.defaultPk != null) 
            return this.defaultPk;
        var pk = this.defaultPk = new EcPk();
        pk.pk = forge.pki.rsa.setPublicKey(this.ppk.n, this.ppk.e);
        return pk;
    };
    /**
     *  Returns true if this PPK is in an array of PPKs.
     * 
     *  @param {Array<EcPpk>} ppks Array of ppks
     *  @return true iff this PPK in ppks.
     *  @method inArray
     */
    prototype.inArray = function(ppks) {
        for (var i = 0; i < ppks.length; i++) {
            if (ppks[i].equals(this)) 
                return true;
        }
        return false;
    };
}, {cache: "Object", jwk: "Object", key: "CryptoKey", signKey: "CryptoKey", ppk: "forge.ppk", defaultPk: "EcPk"}, {});
(function() {
    if (EcPpk.cache == null) 
        EcPpk.cache = new Object();
})();
/**
 *  Helper methods for performing RSA Encryption methods. Uses Optimal Asymmetric
 *  Encryption Padding (OAEP) encryption and decryption. Uses RSA SSA PKCS#1 v1.5
 *  (RSASSA-PKCS1-V1_5) signing and verifying with UTF8 encoding.
 * 
 *  @author fritz.ray@eduworks.com
 *  @module com.eduworks.ec
 *  @class EcRsaOaep
 */
var EcRsaOaep = function() {};
EcRsaOaep = stjs.extend(EcRsaOaep, null, [], function(constructor, prototype) {
    /**
     *  Encrypts a block of plaintext (no more than 256 bytes) with a public key
     *  using RSA OAEP encryption. Returns a base64 encoded ciphertext.
     * 
     *  @param {EcPk}   pk Public Key.
     *  @param {string} plaintext Plaintext. Does not perform encoding.
     *  @method encrypt
     *  @static
     */
    constructor.encrypt = function(pk, plaintext) {
        if ((typeof httpStatus) != "undefined") {
            return rsaEncrypt(plaintext, pk.toPem());
        }
        return forge.util.encode64(pk.pk.encrypt(forge.util.encodeUtf8(plaintext), "RSA-OAEP"));
    };
    /**
     *  Decrypts a block of ciphertext (no more than 256 bytes) with a private
     *  key using RSA OAEP encryption. Returns a unencoded plaintext.
     * 
     *  @param {EcPpk}  ppk Public private keypair.
     *  @param {string} ciphertext Ciphertext.
     *  @return {string} Unencoded plaintext.
     *  @method decrypt
     *  @static
     */
    constructor.decrypt = function(ppk, ciphertext) {
        if (EcCrypto.caching) {
            var cacheGet = null;
            cacheGet = (EcCrypto.decryptionCache)[ppk.toPem() + ciphertext];
            if (cacheGet != null) {
                return cacheGet;
            }
        }
        var result;
        if ((typeof httpStatus) != "undefined") {
            result = rsaDecrypt(ciphertext, ppk.toPem());
        } else {
            result = forge.util.decodeUtf8(ppk.ppk.decrypt(forge.util.decode64(ciphertext), "RSA-OAEP"));
        }
        if (EcCrypto.caching) {
            (EcCrypto.decryptionCache)[ppk.toPem() + ciphertext] = result;
        }
        return result;
    };
    /**
     *  Creates a signature for the provided text using the public private
     *  keypair. May be verified with the public key. Uses SHA1 hash with a UTF8
     *  decoding of the text. Returns base64 encoded signature.
     * 
     *  @param {EcPpk}  ppk Public private keypair.
     *  @param {string} text Text to sign.
     *  @return Base64 encoded signature.
     *  @method sign
     *  @static
     */
    constructor.sign = function(ppk, text) {
        if ((typeof httpStatus) != "undefined") {
            return rsaSign(text, ppk.toPem());
        }
        var s = forge.md.sha1.create();
        s.update(forge.util.encodeUtf8(text), "utf8");
        return forge.util.encode64(ppk.ppk.sign(s));
    };
    /**
     *  Creates a signature for the provided text using the public private
     *  keypair. May be verified with the public key. Uses SHA256 hash with a
     *  UTF8 decoding of the text. Returns base64 encoded signature.
     * 
     *  @param {EcPpk}  ppk Public private keypair.
     *  @param {string} text Text to sign.
     *  @return Base64 encoded signature.
     *  @method signSha256
     *  @static
     */
    constructor.signSha256 = function(ppk, text) {
        var s = forge.md.sha256.create();
        s.update(forge.util.encodeUtf8(text), "utf8");
        return forge.util.encode64(ppk.ppk.sign(s));
    };
    /**
     *  Verifies the integrity of the provided text using a signature and a
     *  public key. Uses SHA1 hash with a UTF8 decoding of the text.
     * 
     *  @param {EcPk}   pk Public key.
     *  @param {string} text Text to verify.
     *  @param {string} signature Base64 encoded signature.
     *  @return True IFF the signature is valid.
     *  @static
     *  @method verify
     */
    constructor.verify = function(pk, text, signature) {
        if ((typeof httpStatus) != "undefined") {
            return rsaVerify(signature, pk.toPem(), text);
        }
        var s = forge.md.sha1.create();
        s.update(forge.util.encodeUtf8(text), "utf8");
        try {
            return pk.verify(s.digest().bytes(), forge.util.decode64(signature));
        }catch (ex) {
            return false;
        }
    };
    /**
     *  Verifies the integrity of the provided text using a signature and a
     *  public key. Uses SHA1 hash with a UTF8 decoding of the text.
     * 
     *  @param {EcPk}   pk Public key.
     *  @param {string} text Text to verify.
     *  @param {string} signature Base64 encoded signature.
     *  @return True IFF the signature is valid.
     *  @static
     *  @method verify
     */
    constructor.verifySha256 = function(pk, text, signature) {
        if ((typeof httpStatus) != "undefined") {
            return rsaVerifySha256(signature, pk.toPem(), text);
        }
        var s = forge.md.sha256.create();
        s.update(forge.util.encodeUtf8(text), "utf8");
        try {
            return pk.verify(s.digest().bytes(), forge.util.decode64(signature));
        }catch (ex) {
            return false;
        }
    };
}, {}, {});
/**
 *  Encrypts data synchronously using AES-256-CTR. Requires secret and iv to be 32 bytes.
 *  Output is encoded in base64 for easier handling.
 * 
 *  @author fritz.ray@eduworks.com
 *  @module com.eduworks.ec
 *  @class EcAesCtr
 */
var EcAesCtr = function() {};
EcAesCtr = stjs.extend(EcAesCtr, null, [], function(constructor, prototype) {
    /**
     *  Encrypts plaintext using AES-256-CTR.
     *  Plaintext is treated as as a sequence of bytes, does not perform UTF8 decoding.
     *  Returns base64 encoded ciphertext.
     * 
     *  @param {string} plaintext Text to encrypt.
     *  @param {string} secret Secret to use to encrypt.
     *  @param {string} iv Initialization Vector to use to encrypt.
     *  @return {string} Ciphertext encoded using base64.
     *  @method encrypt
     *  @static
     */
    constructor.encrypt = function(plaintext, secret, iv) {
        if ((typeof httpStatus) != "undefined" && forge.util.decode64(secret).length == 16 && forge.util.decode64(iv).length == 16) 
            return aesEncrypt(plaintext, iv, secret);
        var c = forge.cipher.createCipher("AES-CTR", forge.util.decode64(secret));
        c.start(new EcAesParameters(iv));
        c.update(forge.util.createBuffer(forge.util.encodeUtf8(plaintext)));
        c.finish();
        var encrypted = c.output;
        return forge.util.encode64(encrypted.bytes());
    };
    /**
     *  Decrypts ciphertext using AES-256-CTR.
     *  Ciphertext must be base64 encoded ciphertext.
     *  Returns plaintext as a string (Sequence of bytes, no encoding).
     * 
     *  @param {string} ciphertext Ciphertext to decrypt.
     *  @param {string} secret Secret to use to decrypt.
     *  @param {string} iv Initialization Vector to use to decrypt.
     *  @return {string} Plaintext with no encoding.
     *  @method decrypt
     *  @static
     */
    constructor.decrypt = function(ciphertext, secret, iv) {
        if (EcCrypto.caching) {
            var cacheGet = (EcCrypto.decryptionCache)[secret + iv + ciphertext];
            if (cacheGet != null) 
                return cacheGet;
        }
        if ((typeof httpStatus) != "undefined" && forge.util.decode64(secret).length == 16 && forge.util.decode64(iv).length == 16) {
            var result = aesDecrypt(ciphertext, iv, secret);
            if (EcCrypto.caching) 
                (EcCrypto.decryptionCache)[secret + iv + ciphertext] = result;
            return result;
        }
        var c = forge.cipher.createDecipher("AES-CTR", forge.util.decode64(secret));
        c.start(new EcAesParameters(iv));
        c.update(forge.util.createBuffer(forge.util.decode64(ciphertext)));
        c.finish();
        var decrypted = c.output;
        if (EcCrypto.caching) 
            (EcCrypto.decryptionCache)[secret + iv + ciphertext] = forge.util.decodeUtf8(decrypted.data);
        return forge.util.decodeUtf8(decrypted.data);
    };
}, {}, {});
/**
 *  Asynchronous implementation of {{#crossLink
 *  "EcRsaOaep"}}EcRsaOaep{{/crossLink}}. Uses web workers and assumes 8 workers.
 * 
 *  @author fritz.ray@eduworks.com
 *  @class EcRsaOaepAsyncWorker
 *  @module com.eduworks.ec
 */
var EcRsaOaepAsyncWorker = function() {};
EcRsaOaepAsyncWorker = stjs.extend(EcRsaOaepAsyncWorker, null, [], function(constructor, prototype) {
    constructor.rotator = 0;
    constructor.w = null;
    constructor.q1 = null;
    constructor.q2 = null;
    constructor.initWorker = function() {
        if (window == null && ((typeof self).equals("undefined")) || Worker == undefined || Worker == null) {
            return;
        }
        if (!EcRemote.async) {
            return;
        }
        if (EcRsaOaepAsyncWorker.w != null) {
            return;
        }
        EcRsaOaepAsyncWorker.rotator = 0;
        EcRsaOaepAsyncWorker.q1 = new Array();
        EcRsaOaepAsyncWorker.q2 = new Array();
        EcRsaOaepAsyncWorker.w = new Array();
        for (var index = 0; index < 8; index++) {
            EcRsaOaepAsyncWorker.createWorker(index);
        }
    };
    constructor.createWorker = function(index) {
        EcRsaOaepAsyncWorker.q1.push(new Array());
        EcRsaOaepAsyncWorker.q2.push(new Array());
        var wkr;
        if ((window)["scriptPath"] != null) 
            EcRsaOaepAsyncWorker.w.push(wkr = new Worker((window)["scriptPath"] + "forgeAsync.js"));
         else 
            EcRsaOaepAsyncWorker.w.push(wkr = new Worker("forgeAsync.js"));
        wkr.onmessage = function(p1) {
            var o = p1.data;
            var success = EcRsaOaepAsyncWorker.q1[index].shift();
            var failure = EcRsaOaepAsyncWorker.q2[index].shift();
            if ((o)["error"] != null) {
                if (failure != null) 
                    failure((o)["error"]);
            } else if (success != null) {
                success((o)["result"]);
            }
        };
        wkr.onerror = function(p1) {
            var success = EcRsaOaepAsyncWorker.q1[index].shift();
            var failure = EcRsaOaepAsyncWorker.q2[index].shift();
            if (failure != null) {
                failure(p1.toString());
            }
        };
    };
    /**
     *  Asynchronous form of {{#crossLink
     *  "EcRsaOaep/encrypt:method"}}EcRsaOaep.encrypt{{/crossLink}}
     * 
     *  @param {EcPk}             pk Public Key to use to encrypt.
     *  @param {string}           plaintext Plaintext to encrypt.
     *  @param {function(string)} success Success method, result is Base64
     *                            encoded Ciphertext.
     *  @param {function(string)} failure Failure method, parameter is error
     *                            message.
     *  @method encrypt
     *  @static
     */
    constructor.encrypt = function(pk, plaintext, success, failure) {
        EcRsaOaepAsyncWorker.initWorker();
        if (!EcRemote.async || EcRsaOaepAsyncWorker.w == null) {
            success(EcRsaOaep.encrypt(pk, plaintext));
        } else {
            var worker = EcRsaOaepAsyncWorker.rotator++;
            EcRsaOaepAsyncWorker.rotator = EcRsaOaepAsyncWorker.rotator % 8;
            var o = new Object();
            (o)["pk"] = pk.toPem();
            (o)["text"] = forge.util.encodeUtf8(plaintext);
            (o)["cmd"] = "encryptRsaOaep";
            EcRsaOaepAsyncWorker.q1[worker].push(success);
            EcRsaOaepAsyncWorker.q2[worker].push(failure);
            EcRsaOaepAsyncWorker.w[worker].postMessage(o);
        }
    };
    /**
     *  Asynchronous form of {{#crossLink
     *  "EcRsaOaep/decrypt:method"}}EcRsaOaep.decrypt{{/crossLink}}
     * 
     *  @param {EcPpk}            ppk Public private keypair to use to decrypt.
     *  @param {string}           ciphertext Ciphertext to decrypt.
     *  @param {function(string)} success Success method, result is unencoded
     *                            plaintext.
     *  @param {function(string)} failure Failure method, parameter is error
     *                            message.
     *  @method decrypt
     *  @static
     */
    constructor.decrypt = function(ppk, ciphertext, success, failure) {
        if (EcCrypto.caching) {
            var cacheGet = null;
            cacheGet = (EcCrypto.decryptionCache)[ppk.toPem() + ciphertext];
            if (cacheGet != null) {
                success(cacheGet);
                return;
            }
        }
        EcRsaOaepAsyncWorker.initWorker();
        if (!EcRemote.async || EcRsaOaepAsyncWorker.w == null) {
            success(EcRsaOaep.decrypt(ppk, ciphertext));
        } else {
            var worker = EcRsaOaepAsyncWorker.rotator++;
            EcRsaOaepAsyncWorker.rotator = EcRsaOaepAsyncWorker.rotator % 8;
            var o = new Object();
            (o)["ppk"] = ppk.toPem();
            (o)["text"] = ciphertext;
            (o)["cmd"] = "decryptRsaOaep";
            if (EcCrypto.caching) {
                EcRsaOaepAsyncWorker.q1[worker].push(function(p1) {
                    (EcCrypto.decryptionCache)[ppk.toPem() + ciphertext] = forge.util.decodeUtf8(p1);
                    success(forge.util.decodeUtf8(p1));
                });
            } else {
                EcRsaOaepAsyncWorker.q1[worker].push(function(p1) {
                    success(forge.util.decodeUtf8(p1));
                });
            }
            EcRsaOaepAsyncWorker.q2[worker].push(failure);
            EcRsaOaepAsyncWorker.w[worker].postMessage(o);
        }
    };
    /**
     *  Asynchronous form of {{#crossLink
     *  "EcRsaOaep/sign:method"}}EcRsaOaep.sign{{/crossLink}}
     * 
     *  @param {EcPpk}            ppk Public private keypair to use to sign message.
     *  @param {string}           text Text to sign.
     *  @param {function(string)} success Success method, result is Base64
     *                            encoded signature.
     *  @param {function(string)} failure Failure method, parameter is error
     *                            message.
     *  @method sign
     *  @static
     */
    constructor.sign = function(ppk, text, success, failure) {
        EcRsaOaepAsyncWorker.initWorker();
        if (!EcRemote.async || EcRsaOaepAsyncWorker.w == null) {
            success(EcRsaOaep.sign(ppk, text));
        } else {
            var worker = EcRsaOaepAsyncWorker.rotator++;
            EcRsaOaepAsyncWorker.rotator = EcRsaOaepAsyncWorker.rotator % 8;
            var o = new Object();
            (o)["ppk"] = ppk.toPem();
            (o)["text"] = forge.util.encodeUtf8(text);
            (o)["cmd"] = "signRsaOaep";
            EcRsaOaepAsyncWorker.q1[worker].push(success);
            EcRsaOaepAsyncWorker.q2[worker].push(failure);
            EcRsaOaepAsyncWorker.w[worker].postMessage(o);
        }
    };
    /**
     *  Asynchronous form of {{#crossLink
     *  "EcRsaOaep/signSha256:method"}}EcRsaOaep.signSha256{{/crossLink}}
     * 
     *  @param {EcPpk}            ppk Public private keypair to use to sign message.
     *  @param {string}           text Text to sign.
     *  @param {function(string)} success Success method, result is Base64
     *                            encoded signature.
     *  @param {function(string)} failure Failure method, parameter is error
     *                            message.
     *  @method signSha256
     *  @static
     */
    constructor.signSha256 = function(ppk, text, success, failure) {
        EcRsaOaepAsyncWorker.initWorker();
        if (!EcRemote.async || EcRsaOaepAsyncWorker.w == null) {
            success(EcRsaOaep.signSha256(ppk, text));
        } else {
            var worker = EcRsaOaepAsyncWorker.rotator++;
            EcRsaOaepAsyncWorker.rotator = EcRsaOaepAsyncWorker.rotator % 8;
            var o = new Object();
            (o)["ppk"] = ppk.toPem();
            (o)["text"] = forge.util.encodeUtf8(text);
            (o)["cmd"] = "signSha256RsaOaep";
            EcRsaOaepAsyncWorker.q1[worker].push(success);
            EcRsaOaepAsyncWorker.q2[worker].push(failure);
            EcRsaOaepAsyncWorker.w[worker].postMessage(o);
        }
    };
    /**
     *  Asynchronous form of {{#crossLink
     *  "EcRsaOaep/verify:method"}}EcRsaOaep.verify{{/crossLink}}
     * 
     *  @param {EcPk}              pk Public key to use to verify message.
     *  @param {string}            text Text to use in verification.
     *  @param {string}            signature Signature to use in verification.
     *  @param {function(boolean)} success Success method, result is whether
     *                             signature is valid.
     *  @param {function(string)}  failure Failure method, parameter is error
     *                             message.
     *  @method verify
     *  @static
     */
    constructor.verify = function(pk, text, signature, success, failure) {
        EcRsaOaepAsyncWorker.initWorker();
        if (!EcRemote.async || EcRsaOaepAsyncWorker.w == null) {
            success(EcRsaOaep.verify(pk, text, signature));
        } else {
            var worker = EcRsaOaepAsyncWorker.rotator++;
            EcRsaOaepAsyncWorker.rotator = EcRsaOaepAsyncWorker.rotator % 8;
            var o = new Object();
            (o)["pk"] = pk.toPem();
            (o)["text"] = forge.util.encodeUtf8(text);
            (o)["signature"] = signature;
            (o)["cmd"] = "verifyRsaOaep";
            EcRsaOaepAsyncWorker.q1[worker].push(success);
            EcRsaOaepAsyncWorker.q2[worker].push(failure);
            EcRsaOaepAsyncWorker.w[worker].postMessage(o);
        }
    };
}, {w: {name: "Array", arguments: [{name: "Worker", arguments: ["Object"]}]}, q1: {name: "Array", arguments: [{name: "Array", arguments: ["Callback1"]}]}, q2: {name: "Array", arguments: [{name: "Array", arguments: ["Callback1"]}]}}, {});
/**
 *  Asynchronous implementation of {{#crossLink
 *  "EcAesCtr"}}EcAesCtr{{/crossLink}}. Uses web workers and assumes 8 workers.
 * 
 *  @author fritz.ray@eduworks.com
 *  @class EcAesCtrAsyncWorker
 *  @module com.eduworks.ec
 */
var EcAesCtrAsyncWorker = function() {};
EcAesCtrAsyncWorker = stjs.extend(EcAesCtrAsyncWorker, null, [], function(constructor, prototype) {
    constructor.rotator = 0;
    constructor.w = null;
    constructor.q1 = null;
    constructor.q2 = null;
    constructor.initWorker = function() {
        if (window == null && ((typeof self).equals("undefined")) || Worker == undefined || Worker == null) {
            return;
        }
        if (!EcRemote.async) {
            return;
        }
        if (EcAesCtrAsyncWorker.w != null) {
            return;
        }
        EcAesCtrAsyncWorker.rotator = 0;
        EcAesCtrAsyncWorker.q1 = new Array();
        EcAesCtrAsyncWorker.q2 = new Array();
        EcAesCtrAsyncWorker.w = new Array();
        for (var index = 0; index < 8; index++) {
            EcAesCtrAsyncWorker.createWorker(index);
        }
    };
    constructor.createWorker = function(index) {
        EcAesCtrAsyncWorker.q1.push(new Array());
        EcAesCtrAsyncWorker.q2.push(new Array());
        var wkr;
        if ((window)["scriptPath"] != null) 
            EcAesCtrAsyncWorker.w.push(wkr = new Worker((window)["scriptPath"] + "forgeAsync.js"));
         else 
            EcAesCtrAsyncWorker.w.push(wkr = new Worker("forgeAsync.js"));
        wkr.onmessage = function(p1) {
            var o = p1.data;
            var success = EcAesCtrAsyncWorker.q1[index].shift();
            var failure = EcAesCtrAsyncWorker.q2[index].shift();
            if ((o)["error"] != null) {
                if (failure != null) 
                    failure((o)["error"]);
            } else if (success != null) {
                success((o)["result"]);
            }
        };
        wkr.onerror = function(p1) {
            var success = EcAesCtrAsyncWorker.q1[index].shift();
            var failure = EcAesCtrAsyncWorker.q2[index].shift();
            if (failure != null) {
                failure(p1.toString());
            }
        };
    };
    /**
     *  Asynchronous form of {{#crossLink
     *  "EcAesCtr/encrypt:method"}}EcAesCtr.encrypt{{/crossLink}}
     * 
     *  @param {string}           plaintext Text to encrypt.
     *  @param {string}           secret Secret to use to encrypt.
     *  @param {string}           iv Initialization Vector to use to encrypt.
     *  @param {function(string)} success Success method, result is Base64
     *                            encoded Ciphertext.
     *  @param {function(string)} failure Failure method, parameter is error
     *                            message.
     *  @method encrypt
     *  @static
     */
    constructor.encrypt = function(plaintext, secret, iv, success, failure) {
        EcAesCtrAsyncWorker.initWorker();
        if (!EcRemote.async || EcAesCtrAsyncWorker.w == null) {
            success(EcAesCtr.encrypt(plaintext, secret, iv));
        } else {
            var worker = EcAesCtrAsyncWorker.rotator++;
            EcAesCtrAsyncWorker.rotator = EcAesCtrAsyncWorker.rotator % 8;
            var o = new Object();
            (o)["secret"] = secret;
            (o)["iv"] = iv;
            (o)["text"] = forge.util.encodeUtf8(plaintext);
            (o)["cmd"] = "encryptAesCtr";
            EcAesCtrAsyncWorker.q1[worker].push(success);
            EcAesCtrAsyncWorker.q2[worker].push(failure);
            EcAesCtrAsyncWorker.w[worker].postMessage(o);
        }
    };
    /**
     *  Asynchronous form of {{#crossLink
     *  "EcAesCtr/decrypt:method"}}EcAesCtr.decrypt{{/crossLink}}
     * 
     *  @param {string}           ciphertext Text to decrypt.
     *  @param {string}           secret Secret to use to decrypt.
     *  @param {string}           iv Initialization Vector to use to decrypt.
     *  @param {function(string)} success Success method, result is Plaintext
     *                            with no encoding.
     *  @param {function(string)} failure Failure method, parameter is error
     *                            message.
     *  @method decrypt
     *  @static
     */
    constructor.decrypt = function(ciphertext, secret, iv, success, failure) {
        if (EcCrypto.caching) {
            var cacheGet = null;
            cacheGet = (EcCrypto.decryptionCache)[secret + iv + ciphertext];
            if (cacheGet != null) {
                success(cacheGet);
                return;
            }
        }
        EcAesCtrAsyncWorker.initWorker();
        if (!EcRemote.async || EcAesCtrAsyncWorker.w == null) {
            success(EcAesCtr.decrypt(ciphertext, secret, iv));
        } else {
            var worker = EcAesCtrAsyncWorker.rotator++;
            EcAesCtrAsyncWorker.rotator = EcAesCtrAsyncWorker.rotator % 8;
            var o = new Object();
            (o)["secret"] = secret;
            (o)["iv"] = iv;
            (o)["text"] = ciphertext;
            (o)["cmd"] = "decryptAesCtr";
            if (EcCrypto.caching) {
                EcAesCtrAsyncWorker.q1[worker].push(function(p1) {
                    (EcCrypto.decryptionCache)[secret + iv + ciphertext] = forge.util.decodeUtf8(p1);
                    success(forge.util.decodeUtf8(p1));
                });
            } else {
                EcAesCtrAsyncWorker.q1[worker].push(function(p1) {
                    success(forge.util.decodeUtf8(p1));
                });
            }
            EcAesCtrAsyncWorker.q2[worker].push(failure);
            EcAesCtrAsyncWorker.w[worker].postMessage(o);
        }
    };
}, {w: {name: "Array", arguments: [{name: "Worker", arguments: ["Object"]}]}, q1: {name: "Array", arguments: [{name: "Array", arguments: ["Callback1"]}]}, q2: {name: "Array", arguments: [{name: "Array", arguments: ["Callback1"]}]}}, {});
/**
 *  Async version of EcRsaOaep that uses browser extensions (window.crypto) to accomplish cryptography much faster.
 *  Falls back to EcRsaOaepAsyncWorker, if window.crypto is not available.
 *  @class EcRsaOaepAsync
 */
var EcRsaOaepAsync = function() {};
EcRsaOaepAsync = stjs.extend(EcRsaOaepAsync, null, [], function(constructor, prototype) {
    /**
     *  Asynchronous form of {{#crossLink
     *  "EcRsaOaep/encrypt:method"}}EcRsaOaep.encrypt{{/crossLink}}
     * 
     *  @param {EcPk}             pk Public Key to use to encrypt.
     *  @param {string}           plaintext Plaintext to encrypt.
     *  @param {function(string)} success Success method, result is Base64
     *                            encoded Ciphertext.
     *  @param {function(string)} failure Failure method, parameter is error
     *                            message.
     *  @method encrypt
     *  @static
     */
    constructor.encrypt = function(pk, plainText, success, failure) {
        if (EcRemote.async == false) {
            success(EcRsaOaep.encrypt(pk, plainText));
            return;
        }
        if (EcBrowserDetection.isIeOrEdge() || window == null || window.crypto == null || window.crypto.subtle == null) {
            EcRsaOaepAsyncWorker.encrypt(pk, plainText, success, failure);
            return;
        }
        var keyUsages = new Array();
        keyUsages.push("encrypt");
        var algorithm = new Object();
        algorithm.name = "RSA-OAEP";
        algorithm.hash = "SHA-1";
        if (pk.key == null) 
            window.crypto.subtle.importKey("jwk", pk.toJwk(), algorithm, false, keyUsages).then(function(key) {
                pk.key = key;
                window.crypto.subtle.encrypt(algorithm, key, str2ab(forge.util.encodeUtf8(plainText))).then(function(p1) {
                    success(base64.encode(p1));
                }, failure);
            }, failure);
         else 
            window.crypto.subtle.encrypt(algorithm, pk.key, str2ab(forge.util.encodeUtf8(plainText))).then(function(p1) {
                success(base64.encode(p1));
            }, failure);
    };
    /**
     *  Asynchronous form of {{#crossLink
     *  "EcRsaOaep/decrypt:method"}}EcRsaOaep.decrypt{{/crossLink}}
     * 
     *  @param {EcPpk}            ppk Public private keypair to use to decrypt.
     *  @param {string}           ciphertext Ciphertext to decrypt.
     *  @param {function(string)} success Success method, result is unencoded
     *                            plaintext.
     *  @param {function(string)} failure Failure method, parameter is error
     *                            message.
     *  @method decrypt
     *  @static
     */
    constructor.decrypt = function(ppk, cipherText, success, failure) {
        if (EcCrypto.caching) {
            var cacheGet = null;
            cacheGet = (EcCrypto.decryptionCache)[ppk.toPem() + cipherText];
            if (cacheGet != null) {
                success(cacheGet);
                return;
            }
        }
        if (EcRemote.async == false) {
            success(EcRsaOaep.decrypt(ppk, cipherText));
            return;
        }
        if (EcBrowserDetection.isIeOrEdge() || window == null || window.crypto == null || window.crypto.subtle == null) {
            EcRsaOaepAsyncWorker.decrypt(ppk, cipherText, success, failure);
            return;
        }
        var keyUsages = new Array();
        keyUsages.push("decrypt");
        var algorithm = new Object();
        algorithm.name = "RSA-OAEP";
        algorithm.hash = "SHA-1";
        if (ppk.key == null) 
            window.crypto.subtle.importKey("jwk", ppk.toJwk(), algorithm, false, keyUsages).then(function(key) {
                ppk.key = key;
                window.crypto.subtle.decrypt(algorithm, key, base64.decode(cipherText)).then(function(p1) {
                    var result = forge.util.decodeUtf8(ab2str(p1));
                    if (EcCrypto.caching) {
                        (EcCrypto.decryptionCache)[ppk.toPem() + cipherText] = result;
                    }
                    success(result);
                }, failure);
            }, failure);
         else 
            window.crypto.subtle.decrypt(algorithm, ppk.key, base64.decode(cipherText)).then(function(p1) {
                var result = forge.util.decodeUtf8(ab2str(p1));
                if (EcCrypto.caching) {
                    (EcCrypto.decryptionCache)[ppk.toPem() + cipherText] = result;
                }
                success(result);
            }, failure);
    };
    /**
     *  Asynchronous form of {{#crossLink
     *  "EcRsaOaep/sign:method"}}EcRsaOaep.sign{{/crossLink}}
     * 
     *  @param {EcPpk}            ppk Public private keypair to use to sign message.
     *  @param {string}           text Text to sign.
     *  @param {function(string)} success Success method, result is Base64
     *                            encoded signature.
     *  @param {function(string)} failure Failure method, parameter is error
     *                            message.
     *  @method sign
     *  @static
     */
    constructor.sign = function(ppk, text, success, failure) {
        if (EcRemote.async == false) {
            success(EcRsaOaep.sign(ppk, text));
            return;
        }
        if (EcBrowserDetection.isIeOrEdge() || window == null || window.crypto == null || window.crypto.subtle == null) {
            EcRsaOaepAsyncWorker.sign(ppk, text, success, failure);
            return;
        }
        var keyUsages = new Array();
        keyUsages.push("sign");
        var algorithm = new Object();
        algorithm.name = "RSASSA-PKCS1-v1_5";
        algorithm.hash = "SHA-1";
        if (ppk.signKey == null) 
            window.crypto.subtle.importKey("jwk", ppk.toJwk(), algorithm, false, keyUsages).then(function(key) {
                ppk.signKey = key;
                window.crypto.subtle.sign(algorithm, key, str2ab(forge.util.encodeUtf8(text))).then(function(p1) {
                    success(base64.encode(p1));
                }, failure);
            }, failure);
         else 
            window.crypto.subtle.sign(algorithm, ppk.signKey, str2ab(forge.util.encodeUtf8(text))).then(function(p1) {
                success(base64.encode(p1));
            }, failure);
    };
    /**
     *  Asynchronous form of {{#crossLink
     *  "EcRsaOaep/signSha256:method"}}EcRsaOaep.signSha256{{/crossLink}}
     * 
     *  @param {EcPpk}            ppk Public private keypair to use to sign message.
     *  @param {string}           text Text to sign.
     *  @param {function(string)} success Success method, result is Base64
     *                            encoded signature.
     *  @param {function(string)} failure Failure method, parameter is error
     *                            message.
     *  @method signSha256
     *  @static
     */
    constructor.signSha256 = function(ppk, text, success, failure) {
        if (EcRemote.async == false) {
            success(EcRsaOaep.signSha256(ppk, text));
            return;
        }
        if (EcBrowserDetection.isIeOrEdge() || window == null || window.crypto == null || window.crypto.subtle == null) {
            EcRsaOaepAsyncWorker.sign(ppk, text, success, failure);
            return;
        }
        var keyUsages = new Array();
        keyUsages.push("sign");
        var algorithm = new Object();
        algorithm.name = "RSASSA-PKCS1-v1_5";
        algorithm.hash = "SHA-256";
        if (ppk.signKey == null) 
            window.crypto.subtle.importKey("jwk", ppk.toJwk(), algorithm, false, keyUsages).then(function(key) {
                ppk.signKey = key;
                window.crypto.subtle.sign(algorithm, key, str2ab(forge.util.encodeUtf8(text))).then(function(p1) {
                    success(base64.encode(p1));
                }, failure);
            }, failure);
         else 
            window.crypto.subtle.sign(algorithm, ppk.signKey, str2ab(forge.util.encodeUtf8(text))).then(function(p1) {
                success(base64.encode(p1));
            }, failure);
    };
    /**
     *  Asynchronous form of {{#crossLink
     *  "EcRsaOaep/verify:method"}}EcRsaOaep.verify{{/crossLink}}
     * 
     *  @param {EcPk}              pk Public key to use to verify message.
     *  @param {string}            text Text to use in verification.
     *  @param {string}            signature Signature to use in verification.
     *  @param {function(boolean)} success Success method, result is whether
     *                             signature is valid.
     *  @param {function(string)}  failure Failure method, parameter is error
     *                             message.
     *  @method verify
     *  @static
     */
    constructor.verify = function(pk, text, signature, success, failure) {
        if (EcRemote.async == false) {
            success(EcRsaOaep.verify(pk, text, signature));
            return;
        }
        if (EcBrowserDetection.isIeOrEdge() || window == null || window.crypto == null || window.crypto.subtle == null) {
            EcRsaOaepAsyncWorker.verify(pk, text, signature, success, failure);
            return;
        }
        var keyUsages = new Array();
        keyUsages.push("verify");
        var algorithm = new Object();
        algorithm.name = "RSASSA-PKCS1-v1_5";
        algorithm.hash = "SHA-1";
        if (pk.signKey == null) 
            window.crypto.subtle.importKey("jwk", pk.toJwk(), algorithm, false, keyUsages).then(function(key) {
                pk.signKey = key;
                window.crypto.subtle.verify(algorithm, key, base64.decode(signature), str2ab(forge.util.encodeUtf8(text))).then(function(p1) {
                    success(p1);
                }, failure);
            }, failure);
         else 
            window.crypto.subtle.verify(algorithm, pk.signKey, base64.decode(signature), str2ab(forge.util.encodeUtf8(text))).then(function(p1) {
                success(p1);
            }, failure);
    };
}, {}, {});
/**
 *  Async version of EcAesCtr that uses browser extensions (window.crypto) to accomplish cryptography much faster.
 *  Falls back to EcAesCtrAsyncWorker, if window.crypto is not available.
 *  @class EcAesCtrAsync
 */
var EcAesCtrAsync = function() {};
EcAesCtrAsync = stjs.extend(EcAesCtrAsync, null, [], function(constructor, prototype) {
    /**
     *  Asynchronous form of {{#crossLink
     *  "EcAesCtr/encrypt:method"}}EcAesCtr.encrypt{{/crossLink}}
     * 
     *  @param {string}           plaintext Text to encrypt.
     *  @param {string}           secret Secret to use to encrypt.
     *  @param {string}           iv Initialization Vector to use to encrypt.
     *  @param {function(string)} success Success method, result is Base64
     *                            encoded Ciphertext.
     *  @param {function(string)} failure Failure method, parameter is error
     *                            message.
     *  @method encrypt
     *  @static
     */
    constructor.encrypt = function(plaintext, secret, iv, success, failure) {
        if (window == null || window.crypto == null || window.crypto.subtle == null) {
            EcAesCtrAsyncWorker.encrypt(plaintext, secret, iv, success, failure);
            return;
        }
        if (EcRemote.async == false) {
            success(EcAesCtr.encrypt(plaintext, secret, iv));
            return;
        }
        var keyUsages = new Array();
        keyUsages.push("encrypt", "decrypt");
        var algorithm = new Object();
        algorithm.name = "AES-CTR";
        algorithm.counter = base64.decode(iv);
        algorithm.length = 128;
        var data;
        data = str2ab(plaintext);
        window.crypto.subtle.importKey("raw", base64.decode(secret), algorithm, false, keyUsages).then(function(key) {
            var p = window.crypto.subtle.encrypt(algorithm, key, data);
            p.then(function(p1) {
                success(base64.encode(p1));
            }, failure);
        }, failure);
    };
    /**
     *  Asynchronous form of {{#crossLink
     *  "EcAesCtr/decrypt:method"}}EcAesCtr.decrypt{{/crossLink}}
     * 
     *  @param {string}           ciphertext Text to decrypt.
     *  @param {string}           secret Secret to use to decrypt.
     *  @param {string}           iv Initialization Vector to use to decrypt.
     *  @param {function(string)} success Success method, result is Plaintext
     *                            with no encoding.
     *  @param {function(string)} failure Failure method, parameter is error
     *                            message.
     *  @method decrypt
     *  @static
     */
    constructor.decrypt = function(ciphertext, secret, iv, success, failure) {
        if (EcCrypto.caching) {
            var cacheGet = (EcCrypto.decryptionCache)[secret + iv + ciphertext];
            if (cacheGet != null) {
                success(cacheGet);
                return;
            }
        }
        if (window.crypto == null || window.crypto.subtle == null) {
            EcAesCtrAsyncWorker.decrypt(ciphertext, secret, iv, success, failure);
            return;
        }
        if (EcRemote.async == false) {
            success(EcAesCtr.decrypt(ciphertext, secret, iv));
        }
        var keyUsages = new Array();
        keyUsages.push("encrypt", "decrypt");
        var algorithm = new Object();
        algorithm.name = "AES-CTR";
        algorithm.counter = base64.decode(iv);
        algorithm.length = 128;
        var data;
        data = base64.decode(ciphertext);
        window.crypto.subtle.importKey("raw", base64.decode(secret), algorithm, false, keyUsages).then(function(key) {
            var p = window.crypto.subtle.decrypt(algorithm, key, data);
            p.then(function(p1) {
                (EcCrypto.decryptionCache)[secret + iv + ciphertext] = ab2str(p1);
                success(ab2str(p1));
            }, failure);
        }, failure);
    };
}, {}, {});

/**
 *  Represents a JSON-LD linked data object and performs serialization.
 *  Note: Serialization and deserialization remove parameters that begin with '@'.
 *  Note: This Linked Data Object is not assumed to have an @id field.
 * 
 *  @author fritz.ray@eduworks.com
 *  @module org.json.ld
 *  @class EcLinkedData
 */
var EcLinkedData = /**
 *  Create a linked data object.
 * 
 *  @param {string} context JSON-LD Context.
 *  @param {string} type JSON-LD Type.
 *  @constructor
 */
function(context, type) {
    this.setContextAndType(context, type);
};
EcLinkedData = stjs.extend(EcLinkedData, null, [], function(constructor, prototype) {
    constructor.atProperties = ["id", "type", "schema", "context", "graph"];
    /**
     *  JSON-LD @type field.
     * 
     *  @property type
     *  @type string
     */
    prototype.type = null;
    /**
     *  JSON-LD @context field.
     * 
     *  @property context
     *  @type string
     */
    prototype.context = null;
    /**
     *  Determines which fields to serialize into @fields.
     * 
     *  @param {string} key Property name to check if it should be an @property.
     *  @return {boolean} True if property is in the set of atProperties.
     *  @internal
     *  @static
     *  @method isAtProperty
     */
    constructor.isAtProperty = function(key) {
        for (var i = 0; i < EcLinkedData.atProperties.length; i++) 
            if (EcLinkedData.atProperties[i].equals(key)) 
                return true;
        return false;
    };
    /**
     *  Helper function to determine if a piece of data is probably a JSON
     *  object.
     * 
     *  @param {string} probableJson JSON to test.
     *  @return {boolean} True if it is probably JSON. False if not.
     *  @method isProbablyJson
     *  @static
     */
    constructor.isProbablyJson = function(probableJson) {
        return probableJson.trim().startsWith("{") && probableJson.trim().endsWith("}");
    };
    /**
     *  Set the JSON-LD @context and @type.
     * 
     *  @param {string} context JSON-LD Context.
     *  @param {string} type JSON-LD Type.
     *  @method setContextAndType
     */
    prototype.setContextAndType = function(context, type) {
        this.context = context;
        this.type = type;
        if (type != null) {
            this.type = type.replace(context, "");
            if (this.type.startsWith("/")) 
                this.type = this.type.substring(1);
        }
    };
    /**
     *  Serializes this object to JSON.
     * 
     *  @return {string} JSON formatted object (with JSON-LD fields).
     *  @method toJson
     */
    prototype.toJson = function() {
        var o = this.atIfy();
        return JSON.stringify(o);
    };
    /**
     *  Forces Javascript to encode the object in alphabetical order in order to
     *  make signature based actions more viable. Also places @(at) symbols in
     *  front of appropriate fields.
     * 
     *  @return {Object} Serializable JSON object.
     *  @internal
     *  @method atIfy
     */
    prototype.atIfy = function() {
        return this.atIfyObject(this);
    };
    prototype.atIfyArray = function(o) {
        var a = new Array();
        for (var i = 0; i < o.length; i++) {
            if (EcObject.isObject(o[i])) {
                if (stjs.isInstanceOf(o[i].constructor, EcLinkedData)) 
                    a[i] = this.atIfyObject(o[i]);
                 else {
                    a[i] = o[i];
                }
            } else if (EcArray.isArray(o[i])) 
                a[i] = this.atIfyArray(o[i]);
             else 
                a[i] = o[i];
        }
        return a;
    };
    prototype.atIfyObject = function(o) {
        var keys = new Array();
        var me = (o);
        for (var key in me) {
            if (me["type"] != null) 
                if (EcLinkedData.isAtProperty(key)) 
                    key = "@" + key;
            keys.push(key);
        }
        keys.sort(function(a, b) {
            return a.compareTo(b);
        });
        var op = (new Object());
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            var value = me[key.replace("@", "")];
            if (value != null) 
                if (stjs.isInstanceOf(value.constructor, EcLinkedData)) 
                    value = (value).atIfy();
                 else if (EcArray.isArray(value)) 
                    value = this.atIfyArray(value);
            if (value != null) 
                op[key] = value;
             else 
                value = me[key];
            if (value != null) 
                op[key] = value;
        }
        return op;
    };
    /**
     *  Uses the object's fully qualified type name and compares it to the
     *  provided type.
     * 
     *  @param {string} type Fully qualified type name uri.
     *  @return {boolean} True if match, False if not.
     *  @method isA
     */
    prototype.isA = function(type) {
        var computedType = this.getFullType();
        return computedType.equals(type) || this.type.equals(type);
    };
    /**
     *  Uses the object's fully qualified type name and compares it to the
     *  provided type.
     * 
     *  @param {string[]} type Fully qualified type name uris.
     *  @return {boolean} True if match, False if not.
     *  @method isAny
     */
    prototype.isAny = function(type) {
        var computedType = this.getFullType();
        if (type.length == 0) 
            return true;
        for (var i = 0; i < type.length; i++) 
            if (type[i].equals(computedType) || type[i].equals(this.type)) 
                return true;
        return false;
    };
    /**
     *  Gets the fully qualified type name, as JSON-LD allows the "namespace" of
     *  the type to be defined in @context.
     * 
     *  @return {string} Fully qualified type name.
     *  @method getFullType
     */
    prototype.getFullType = function() {
        if (this.context == null) 
            return this.type;
        if (this.type.indexOf("http") != -1) 
            return this.type;
        var computedType = this.context;
        if (EcObject.isObject(this.context)) {
            var typeParts = this.type.split(":");
            if (typeParts.length == 2) {
                computedType = (this.context)[typeParts[0]];
                if (!computedType.endsWith("/")) 
                    computedType += "/";
                computedType += typeParts[1];
                return computedType;
            } else if ((this.context)["@vocab"] != null) 
                computedType = (this.context)["@vocab"];
        }
        if (!computedType.endsWith("/")) 
            computedType += "/";
        computedType += this.type;
        return computedType;
    };
    /**
     *  Also could be called "upcast", for those in the know.
     *  <p>
     *  Ghetto method of copying properties from some other object. As freshly
     *  deserialized javascript objects do not inherently attach the functions of
     *  their type, it is this or factory hell.
     * 
     *  @param that The freshly deserialized object, or the object to upcast into this object.
     *  @method copyFrom
     */
    prototype.copyFrom = function(that) {
        var me = (this);
        for (var key in me) {
            if ((typeof me[key]) != "function") 
                delete me[key];
        }
        var you = (that);
        for (var key in you) {
            if ((typeof you[key]) != "function") {
                if (you["@type"] != null) 
                    me[key.replace("@", "")] = you[key];
                 else 
                    me[key] = you[key];
            }
        }
        var stripNamespace = null;
        var newContext = null;
        if (this.type != null && this.context != null && EcObject.isObject(this.context)) {
            var typeParts = this.type.split(":");
            if (typeParts.length == 2) {
                newContext = (this.context)[typeParts[0]];
                stripNamespace = typeParts[0];
                if (!newContext.endsWith("/")) 
                    newContext += "/";
            } else if ((this.context)["@vocab"] != null) 
                newContext = (this.context)["@vocab"];
        }
        if (stripNamespace != null) 
            for (var key in me) {
                if ((typeof me[key]) != "function") {
                    if (key.startsWith(stripNamespace + ":")) {
                        if (EcArray.isArray(me[key])) {
                            (me)[key.replace(stripNamespace + ":", "")] = JSON.parse(JSON.stringify(me[key]).replaceAll(stripNamespace + ":", ""));
                        } else if (EcObject.isObject(me[key])) {
                            (me)[key.replace(stripNamespace + ":", "")] = JSON.parse(JSON.stringify(me[key]).replaceAll(stripNamespace + ":", ""));
                        } else 
                            (me)[key.replace(stripNamespace + ":", "")] = me[key];
                        delete me[key];
                    }
                }
            }
        if (newContext != null) 
            this.context = newContext;
        this.upgrade();
        if (!this.isAny(this.getTypes())) 
             throw new RuntimeException("Incompatible type: " + this.getFullType());
    };
    prototype.recast = function(translationContext, targetContext, success, failure) {
        var me = this;
        var json = JSON.parse(this.toJson());
        if (targetContext == null) 
            targetContext = (json)["@context"];
        (json)["@context"] = translationContext;
        var finalTargetContext = targetContext;
        jsonld.expand(json, new Object(), function(error, actual) {
            if (error != null) {
                failure((error)["message"]);
                return;
            }
            jsonld.compact(actual, finalTargetContext, new Object(), function(s, o, o2) {
                if (s != null) {
                    failure(s);
                    return;
                }
                me.copyFrom(o);
                (me)["@context"] = finalTargetContext;
                success(me);
            });
        });
    };
    /**
     *  Upgrades the object to the latest version, performing transforms and the like.
     * 
     *  @method upgrade
     */
    prototype.upgrade = function() {};
    /**
     *  Removes the @ symbol from properties in order to make them more
     *  accessible in Javascript.
     * 
     *  @return {EcLinkedData} This object, with @ properties converted to @-less properties.
     *  @method deAtify
     *  @internal
     */
    prototype.deAtify = function() {
        var me = (this);
        var typeFound = false;
        if (me["@type"] != null) 
            typeFound = true;
        for (var key in me) {
            if (me[key] == null) {
                if (typeFound) {
                    var value = me[key];
                    if (value != null) 
                        if (stjs.isInstanceOf(value.constructor, EcLinkedData)) 
                            value = (value).deAtify();
                    me[key.replace("@", "")] = value;
                } else {
                    var value = me[key];
                    if (value != null) 
                        if (stjs.isInstanceOf(value.constructor, EcLinkedData)) 
                            value = (value).deAtify();
                    me[key] = value;
                }
            }
        }
        return this;
    };
    /**
     *  Gets all versions of JSON-LD type strings for this type of object.
     * 
     *  @return {string[]} Array of URIs.
     *  @method getTypes
     */
    prototype.getTypes = function() {
        var a = new Array();
        if (this.context != null && this.type != null) {
            if (!EcObject.isObject(this.context)) {
                var context = (!this.context.endsWith("/") ? this.context + "/" : this.context);
                if (this.type.indexOf(context) == 0) 
                    a.push(this.type);
                 else 
                    a.push(context + this.type);
            }
        }
        return a;
    };
    prototype.compact = function(remoteContextUrl, success, failure) {
        var me = this;
        jsonld.compact(this.toJson(), remoteContextUrl, new Object(), function(err, compacted, context) {
            if (err != null) {
                failure(err);
                return;
            }
            me.copyFrom(compacted);
            success(this);
        });
    };
}, {atProperties: {name: "Array", arguments: [null]}}, {});

/**
 *  Location of strings that store the current namespace for EBAC/KBAC.
 * 
 *  @author fritz.ray@eduworks.com
 *  @class Ebac
 *  @module org.cassproject
 */
var Ebac = function() {};
Ebac = stjs.extend(Ebac, null, [], function(constructor, prototype) {
    constructor.context_0_1 = "http://schema.eduworks.com/ebac/0.1";
    constructor.context_0_2 = "http://schema.eduworks.com/ebac/0.2";
    constructor.context_0_3 = "http://schema.cassproject.org/kbac/0.2";
    constructor.context_0_4 = "https://schema.cassproject.org/kbac/0.4";
    /**
     *  Current version of KBAC.
     * 
     *  @property context
     *  @static
     *  @type string (URL)
     */
    constructor.context = Ebac.context_0_4;
}, {}, {});
/**
 *  Location of strings that store the current namespace for general Eduworks Objects.
 * 
 *  @author fritz.ray@eduworks.com
 *  @class General
 *  @module com.eduworks.ec
 */
var General = function() {};
General = stjs.extend(General, null, [], function(constructor, prototype) {
    constructor.context_0_2 = "http://schema.eduworks.com/general/0.2";
    constructor.context_0_1 = "http://schema.eduworks.com/general/0.1";
    /**
     *  The latest version of the Eduworks Object namespace.
     * 
     *  @property context
     *  @static
     *  @type {string}
     */
    constructor.context = "http://schema.eduworks.com/general/0.2";
}, {}, {});
/**
 *  Data wrapper to represent remotely hosted data. Includes necessary KBAC fields for
 *  permission controls, signing, identifying and locating the object.
 * 
 *  @author fritz.ray@eduworks.com
 *  @class EcRemoteLinkedData
 *  @extends EcLinkedData
 *  @module org.cassproject
 */
var EcRemoteLinkedData = /**
 *  Constructor for remote linked data object.
 * 
 *  @param {string} context JSON-LD Context.
 *  @param {string} type JSON-LD Type.
 *  @constructor
 */
function(context, type) {
    EcLinkedData.call(this, context, type);
};
EcRemoteLinkedData = stjs.extend(EcRemoteLinkedData, EcLinkedData, [], function(constructor, prototype) {
    /**
     *  PEM encoded public keys of the owner of the object. A repository, upon
     *  receiving a write operation, will ensure either the data did not
     *  previously exist, or that an owner has provided a signature authorizing
     *  the replacement of the old data with the new data.
     * 
     *  @property owner
     *  @type string[] (PEM)
     */
    prototype.owner = null;
    /**
     *  Signatures of the object. The signing method is as follows: Remove the
     *  signature field. Encode the object and its fields in ascii-sort order
     *  JSON-LD using a space-free, tab-free encoding. Sign the aforementioned
     *  string.
     * 
     *  @property signature
     *  @type string[] (Base64)
     */
    prototype.signature = null;
    /**
     *  URL/URI used to retrieve, store and identify the object.
     * 
     *  @property id
     *  @type string (URL)
     */
    prototype.id = null;
    prototype.equals = function(obj) {
        return this.isId((obj).id);
    };
    /**
     *  PEM encoded public keys of identities authorized to view the object. A
     *  repository will ignore write operations from these identities, but will
     *  allow them to read the object.
     * 
     *  @property reader
     *  @type string[] (PEM)
     */
    prototype.reader = null;
    /**
     *  Removes the version information from an identifier.
     *  Warning: Will remove identifier if the identifier is composed solely of digits!!!
     * 
     *  @param {string} id Slash delimited URL or path.
     *  @return ID without version.
     *  @method trimVersionFromUrl
     *  @static
     */
    constructor.trimVersionFromUrl = function(id) {
        if (id == null) 
            return null;
        if (id.indexOf("/api/data/") == -1 && id.indexOf("/api/custom/data/") == -1) 
            return id;
        if (!id.substring(id.lastIndexOf("/")).matches("\\/[0-9]+")) 
            return id;
        var rawId = id.substring(0, id.lastIndexOf("/"));
        if (rawId.endsWith("/")) 
            rawId = rawId.substring(0, rawId.length - 1);
        return rawId;
    };
    /**
     *  Will generate an identifier using the server URL provided (usually from
     *  an EcRepository).
     * 
     *  @param {string} server Base URL of the server's repository functionality.
     *  @method generateId
     */
    prototype.generateId = function(server) {
        this.id = server;
        if (!this.id.endsWith("/") && !this.id.endsWith("ce-")) 
            this.id += "/";
        this.id += "data/";
        this.id += this.getDottedType();
        this.id += "/";
        this.id += generateUUID();
        this.id += "/";
        this.id += new Date().getTime();
    };
    /**
     *  Will generate an short (non-versioned) identifier using the server URL provided (usually from
     *  an EcRepository).
     * 
     *  @param {string} server Base URL of the server's repository functionality.
     *  @method generateShortId
     */
    prototype.generateShortId = function(server) {
        this.id = server;
        if (!this.id.endsWith("/") && !this.id.endsWith("ce-")) 
            this.id += "/";
        this.id += generateUUID();
    };
    prototype.getDottedType = function() {
        return this.getFullType().replace("http://", "").replace("https://", "").replaceAll("/", ".");
    };
    /**
     *  Will generate an identifier using the server URL provided (usually from
     *  an EcRepository) and unique identifier.
     * 
     *  @param {string} server Base URL of the server's repository functionality.
     *  @param {string} uniqueIdentifier Canonical identifier. Must contain a letter or symbol.
     *  @method assignId
     */
    prototype.assignId = function(server, uniqueIdentifier) {
        this.id = server;
        if (!this.id.endsWith("/")) 
            this.id += "/";
        this.id += "data/";
        this.id += this.getDottedType();
        this.id += "/";
        this.id += uniqueIdentifier;
        this.id += "/";
        this.id += new Date().getTime();
    };
    /**
     *  Will generate an identifier using the server URL provided (usually from
     *  an EcRepository) and unique identifier.
     * 
     *  @param {string} server Base URL of the server's repository functionality.
     *  @param {string} uniqueIdentifier Canonical identifier. Must contain a letter or symbol.
     *  @method assignId
     */
    constructor.veryShortId = function(server, uniqueIdentifier) {
        var id;
        id = server;
        if (!id.endsWith("/")) 
            id += "/";
        id += "data/";
        id += uniqueIdentifier;
        return id;
    };
    /**
     *  Will generate an identifier using the server URL provided (usually from
     *  an EcRepository) and unique identifier.
     * 
     *  @param {string} server Base URL of the server's repository functionality.
     *  @param {string} uniqueIdentifier Canonical identifier. Must contain a letter or symbol.
     *  @method assignId
     */
    prototype.assignIdAndVersion = function(server, uniqueIdentifier, version) {
        this.id = server;
        if (!this.id.endsWith("/")) 
            this.id += "/";
        this.id += "data/";
        this.id += this.getDottedType();
        this.id += "/";
        this.id += uniqueIdentifier;
        this.id += "/";
        this.id += version;
    };
    /**
     *  Determines if the object has an owner identified by pk.
     *  Homogenizes the PEM strings for comparison.
     *  Homogenization is necessary for comparing PKCS#1 and PKCS#8 or PKs with Certificates, etc.
     * 
     *  @param {EcPk} pk Public Key of the owner.
     *  @return {boolean} True if owner is represented by the PK, false otherwise.
     *  @method hasOwner
     */
    prototype.hasOwner = function(pk) {
        if (this.owner == null) 
            return false;
        var pkPem = pk.toPem();
        for (var i = 0; i < this.owner.length; i++) 
            if (pkPem == EcPk.fromPem(this.owner[i]).toPem()) 
                return true;
        return false;
    };
    /**
     *  Determines if the object has a reader identified by pk.
     *  Homogenizes the PEM strings for comparison.
     *  Homogenization is necessary for comparing PKCS#1 and PKCS#8 or PKs with Certificates, etc.
     * 
     *  @param {EcPk} pk Public Key of the owner.
     *  @return {boolean} True if owner is represented by the PK, false otherwise.
     *  @method hasOwner
     */
    prototype.hasReader = function(pk) {
        if (this.reader == null) 
            return false;
        var pkPem = pk.toPem();
        for (var i = 0; i < this.reader.length; i++) 
            if (pkPem == EcPk.fromPem(this.reader[i]).toPem()) 
                return true;
        return false;
    };
    /**
     *  Determines if the PK matches an owner or if the object is public.
     *  Homogenizes the PEM strings for comparison.
     *  Homogenization is necessary for comparing PKCS#1 and PKCS#8 or PKs with Certificates, etc.
     * 
     *  @param {EcPk} pk Public Key of the owner.
     *  @return {boolean} True if owner is represented by the PK, false otherwise.
     *  @method canEdit
     */
    prototype.canEdit = function(pk) {
        if (this.owner == null || this.owner.length == 0) 
            return true;
        return this.hasOwner(pk);
    };
    /**
     *  Determines if the PK matches an owner or if the object is public.
     *  Homogenizes the PEM strings for comparison.
     *  Homogenization is necessary for comparing PKCS#1 and PKCS#8 or PKs with Certificates, etc.
     * 
     *  @param {EcPk} pk Public Key of the owner.
     *  @return {boolean} True if owner is represented by the PK, false otherwise.
     *  @method canEdit
     */
    prototype.canEditAny = function(ids) {
        if (this.owner == null || this.owner.length == 0) 
            return true;
        if (ids == null) 
            return false;
        for (var i = 0; i < ids.length; i++) 
            if (this.hasOwner(ids[i])) 
                return true;
        return false;
    };
    /**
     *  Encodes the object in a form where it is ready to be signed.
     *  This method is under long term review, and may change from version to version.
     * 
     *  @return ASCII-sort order encoded space-free and tab-free JSON-LD.
     *  @method toSignableJson
     */
    prototype.toSignableJson = function() {
        var d = JSON.parse(this.toJson());
        if (this.type.indexOf("http://schema.eduworks.com/") != -1 && this.type.indexOf("/0.1/") != -1) {
            delete (d)["signature"];
            delete (d)["owner"];
            delete (d)["reader"];
            delete (d)["@signature"];
            delete (d)["@owner"];
            delete (d)["@reader"];
            delete (d)["@id"];
        } else {
            delete (d)["signature"];
            delete (d)["@signature"];
            delete (d)["@id"];
        }
        var e = new EcLinkedData(d.context, d.type);
        e.copyFrom(d);
        return e.toJson();
    };
    /**
     *  Sign this object using a private key.
     *  Does not check for ownership, objects signed with keys absent from owner or reader may be removed.
     * 
     *  @param {EcPpk} ppk Public private keypair.
     *  @method signWith
     */
    prototype.signWith = function(ppk) {
        var signableJson = this.toSignableJson();
        var signed = EcRsaOaep.sign(ppk, signableJson);
        if (this.signature != null) {
            for (var i = 0; i < this.signature.length; i++) 
                if (this.signature[i] == signed) 
                    return;
        } else {
            this.signature = new Array();
        }
        this.signature.push(signed);
    };
    /**
     *  Verifies the object's signatures.
     * 
     *  @return {boolean} true if all of the signatures could be verified, false if they could not
     *  @method verify
     */
    prototype.verify = function() {
        if (this.signature != null) {
            for (var i = 0; i < this.signature.length; ) {
                var works = false;
                var sig = this.signature[i];
                if (this.owner != null) {
                    for (var j = 0; j < this.owner.length; j++) {
                        var own = this.owner[j];
                        var pk = EcPk.fromPem(own);
                        var verify = false;
                        try {
                            verify = EcRsaOaep.verify(pk, this.toSignableJson(), sig);
                        }catch (ex) {}
                        if (verify) {
                            works = true;
                            break;
                        }
                    }
                }
                if (!works) 
                    return false;
                 else 
                    i++;
            }
            if (this.signature.length == 0) 
                return false;
            return true;
        }
        return false;
    };
    /**
     *  Adds an owner to the object, if the owner does not exist.
     *  Note that this method invalidates all signatures.
     * 
     *  @param {EcPk} newOwner PK of the new owner.
     *  @method addOwner
     */
    prototype.addOwner = function(newOwner) {
        var pem = newOwner.toPem();
        if (this.owner == null) 
            this.owner = new Array();
        for (var i = 0; i < this.owner.length; i++) 
            if (this.owner[i] == pem) 
                return;
        this.owner.push(pem);
        this.signature = null;
    };
    /**
     *  Removes an owner from the object, if the owner does exist.
     *  Note that this method invalidates all signatures.
     * 
     *  @param {EcPk} oldOwner PK to remove.
     *  @method removeOwner
     */
    prototype.removeOwner = function(oldOwner) {
        var pem = oldOwner.toPem();
        if (this.owner == null) 
            this.owner = new Array();
        for (var i = 0; i < this.owner.length; i++) 
            if (this.owner[i] == pem) 
                this.owner.splice(i, 1);
        this.signature = null;
    };
    /**
     *  Adds a reader to the object, if the reader does not exist.
     *  Note that this method invalidates all signatures.
     * 
     *  @param {EcPk} newReader PK of the new reader.
     *  @method addReader
     */
    prototype.addReader = function(newReader) {
        var pem = newReader.toPem();
        if (this.reader == null) 
            this.reader = new Array();
        EcArray.setAdd(this.reader, pem);
        this.signature = null;
    };
    /**
     *  Removes a reader from the object, if the reader does exist.
     *  Note that this method invalidates all signatures.
     * 
     *  @param {EcPk} oldReader PK of the old reader.
     *  @method removeReader
     */
    prototype.removeReader = function(oldReader) {
        var pem = oldReader.toPem();
        if (this.reader == null) 
            this.reader = new Array();
        EcArray.setRemove(this.reader, pem);
        this.signature = null;
    };
    /**
     *  Determines if the object is not retrievable from a repository should it be written.
     * 
     *  @return {boolean} True if the object is NOT VALID for storage, false otherwise.
     *  @method invalid
     */
    prototype.invalid = function() {
        if (this.id == null) 
            return true;
        if (this.context == null) 
            return true;
        if (this.getFullType() == null) 
            return true;
        if (this.getFullType().indexOf("http://") == -1 && this.getFullType().indexOf("https://") == -1) 
            return true;
        return false;
    };
    /**
     *  Updates the ID timestamp of the object, for versioning purposes.
     * 
     *  @method updateTimestamp
     */
    prototype.updateTimestamp = function() {
        if (this.getTimestamp() == null) 
            return;
        var rawId = this.id.substring(0, this.id.lastIndexOf("/"));
        if (rawId.endsWith("/") == false) 
            rawId += "/";
        rawId += new Date().getTime();
        this.id = rawId;
    };
    /**
     *  Returns the ID timestamp of the object, for versioning purposes.
     * 
     *  @method getTimestamp
     */
    prototype.getTimestamp = function() {
        var timestamp = this.id.substring(this.id.lastIndexOf("/") + 1);
        if (timestamp.matches("[0-9]+")) {
            return Integer.parseInt(timestamp);
        } else {
            return null;
        }
    };
    /**
     *  Returns true if the provided ID represents this object.
     *  Use this, as version information can make direct comparison difficult.
     * 
     *  @param {string} id
     *  @return {boolean} True if the provided ID represents this object.
     *  @method isId
     */
    prototype.isId = function(id) {
        return EcRemoteLinkedData.trimVersionFromUrl(this.id) == EcRemoteLinkedData.trimVersionFromUrl(id);
    };
    /**
     *  Return the ID of this object without the version information.
     *  Used to reference the latest version of an object.
     * 
     *  @return {string} ID of the latest version of this object.
     *  @method shortId
     */
    prototype.shortId = function() {
        return EcRemoteLinkedData.trimVersionFromUrl(this.id);
    };
    /**
     *  Return the GUID portion of the short ID.
     * 
     *  @return {string} Guid of the linked data object.
     *  @method getGuid
     */
    prototype.getGuid = function() {
        var shortId = EcRemoteLinkedData.trimVersionFromUrl(this.id);
        var parts = shortId.split("/");
        return parts[parts.length - 1];
    };
    /**
     *  Return the URL Base portion of the short ID.
     * 
     *  @return {string} Server Base URL of the linked data object.
     *  @method getServerBaseUrl
     */
    prototype.getServerBaseUrl = function() {
        var shortId = EcRemoteLinkedData.trimVersionFromUrl(this.id);
        var parts = shortId.split("/");
        return parts.slice(0, parts.indexOf("data")).join("/");
    };
    /**
     *  Return a valid ElasticSearch search string that will retrieve all objects with this type.
     * 
     *  @return {string} ElasticSearch compatible search string.
     *  @method getSearchStringByType
     */
    prototype.getSearchStringByType = function() {
        var types = this.getTypes();
        var result = "";
        for (var i = 0; i < types.length; i++) {
            if (i != 0) 
                result += " OR ";
            result += "@type:\"" + types[i] + "\"";
            var lastSlash = types[i].lastIndexOf("/");
            result += " OR (@context:\"" + types[i].substring(0, lastSlash + 1) + "\" AND @type:\"" + types[i].substring(lastSlash + 1) + "\")";
        }
        for (var i = 0; i < types.length; i++) {
            if (result != "") 
                result += " OR ";
            result += "\\*encryptedType:\"" + types[i] + "\"";
            var lastSlash = types[i].lastIndexOf("/");
            result += " OR (@context:\"" + Ebac.context + "\" AND \\*encryptedType:\"" + types[i].substring(lastSlash + 1) + "\")";
        }
        return "(" + result + ")";
    };
    prototype.asRdfXml = function(success, failure, signatureSheet) {
        var fd = new FormData();
        var id = this.id;
        if (signatureSheet != null || signatureSheet != undefined) 
            fd.append("signatureSheet", signatureSheet);
        var headers = {};
        headers["Accept"] = "application/rdf+xml";
        EcRemote.postWithHeadersExpectingString(id, "", fd, headers, success, failure);
    };
    prototype.asNQuads = function(success, failure, signatureSheet) {
        var fd = new FormData();
        var id = this.id;
        if (signatureSheet != null || signatureSheet != undefined) 
            fd.append("signatureSheet", signatureSheet);
        var headers = {};
        headers["Accept"] = "text/n4";
        EcRemote.postWithHeadersExpectingString(id, "", fd, headers, success, failure);
    };
    prototype.asTurtle = function(success, failure, signatureSheet) {
        var fd = new FormData();
        var id = this.id;
        if (signatureSheet != null || signatureSheet != undefined) 
            fd.append("signatureSheet", signatureSheet);
        var headers = {};
        headers["Accept"] = "text/turtle";
        EcRemote.postWithHeadersExpectingString(id, "", fd, headers, success, failure);
    };
    /**
     *  Upgrades the object to the latest version, performing transforms and the like.
     * 
     *  @method upgrade
     */
    prototype.upgrade = function() {
        var me = (this);
        if (me["@owner"] != null) {
            me["owner"] = me["@owner"];
        }
        if (me["@reader"] != null) {
            me["reader"] = me["@reader"];
        }
        if (me["@signature"] != null) {
            me["signature"] = me["@signature"];
        }
        if (me["@encryptedType"] != null) {
            me["encryptedType"] = me["@encryptedType"];
        }
        if (me["@encryptedContext"] != null) {
            me["encryptedContext"] = me["@encryptedContext"];
        }
        this.handleForwarding();
    };
    constructor.forwardingTable = new Object();
    prototype.handleForwarding = function() {
        var me = (this);
        if (this.owner != null) {
            for (var i = 0; i < this.owner.length; i++) {
                var forwardTo = "";
                 while (forwardTo != null){
                    var homogenizedPk = EcPk.fromPem(this.owner[i]).toPem();
                    forwardTo = (EcRemoteLinkedData.forwardingTable)[homogenizedPk];
                    if (forwardTo != null) 
                        this.owner[i] = forwardTo;
                }
            }
        }
        if (this.reader != null) {
            for (var i = 0; i < this.reader.length; i++) {
                var forwardTo = "";
                 while (forwardTo != null){
                    var homogenizedPk = EcPk.fromPem(this.reader[i]).toPem();
                    forwardTo = (EcRemoteLinkedData.forwardingTable)[homogenizedPk];
                    if (forwardTo != null) 
                        this.reader[i] = forwardTo;
                }
            }
        }
    };
    constructor.forwardKey = function(oldKey, newKey) {
        (EcRemoteLinkedData.forwardingTable)[oldKey] = newKey;
    };
}, {owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});

/**
 *  Schema.org/Thing
 *  The most generic type of item.
 * 
 *  @author schema.org
 *  @class Thing
 *  @module org.schema
 */
var Thing = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    EcRemoteLinkedData.call(this, "http://schema.org/", "Thing");
};
Thing = stjs.extend(Thing, EcRemoteLinkedData, [], function(constructor, prototype) {
    /**
     *  Schema.org/name
     *  The name of the item.
     * 
     *  @property name
     *  @type Text
     */
    prototype.name = null;
    /**
     *  Schema.org/identifier
     *  The identifier property represents any kind of identifier for any kind of [[Thing]], such as ISBNs, GTIN codes, UUIDs etc. Schema.org provides dedicated properties for representing many of these, either as textual strings or as URL (URI) links. See [background notes](/docs/datamodel.html#identifierBg) for more details.
     * 
     *  @property identifier
     *  @type schema, URL | schema,Text | schema,PropertyValue
     */
    prototype.identifier = null;
    /**
     *  Schema.org/url
     *  URL of the item.
     * 
     *  @property url
     *  @type URL
     */
    prototype.url = null;
    /**
     *  Schema.org/image
     *  An image of the item. This can be a [[URL]] or a fully described [[ImageObject]].
     * 
     *  @property image
     *  @type schema, URL | schema,ImageObject
     */
    prototype.image = null;
    /**
     *  Schema.org/description
     *  A description of the item.
     * 
     *  @property description
     *  @type Text
     */
    prototype.description = null;
    /**
     *  Schema.org/disambiguatingDescription
     *  A sub property of description. A short description of the item used to disambiguate from other, similar items. Information from other properties (in particular, name) may be necessary for the description to be useful for disambiguation.
     * 
     *  @property disambiguatingDescription
     *  @type Text
     */
    prototype.disambiguatingDescription = null;
    /**
     *  Schema.org/alternateName
     *  An alias for the item.
     * 
     *  @property alternateName
     *  @type Text
     */
    prototype.alternateName = null;
    /**
     *  Schema.org/sameAs
     *  URL of a reference Web page that unambiguously indicates the item's identity. E.g. the URL of the item's Wikipedia page, Wikidata entry, or official website.
     * 
     *  @property sameAs
     *  @type URL
     */
    prototype.sameAs = null;
    /**
     *  Schema.org/additionalType
     *  An additional type for the item, typically used for adding more specific types from external vocabularies in microdata syntax. This is a relationship between something and a class that the thing is in. In RDFa syntax, it is better to use the native RDFa syntax - the 'typeof' attribute - for multiple types. Schema.org tools may have only weaker understanding of extra types, in particular those defined externally.
     * 
     *  @property additionalType
     *  @type URL
     */
    prototype.additionalType = null;
    /**
     *  Schema.org/potentialAction
     *  Indicates a potential Action, which describes an idealized action in which this thing would play an 'object' role.
     * 
     *  @property potentialAction
     *  @type Action
     */
    prototype.potentialAction = null;
    /**
     *  Schema.org/mainEntityOfPage
     *  Indicates a page (or other CreativeWork) for which this thing is the main entity being described. See [background notes](/docs/datamodel.html#mainEntityBackground) for details.
     * 
     *  @property mainEntityOfPage
     *  @type schema, URL | schema,CreativeWork
     */
    prototype.mainEntityOfPage = null;
    /**
     *  Returns the name of the thing
     * 
     *  @return {String} name of Thing
     *  @memberOf Thing
     *  @method getName
     */
    prototype.getName = function() {
        var n = this.name;
        return Thing.getDisplayStringFrom(n);
    };
    /**
     *  Method to set Thing name
     * 
     *  @param {String} name
     *                  Name to set for this Thing
     *  @memberOf Thing
     *  @method setName
     */
    prototype.setName = function(name) {
        if (this.name != null && EcObject.isObject(this.name) && (this.name).hasOwnProperty("@value")) {
            var obj = (this)["name"];
            (obj)["@value"] = name;
            (this)["name"] = obj;
        } else {
            this.name = name;
        }
    };
    /**
     *  Returns the description of the thing
     * 
     *  @return {String} description of Thing
     *  @memberOf Thing
     *  @method getDescription
     */
    prototype.getDescription = function() {
        var n = this.description;
        return Thing.getDisplayStringFrom(n);
    };
    constructor.getDisplayStringFrom = function(n) {
        if (n != null && EcArray.isArray(n)) {
            if ((n).length > 0) 
                n = (n)[0];
        }
        if (n != null && EcObject.isObject(n) && (n).hasOwnProperty("@value")) {
            return (n)["@value"];
        }
        return n;
    };
    /**
     *  Method to set Thing description
     * 
     *  @param {String} description
     *                  Description to set for its Thing
     *  @memberOf Thing
     *  @method setDescription
     */
    prototype.setDescription = function(description) {
        if (this.description != null && EcObject.isObject(this.description) && (this.description).hasOwnProperty("@value")) {
            var obj = (this)["description"];
            (obj)["@value"] = description;
            (this)["description"] = obj;
        } else {
            this.description = description;
        }
    };
}, {identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/SchemaEvent
 *  An event happening at a certain time and location, such as a concert, lecture, or festival. Ticketing information may be added via the [[offers]] property. Repeated events may be structured as separate SchemaEvent objects.
 * 
 *  @author schema.org
 *  @class SchemaEvent
 *  @module org.schema
 *  @extends Thing
 */
var SchemaEvent = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Thing.call(this);
    this.context = "http://schema.org/";
    this.type = "SchemaEvent";
};
SchemaEvent = stjs.extend(SchemaEvent, Thing, [], function(constructor, prototype) {
    /**
     *  Schema.org/about
     *  The subject matter of the content.
     * 
     *  @property about
     *  @type Thing
     */
    prototype.about = null;
    /**
     *  Schema.org/funder
     *  A person or organization that supports (sponsors) something through some kind of financial contribution.
     * 
     *  @property funder
     *  @type Person
     */
    prototype.funder = null;
    /**
     *  Schema.org/workFeatured
     *  A work featured in some event, e.g. exhibited in an ExhibitionEvent.
     *  Specific subproperties are available for workPerformed (e.g. a play), or a workPresented (a Movie at a ScreeningEvent).
     * 
     *  @property workFeatured
     *  @type CreativeWork
     */
    prototype.workFeatured = null;
    /**
     *  Schema.org/audience
     *  An intended audience, i.e. a group for whom something was created.
     * 
     *  @property audience
     *  @type Audience
     */
    prototype.audience = null;
    /**
     *  Schema.org/remainingAttendeeCapacity
     *  The number of attendee places for an event that remain unallocated.
     * 
     *  @property remainingAttendeeCapacity
     *  @type Integer
     */
    prototype.remainingAttendeeCapacity = null;
    /**
     *  Schema.org/actor
     *  An actor, e.g. in tv, radio, movie, video games etc., or in an event. Actors can be associated with individual items or with a series, episode, clip.
     * 
     *  @property actor
     *  @type Person
     */
    prototype.actor = null;
    /**
     *  Schema.org/performers
     *  The main performer or performers of the event&#x2014;for example, a presenter, musician, or actor.
     * 
     *  @property performers
     *  @type Organization
     */
    prototype.performers = null;
    /**
     *  Schema.org/endDate
     *  The end date and time of the item (in [ISO 8601 date format](http://en.wikipedia.org/wiki/ISO_8601)).
     * 
     *  @property endDate
     *  @type DateTime
     */
    prototype.endDate = null;
    /**
     *  Schema.org/doorTime
     *  The time admission will commence.
     * 
     *  @property doorTime
     *  @type DateTime
     */
    prototype.doorTime = null;
    /**
     *  Schema.org/contributor
     *  A secondary contributor to the CreativeWork or SchemaEvent.
     * 
     *  @property contributor
     *  @type Organization
     */
    prototype.contributor = null;
    /**
     *  Schema.org/maximumAttendeeCapacity
     *  The total number of individuals that may attend an event or venue.
     * 
     *  @property maximumAttendeeCapacity
     *  @type Integer
     */
    prototype.maximumAttendeeCapacity = null;
    /**
     *  Schema.org/typicalAgeRange
     *  The typical expected age range, e.g. '7-9', '11-'.
     * 
     *  @property typicalAgeRange
     *  @type Text
     */
    prototype.typicalAgeRange = null;
    /**
     *  Schema.org/organizer
     *  An organizer of an SchemaEvent.
     * 
     *  @property organizer
     *  @type Person
     */
    prototype.organizer = null;
    /**
     *  Schema.org/attendees
     *  A person attending the event.
     * 
     *  @property attendees
     *  @type Person
     */
    prototype.attendees = null;
    /**
     *  Schema.org/aggregateRating
     *  The overall rating, based on a collection of reviews or ratings, of the item.
     * 
     *  @property aggregateRating
     *  @type AggregateRating
     */
    prototype.aggregateRating = null;
    /**
     *  Schema.org/subEvent
     *  An SchemaEvent that is part of this event. For example, a conference event includes many presentations, each of which is a subEvent of the conference.
     * 
     *  @property subEvent
     *  @type SchemaEvent
     */
    prototype.subEvent = null;
    /**
     *  Schema.org/subEvents
     *  Events that are a part of this event. For example, a conference event includes many presentations, each subEvents of the conference.
     * 
     *  @property subEvents
     *  @type SchemaEvent
     */
    prototype.subEvents = null;
    /**
     *  Schema.org/offers
     *  An offer to provide this item&#x2014;for example, an offer to sell a product, rent the DVD of a movie, perform a service, or give away tickets to an event.
     * 
     *  @property offers
     *  @type Offer
     */
    prototype.offers = null;
    /**
     *  Schema.org/attendee
     *  A person or organization attending the event.
     * 
     *  @property attendee
     *  @type Organization
     */
    prototype.attendee = null;
    /**
     *  Schema.org/workPerformed
     *  A work performed in some event, for example a play performed in a TheaterEvent.
     * 
     *  @property workPerformed
     *  @type CreativeWork
     */
    prototype.workPerformed = null;
    /**
     *  Schema.org/eventStatus
     *  An eventStatus of an event represents its status; particularly useful when an event is cancelled or rescheduled.
     * 
     *  @property eventStatus
     *  @type EventStatusType
     */
    prototype.eventStatus = null;
    /**
     *  Schema.org/startDate
     *  The start date and time of the item (in [ISO 8601 date format](http://en.wikipedia.org/wiki/ISO_8601)).
     * 
     *  @property startDate
     *  @type Date
     */
    prototype.startDate = null;
    /**
     *  Schema.org/director
     *  A director of e.g. tv, radio, movie, video gaming etc. content, or of an event. Directors can be associated with individual items or with a series, episode, clip.
     * 
     *  @property director
     *  @type Person
     */
    prototype.director = null;
    /**
     *  Schema.org/superEvent
     *  An event that this event is a part of. For example, a collection of individual music performances might each have a music festival as their superEvent.
     * 
     *  @property superEvent
     *  @type SchemaEvent
     */
    prototype.superEvent = null;
    /**
     *  Schema.org/duration
     *  The duration of the item (movie, audio recording, event, etc.) in [ISO 8601 date format](http://en.wikipedia.org/wiki/ISO_8601).
     * 
     *  @property duration
     *  @type Duration
     */
    prototype.duration = null;
    /**
     *  Schema.org/translator
     *  Organization or person who adapts a creative work to different languages, regional differences and technical requirements of a target market, or that translates during some event.
     * 
     *  @property translator
     *  @type Person
     */
    prototype.translator = null;
    /**
     *  Schema.org/inLanguage
     *  The language of the content or performance or used in an action. Please use one of the language codes from the [IETF BCP 47 standard](http://tools.ietf.org/html/bcp47). See also [[availableLanguage]].
     * 
     *  @property inLanguage
     *  @type Language
     */
    prototype.inLanguage = null;
    /**
     *  Schema.org/previousStartDate
     *  Used in conjunction with eventStatus for rescheduled or cancelled events. This property contains the previously scheduled start date. For rescheduled events, the startDate property should be used for the newly scheduled start date. In the (rare) case of an event that has been postponed and rescheduled multiple times, this field may be repeated.
     * 
     *  @property previousStartDate
     *  @type Date
     */
    prototype.previousStartDate = null;
    /**
     *  Schema.org/review
     *  A review of the item.
     * 
     *  @property review
     *  @type Review
     */
    prototype.review = null;
    /**
     *  Schema.org/sponsor
     *  A person or organization that supports a thing through a pledge, promise, or financial contribution. e.g. a sponsor of a Medical Study or a corporate sponsor of an event.
     * 
     *  @property sponsor
     *  @type Organization
     */
    prototype.sponsor = null;
    /**
     *  Schema.org/location
     *  The location of for example where the event is happening, an organization is located, or where an action takes place.
     * 
     *  @property location
     *  @type PostalAddress
     */
    prototype.location = null;
    /**
     *  Schema.org/recordedIn
     *  The CreativeWork that captured all or part of this SchemaEvent.
     * 
     *  @property recordedIn
     *  @type CreativeWork
     */
    prototype.recordedIn = null;
    /**
     *  Schema.org/composer
     *  The person or organization who wrote a composition, or who is the composer of a work performed at some event.
     * 
     *  @property composer
     *  @type Organization
     */
    prototype.composer = null;
    /**
     *  Schema.org/isAccessibleForFree
     *  A flag to signal that the publication is accessible for free.
     * 
     *  @property isAccessibleForFree
     *  @type Boolean
     */
    prototype.isAccessibleForFree = null;
    /**
     *  Schema.org/performer
     *  A performer at the event&#x2014;for example, a presenter, musician, musical group or actor.
     * 
     *  @property performer
     *  @type Person
     */
    prototype.performer = null;
}, {about: "Thing", funder: "Person", workFeatured: "CreativeWork", audience: "Audience", actor: "Person", performers: "Organization", contributor: "Organization", organizer: "Person", attendees: "Person", aggregateRating: "AggregateRating", subEvent: "SchemaEvent", subEvents: "SchemaEvent", offers: "Offer", attendee: "Organization", workPerformed: "CreativeWork", eventStatus: "EventStatusType", director: "Person", superEvent: "SchemaEvent", duration: "Duration", translator: "Person", inLanguage: "Language", review: "Review", sponsor: "Organization", location: "PostalAddress", recordedIn: "CreativeWork", composer: "Organization", performer: "Person", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Place
 *  Entities that have a somewhat fixed, physical extension.
 * 
 *  @author schema.org
 *  @class Place
 *  @module org.schema
 *  @extends Thing
 */
var Place = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Thing.call(this);
    this.context = "http://schema.org/";
    this.type = "Place";
};
Place = stjs.extend(Place, Thing, [], function(constructor, prototype) {
    /**
     *  Schema.org/photo
     *  A photograph of this place.
     * 
     *  @property photo
     *  @type ImageObject
     */
    prototype.photo = null;
    /**
     *  Schema.org/address
     *  Physical address of the item.
     * 
     *  @property address
     *  @type PostalAddress
     */
    prototype.address = null;
    /**
     *  Schema.org/openingHoursSpecification
     *  The opening hours of a certain place.
     * 
     *  @property openingHoursSpecification
     *  @type OpeningHoursSpecification
     */
    prototype.openingHoursSpecification = null;
    /**
     *  Schema.org/containedInPlace
     *  The basic containment relation between a place and one that contains it.
     * 
     *  @property containedInPlace
     *  @type Place
     */
    prototype.containedInPlace = null;
    /**
     *  Schema.org/smokingAllowed
     *  Indicates whether it is allowed to smoke in the place, e.g. in the restaurant, hotel or hotel room.
     * 
     *  @property smokingAllowed
     *  @type Boolean
     */
    prototype.smokingAllowed = null;
    /**
     *  Schema.org/globalLocationNumber
     *  The [Global Location Number](http://www.gs1.org/gln) (GLN, sometimes also referred to as International Location Number or ILN) of the respective organization, person, or place. The GLN is a 13-digit number used to identify parties and physical locations.
     * 
     *  @property globalLocationNumber
     *  @type Text
     */
    prototype.globalLocationNumber = null;
    /**
     *  Schema.org/maximumAttendeeCapacity
     *  The total number of individuals that may attend an event or venue.
     * 
     *  @property maximumAttendeeCapacity
     *  @type Integer
     */
    prototype.maximumAttendeeCapacity = null;
    /**
     *  Schema.org/reviews
     *  Review of the item.
     * 
     *  @property reviews
     *  @type Review
     */
    prototype.reviews = null;
    /**
     *  Schema.org/aggregateRating
     *  The overall rating, based on a collection of reviews or ratings, of the item.
     * 
     *  @property aggregateRating
     *  @type AggregateRating
     */
    prototype.aggregateRating = null;
    /**
     *  Schema.org/photos
     *  Photographs of this place.
     * 
     *  @property photos
     *  @type Photograph
     */
    prototype.photos = null;
    /**
     *  Schema.org/map
     *  A URL to a map of the place.
     * 
     *  @property map
     *  @type URL
     */
    prototype.map = null;
    /**
     *  Schema.org/branchCode
     *  A short textual code (also called "store code") that uniquely identifies a place of business. The code is typically assigned by the parentOrganization and used in structured URLs.\n\nFor example, in the URL http://www.starbucks.co.uk/store-locator/etc/detail/3047 the code "3047" is a branchCode for a particular branch.
     * 
     *  @property branchCode
     *  @type Text
     */
    prototype.branchCode = null;
    /**
     *  Schema.org/hasMap
     *  A URL to a map of the place.
     * 
     *  @property hasMap
     *  @type Object
     */
    prototype.hasMap = null;
    /**
     *  Schema.org/additionalProperty
     *  A property-value pair representing an additional characteristics of the entitity, e.g. a product feature or another characteristic for which there is no matching property in schema.org.\n\nNote: Publishers should be aware that applications designed to use specific schema.org properties (e.g. schema:width, schema:color, schema:gtin13, ...) will typically expect such data to be provided using those properties, rather than using the generic property/value mechanism.
     * 
     *  @property additionalProperty
     *  @type PropertyValue
     */
    prototype.additionalProperty = null;
    /**
     *  Schema.org/events
     *  Upcoming or past events associated with this place or organization.
     * 
     *  @property events
     *  @type SchemaEvent
     */
    prototype.events = null;
    /**
     *  Schema.org/specialOpeningHoursSpecification
     *  The special opening hours of a certain place.\n\nUse this to explicitly override general opening hours brought in scope by [[openingHoursSpecification]] or [[openingHours]].
     * 
     *  @property specialOpeningHoursSpecification
     *  @type OpeningHoursSpecification
     */
    prototype.specialOpeningHoursSpecification = null;
    /**
     *  Schema.org/amenityFeature
     *  An amenity feature (e.g. a characteristic or service) of the Accommodation. This generic property does not make a statement about whether the feature is included in an offer for the main accommodation or available at extra costs.
     * 
     *  @property amenityFeature
     *  @type LocationFeatureSpecification
     */
    prototype.amenityFeature = null;
    /**
     *  Schema.org/logo
     *  An associated logo.
     * 
     *  @property logo
     *  @type ImageObject
     */
    prototype.logo = null;
    /**
     *  Schema.org/telephone
     *  The telephone number.
     * 
     *  @property telephone
     *  @type Text
     */
    prototype.telephone = null;
    /**
     *  Schema.org/geo
     *  The geo coordinates of the place.
     * 
     *  @property geo
     *  @type GeoCoordinates
     */
    prototype.geo = null;
    /**
     *  Schema.org/review
     *  A review of the item.
     * 
     *  @property review
     *  @type Review
     */
    prototype.review = null;
    /**
     *  Schema.org/event
     *  Upcoming or past event associated with this place, organization, or action.
     * 
     *  @property event
     *  @type SchemaEvent
     */
    prototype.event = null;
    /**
     *  Schema.org/containsPlace
     *  The basic containment relation between a place and another that it contains.
     * 
     *  @property containsPlace
     *  @type Place
     */
    prototype.containsPlace = null;
    /**
     *  Schema.org/isicV4
     *  The International Standard of Industrial Classification of All Economic Activities (ISIC), Revision 4 code for a particular organization, business person, or place.
     * 
     *  @property isicV4
     *  @type Text
     */
    prototype.isicV4 = null;
    /**
     *  Schema.org/maps
     *  A URL to a map of the place.
     * 
     *  @property maps
     *  @type URL
     */
    prototype.maps = null;
    /**
     *  Schema.org/faxNumber
     *  The fax number.
     * 
     *  @property faxNumber
     *  @type Text
     */
    prototype.faxNumber = null;
    /**
     *  Schema.org/containedIn
     *  The basic containment relation between a place and one that contains it.
     * 
     *  @property containedIn
     *  @type Place
     */
    prototype.containedIn = null;
}, {photo: "ImageObject", address: "PostalAddress", openingHoursSpecification: "OpeningHoursSpecification", containedInPlace: "Place", reviews: "Review", aggregateRating: "AggregateRating", photos: "Photograph", hasMap: "SchemaMap", additionalProperty: "PropertyValue", events: "SchemaEvent", specialOpeningHoursSpecification: "OpeningHoursSpecification", amenityFeature: "LocationFeatureSpecification", logo: "ImageObject", geo: "GeoCoordinates", review: "Review", event: "SchemaEvent", containsPlace: "Place", containedIn: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Person
 *  A person (alive, dead, undead, or fictional).
 * 
 *  @author schema.org
 *  @class Person
 *  @module org.schema
 *  @extends Thing
 */
var Person = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Thing.call(this);
    this.context = "http://schema.org/";
    this.type = "Person";
};
Person = stjs.extend(Person, Thing, [], function(constructor, prototype) {
    /**
     *  Schema.org/address
     *  Physical address of the item.
     * 
     *  @property address
     *  @type PostalAddress
     */
    prototype.address = null;
    /**
     *  Schema.org/spouse
     *  The person's spouse.
     * 
     *  @property spouse
     *  @type Person
     */
    prototype.spouse = null;
    /**
     *  Schema.org/funder
     *  A person or organization that supports (sponsors) something through some kind of financial contribution.
     * 
     *  @property funder
     *  @type Person
     */
    prototype.funder = null;
    /**
     *  Schema.org/colleagues
     *  A colleague of the person.
     * 
     *  @property colleagues
     *  @type Person
     */
    prototype.colleagues = null;
    /**
     *  Schema.org/deathDate
     *  Date of death.
     * 
     *  @property deathDate
     *  @type Date
     */
    prototype.deathDate = null;
    /**
     *  Schema.org/memberOf
     *  An Organization (or ProgramMembership) to which this Person or Organization belongs.
     * 
     *  @property memberOf
     *  @type Organization
     */
    prototype.memberOf = null;
    /**
     *  Schema.org/height
     *  The height of the item.
     * 
     *  @property height
     *  @type Distance
     */
    prototype.height = null;
    /**
     *  Schema.org/workLocation
     *  A contact location for a person's place of work.
     * 
     *  @property workLocation
     *  @type ContactPoint
     */
    prototype.workLocation = null;
    /**
     *  Schema.org/netWorth
     *  The total financial value of the person as calculated by subtracting assets from liabilities.
     * 
     *  @property netWorth
     *  @type PriceSpecification
     */
    prototype.netWorth = null;
    /**
     *  Schema.org/children
     *  A child of the person.
     * 
     *  @property children
     *  @type Person
     */
    prototype.children = null;
    /**
     *  Schema.org/jobTitle
     *  The job title of the person (for example, Financial Manager).
     * 
     *  @property jobTitle
     *  @type Text
     */
    prototype.jobTitle = null;
    /**
     *  Schema.org/hasOfferCatalog
     *  Indicates an OfferCatalog listing for this Organization, Person, or Service.
     * 
     *  @property hasOfferCatalog
     *  @type OfferCatalog
     */
    prototype.hasOfferCatalog = null;
    /**
     *  Schema.org/deathPlace
     *  The place where the person died.
     * 
     *  @property deathPlace
     *  @type Place
     */
    prototype.deathPlace = null;
    /**
     *  Schema.org/globalLocationNumber
     *  The [Global Location Number](http://www.gs1.org/gln) (GLN, sometimes also referred to as International Location Number or ILN) of the respective organization, person, or place. The GLN is a 13-digit number used to identify parties and physical locations.
     * 
     *  @property globalLocationNumber
     *  @type Text
     */
    prototype.globalLocationNumber = null;
    /**
     *  Schema.org/birthPlace
     *  The place where the person was born.
     * 
     *  @property birthPlace
     *  @type Place
     */
    prototype.birthPlace = null;
    /**
     *  Schema.org/gender
     *  Gender of the person. While schema:Male and schema:Female may be used, text strings are also acceptable for people who do not identify as a binary gender.
     * 
     *  @property gender
     *  @type Text
     */
    prototype.gender = null;
    /**
     *  Schema.org/parents
     *  A parents of the person.
     * 
     *  @property parents
     *  @type Person
     */
    prototype.parents = null;
    /**
     *  Schema.org/alumniOf
     *  An organization that the person is an alumni of.
     * 
     *  @property alumniOf
     *  @type EducationalOrganization
     */
    prototype.alumniOf = null;
    /**
     *  Schema.org/homeLocation
     *  A contact location for a person's residence.
     * 
     *  @property homeLocation
     *  @type ContactPoint
     */
    prototype.homeLocation = null;
    /**
     *  Schema.org/duns
     *  The Dun & Bradstreet DUNS number for identifying an organization or business person.
     * 
     *  @property duns
     *  @type Text
     */
    prototype.duns = null;
    /**
     *  Schema.org/taxID
     *  The Tax / Fiscal ID of the organization or person, e.g. the TIN in the US or the CIF/NIF in Spain.
     * 
     *  @property taxID
     *  @type Text
     */
    prototype.taxID = null;
    /**
     *  Schema.org/award
     *  An award won by or for this item.
     * 
     *  @property award
     *  @type Text
     */
    prototype.award = null;
    /**
     *  Schema.org/birthDate
     *  Date of birth.
     * 
     *  @property birthDate
     *  @type Date
     */
    prototype.birthDate = null;
    /**
     *  Schema.org/makesOffer
     *  A pointer to products or services offered by the organization or person.
     * 
     *  @property makesOffer
     *  @type Offer
     */
    prototype.makesOffer = null;
    /**
     *  Schema.org/contactPoints
     *  A contact point for a person or organization.
     * 
     *  @property contactPoints
     *  @type ContactPoint
     */
    prototype.contactPoints = null;
    /**
     *  Schema.org/awards
     *  Awards won by or for this item.
     * 
     *  @property awards
     *  @type Text
     */
    prototype.awards = null;
    /**
     *  Schema.org/familyName
     *  Family name. In the U.S., the last name of an Person. This can be used along with givenName instead of the name property.
     * 
     *  @property familyName
     *  @type Text
     */
    prototype.familyName = null;
    /**
     *  Schema.org/seeks
     *  A pointer to products or services sought by the organization or person (demand).
     * 
     *  @property seeks
     *  @type Demand
     */
    prototype.seeks = null;
    /**
     *  Schema.org/sibling
     *  A sibling of the person.
     * 
     *  @property sibling
     *  @type Person
     */
    prototype.sibling = null;
    /**
     *  Schema.org/performerIn
     *  SchemaEvent that this person is a performer or participant in.
     * 
     *  @property performerIn
     *  @type SchemaEvent
     */
    prototype.performerIn = null;
    /**
     *  Schema.org/honorificPrefix
     *  An honorific prefix preceding a Person's name such as Dr/Mrs/Mr.
     * 
     *  @property honorificPrefix
     *  @type Text
     */
    prototype.honorificPrefix = null;
    /**
     *  Schema.org/additionalName
     *  An additional name for a Person, can be used for a middle name.
     * 
     *  @property additionalName
     *  @type Text
     */
    prototype.additionalName = null;
    /**
     *  Schema.org/siblings
     *  A sibling of the person.
     * 
     *  @property siblings
     *  @type Person
     */
    prototype.siblings = null;
    /**
     *  Schema.org/telephone
     *  The telephone number.
     * 
     *  @property telephone
     *  @type Text
     */
    prototype.telephone = null;
    /**
     *  Schema.org/email
     *  Email address.
     * 
     *  @property email
     *  @type Text
     */
    prototype.email = null;
    /**
     *  Schema.org/weight
     *  The weight of the product or person.
     * 
     *  @property weight
     *  @type QuantitativeValue
     */
    prototype.weight = null;
    /**
     *  Schema.org/contactPoint
     *  A contact point for a person or organization.
     * 
     *  @property contactPoint
     *  @type ContactPoint
     */
    prototype.contactPoint = null;
    /**
     *  Schema.org/colleague
     *  A colleague of the person.
     * 
     *  @property colleague
     *  @type URL
     */
    prototype.colleague = null;
    /**
     *  Schema.org/givenName
     *  Given name. In the U.S., the first name of a Person. This can be used along with familyName instead of the name property.
     * 
     *  @property givenName
     *  @type Text
     */
    prototype.givenName = null;
    /**
     *  Schema.org/naics
     *  The North American Industry Classification System (NAICS) code for a particular organization or business person.
     * 
     *  @property naics
     *  @type Text
     */
    prototype.naics = null;
    /**
     *  Schema.org/hasPOS
     *  Points-of-Sales operated by the organization or person.
     * 
     *  @property hasPOS
     *  @type Place
     */
    prototype.hasPOS = null;
    /**
     *  Schema.org/parent
     *  A parent of this person.
     * 
     *  @property parent
     *  @type Person
     */
    prototype.parent = null;
    /**
     *  Schema.org/owns
     *  Products owned by the organization or person.
     * 
     *  @property owns
     *  @type OwnershipInfo
     */
    prototype.owns = null;
    /**
     *  Schema.org/affiliation
     *  An organization that this person is affiliated with. For example, a school/university, a club, or a team.
     * 
     *  @property affiliation
     *  @type Organization
     */
    prototype.affiliation = null;
    /**
     *  Schema.org/sponsor
     *  A person or organization that supports a thing through a pledge, promise, or financial contribution. e.g. a sponsor of a Medical Study or a corporate sponsor of an event.
     * 
     *  @property sponsor
     *  @type Organization
     */
    prototype.sponsor = null;
    /**
     *  Schema.org/isicV4
     *  The International Standard of Industrial Classification of All Economic Activities (ISIC), Revision 4 code for a particular organization, business person, or place.
     * 
     *  @property isicV4
     *  @type Text
     */
    prototype.isicV4 = null;
    /**
     *  Schema.org/brand
     *  The brand(s) associated with a product or service, or the brand(s) maintained by an organization or business person.
     * 
     *  @property brand
     *  @type Organization
     */
    prototype.brand = null;
    /**
     *  Schema.org/honorificSuffix
     *  An honorific suffix preceding a Person's name such as M.D. /PhD/MSCSW.
     * 
     *  @property honorificSuffix
     *  @type Text
     */
    prototype.honorificSuffix = null;
    /**
     *  Schema.org/vatID
     *  The Value-added Tax ID of the organization or person.
     * 
     *  @property vatID
     *  @type Text
     */
    prototype.vatID = null;
    /**
     *  Schema.org/nationality
     *  Nationality of the person.
     * 
     *  @property nationality
     *  @type Country
     */
    prototype.nationality = null;
    /**
     *  Schema.org/faxNumber
     *  The fax number.
     * 
     *  @property faxNumber
     *  @type Text
     */
    prototype.faxNumber = null;
    /**
     *  Schema.org/relatedTo
     *  The most generic familial relation.
     * 
     *  @property relatedTo
     *  @type Person
     */
    prototype.relatedTo = null;
    /**
     *  Schema.org/follows
     *  The most generic uni-directional social relation.
     * 
     *  @property follows
     *  @type Person
     */
    prototype.follows = null;
    /**
     *  Schema.org/knows
     *  The most generic bi-directional social/work relation.
     * 
     *  @property knows
     *  @type Person
     */
    prototype.knows = null;
    /**
     *  Schema.org/worksFor
     *  Organizations that the person works for.
     * 
     *  @property worksFor
     *  @type Organization
     */
    prototype.worksFor = null;
}, {address: "PostalAddress", spouse: "Person", funder: "Person", colleagues: "Person", memberOf: "Organization", height: "Distance", workLocation: "ContactPoint", netWorth: "PriceSpecification", children: "Person", hasOfferCatalog: "OfferCatalog", deathPlace: "Place", birthPlace: "Place", parents: "Person", alumniOf: "EducationalOrganization", homeLocation: "ContactPoint", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", sibling: "Person", performerIn: "SchemaEvent", siblings: "Person", weight: "QuantitativeValue", contactPoint: "ContactPoint", hasPOS: "Place", parent: "Person", owns: "OwnershipInfo", affiliation: "Organization", sponsor: "Organization", brand: "Organization", nationality: "Country", relatedTo: "Person", follows: "Person", knows: "Person", worksFor: "Organization", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Action
 *  An action performed by a direct agent and indirect participants upon a direct object. Optionally happens at a location with the help of an inanimate instrument. The execution of the action may produce a result. Specific action sub-type documentation specifies the exact expectation of each argument/role.\n\nSee also [blog post](http://blog.schema.org/2014/04/announcing-schemaorg-actions.html) and [Actions overview document](schema:docs/actions.html).
 * 
 *  @author schema.org
 *  @class Action
 *  @module org.schema
 *  @extends Thing
 */
var Action = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Thing.call(this);
    this.context = "http://schema.org/";
    this.type = "Action";
};
Action = stjs.extend(Action, Thing, [], function(constructor, prototype) {
    /**
     *  Schema.org/result
     *  The result produced in the action. e.g. John wrote *a book*.
     * 
     *  @property result
     *  @type Thing
     */
    prototype.result = null;
    /**
     *  Schema.org/actionStatus
     *  Indicates the current disposition of the Action.
     * 
     *  @property actionStatus
     *  @type ActionStatusType
     */
    prototype.actionStatus = null;
    /**
     *  Schema.org/target
     *  Indicates a target EntryPoint for an Action.
     * 
     *  @property target
     *  @type EntryPoint
     */
    prototype.target = null;
    /**
     *  Schema.org/agent
     *  The direct performer or driver of the action (animate or inanimate). e.g. *John* wrote a book.
     * 
     *  @property agent
     *  @type Person
     */
    prototype.agent = null;
    /**
     *  Schema.org/startTime
     *  The startTime of something. For a reserved event or service (e.g. FoodEstablishmentReservation), the time that it is expected to start. For actions that span a period of time, when the action was performed. e.g. John wrote a book from *January* to December.\n\nNote that SchemaEvent uses startDate/endDate instead of startTime/endTime, even when describing dates with times. This situation may be clarified in future revisions.
     * 
     *  @property startTime
     *  @type DateTime
     */
    prototype.startTime = null;
    /**
     *  Schema.org/endTime
     *  The endTime of something. For a reserved event or service (e.g. FoodEstablishmentReservation), the time that it is expected to end. For actions that span a period of time, when the action was performed. e.g. John wrote a book from January to *December*.\n\nNote that SchemaEvent uses startDate/endDate instead of startTime/endTime, even when describing dates with times. This situation may be clarified in future revisions.
     * 
     *  @property endTime
     *  @type DateTime
     */
    prototype.endTime = null;
    /**
     *  Schema.org/participant
     *  Other co-agents that participated in the action indirectly. e.g. John wrote a book with *Steve*.
     * 
     *  @property participant
     *  @type Person
     */
    prototype.participant = null;
    /**
     *  Schema.org/instrument
     *  The object that helped the agent perform the action. e.g. John wrote a book with *a pen*.
     * 
     *  @property instrument
     *  @type Thing
     */
    prototype.instrument = null;
    /**
     *  Schema.org/object
     *  The object upon which the action is carried out, whose state is kept intact or changed. Also known as the semantic roles patient, affected or undergoer (which change their state) or theme (which doesn't). e.g. John read *a book*.
     * 
     *  @property object
     *  @type Thing
     */
    prototype.object = null;
    /**
     *  Schema.org/error
     *  For failed actions, more information on the cause of the failure.
     * 
     *  @property error
     *  @type Thing
     */
    prototype.error = null;
    /**
     *  Schema.org/location
     *  The location of for example where the event is happening, an organization is located, or where an action takes place.
     * 
     *  @property location
     *  @type PostalAddress
     */
    prototype.location = null;
}, {result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Organization
 *  An organization such as a school, NGO, corporation, club, etc.
 * 
 *  @author schema.org
 *  @class Organization
 *  @module org.schema
 *  @extends Thing
 */
var Organization = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Thing.call(this);
    this.context = "http://schema.org/";
    this.type = "Organization";
};
Organization = stjs.extend(Organization, Thing, [], function(constructor, prototype) {
    /**
     *  Schema.org/serviceArea
     *  The geographic area where the service is provided.
     * 
     *  @property serviceArea
     *  @type GeoShape
     */
    prototype.serviceArea = null;
    /**
     *  Schema.org/address
     *  Physical address of the item.
     * 
     *  @property address
     *  @type PostalAddress
     */
    prototype.address = null;
    /**
     *  Schema.org/funder
     *  A person or organization that supports (sponsors) something through some kind of financial contribution.
     * 
     *  @property funder
     *  @type Person
     */
    prototype.funder = null;
    /**
     *  Schema.org/memberOf
     *  An Organization (or ProgramMembership) to which this Person or Organization belongs.
     * 
     *  @property memberOf
     *  @type Organization
     */
    prototype.memberOf = null;
    /**
     *  Schema.org/subOrganization
     *  A relationship between two organizations where the first includes the second, e.g., as a subsidiary. See also: the more specific 'department' property.
     * 
     *  @property subOrganization
     *  @type Organization
     */
    prototype.subOrganization = null;
    /**
     *  Schema.org/hasOfferCatalog
     *  Indicates an OfferCatalog listing for this Organization, Person, or Service.
     * 
     *  @property hasOfferCatalog
     *  @type OfferCatalog
     */
    prototype.hasOfferCatalog = null;
    /**
     *  Schema.org/globalLocationNumber
     *  The [Global Location Number](http://www.gs1.org/gln) (GLN, sometimes also referred to as International Location Number or ILN) of the respective organization, person, or place. The GLN is a 13-digit number used to identify parties and physical locations.
     * 
     *  @property globalLocationNumber
     *  @type Text
     */
    prototype.globalLocationNumber = null;
    /**
     *  Schema.org/reviews
     *  Review of the item.
     * 
     *  @property reviews
     *  @type Review
     */
    prototype.reviews = null;
    /**
     *  Schema.org/members
     *  A member of this organization.
     * 
     *  @property members
     *  @type Organization
     */
    prototype.members = null;
    /**
     *  Schema.org/aggregateRating
     *  The overall rating, based on a collection of reviews or ratings, of the item.
     * 
     *  @property aggregateRating
     *  @type AggregateRating
     */
    prototype.aggregateRating = null;
    /**
     *  Schema.org/duns
     *  The Dun & Bradstreet DUNS number for identifying an organization or business person.
     * 
     *  @property duns
     *  @type Text
     */
    prototype.duns = null;
    /**
     *  Schema.org/taxID
     *  The Tax / Fiscal ID of the organization or person, e.g. the TIN in the US or the CIF/NIF in Spain.
     * 
     *  @property taxID
     *  @type Text
     */
    prototype.taxID = null;
    /**
     *  Schema.org/award
     *  An award won by or for this item.
     * 
     *  @property award
     *  @type Text
     */
    prototype.award = null;
    /**
     *  Schema.org/makesOffer
     *  A pointer to products or services offered by the organization or person.
     * 
     *  @property makesOffer
     *  @type Offer
     */
    prototype.makesOffer = null;
    /**
     *  Schema.org/contactPoints
     *  A contact point for a person or organization.
     * 
     *  @property contactPoints
     *  @type ContactPoint
     */
    prototype.contactPoints = null;
    /**
     *  Schema.org/awards
     *  Awards won by or for this item.
     * 
     *  @property awards
     *  @type Text
     */
    prototype.awards = null;
    /**
     *  Schema.org/seeks
     *  A pointer to products or services sought by the organization or person (demand).
     * 
     *  @property seeks
     *  @type Demand
     */
    prototype.seeks = null;
    /**
     *  Schema.org/member
     *  A member of an Organization or a ProgramMembership. Organizations can be members of organizations; ProgramMembership is typically for individuals.
     * 
     *  @property member
     *  @type Organization
     */
    prototype.member = null;
    /**
     *  Schema.org/founders
     *  A person who founded this organization.
     * 
     *  @property founders
     *  @type Person
     */
    prototype.founders = null;
    /**
     *  Schema.org/alumni
     *  Alumni of an organization.
     * 
     *  @property alumni
     *  @type Person
     */
    prototype.alumni = null;
    /**
     *  Schema.org/dissolutionDate
     *  The date that this organization was dissolved.
     * 
     *  @property dissolutionDate
     *  @type Date
     */
    prototype.dissolutionDate = null;
    /**
     *  Schema.org/events
     *  Upcoming or past events associated with this place or organization.
     * 
     *  @property events
     *  @type SchemaEvent
     */
    prototype.events = null;
    /**
     *  Schema.org/logo
     *  An associated logo.
     * 
     *  @property logo
     *  @type ImageObject
     */
    prototype.logo = null;
    /**
     *  Schema.org/employees
     *  People working for this organization.
     * 
     *  @property employees
     *  @type Person
     */
    prototype.employees = null;
    /**
     *  Schema.org/telephone
     *  The telephone number.
     * 
     *  @property telephone
     *  @type Text
     */
    prototype.telephone = null;
    /**
     *  Schema.org/email
     *  Email address.
     * 
     *  @property email
     *  @type Text
     */
    prototype.email = null;
    /**
     *  Schema.org/department
     *  A relationship between an organization and a department of that organization, also described as an organization (allowing different urls, logos, opening hours). For example: a store with a pharmacy, or a bakery with a cafe.
     * 
     *  @property department
     *  @type Organization
     */
    prototype.department = null;
    /**
     *  Schema.org/contactPoint
     *  A contact point for a person or organization.
     * 
     *  @property contactPoint
     *  @type ContactPoint
     */
    prototype.contactPoint = null;
    /**
     *  Schema.org/parentOrganization
     *  The larger organization that this organization is a [[subOrganization]] of, if any.
     * 
     *  @property parentOrganization
     *  @type Organization
     */
    prototype.parentOrganization = null;
    /**
     *  Schema.org/legalName
     *  The official name of the organization, e.g. the registered company name.
     * 
     *  @property legalName
     *  @type Text
     */
    prototype.legalName = null;
    /**
     *  Schema.org/foundingDate
     *  The date that this organization was founded.
     * 
     *  @property foundingDate
     *  @type Date
     */
    prototype.foundingDate = null;
    /**
     *  Schema.org/employee
     *  Someone working for this organization.
     * 
     *  @property employee
     *  @type Person
     */
    prototype.employee = null;
    /**
     *  Schema.org/numberOfEmployees
     *  The number of employees in an organization e.g. business.
     * 
     *  @property numberOfEmployees
     *  @type QuantitativeValue
     */
    prototype.numberOfEmployees = null;
    /**
     *  Schema.org/naics
     *  The North American Industry Classification System (NAICS) code for a particular organization or business person.
     * 
     *  @property naics
     *  @type Text
     */
    prototype.naics = null;
    /**
     *  Schema.org/hasPOS
     *  Points-of-Sales operated by the organization or person.
     * 
     *  @property hasPOS
     *  @type Place
     */
    prototype.hasPOS = null;
    /**
     *  Schema.org/review
     *  A review of the item.
     * 
     *  @property review
     *  @type Review
     */
    prototype.review = null;
    /**
     *  Schema.org/foundingLocation
     *  The place where the Organization was founded.
     * 
     *  @property foundingLocation
     *  @type Place
     */
    prototype.foundingLocation = null;
    /**
     *  Schema.org/owns
     *  Products owned by the organization or person.
     * 
     *  @property owns
     *  @type OwnershipInfo
     */
    prototype.owns = null;
    /**
     *  Schema.org/event
     *  Upcoming or past event associated with this place, organization, or action.
     * 
     *  @property event
     *  @type SchemaEvent
     */
    prototype.event = null;
    /**
     *  Schema.org/founder
     *  A person who founded this organization.
     * 
     *  @property founder
     *  @type Person
     */
    prototype.founder = null;
    /**
     *  Schema.org/sponsor
     *  A person or organization that supports a thing through a pledge, promise, or financial contribution. e.g. a sponsor of a Medical Study or a corporate sponsor of an event.
     * 
     *  @property sponsor
     *  @type Organization
     */
    prototype.sponsor = null;
    /**
     *  Schema.org/isicV4
     *  The International Standard of Industrial Classification of All Economic Activities (ISIC), Revision 4 code for a particular organization, business person, or place.
     * 
     *  @property isicV4
     *  @type Text
     */
    prototype.isicV4 = null;
    /**
     *  Schema.org/location
     *  The location of for example where the event is happening, an organization is located, or where an action takes place.
     * 
     *  @property location
     *  @type PostalAddress
     */
    prototype.location = null;
    /**
     *  Schema.org/brand
     *  The brand(s) associated with a product or service, or the brand(s) maintained by an organization or business person.
     * 
     *  @property brand
     *  @type Organization
     */
    prototype.brand = null;
    /**
     *  Schema.org/vatID
     *  The Value-added Tax ID of the organization or person.
     * 
     *  @property vatID
     *  @type Text
     */
    prototype.vatID = null;
    /**
     *  Schema.org/leiCode
     *  An organization identifier that uniquely identifies a legal entity as defined in ISO 17442.
     * 
     *  @property leiCode
     *  @type Text
     */
    prototype.leiCode = null;
    /**
     *  Schema.org/faxNumber
     *  The fax number.
     * 
     *  @property faxNumber
     *  @type Text
     */
    prototype.faxNumber = null;
    /**
     *  Schema.org/areaServed
     *  The geographic area where a service or offered item is provided.
     * 
     *  @property areaServed
     *  @type Place
     */
    prototype.areaServed = null;
}, {serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Intangible
 *  A utility class that serves as the umbrella for a number of 'intangible' things such as quantities, structured values, etc.
 * 
 *  @author schema.org
 *  @class Intangible
 *  @module org.schema
 *  @extends Thing
 */
var Intangible = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Thing.call(this);
    this.context = "http://schema.org/";
    this.type = "Intangible";
};
Intangible = stjs.extend(Intangible, Thing, [], null, {identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Product
 *  Any offered product or service. For example: a pair of shoes; a concert ticket; the rental of a car; a haircut; or an episode of a TV show streamed online.
 * 
 *  @author schema.org
 *  @class Product
 *  @module org.schema
 *  @extends Thing
 */
var Product = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Thing.call(this);
    this.context = "http://schema.org/";
    this.type = "Product";
};
Product = stjs.extend(Product, Thing, [], function(constructor, prototype) {
    /**
     *  Schema.org/manufacturer
     *  The manufacturer of the product.
     * 
     *  @property manufacturer
     *  @type Organization
     */
    prototype.manufacturer = null;
    /**
     *  Schema.org/sku
     *  The Stock Keeping Unit (SKU), i.e. a merchant-specific identifier for a product or service, or the product to which the offer refers.
     * 
     *  @property sku
     *  @type Text
     */
    prototype.sku = null;
    /**
     *  Schema.org/productionDate
     *  The date of production of the item, e.g. vehicle.
     * 
     *  @property productionDate
     *  @type Date
     */
    prototype.productionDate = null;
    /**
     *  Schema.org/audience
     *  An intended audience, i.e. a group for whom something was created.
     * 
     *  @property audience
     *  @type Audience
     */
    prototype.audience = null;
    /**
     *  Schema.org/mpn
     *  The Manufacturer Part Number (MPN) of the product, or the product to which the offer refers.
     * 
     *  @property mpn
     *  @type Text
     */
    prototype.mpn = null;
    /**
     *  Schema.org/height
     *  The height of the item.
     * 
     *  @property height
     *  @type Distance
     */
    prototype.height = null;
    /**
     *  Schema.org/gtin8
     *  The [GTIN-8](http://apps.gs1.org/GDD/glossary/Pages/GTIN-8.aspx) code of the product, or the product to which the offer refers. This code is also known as EAN/UCC-8 or 8-digit EAN. See [GS1 GTIN Summary](http://www.gs1.org/barcodes/technical/idkeys/gtin) for more details.
     * 
     *  @property gtin8
     *  @type Text
     */
    prototype.gtin8 = null;
    /**
     *  Schema.org/reviews
     *  Review of the item.
     * 
     *  @property reviews
     *  @type Review
     */
    prototype.reviews = null;
    /**
     *  Schema.org/aggregateRating
     *  The overall rating, based on a collection of reviews or ratings, of the item.
     * 
     *  @property aggregateRating
     *  @type AggregateRating
     */
    prototype.aggregateRating = null;
    /**
     *  Schema.org/isConsumableFor
     *  A pointer to another product (or multiple products) for which this product is a consumable.
     * 
     *  @property isConsumableFor
     *  @type Product
     */
    prototype.isConsumableFor = null;
    /**
     *  Schema.org/offers
     *  An offer to provide this item&#x2014;for example, an offer to sell a product, rent the DVD of a movie, perform a service, or give away tickets to an event.
     * 
     *  @property offers
     *  @type Offer
     */
    prototype.offers = null;
    /**
     *  Schema.org/award
     *  An award won by or for this item.
     * 
     *  @property award
     *  @type Text
     */
    prototype.award = null;
    /**
     *  Schema.org/category
     *  A category for the item. Greater signs or slashes can be used to informally indicate a category hierarchy.
     * 
     *  @property category
     *  @type Text
     */
    prototype.category = null;
    /**
     *  Schema.org/width
     *  The width of the item.
     * 
     *  @property width
     *  @type Distance
     */
    prototype.width = null;
    /**
     *  Schema.org/awards
     *  Awards won by or for this item.
     * 
     *  @property awards
     *  @type Text
     */
    prototype.awards = null;
    /**
     *  Schema.org/additionalProperty
     *  A property-value pair representing an additional characteristics of the entitity, e.g. a product feature or another characteristic for which there is no matching property in schema.org.\n\nNote: Publishers should be aware that applications designed to use specific schema.org properties (e.g. schema:width, schema:color, schema:gtin13, ...) will typically expect such data to be provided using those properties, rather than using the generic property/value mechanism.
     * 
     *  @property additionalProperty
     *  @type PropertyValue
     */
    prototype.additionalProperty = null;
    /**
     *  Schema.org/isAccessoryOrSparePartFor
     *  A pointer to another product (or multiple products) for which this product is an accessory or spare part.
     * 
     *  @property isAccessoryOrSparePartFor
     *  @type Product
     */
    prototype.isAccessoryOrSparePartFor = null;
    /**
     *  Schema.org/logo
     *  An associated logo.
     * 
     *  @property logo
     *  @type ImageObject
     */
    prototype.logo = null;
    /**
     *  Schema.org/gtin14
     *  The [GTIN-14](http://apps.gs1.org/GDD/glossary/Pages/GTIN-14.aspx) code of the product, or the product to which the offer refers. See [GS1 GTIN Summary](http://www.gs1.org/barcodes/technical/idkeys/gtin) for more details.
     * 
     *  @property gtin14
     *  @type Text
     */
    prototype.gtin14 = null;
    /**
     *  Schema.org/gtin13
     *  The [GTIN-13](http://apps.gs1.org/GDD/glossary/Pages/GTIN-13.aspx) code of the product, or the product to which the offer refers. This is equivalent to 13-digit ISBN codes and EAN UCC-13. Former 12-digit UPC codes can be converted into a GTIN-13 code by simply adding a preceeding zero. See [GS1 GTIN Summary](http://www.gs1.org/barcodes/technical/idkeys/gtin) for more details.
     * 
     *  @property gtin13
     *  @type Text
     */
    prototype.gtin13 = null;
    /**
     *  Schema.org/gtin12
     *  The [GTIN-12](http://apps.gs1.org/GDD/glossary/Pages/GTIN-12.aspx) code of the product, or the product to which the offer refers. The GTIN-12 is the 12-digit GS1 Identification Key composed of a U.P.C. Company Prefix, Item Reference, and Check Digit used to identify trade items. See [GS1 GTIN Summary](http://www.gs1.org/barcodes/technical/idkeys/gtin) for more details.
     * 
     *  @property gtin12
     *  @type Text
     */
    prototype.gtin12 = null;
    /**
     *  Schema.org/material
     *  A material that something is made from, e.g. leather, wool, cotton, paper.
     * 
     *  @property material
     *  @type URL
     */
    prototype.material = null;
    /**
     *  Schema.org/weight
     *  The weight of the product or person.
     * 
     *  @property weight
     *  @type QuantitativeValue
     */
    prototype.weight = null;
    /**
     *  Schema.org/depth
     *  The depth of the item.
     * 
     *  @property depth
     *  @type Distance
     */
    prototype.depth = null;
    /**
     *  Schema.org/isSimilarTo
     *  A pointer to another, functionally similar product (or multiple products).
     * 
     *  @property isSimilarTo
     *  @type Product
     */
    prototype.isSimilarTo = null;
    /**
     *  Schema.org/model
     *  The model of the product. Use with the URL of a ProductModel or a textual representation of the model identifier. The URL of the ProductModel can be from an external source. It is recommended to additionally provide strong product identifiers via the gtin8/gtin13/gtin14 and mpn properties.
     * 
     *  @property model
     *  @type Text
     */
    prototype.model = null;
    /**
     *  Schema.org/color
     *  The color of the product.
     * 
     *  @property color
     *  @type Text
     */
    prototype.color = null;
    /**
     *  Schema.org/isRelatedTo
     *  A pointer to another, somehow related product (or multiple products).
     * 
     *  @property isRelatedTo
     *  @type Product
     */
    prototype.isRelatedTo = null;
    /**
     *  Schema.org/productID
     *  The product identifier, such as ISBN. For example: ``` meta itemprop="productID" content="isbn:123-456-789" ```.
     * 
     *  @property productID
     *  @type Text
     */
    prototype.productID = null;
    /**
     *  Schema.org/review
     *  A review of the item.
     * 
     *  @property review
     *  @type Review
     */
    prototype.review = null;
    /**
     *  Schema.org/purchaseDate
     *  The date the item e.g. vehicle was purchased by the current owner.
     * 
     *  @property purchaseDate
     *  @type Date
     */
    prototype.purchaseDate = null;
    /**
     *  Schema.org/itemCondition
     *  A predefined value from OfferItemCondition or a textual description of the condition of the product or service, or the products or services included in the offer.
     * 
     *  @property itemCondition
     *  @type OfferItemCondition
     */
    prototype.itemCondition = null;
    /**
     *  Schema.org/brand
     *  The brand(s) associated with a product or service, or the brand(s) maintained by an organization or business person.
     * 
     *  @property brand
     *  @type Organization
     */
    prototype.brand = null;
    /**
     *  Schema.org/releaseDate
     *  The release date of a product or product model. This can be used to distinguish the exact variant of a product.
     * 
     *  @property releaseDate
     *  @type Date
     */
    prototype.releaseDate = null;
}, {manufacturer: "Organization", audience: "Audience", height: "Distance", reviews: "Review", aggregateRating: "AggregateRating", isConsumableFor: "Product", offers: "Offer", width: "Distance", additionalProperty: "PropertyValue", isAccessoryOrSparePartFor: "Product", logo: "ImageObject", weight: "QuantitativeValue", depth: "Distance", isSimilarTo: "Product", isRelatedTo: "Product", review: "Review", itemCondition: "OfferItemCondition", brand: "Organization", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/CreativeWork
 *  The most generic kind of creative work, including books, movies, photographs, software programs, etc.
 * 
 *  @author schema.org
 *  @class CreativeWork
 *  @module org.schema
 *  @extends Thing
 */
var CreativeWork = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Thing.call(this);
    this.context = "http://schema.org/";
    this.type = "CreativeWork";
};
CreativeWork = stjs.extend(CreativeWork, Thing, [], function(constructor, prototype) {
    /**
     *  Schema.org/about
     *  The subject matter of the content.
     * 
     *  @property about
     *  @type Thing
     */
    prototype.about = null;
    /**
     *  Schema.org/educationalAlignment
     *  An alignment to an established educational framework.
     * 
     *  @property educationalAlignment
     *  @type AlignmentObject
     */
    prototype.educationalAlignment = null;
    /**
     *  Schema.org/associatedMedia
     *  A media object that encodes this CreativeWork. This property is a synonym for encoding.
     * 
     *  @property associatedMedia
     *  @type MediaObject
     */
    prototype.associatedMedia = null;
    /**
     *  Schema.org/funder
     *  A person or organization that supports (sponsors) something through some kind of financial contribution.
     * 
     *  @property funder
     *  @type Person
     */
    prototype.funder = null;
    /**
     *  Schema.org/audio
     *  An embedded audio object.
     * 
     *  @property audio
     *  @type AudioObject
     */
    prototype.audio = null;
    /**
     *  Schema.org/workExample
     *  Example/instance/realization/derivation of the concept of this creative work. eg. The paperback edition, first edition, or eBook.
     * 
     *  @property workExample
     *  @type CreativeWork
     */
    prototype.workExample = null;
    /**
     *  Schema.org/provider
     *  The service provider, service operator, or service performer; the goods producer. Another party (a seller) may offer those services or goods on behalf of the provider. A provider may also serve as the seller.
     * 
     *  @property provider
     *  @type Person
     */
    prototype.provider = null;
    /**
     *  Schema.org/encoding
     *  A media object that encodes this CreativeWork. This property is a synonym for associatedMedia.
     * 
     *  @property encoding
     *  @type MediaObject
     */
    prototype.encoding = null;
    /**
     *  Schema.org/interactivityType
     *  The predominant mode of learning supported by the learning resource. Acceptable values are 'active', 'expositive', or 'mixed'.
     * 
     *  @property interactivityType
     *  @type Text
     */
    prototype.interactivityType = null;
    /**
     *  Schema.org/accessibilitySummary
     *  A human-readable summary of specific accessibility features or deficiencies, consistent with the other accessibility metadata but expressing subtleties such as "short descriptions are present but long descriptions will be needed for non-visual users" or "short descriptions are present and no long descriptions are needed."
     * 
     *  @property accessibilitySummary
     *  @type Text
     */
    prototype.accessibilitySummary = null;
    /**
     *  Schema.org/character
     *  Fictional person connected with a creative work.
     * 
     *  @property character
     *  @type Person
     */
    prototype.character = null;
    /**
     *  Schema.org/audience
     *  An intended audience, i.e. a group for whom something was created.
     * 
     *  @property audience
     *  @type Audience
     */
    prototype.audience = null;
    /**
     *  Schema.org/sourceOrganization
     *  The Organization on whose behalf the creator was working.
     * 
     *  @property sourceOrganization
     *  @type Organization
     */
    prototype.sourceOrganization = null;
    /**
     *  Schema.org/isPartOf
     *  Indicates a CreativeWork that this CreativeWork is (in some sense) part of.
     * 
     *  @property isPartOf
     *  @type CreativeWork
     */
    prototype.isPartOf = null;
    /**
     *  Schema.org/video
     *  An embedded video object.
     * 
     *  @property video
     *  @type VideoObject
     */
    prototype.video = null;
    /**
     *  Schema.org/publication
     *  A publication event associated with the item.
     * 
     *  @property publication
     *  @type PublicationEvent
     */
    prototype.publication = null;
    /**
     *  Schema.org/text
     *  The textual content of this CreativeWork.
     * 
     *  @property text
     *  @type Text
     */
    prototype.text = null;
    /**
     *  Schema.org/contributor
     *  A secondary contributor to the CreativeWork or SchemaEvent.
     * 
     *  @property contributor
     *  @type Organization
     */
    prototype.contributor = null;
    /**
     *  Schema.org/reviews
     *  Review of the item.
     * 
     *  @property reviews
     *  @type Review
     */
    prototype.reviews = null;
    /**
     *  Schema.org/typicalAgeRange
     *  The typical expected age range, e.g. '7-9', '11-'.
     * 
     *  @property typicalAgeRange
     *  @type Text
     */
    prototype.typicalAgeRange = null;
    /**
     *  Schema.org/hasPart
     *  Indicates a CreativeWork that is (in some sense) a part of this CreativeWork.
     * 
     *  @property hasPart
     *  @type CreativeWork
     */
    prototype.hasPart = null;
    /**
     *  Schema.org/position
     *  The position of an item in a series or sequence of items.
     * 
     *  @property position
     *  @type Integer
     */
    prototype.position = null;
    /**
     *  Schema.org/releasedEvent
     *  The place and time the release was issued, expressed as a PublicationEvent.
     * 
     *  @property releasedEvent
     *  @type PublicationEvent
     */
    prototype.releasedEvent = null;
    /**
     *  Schema.org/educationalUse
     *  The purpose of a work in the context of education; for example, 'assignment', 'group work'.
     * 
     *  @property educationalUse
     *  @type Text
     */
    prototype.educationalUse = null;
    /**
     *  Schema.org/contentLocation
     *  The location depicted or described in the content. For example, the location in a photograph or painting.
     * 
     *  @property contentLocation
     *  @type Place
     */
    prototype.contentLocation = null;
    /**
     *  Schema.org/schemaVersion
     *  Indicates (by URL or string) a particular version of a schema used in some CreativeWork. For example, a document could declare a schemaVersion using an URL such as schema:version/2.0/ if precise indication of schema version was required by some application.
     * 
     *  @property schemaVersion
     *  @type URL
     */
    prototype.schemaVersion = null;
    /**
     *  Schema.org/accessibilityFeature
     *  Content features of the resource, such as accessible media, alternatives and supported enhancements for accessibility ([WebSchemas wiki lists possible values](http://www.w3.org/wiki/WebSchemas/Accessibility)).
     * 
     *  @property accessibilityFeature
     *  @type Text
     */
    prototype.accessibilityFeature = null;
    /**
     *  Schema.org/aggregateRating
     *  The overall rating, based on a collection of reviews or ratings, of the item.
     * 
     *  @property aggregateRating
     *  @type AggregateRating
     */
    prototype.aggregateRating = null;
    /**
     *  Schema.org/locationCreated
     *  The location where the CreativeWork was created, which may not be the same as the location depicted in the CreativeWork.
     * 
     *  @property locationCreated
     *  @type Place
     */
    prototype.locationCreated = null;
    /**
     *  Schema.org/accessModeSufficient
     *  A list of single or combined accessModes that are sufficient to understand all the intellectual content of a resource. Expected values include:  auditory, tactile, textual, visual.
     * 
     *  @property accessModeSufficient
     *  @type Text
     */
    prototype.accessModeSufficient = null;
    /**
     *  Schema.org/temporalCoverage
     *  The temporalCoverage of a CreativeWork indicates the period that the content applies to, i.e. that it describes, either as a DateTime or as a textual string indicating a time period in [ISO 8601 time interval format](https://en.wikipedia.org/wiki/ISO_8601#Time_intervals). In
     *  the case of a Dataset it will typically indicate the relevant time period in a precise notation (e.g. for a 2011 census dataset, the year 2011 would be written "2011/2012"). Other forms of content e.g. ScholarlyArticle, Book, TVSeries or TVEpisode may indicate their temporalCoverage in broader terms - textually or via well-known URL.
     *  Written works such as books may sometimes have precise temporal coverage too, e.g. a work set in 1939 - 1945 can be indicated in ISO 8601 interval format format via "1939/1945".
     * 
     *  @property temporalCoverage
     *  @type URL
     */
    prototype.temporalCoverage = null;
    /**
     *  Schema.org/accountablePerson
     *  Specifies the Person that is legally accountable for the CreativeWork.
     * 
     *  @property accountablePerson
     *  @type Person
     */
    prototype.accountablePerson = null;
    /**
     *  Schema.org/spatialCoverage
     *  The spatialCoverage of a CreativeWork indicates the place(s) which are the focus of the content. It is a subproperty of
     *  contentLocation intended primarily for more technical and detailed materials. For example with a Dataset, it indicates
     *  areas that the dataset describes: a dataset of New York weather would have spatialCoverage which was the place: the state of New York.
     * 
     *  @property spatialCoverage
     *  @type Place
     */
    prototype.spatialCoverage = null;
    /**
     *  Schema.org/offers
     *  An offer to provide this item&#x2014;for example, an offer to sell a product, rent the DVD of a movie, perform a service, or give away tickets to an event.
     * 
     *  @property offers
     *  @type Offer
     */
    prototype.offers = null;
    /**
     *  Schema.org/editor
     *  Specifies the Person who edited the CreativeWork.
     * 
     *  @property editor
     *  @type Person
     */
    prototype.editor = null;
    /**
     *  Schema.org/discussionUrl
     *  A link to the page containing the comments of the CreativeWork.
     * 
     *  @property discussionUrl
     *  @type URL
     */
    prototype.discussionUrl = null;
    /**
     *  Schema.org/award
     *  An award won by or for this item.
     * 
     *  @property award
     *  @type Text
     */
    prototype.award = null;
    /**
     *  Schema.org/copyrightHolder
     *  The party holding the legal copyright to the CreativeWork.
     * 
     *  @property copyrightHolder
     *  @type Person
     */
    prototype.copyrightHolder = null;
    /**
     *  Schema.org/accessibilityHazard
     *  A characteristic of the described resource that is physiologically dangerous to some users. Related to WCAG 2.0 guideline 2.3 ([WebSchemas wiki lists possible values](http://www.w3.org/wiki/WebSchemas/Accessibility)).
     * 
     *  @property accessibilityHazard
     *  @type Text
     */
    prototype.accessibilityHazard = null;
    /**
     *  Schema.org/copyrightYear
     *  The year during which the claimed copyright for the CreativeWork was first asserted.
     * 
     *  @property copyrightYear
     *  @type Number
     */
    prototype.copyrightYear = null;
    /**
     *  Schema.org/awards
     *  Awards won by or for this item.
     * 
     *  @property awards
     *  @type Text
     */
    prototype.awards = null;
    /**
     *  Schema.org/recordedAt
     *  The SchemaEvent where the CreativeWork was recorded. The CreativeWork may capture all or part of the event.
     * 
     *  @property recordedAt
     *  @type SchemaEvent
     */
    prototype.recordedAt = null;
    /**
     *  Schema.org/commentCount
     *  The number of comments this CreativeWork (e.g. Article, Question or Answer) has received. This is most applicable to works published in Web sites with commenting system; additional comments may exist elsewhere.
     * 
     *  @property commentCount
     *  @type Integer
     */
    prototype.commentCount = null;
    /**
     *  Schema.org/fileFormat
     *  Media type, typically MIME format (see [IANA site](http://www.iana.org/assignments/media-types/media-types.xhtml)) of the content e.g. application/zip of a SoftwareApplication binary. In cases where a CreativeWork has several media type representations, 'encoding' can be used to indicate each MediaObject alongside particular fileFormat information. Unregistered or niche file formats can be indicated instead via the most appropriate URL, e.g. defining Web page or a Wikipedia entry.
     * 
     *  @property fileFormat
     *  @type Text
     */
    prototype.fileFormat = null;
    /**
     *  Schema.org/accessibilityAPI
     *  Indicates that the resource is compatible with the referenced accessibility API ([WebSchemas wiki lists possible values](http://www.w3.org/wiki/WebSchemas/Accessibility)).
     * 
     *  @property accessibilityAPI
     *  @type Text
     */
    prototype.accessibilityAPI = null;
    /**
     *  Schema.org/publisher
     *  The publisher of the creative work.
     * 
     *  @property publisher
     *  @type Person
     */
    prototype.publisher = null;
    /**
     *  Schema.org/interactionStatistic
     *  The number of interactions for the CreativeWork using the WebSite or SoftwareApplication. The most specific child type of InteractionCounter should be used.
     * 
     *  @property interactionStatistic
     *  @type InteractionCounter
     */
    prototype.interactionStatistic = null;
    /**
     *  Schema.org/contentRating
     *  Official rating of a piece of content&#x2014;for example,'MPAA PG-13'.
     * 
     *  @property contentRating
     *  @type Text
     */
    prototype.contentRating = null;
    /**
     *  Schema.org/learningResourceType
     *  The predominant type or kind characterizing the learning resource. For example, 'presentation', 'handout'.
     * 
     *  @property learningResourceType
     *  @type Text
     */
    prototype.learningResourceType = null;
    /**
     *  Schema.org/accessMode
     *  The human sensory perceptual system or cognitive faculty through which a person may process or perceive information. Expected values include: auditory, tactile, textual, visual, colorDependent, chartOnVisual, chemOnVisual, diagramOnVisual, mathOnVisual, musicOnVisual, textOnVisual.
     * 
     *  @property accessMode
     *  @type Text
     */
    prototype.accessMode = null;
    /**
     *  Schema.org/material
     *  A material that something is made from, e.g. leather, wool, cotton, paper.
     * 
     *  @property material
     *  @type URL
     */
    prototype.material = null;
    /**
     *  Schema.org/isFamilyFriendly
     *  Indicates whether this content is family friendly.
     * 
     *  @property isFamilyFriendly
     *  @type Boolean
     */
    prototype.isFamilyFriendly = null;
    /**
     *  Schema.org/exampleOfWork
     *  A creative work that this work is an example/instance/realization/derivation of.
     * 
     *  @property exampleOfWork
     *  @type CreativeWork
     */
    prototype.exampleOfWork = null;
    /**
     *  Schema.org/version
     *  The version of the CreativeWork embodied by a specified resource.
     * 
     *  @property version
     *  @type Text
     */
    prototype.version = null;
    /**
     *  Schema.org/dateModified
     *  The date on which the CreativeWork was most recently modified or when the item's entry was modified within a DataFeed.
     * 
     *  @property dateModified
     *  @type DateTime
     */
    prototype.dateModified = null;
    /**
     *  Schema.org/mainEntity
     *  Indicates the primary entity described in some page or other CreativeWork.
     * 
     *  @property mainEntity
     *  @type Thing
     */
    prototype.mainEntity = null;
    /**
     *  Schema.org/genre
     *  Genre of the creative work, broadcast channel or group.
     * 
     *  @property genre
     *  @type URL
     */
    prototype.genre = null;
    /**
     *  Schema.org/keywords
     *  Keywords or tags used to describe this content. Multiple entries in a keywords list are typically delimited by commas.
     * 
     *  @property keywords
     *  @type Text
     */
    prototype.keywords = null;
    /**
     *  Schema.org/author
     *  The author of this content or rating. Please note that author is special in that HTML 5 provides a special mechanism for indicating authorship via the rel tag. That is equivalent to this and may be used interchangeably.
     * 
     *  @property author
     *  @type Person
     */
    prototype.author = null;
    /**
     *  Schema.org/isBasedOnUrl
     *  A resource that was used in the creation of this resource. This term can be repeated for multiple sources. For example, http://example.com/great-multiplication-intro.html.
     * 
     *  @property isBasedOnUrl
     *  @type URL
     */
    prototype.isBasedOnUrl = null;
    /**
     *  Schema.org/timeRequired
     *  Approximate or typical time it takes to work with or through this learning resource for the typical intended target audience, e.g. 'P30M', 'P1H25M'.
     * 
     *  @property timeRequired
     *  @type Duration
     */
    prototype.timeRequired = null;
    /**
     *  Schema.org/translator
     *  Organization or person who adapts a creative work to different languages, regional differences and technical requirements of a target market, or that translates during some event.
     * 
     *  @property translator
     *  @type Person
     */
    prototype.translator = null;
    /**
     *  Schema.org/thumbnailUrl
     *  A thumbnail image relevant to the Thing.
     * 
     *  @property thumbnailUrl
     *  @type URL
     */
    prototype.thumbnailUrl = null;
    /**
     *  Schema.org/comment
     *  Comments, typically from users.
     * 
     *  @property comment
     *  @type Comment
     */
    prototype.comment = null;
    /**
     *  Schema.org/inLanguage
     *  The language of the content or performance or used in an action. Please use one of the language codes from the [IETF BCP 47 standard](http://tools.ietf.org/html/bcp47). See also [[availableLanguage]].
     * 
     *  @property inLanguage
     *  @type Language
     */
    prototype.inLanguage = null;
    /**
     *  Schema.org/review
     *  A review of the item.
     * 
     *  @property review
     *  @type Review
     */
    prototype.review = null;
    /**
     *  Schema.org/license
     *  A license document that applies to this content, typically indicated by URL.
     * 
     *  @property license
     *  @type CreativeWork
     */
    prototype.license = null;
    /**
     *  Schema.org/accessibilityControl
     *  Identifies input methods that are sufficient to fully control the described resource ([WebSchemas wiki lists possible values](http://www.w3.org/wiki/WebSchemas/Accessibility)).
     * 
     *  @property accessibilityControl
     *  @type Text
     */
    prototype.accessibilityControl = null;
    /**
     *  Schema.org/encodings
     *  A media object that encodes this CreativeWork.
     * 
     *  @property encodings
     *  @type MediaObject
     */
    prototype.encodings = null;
    /**
     *  Schema.org/isBasedOn
     *  A resource that was used in the creation of this resource. This term can be repeated for multiple sources. For example, http://example.com/great-multiplication-intro.html.
     * 
     *  @property isBasedOn
     *  @type Product
     */
    prototype.isBasedOn = null;
    /**
     *  Schema.org/creator
     *  The creator/author of this CreativeWork. This is the same as the Author property for CreativeWork.
     * 
     *  @property creator
     *  @type Person
     */
    prototype.creator = null;
    /**
     *  Schema.org/publishingPrinciples
     *  Link to page describing the editorial principles of the organization primarily responsible for the creation of the CreativeWork.
     * 
     *  @property publishingPrinciples
     *  @type URL
     */
    prototype.publishingPrinciples = null;
    /**
     *  Schema.org/sponsor
     *  A person or organization that supports a thing through a pledge, promise, or financial contribution. e.g. a sponsor of a Medical Study or a corporate sponsor of an event.
     * 
     *  @property sponsor
     *  @type Organization
     */
    prototype.sponsor = null;
    /**
     *  Schema.org/producer
     *  The person or organization who produced the work (e.g. music album, movie, tv/radio series etc.).
     * 
     *  @property producer
     *  @type Person
     */
    prototype.producer = null;
    /**
     *  Schema.org/mentions
     *  Indicates that the CreativeWork contains a reference to, but is not necessarily about a concept.
     * 
     *  @property mentions
     *  @type Thing
     */
    prototype.mentions = null;
    /**
     *  Schema.org/dateCreated
     *  The date on which the CreativeWork was created or the item was added to a DataFeed.
     * 
     *  @property dateCreated
     *  @type Date
     */
    prototype.dateCreated = null;
    /**
     *  Schema.org/datePublished
     *  Date of first broadcast/publication.
     * 
     *  @property datePublished
     *  @type Date
     */
    prototype.datePublished = null;
    /**
     *  Schema.org/isAccessibleForFree
     *  A flag to signal that the publication is accessible for free.
     * 
     *  @property isAccessibleForFree
     *  @type Boolean
     */
    prototype.isAccessibleForFree = null;
    /**
     *  Schema.org/alternativeHeadline
     *  A secondary title of the CreativeWork.
     * 
     *  @property alternativeHeadline
     *  @type Text
     */
    prototype.alternativeHeadline = null;
    /**
     *  Schema.org/headline
     *  Headline of the article.
     * 
     *  @property headline
     *  @type Text
     */
    prototype.headline = null;
    /**
     *  Schema.org/citation
     *  A citation or reference to another creative work, such as another publication, web page, scholarly article, etc.
     * 
     *  @property citation
     *  @type Text
     */
    prototype.citation = null;
}, {about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/BusinessEvent
 *  SchemaEvent type: Business event.
 * 
 *  @author schema.org
 *  @class BusinessEvent
 *  @module org.schema
 *  @extends SchemaEvent
 */
var BusinessEvent = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    SchemaEvent.call(this);
    this.context = "http://schema.org/";
    this.type = "BusinessEvent";
};
BusinessEvent = stjs.extend(BusinessEvent, SchemaEvent, [], null, {about: "Thing", funder: "Person", workFeatured: "CreativeWork", audience: "Audience", actor: "Person", performers: "Organization", contributor: "Organization", organizer: "Person", attendees: "Person", aggregateRating: "AggregateRating", subEvent: "SchemaEvent", subEvents: "SchemaEvent", offers: "Offer", attendee: "Organization", workPerformed: "CreativeWork", eventStatus: "EventStatusType", director: "Person", superEvent: "SchemaEvent", duration: "Duration", translator: "Person", inLanguage: "Language", review: "Review", sponsor: "Organization", location: "PostalAddress", recordedIn: "CreativeWork", composer: "Organization", performer: "Person", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/SaleEvent
 *  SchemaEvent type: Sales event.
 * 
 *  @author schema.org
 *  @class SaleEvent
 *  @module org.schema
 *  @extends SchemaEvent
 */
var SaleEvent = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    SchemaEvent.call(this);
    this.context = "http://schema.org/";
    this.type = "SaleEvent";
};
SaleEvent = stjs.extend(SaleEvent, SchemaEvent, [], null, {about: "Thing", funder: "Person", workFeatured: "CreativeWork", audience: "Audience", actor: "Person", performers: "Organization", contributor: "Organization", organizer: "Person", attendees: "Person", aggregateRating: "AggregateRating", subEvent: "SchemaEvent", subEvents: "SchemaEvent", offers: "Offer", attendee: "Organization", workPerformed: "CreativeWork", eventStatus: "EventStatusType", director: "Person", superEvent: "SchemaEvent", duration: "Duration", translator: "Person", inLanguage: "Language", review: "Review", sponsor: "Organization", location: "PostalAddress", recordedIn: "CreativeWork", composer: "Organization", performer: "Person", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/TheaterEvent
 *  SchemaEvent type: Theater performance.
 * 
 *  @author schema.org
 *  @class TheaterEvent
 *  @module org.schema
 *  @extends SchemaEvent
 */
var TheaterEvent = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    SchemaEvent.call(this);
    this.context = "http://schema.org/";
    this.type = "TheaterEvent";
};
TheaterEvent = stjs.extend(TheaterEvent, SchemaEvent, [], null, {about: "Thing", funder: "Person", workFeatured: "CreativeWork", audience: "Audience", actor: "Person", performers: "Organization", contributor: "Organization", organizer: "Person", attendees: "Person", aggregateRating: "AggregateRating", subEvent: "SchemaEvent", subEvents: "SchemaEvent", offers: "Offer", attendee: "Organization", workPerformed: "CreativeWork", eventStatus: "EventStatusType", director: "Person", superEvent: "SchemaEvent", duration: "Duration", translator: "Person", inLanguage: "Language", review: "Review", sponsor: "Organization", location: "PostalAddress", recordedIn: "CreativeWork", composer: "Organization", performer: "Person", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/EducationEvent
 *  SchemaEvent type: Education event.
 * 
 *  @author schema.org
 *  @class EducationEvent
 *  @module org.schema
 *  @extends SchemaEvent
 */
var EducationEvent = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    SchemaEvent.call(this);
    this.context = "http://schema.org/";
    this.type = "EducationEvent";
};
EducationEvent = stjs.extend(EducationEvent, SchemaEvent, [], null, {about: "Thing", funder: "Person", workFeatured: "CreativeWork", audience: "Audience", actor: "Person", performers: "Organization", contributor: "Organization", organizer: "Person", attendees: "Person", aggregateRating: "AggregateRating", subEvent: "SchemaEvent", subEvents: "SchemaEvent", offers: "Offer", attendee: "Organization", workPerformed: "CreativeWork", eventStatus: "EventStatusType", director: "Person", superEvent: "SchemaEvent", duration: "Duration", translator: "Person", inLanguage: "Language", review: "Review", sponsor: "Organization", location: "PostalAddress", recordedIn: "CreativeWork", composer: "Organization", performer: "Person", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/SocialEvent
 *  SchemaEvent type: Social event.
 * 
 *  @author schema.org
 *  @class SocialEvent
 *  @module org.schema
 *  @extends SchemaEvent
 */
var SocialEvent = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    SchemaEvent.call(this);
    this.context = "http://schema.org/";
    this.type = "SocialEvent";
};
SocialEvent = stjs.extend(SocialEvent, SchemaEvent, [], null, {about: "Thing", funder: "Person", workFeatured: "CreativeWork", audience: "Audience", actor: "Person", performers: "Organization", contributor: "Organization", organizer: "Person", attendees: "Person", aggregateRating: "AggregateRating", subEvent: "SchemaEvent", subEvents: "SchemaEvent", offers: "Offer", attendee: "Organization", workPerformed: "CreativeWork", eventStatus: "EventStatusType", director: "Person", superEvent: "SchemaEvent", duration: "Duration", translator: "Person", inLanguage: "Language", review: "Review", sponsor: "Organization", location: "PostalAddress", recordedIn: "CreativeWork", composer: "Organization", performer: "Person", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/LiteraryEvent
 *  SchemaEvent type: Literary event.
 * 
 *  @author schema.org
 *  @class LiteraryEvent
 *  @module org.schema
 *  @extends SchemaEvent
 */
var LiteraryEvent = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    SchemaEvent.call(this);
    this.context = "http://schema.org/";
    this.type = "LiteraryEvent";
};
LiteraryEvent = stjs.extend(LiteraryEvent, SchemaEvent, [], null, {about: "Thing", funder: "Person", workFeatured: "CreativeWork", audience: "Audience", actor: "Person", performers: "Organization", contributor: "Organization", organizer: "Person", attendees: "Person", aggregateRating: "AggregateRating", subEvent: "SchemaEvent", subEvents: "SchemaEvent", offers: "Offer", attendee: "Organization", workPerformed: "CreativeWork", eventStatus: "EventStatusType", director: "Person", superEvent: "SchemaEvent", duration: "Duration", translator: "Person", inLanguage: "Language", review: "Review", sponsor: "Organization", location: "PostalAddress", recordedIn: "CreativeWork", composer: "Organization", performer: "Person", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/DanceEvent
 *  SchemaEvent type: A social dance.
 * 
 *  @author schema.org
 *  @class DanceEvent
 *  @module org.schema
 *  @extends SchemaEvent
 */
var DanceEvent = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    SchemaEvent.call(this);
    this.context = "http://schema.org/";
    this.type = "DanceEvent";
};
DanceEvent = stjs.extend(DanceEvent, SchemaEvent, [], null, {about: "Thing", funder: "Person", workFeatured: "CreativeWork", audience: "Audience", actor: "Person", performers: "Organization", contributor: "Organization", organizer: "Person", attendees: "Person", aggregateRating: "AggregateRating", subEvent: "SchemaEvent", subEvents: "SchemaEvent", offers: "Offer", attendee: "Organization", workPerformed: "CreativeWork", eventStatus: "EventStatusType", director: "Person", superEvent: "SchemaEvent", duration: "Duration", translator: "Person", inLanguage: "Language", review: "Review", sponsor: "Organization", location: "PostalAddress", recordedIn: "CreativeWork", composer: "Organization", performer: "Person", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/UserInteraction
 *  UserInteraction and its subtypes is an old way of talking about users interacting with pages. It is generally better to use [[Action]]-based vocabulary, alongside types such as [[Comment]].
 * 
 *  @author schema.org
 *  @class UserInteraction
 *  @module org.schema
 *  @extends SchemaEvent
 */
var UserInteraction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    SchemaEvent.call(this);
    this.context = "http://schema.org/";
    this.type = "UserInteraction";
};
UserInteraction = stjs.extend(UserInteraction, SchemaEvent, [], null, {about: "Thing", funder: "Person", workFeatured: "CreativeWork", audience: "Audience", actor: "Person", performers: "Organization", contributor: "Organization", organizer: "Person", attendees: "Person", aggregateRating: "AggregateRating", subEvent: "SchemaEvent", subEvents: "SchemaEvent", offers: "Offer", attendee: "Organization", workPerformed: "CreativeWork", eventStatus: "EventStatusType", director: "Person", superEvent: "SchemaEvent", duration: "Duration", translator: "Person", inLanguage: "Language", review: "Review", sponsor: "Organization", location: "PostalAddress", recordedIn: "CreativeWork", composer: "Organization", performer: "Person", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/DeliveryEvent
 *  An event involving the delivery of an item.
 * 
 *  @author schema.org
 *  @class DeliveryEvent
 *  @module org.schema
 *  @extends SchemaEvent
 */
var DeliveryEvent = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    SchemaEvent.call(this);
    this.context = "http://schema.org/";
    this.type = "DeliveryEvent";
};
DeliveryEvent = stjs.extend(DeliveryEvent, SchemaEvent, [], function(constructor, prototype) {
    /**
     *  Schema.org/hasDeliveryMethod
     *  Method used for delivery or shipping.
     * 
     *  @property hasDeliveryMethod
     *  @type DeliveryMethod
     */
    prototype.hasDeliveryMethod = null;
    /**
     *  Schema.org/availableThrough
     *  After this date, the item will no longer be available for pickup.
     * 
     *  @property availableThrough
     *  @type DateTime
     */
    prototype.availableThrough = null;
    /**
     *  Schema.org/availableFrom
     *  When the item is available for pickup from the store, locker, etc.
     * 
     *  @property availableFrom
     *  @type DateTime
     */
    prototype.availableFrom = null;
    /**
     *  Schema.org/accessCode
     *  Password, PIN, or access code needed for delivery (e.g. from a locker).
     * 
     *  @property accessCode
     *  @type Text
     */
    prototype.accessCode = null;
}, {hasDeliveryMethod: "DeliveryMethod", about: "Thing", funder: "Person", workFeatured: "CreativeWork", audience: "Audience", actor: "Person", performers: "Organization", contributor: "Organization", organizer: "Person", attendees: "Person", aggregateRating: "AggregateRating", subEvent: "SchemaEvent", subEvents: "SchemaEvent", offers: "Offer", attendee: "Organization", workPerformed: "CreativeWork", eventStatus: "EventStatusType", director: "Person", superEvent: "SchemaEvent", duration: "Duration", translator: "Person", inLanguage: "Language", review: "Review", sponsor: "Organization", location: "PostalAddress", recordedIn: "CreativeWork", composer: "Organization", performer: "Person", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/PublicationEvent
 *  A PublicationEvent corresponds indifferently to the event of publication for a CreativeWork of any type e.g. a broadcast event, an on-demand event, a book/journal publication via a variety of delivery media.
 * 
 *  @author schema.org
 *  @class PublicationEvent
 *  @module org.schema
 *  @extends SchemaEvent
 */
var PublicationEvent = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    SchemaEvent.call(this);
    this.context = "http://schema.org/";
    this.type = "PublicationEvent";
};
PublicationEvent = stjs.extend(PublicationEvent, SchemaEvent, [], function(constructor, prototype) {
    /**
     *  Schema.org/publishedOn
     *  A broadcast service associated with the publication event.
     * 
     *  @property publishedOn
     *  @type BroadcastService
     */
    prototype.publishedOn = null;
    /**
     *  Schema.org/free
     *  A flag to signal that the publication or event is accessible for free.
     * 
     *  @property free
     *  @type Boolean
     */
    prototype.free = null;
    /**
     *  Schema.org/isAccessibleForFree
     *  A flag to signal that the publication is accessible for free.
     * 
     *  @property isAccessibleForFree
     *  @type Boolean
     */
    prototype.isAccessibleForFree = null;
}, {publishedOn: "BroadcastService", about: "Thing", funder: "Person", workFeatured: "CreativeWork", audience: "Audience", actor: "Person", performers: "Organization", contributor: "Organization", organizer: "Person", attendees: "Person", aggregateRating: "AggregateRating", subEvent: "SchemaEvent", subEvents: "SchemaEvent", offers: "Offer", attendee: "Organization", workPerformed: "CreativeWork", eventStatus: "EventStatusType", director: "Person", superEvent: "SchemaEvent", duration: "Duration", translator: "Person", inLanguage: "Language", review: "Review", sponsor: "Organization", location: "PostalAddress", recordedIn: "CreativeWork", composer: "Organization", performer: "Person", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/ScreeningEvent
 *  A screening of a movie or other video.
 * 
 *  @author schema.org
 *  @class ScreeningEvent
 *  @module org.schema
 *  @extends SchemaEvent
 */
var ScreeningEvent = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    SchemaEvent.call(this);
    this.context = "http://schema.org/";
    this.type = "ScreeningEvent";
};
ScreeningEvent = stjs.extend(ScreeningEvent, SchemaEvent, [], function(constructor, prototype) {
    /**
     *  Schema.org/videoFormat
     *  The type of screening or video broadcast used (e.g. IMAX, 3D, SD, HD, etc.).
     * 
     *  @property videoFormat
     *  @type Text
     */
    prototype.videoFormat = null;
    /**
     *  Schema.org/subtitleLanguage
     *  Languages in which subtitles/captions are available, in [IETF BCP 47 standard format](http://tools.ietf.org/html/bcp47).
     * 
     *  @property subtitleLanguage
     *  @type Text
     */
    prototype.subtitleLanguage = null;
    /**
     *  Schema.org/workPresented
     *  The movie presented during this event.
     * 
     *  @property workPresented
     *  @type Movie
     */
    prototype.workPresented = null;
}, {workPresented: "Movie", about: "Thing", funder: "Person", workFeatured: "CreativeWork", audience: "Audience", actor: "Person", performers: "Organization", contributor: "Organization", organizer: "Person", attendees: "Person", aggregateRating: "AggregateRating", subEvent: "SchemaEvent", subEvents: "SchemaEvent", offers: "Offer", attendee: "Organization", workPerformed: "CreativeWork", eventStatus: "EventStatusType", director: "Person", superEvent: "SchemaEvent", duration: "Duration", translator: "Person", inLanguage: "Language", review: "Review", sponsor: "Organization", location: "PostalAddress", recordedIn: "CreativeWork", composer: "Organization", performer: "Person", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/ChildrensEvent
 *  SchemaEvent type: Children's event.
 * 
 *  @author schema.org
 *  @class ChildrensEvent
 *  @module org.schema
 *  @extends SchemaEvent
 */
var ChildrensEvent = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    SchemaEvent.call(this);
    this.context = "http://schema.org/";
    this.type = "ChildrensEvent";
};
ChildrensEvent = stjs.extend(ChildrensEvent, SchemaEvent, [], null, {about: "Thing", funder: "Person", workFeatured: "CreativeWork", audience: "Audience", actor: "Person", performers: "Organization", contributor: "Organization", organizer: "Person", attendees: "Person", aggregateRating: "AggregateRating", subEvent: "SchemaEvent", subEvents: "SchemaEvent", offers: "Offer", attendee: "Organization", workPerformed: "CreativeWork", eventStatus: "EventStatusType", director: "Person", superEvent: "SchemaEvent", duration: "Duration", translator: "Person", inLanguage: "Language", review: "Review", sponsor: "Organization", location: "PostalAddress", recordedIn: "CreativeWork", composer: "Organization", performer: "Person", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/VisualArtsEvent
 *  SchemaEvent type: Visual arts event.
 * 
 *  @author schema.org
 *  @class VisualArtsEvent
 *  @module org.schema
 *  @extends SchemaEvent
 */
var VisualArtsEvent = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    SchemaEvent.call(this);
    this.context = "http://schema.org/";
    this.type = "VisualArtsEvent";
};
VisualArtsEvent = stjs.extend(VisualArtsEvent, SchemaEvent, [], null, {about: "Thing", funder: "Person", workFeatured: "CreativeWork", audience: "Audience", actor: "Person", performers: "Organization", contributor: "Organization", organizer: "Person", attendees: "Person", aggregateRating: "AggregateRating", subEvent: "SchemaEvent", subEvents: "SchemaEvent", offers: "Offer", attendee: "Organization", workPerformed: "CreativeWork", eventStatus: "EventStatusType", director: "Person", superEvent: "SchemaEvent", duration: "Duration", translator: "Person", inLanguage: "Language", review: "Review", sponsor: "Organization", location: "PostalAddress", recordedIn: "CreativeWork", composer: "Organization", performer: "Person", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/MusicEvent
 *  SchemaEvent type: Music event.
 * 
 *  @author schema.org
 *  @class MusicEvent
 *  @module org.schema
 *  @extends SchemaEvent
 */
var MusicEvent = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    SchemaEvent.call(this);
    this.context = "http://schema.org/";
    this.type = "MusicEvent";
};
MusicEvent = stjs.extend(MusicEvent, SchemaEvent, [], null, {about: "Thing", funder: "Person", workFeatured: "CreativeWork", audience: "Audience", actor: "Person", performers: "Organization", contributor: "Organization", organizer: "Person", attendees: "Person", aggregateRating: "AggregateRating", subEvent: "SchemaEvent", subEvents: "SchemaEvent", offers: "Offer", attendee: "Organization", workPerformed: "CreativeWork", eventStatus: "EventStatusType", director: "Person", superEvent: "SchemaEvent", duration: "Duration", translator: "Person", inLanguage: "Language", review: "Review", sponsor: "Organization", location: "PostalAddress", recordedIn: "CreativeWork", composer: "Organization", performer: "Person", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Festival
 *  SchemaEvent type: Festival.
 * 
 *  @author schema.org
 *  @class Festival
 *  @module org.schema
 *  @extends SchemaEvent
 */
var Festival = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    SchemaEvent.call(this);
    this.context = "http://schema.org/";
    this.type = "Festival";
};
Festival = stjs.extend(Festival, SchemaEvent, [], null, {about: "Thing", funder: "Person", workFeatured: "CreativeWork", audience: "Audience", actor: "Person", performers: "Organization", contributor: "Organization", organizer: "Person", attendees: "Person", aggregateRating: "AggregateRating", subEvent: "SchemaEvent", subEvents: "SchemaEvent", offers: "Offer", attendee: "Organization", workPerformed: "CreativeWork", eventStatus: "EventStatusType", director: "Person", superEvent: "SchemaEvent", duration: "Duration", translator: "Person", inLanguage: "Language", review: "Review", sponsor: "Organization", location: "PostalAddress", recordedIn: "CreativeWork", composer: "Organization", performer: "Person", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/CourseInstance
 *  An instance of a [[Course]] which is distinct from other instances because it is offered at a different time or location or through different media or modes of study or to a specific section of students.
 * 
 *  @author schema.org
 *  @class CourseInstance
 *  @module org.schema
 *  @extends SchemaEvent
 */
var CourseInstance = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    SchemaEvent.call(this);
    this.context = "http://schema.org/";
    this.type = "CourseInstance";
};
CourseInstance = stjs.extend(CourseInstance, SchemaEvent, [], function(constructor, prototype) {
    /**
     *  Schema.org/instructor
     *  A person assigned to instruct or provide instructional assistance for the [[CourseInstance]].
     * 
     *  @property instructor
     *  @type Person
     */
    prototype.instructor = null;
    /**
     *  Schema.org/courseMode
     *  The medium or means of delivery of the course instance or the mode of study, either as a text label (e.g. "online", "onsite" or "blended"; "synchronous" or "asynchronous"; "full-time" or "part-time") or as a URL reference to a term from a controlled vocabulary (e.g. https://ceds.ed.gov/element/001311#Asynchronous ).
     * 
     *  @property courseMode
     *  @type Text
     */
    prototype.courseMode = null;
}, {instructor: "Person", about: "Thing", funder: "Person", workFeatured: "CreativeWork", audience: "Audience", actor: "Person", performers: "Organization", contributor: "Organization", organizer: "Person", attendees: "Person", aggregateRating: "AggregateRating", subEvent: "SchemaEvent", subEvents: "SchemaEvent", offers: "Offer", attendee: "Organization", workPerformed: "CreativeWork", eventStatus: "EventStatusType", director: "Person", superEvent: "SchemaEvent", duration: "Duration", translator: "Person", inLanguage: "Language", review: "Review", sponsor: "Organization", location: "PostalAddress", recordedIn: "CreativeWork", composer: "Organization", performer: "Person", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/ComedyEvent
 *  SchemaEvent type: Comedy event.
 * 
 *  @author schema.org
 *  @class ComedyEvent
 *  @module org.schema
 *  @extends SchemaEvent
 */
var ComedyEvent = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    SchemaEvent.call(this);
    this.context = "http://schema.org/";
    this.type = "ComedyEvent";
};
ComedyEvent = stjs.extend(ComedyEvent, SchemaEvent, [], null, {about: "Thing", funder: "Person", workFeatured: "CreativeWork", audience: "Audience", actor: "Person", performers: "Organization", contributor: "Organization", organizer: "Person", attendees: "Person", aggregateRating: "AggregateRating", subEvent: "SchemaEvent", subEvents: "SchemaEvent", offers: "Offer", attendee: "Organization", workPerformed: "CreativeWork", eventStatus: "EventStatusType", director: "Person", superEvent: "SchemaEvent", duration: "Duration", translator: "Person", inLanguage: "Language", review: "Review", sponsor: "Organization", location: "PostalAddress", recordedIn: "CreativeWork", composer: "Organization", performer: "Person", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/SportsEvent
 *  SchemaEvent type: Sports event.
 * 
 *  @author schema.org
 *  @class SportsEvent
 *  @module org.schema
 *  @extends SchemaEvent
 */
var SportsEvent = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    SchemaEvent.call(this);
    this.context = "http://schema.org/";
    this.type = "SportsEvent";
};
SportsEvent = stjs.extend(SportsEvent, SchemaEvent, [], function(constructor, prototype) {
    /**
     *  Schema.org/awayTeam
     *  The away team in a sports event.
     * 
     *  @property awayTeam
     *  @type Person
     */
    prototype.awayTeam = null;
    /**
     *  Schema.org/homeTeam
     *  The home team in a sports event.
     * 
     *  @property homeTeam
     *  @type SportsTeam
     */
    prototype.homeTeam = null;
    /**
     *  Schema.org/competitor
     *  A competitor in a sports event.
     * 
     *  @property competitor
     *  @type Person
     */
    prototype.competitor = null;
}, {awayTeam: "Person", homeTeam: "SportsTeam", competitor: "Person", about: "Thing", funder: "Person", workFeatured: "CreativeWork", audience: "Audience", actor: "Person", performers: "Organization", contributor: "Organization", organizer: "Person", attendees: "Person", aggregateRating: "AggregateRating", subEvent: "SchemaEvent", subEvents: "SchemaEvent", offers: "Offer", attendee: "Organization", workPerformed: "CreativeWork", eventStatus: "EventStatusType", director: "Person", superEvent: "SchemaEvent", duration: "Duration", translator: "Person", inLanguage: "Language", review: "Review", sponsor: "Organization", location: "PostalAddress", recordedIn: "CreativeWork", composer: "Organization", performer: "Person", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/ExhibitionEvent
 *  SchemaEvent type: Exhibition event, e.g. at a museum, library, archive, tradeshow, ...
 * 
 *  @author schema.org
 *  @class ExhibitionEvent
 *  @module org.schema
 *  @extends SchemaEvent
 */
var ExhibitionEvent = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    SchemaEvent.call(this);
    this.context = "http://schema.org/";
    this.type = "ExhibitionEvent";
};
ExhibitionEvent = stjs.extend(ExhibitionEvent, SchemaEvent, [], null, {about: "Thing", funder: "Person", workFeatured: "CreativeWork", audience: "Audience", actor: "Person", performers: "Organization", contributor: "Organization", organizer: "Person", attendees: "Person", aggregateRating: "AggregateRating", subEvent: "SchemaEvent", subEvents: "SchemaEvent", offers: "Offer", attendee: "Organization", workPerformed: "CreativeWork", eventStatus: "EventStatusType", director: "Person", superEvent: "SchemaEvent", duration: "Duration", translator: "Person", inLanguage: "Language", review: "Review", sponsor: "Organization", location: "PostalAddress", recordedIn: "CreativeWork", composer: "Organization", performer: "Person", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/FoodEvent
 *  SchemaEvent type: Food event.
 * 
 *  @author schema.org
 *  @class FoodEvent
 *  @module org.schema
 *  @extends SchemaEvent
 */
var FoodEvent = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    SchemaEvent.call(this);
    this.context = "http://schema.org/";
    this.type = "FoodEvent";
};
FoodEvent = stjs.extend(FoodEvent, SchemaEvent, [], null, {about: "Thing", funder: "Person", workFeatured: "CreativeWork", audience: "Audience", actor: "Person", performers: "Organization", contributor: "Organization", organizer: "Person", attendees: "Person", aggregateRating: "AggregateRating", subEvent: "SchemaEvent", subEvents: "SchemaEvent", offers: "Offer", attendee: "Organization", workPerformed: "CreativeWork", eventStatus: "EventStatusType", director: "Person", superEvent: "SchemaEvent", duration: "Duration", translator: "Person", inLanguage: "Language", review: "Review", sponsor: "Organization", location: "PostalAddress", recordedIn: "CreativeWork", composer: "Organization", performer: "Person", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/AdministrativeArea
 *  A geographical region, typically under the jurisdiction of a particular government.
 * 
 *  @author schema.org
 *  @class AdministrativeArea
 *  @module org.schema
 *  @extends Place
 */
var AdministrativeArea = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Place.call(this);
    this.context = "http://schema.org/";
    this.type = "AdministrativeArea";
};
AdministrativeArea = stjs.extend(AdministrativeArea, Place, [], null, {photo: "ImageObject", address: "PostalAddress", openingHoursSpecification: "OpeningHoursSpecification", containedInPlace: "Place", reviews: "Review", aggregateRating: "AggregateRating", photos: "Photograph", hasMap: "SchemaMap", additionalProperty: "PropertyValue", events: "SchemaEvent", specialOpeningHoursSpecification: "OpeningHoursSpecification", amenityFeature: "LocationFeatureSpecification", logo: "ImageObject", geo: "GeoCoordinates", review: "Review", event: "SchemaEvent", containsPlace: "Place", containedIn: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/CivicStructure
 *  A public structure, such as a town hall or concert hall.
 * 
 *  @author schema.org
 *  @class CivicStructure
 *  @module org.schema
 *  @extends Place
 */
var CivicStructure = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Place.call(this);
    this.context = "http://schema.org/";
    this.type = "CivicStructure";
};
CivicStructure = stjs.extend(CivicStructure, Place, [], function(constructor, prototype) {
    /**
     *  Schema.org/openingHours
     *  The general opening hours for a business. Opening hours can be specified as a weekly time range, starting with days, then times per day. Multiple days can be listed with commas ',' separating each day. Day or time ranges are specified using a hyphen '-'.\n\n* Days are specified using the following two-letter combinations: ```Mo```, ```Tu```, ```We```, ```Th```, ```Fr```, ```Sa```, ```Su```.\n* Times are specified using 24:00 time. For example, 3pm is specified as ```15:00```. \n* Here is an example: <code>&lt;time itemprop="openingHours" datetime=&quot;Tu,Th 16:00-20:00&quot;&gt;Tuesdays and Thursdays 4-8pm&lt;/time&gt;</code>.\n* If a business is open 7 days a week, then it can be specified as <code>&lt;time itemprop=&quot;openingHours&quot; datetime=&quot;Mo-Su&quot;&gt;Monday through Sunday, all day&lt;/time&gt;</code>.
     * 
     *  @property openingHours
     *  @type Text
     */
    prototype.openingHours = null;
}, {photo: "ImageObject", address: "PostalAddress", openingHoursSpecification: "OpeningHoursSpecification", containedInPlace: "Place", reviews: "Review", aggregateRating: "AggregateRating", photos: "Photograph", hasMap: "SchemaMap", additionalProperty: "PropertyValue", events: "SchemaEvent", specialOpeningHoursSpecification: "OpeningHoursSpecification", amenityFeature: "LocationFeatureSpecification", logo: "ImageObject", geo: "GeoCoordinates", review: "Review", event: "SchemaEvent", containsPlace: "Place", containedIn: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/TouristAttraction
 *  A tourist attraction.
 * 
 *  @author schema.org
 *  @class TouristAttraction
 *  @module org.schema
 *  @extends Place
 */
var TouristAttraction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Place.call(this);
    this.context = "http://schema.org/";
    this.type = "TouristAttraction";
};
TouristAttraction = stjs.extend(TouristAttraction, Place, [], null, {photo: "ImageObject", address: "PostalAddress", openingHoursSpecification: "OpeningHoursSpecification", containedInPlace: "Place", reviews: "Review", aggregateRating: "AggregateRating", photos: "Photograph", hasMap: "SchemaMap", additionalProperty: "PropertyValue", events: "SchemaEvent", specialOpeningHoursSpecification: "OpeningHoursSpecification", amenityFeature: "LocationFeatureSpecification", logo: "ImageObject", geo: "GeoCoordinates", review: "Review", event: "SchemaEvent", containsPlace: "Place", containedIn: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/LandmarksOrHistoricalBuildings
 *  An historical landmark or building.
 * 
 *  @author schema.org
 *  @class LandmarksOrHistoricalBuildings
 *  @module org.schema
 *  @extends Place
 */
var LandmarksOrHistoricalBuildings = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Place.call(this);
    this.context = "http://schema.org/";
    this.type = "LandmarksOrHistoricalBuildings";
};
LandmarksOrHistoricalBuildings = stjs.extend(LandmarksOrHistoricalBuildings, Place, [], null, {photo: "ImageObject", address: "PostalAddress", openingHoursSpecification: "OpeningHoursSpecification", containedInPlace: "Place", reviews: "Review", aggregateRating: "AggregateRating", photos: "Photograph", hasMap: "SchemaMap", additionalProperty: "PropertyValue", events: "SchemaEvent", specialOpeningHoursSpecification: "OpeningHoursSpecification", amenityFeature: "LocationFeatureSpecification", logo: "ImageObject", geo: "GeoCoordinates", review: "Review", event: "SchemaEvent", containsPlace: "Place", containedIn: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Accommodation
 *  An accommodation is a place that can accommodate human beings, e.g. a hotel room, a camping pitch, or a meeting room. Many accommodations are for overnight stays, but this is not a mandatory requirement.
 *  For more specific types of accommodations not defined in schema.org, one can use additionalType with external vocabularies.
 *  <br /><br />
 *  See also the <a href="/docs/hotels.html">dedicated document on the use of schema.org for marking up hotels and other forms of accommodations</a>.
 * 
 *  @author schema.org
 *  @class Accommodation
 *  @module org.schema
 *  @extends Place
 */
var Accommodation = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Place.call(this);
    this.context = "http://schema.org/";
    this.type = "Accommodation";
};
Accommodation = stjs.extend(Accommodation, Place, [], function(constructor, prototype) {
    /**
     *  Schema.org/floorSize
     *  The size of the accommodation, e.g. in square meter or squarefoot.
     *  Typical unit code(s): MTK for square meter, FTK for square foot, or YDK for square yard
     * 
     *  @property floorSize
     *  @type QuantitativeValue
     */
    prototype.floorSize = null;
    /**
     *  Schema.org/petsAllowed
     *  Indicates whether pets are allowed to enter the accommodation or lodging business. More detailed information can be put in a text value.
     * 
     *  @property petsAllowed
     *  @type Boolean
     */
    prototype.petsAllowed = null;
    /**
     *  Schema.org/amenityFeature
     *  An amenity feature (e.g. a characteristic or service) of the Accommodation. This generic property does not make a statement about whether the feature is included in an offer for the main accommodation or available at extra costs.
     * 
     *  @property amenityFeature
     *  @type LocationFeatureSpecification
     */
    prototype.amenityFeature = null;
    /**
     *  Schema.org/numberOfRooms
     *  The number of rooms (excluding bathrooms and closets) of the acccommodation or lodging business.
     *  Typical unit code(s): ROM for room or C62 for no unit. The type of room can be put in the unitText property of the QuantitativeValue.
     * 
     *  @property numberOfRooms
     *  @type Number
     */
    prototype.numberOfRooms = null;
    /**
     *  Schema.org/permittedUsage
     *  Indications regarding the permitted usage of the accommodation.
     * 
     *  @property permittedUsage
     *  @type Text
     */
    prototype.permittedUsage = null;
}, {floorSize: "QuantitativeValue", amenityFeature: "LocationFeatureSpecification", photo: "ImageObject", address: "PostalAddress", openingHoursSpecification: "OpeningHoursSpecification", containedInPlace: "Place", reviews: "Review", aggregateRating: "AggregateRating", photos: "Photograph", hasMap: "SchemaMap", additionalProperty: "PropertyValue", events: "SchemaEvent", specialOpeningHoursSpecification: "OpeningHoursSpecification", amenityFeature: "LocationFeatureSpecification", logo: "ImageObject", geo: "GeoCoordinates", review: "Review", event: "SchemaEvent", containsPlace: "Place", containedIn: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Landform
 *  A landform or physical feature.  Landform elements include mountains, plains, lakes, rivers, seascape and oceanic waterbody interface features such as bays, peninsulas, seas and so forth, including sub-aqueous terrain features such as submersed mountain ranges, volcanoes, and the great ocean basins.
 * 
 *  @author schema.org
 *  @class Landform
 *  @module org.schema
 *  @extends Place
 */
var Landform = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Place.call(this);
    this.context = "http://schema.org/";
    this.type = "Landform";
};
Landform = stjs.extend(Landform, Place, [], null, {photo: "ImageObject", address: "PostalAddress", openingHoursSpecification: "OpeningHoursSpecification", containedInPlace: "Place", reviews: "Review", aggregateRating: "AggregateRating", photos: "Photograph", hasMap: "SchemaMap", additionalProperty: "PropertyValue", events: "SchemaEvent", specialOpeningHoursSpecification: "OpeningHoursSpecification", amenityFeature: "LocationFeatureSpecification", logo: "ImageObject", geo: "GeoCoordinates", review: "Review", event: "SchemaEvent", containsPlace: "Place", containedIn: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Residence
 *  The place where a person lives.
 * 
 *  @author schema.org
 *  @class Residence
 *  @module org.schema
 *  @extends Place
 */
var Residence = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Place.call(this);
    this.context = "http://schema.org/";
    this.type = "Residence";
};
Residence = stjs.extend(Residence, Place, [], null, {photo: "ImageObject", address: "PostalAddress", openingHoursSpecification: "OpeningHoursSpecification", containedInPlace: "Place", reviews: "Review", aggregateRating: "AggregateRating", photos: "Photograph", hasMap: "SchemaMap", additionalProperty: "PropertyValue", events: "SchemaEvent", specialOpeningHoursSpecification: "OpeningHoursSpecification", amenityFeature: "LocationFeatureSpecification", logo: "ImageObject", geo: "GeoCoordinates", review: "Review", event: "SchemaEvent", containsPlace: "Place", containedIn: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/UpdateAction
 *  The act of managing by changing/editing the state of the object.
 * 
 *  @author schema.org
 *  @class UpdateAction
 *  @module org.schema
 *  @extends Action
 */
var UpdateAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Action.call(this);
    this.context = "http://schema.org/";
    this.type = "UpdateAction";
};
UpdateAction = stjs.extend(UpdateAction, Action, [], function(constructor, prototype) {
    /**
     *  Schema.org/collection
     *  A sub property of object. The collection target of the action.
     * 
     *  @property collection
     *  @type Thing
     */
    prototype.collection = null;
    /**
     *  Schema.org/targetCollection
     *  A sub property of object. The collection target of the action.
     * 
     *  @property targetCollection
     *  @type Thing
     */
    prototype.targetCollection = null;
}, {collection: "Thing", targetCollection: "Thing", result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/TradeAction
 *  The act of participating in an exchange of goods and services for monetary compensation. An agent trades an object, product or service with a participant in exchange for a one time or periodic payment.
 * 
 *  @author schema.org
 *  @class TradeAction
 *  @module org.schema
 *  @extends Action
 */
var TradeAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Action.call(this);
    this.context = "http://schema.org/";
    this.type = "TradeAction";
};
TradeAction = stjs.extend(TradeAction, Action, [], function(constructor, prototype) {
    /**
     *  Schema.org/priceSpecification
     *  One or more detailed price specifications, indicating the unit price and delivery or payment charges.
     * 
     *  @property priceSpecification
     *  @type PriceSpecification
     */
    prototype.priceSpecification = null;
    /**
     *  Schema.org/price
     *  The offer price of a product, or of a price component when attached to PriceSpecification and its subtypes.\n\nUsage guidelines:\n\n* Use the [[priceCurrency]] property (with [ISO 4217 codes](http://en.wikipedia.org/wiki/ISO_4217#Active_codes) e.g. "USD") instead of
     *  including [ambiguous symbols](http://en.wikipedia.org/wiki/Dollar_sign#Currencies_that_use_the_dollar_or_peso_sign) such as '

var decls = "";

for (var j = 0; j < results.length; j++)
	for (var i = 0; i < results[j].body.length; i++)
		if (results[j].body[i].declarations != null)
			decls += "\nglobal." + results[j].body[i].declarations[0].id.name + " = " + results[j].body[i].declarations[0].id.name;

eval(decls);

global.forge = forge;
global.FormData = FormData;
global.antlr4 = antlr4;
global.pemJwk = pemJwk;
global.stjs = stjs;
global.base64 = base64;
global.jsonld = require('jsonld');
global.UUID = require('pure-uuid'); in the value.\n* Use '.' (Unicode 'FULL STOP' (U+002E)) rather than ',' to indicate a decimal point. Avoid using these symbols as a readability separator.\n* Note that both [RDFa](http://www.w3.org/TR/xhtml-rdfa-primer/#using-the-content-attribute) and Microdata syntax allow the use of a "content=" attribute for publishing simple machine-readable values alongside more human-friendly formatting.\n* Use values from 0123456789 (Unicode 'DIGIT ZERO' (U+0030) to 'DIGIT NINE' (U+0039)) rather than superficially similiar Unicode symbols.
     * 
     *  @property price
     *  @type Number
     */
    prototype.price = null;
}, {priceSpecification: "PriceSpecification", result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/TransferAction
 *  The act of transferring/moving (abstract or concrete) animate or inanimate objects from one place to another.
 * 
 *  @author schema.org
 *  @class TransferAction
 *  @module org.schema
 *  @extends Action
 */
var TransferAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Action.call(this);
    this.context = "http://schema.org/";
    this.type = "TransferAction";
};
TransferAction = stjs.extend(TransferAction, Action, [], function(constructor, prototype) {
    /**
     *  Schema.org/toLocation
     *  A sub property of location. The final location of the object or the agent after the action.
     * 
     *  @property toLocation
     *  @type Place
     */
    prototype.toLocation = null;
    /**
     *  Schema.org/fromLocation
     *  A sub property of location. The original location of the object or the agent before the action.
     * 
     *  @property fromLocation
     *  @type Place
     */
    prototype.fromLocation = null;
}, {toLocation: "Place", fromLocation: "Place", result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/MoveAction
 *  The act of an agent relocating to a place.\n\nRelated actions:\n\n* [[TransferAction]]: Unlike TransferAction, the subject of the move is a living Person or Organization rather than an inanimate object.
 * 
 *  @author schema.org
 *  @class MoveAction
 *  @module org.schema
 *  @extends Action
 */
var MoveAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Action.call(this);
    this.context = "http://schema.org/";
    this.type = "MoveAction";
};
MoveAction = stjs.extend(MoveAction, Action, [], function(constructor, prototype) {
    /**
     *  Schema.org/toLocation
     *  A sub property of location. The final location of the object or the agent after the action.
     * 
     *  @property toLocation
     *  @type Place
     */
    prototype.toLocation = null;
    /**
     *  Schema.org/fromLocation
     *  A sub property of location. The original location of the object or the agent before the action.
     * 
     *  @property fromLocation
     *  @type Place
     */
    prototype.fromLocation = null;
}, {toLocation: "Place", fromLocation: "Place", result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/InteractAction
 *  The act of interacting with another person or organization.
 * 
 *  @author schema.org
 *  @class InteractAction
 *  @module org.schema
 *  @extends Action
 */
var InteractAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Action.call(this);
    this.context = "http://schema.org/";
    this.type = "InteractAction";
};
InteractAction = stjs.extend(InteractAction, Action, [], null, {result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/PlayAction
 *  The act of playing/exercising/training/performing for enjoyment, leisure, recreation, Competition or exercise.\n\nRelated actions:\n\n* [[ListenAction]]: Unlike ListenAction (which is under ConsumeAction), PlayAction refers to performing for an audience or at an event, rather than consuming music.\n* [[WatchAction]]: Unlike WatchAction (which is under ConsumeAction), PlayAction refers to showing/displaying for an audience or at an event, rather than consuming visual content.
 * 
 *  @author schema.org
 *  @class PlayAction
 *  @module org.schema
 *  @extends Action
 */
var PlayAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Action.call(this);
    this.context = "http://schema.org/";
    this.type = "PlayAction";
};
PlayAction = stjs.extend(PlayAction, Action, [], function(constructor, prototype) {
    /**
     *  Schema.org/audience
     *  An intended audience, i.e. a group for whom something was created.
     * 
     *  @property audience
     *  @type Audience
     */
    prototype.audience = null;
    /**
     *  Schema.org/event
     *  Upcoming or past event associated with this place, organization, or action.
     * 
     *  @property event
     *  @type SchemaEvent
     */
    prototype.event = null;
}, {audience: "Audience", event: "SchemaEvent", result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/OrganizeAction
 *  The act of manipulating/administering/supervising/controlling one or more objects.
 * 
 *  @author schema.org
 *  @class OrganizeAction
 *  @module org.schema
 *  @extends Action
 */
var OrganizeAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Action.call(this);
    this.context = "http://schema.org/";
    this.type = "OrganizeAction";
};
OrganizeAction = stjs.extend(OrganizeAction, Action, [], null, {result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/ControlAction
 *  An agent controls a device or application.
 * 
 *  @author schema.org
 *  @class ControlAction
 *  @module org.schema
 *  @extends Action
 */
var ControlAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Action.call(this);
    this.context = "http://schema.org/";
    this.type = "ControlAction";
};
ControlAction = stjs.extend(ControlAction, Action, [], null, {result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/AssessAction
 *  The act of forming one's opinion, reaction or sentiment.
 * 
 *  @author schema.org
 *  @class AssessAction
 *  @module org.schema
 *  @extends Action
 */
var AssessAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Action.call(this);
    this.context = "http://schema.org/";
    this.type = "AssessAction";
};
AssessAction = stjs.extend(AssessAction, Action, [], null, {result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/ConsumeAction
 *  The act of ingesting information/resources/food.
 * 
 *  @author schema.org
 *  @class ConsumeAction
 *  @module org.schema
 *  @extends Action
 */
var ConsumeAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Action.call(this);
    this.context = "http://schema.org/";
    this.type = "ConsumeAction";
};
ConsumeAction = stjs.extend(ConsumeAction, Action, [], function(constructor, prototype) {
    /**
     *  Schema.org/expectsAcceptanceOf
     *  An Offer which must be accepted before the user can perform the Action. For example, the user may need to buy a movie before being able to watch it.
     * 
     *  @property expectsAcceptanceOf
     *  @type Offer
     */
    prototype.expectsAcceptanceOf = null;
}, {expectsAcceptanceOf: "Offer", result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/SearchAction
 *  The act of searching for an object.\n\nRelated actions:\n\n* [[FindAction]]: SearchAction generally leads to a FindAction, but not necessarily.
 * 
 *  @author schema.org
 *  @class SearchAction
 *  @module org.schema
 *  @extends Action
 */
var SearchAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Action.call(this);
    this.context = "http://schema.org/";
    this.type = "SearchAction";
};
SearchAction = stjs.extend(SearchAction, Action, [], function(constructor, prototype) {
    /**
     *  Schema.org/query
     *  A sub property of instrument. The query used on this action.
     * 
     *  @property query
     *  @type Text
     */
    prototype.query = null;
}, {result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/CreateAction
 *  The act of deliberately creating/producing/generating/building a result out of the agent.
 * 
 *  @author schema.org
 *  @class CreateAction
 *  @module org.schema
 *  @extends Action
 */
var CreateAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Action.call(this);
    this.context = "http://schema.org/";
    this.type = "CreateAction";
};
CreateAction = stjs.extend(CreateAction, Action, [], null, {result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/AchieveAction
 *  The act of accomplishing something via previous efforts. It is an instantaneous action rather than an ongoing process.
 * 
 *  @author schema.org
 *  @class AchieveAction
 *  @module org.schema
 *  @extends Action
 */
var AchieveAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Action.call(this);
    this.context = "http://schema.org/";
    this.type = "AchieveAction";
};
AchieveAction = stjs.extend(AchieveAction, Action, [], null, {result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/FindAction
 *  The act of finding an object.\n\nRelated actions:\n\n* [[SearchAction]]: FindAction is generally lead by a SearchAction, but not necessarily.
 * 
 *  @author schema.org
 *  @class FindAction
 *  @module org.schema
 *  @extends Action
 */
var FindAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Action.call(this);
    this.context = "http://schema.org/";
    this.type = "FindAction";
};
FindAction = stjs.extend(FindAction, Action, [], null, {result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/SportsOrganization
 *  Represents the collection of all sports organizations, including sports teams, governing bodies, and sports associations.
 * 
 *  @author schema.org
 *  @class SportsOrganization
 *  @module org.schema
 *  @extends Organization
 */
var SportsOrganization = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Organization.call(this);
    this.context = "http://schema.org/";
    this.type = "SportsOrganization";
};
SportsOrganization = stjs.extend(SportsOrganization, Organization, [], function(constructor, prototype) {
    /**
     *  Schema.org/sport
     *  A type of sport (e.g. Baseball).
     * 
     *  @property sport
     *  @type Text
     */
    prototype.sport = null;
}, {serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/PerformingGroup
 *  A performance group, such as a band, an orchestra, or a circus.
 * 
 *  @author schema.org
 *  @class PerformingGroup
 *  @module org.schema
 *  @extends Organization
 */
var PerformingGroup = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Organization.call(this);
    this.context = "http://schema.org/";
    this.type = "PerformingGroup";
};
PerformingGroup = stjs.extend(PerformingGroup, Organization, [], null, {serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/GovernmentOrganization
 *  A governmental organization or agency.
 * 
 *  @author schema.org
 *  @class GovernmentOrganization
 *  @module org.schema
 *  @extends Organization
 */
var GovernmentOrganization = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Organization.call(this);
    this.context = "http://schema.org/";
    this.type = "GovernmentOrganization";
};
GovernmentOrganization = stjs.extend(GovernmentOrganization, Organization, [], null, {serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Corporation
 *  Organization: A business corporation.
 * 
 *  @author schema.org
 *  @class Corporation
 *  @module org.schema
 *  @extends Organization
 */
var Corporation = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Organization.call(this);
    this.context = "http://schema.org/";
    this.type = "Corporation";
};
Corporation = stjs.extend(Corporation, Organization, [], function(constructor, prototype) {
    /**
     *  Schema.org/tickerSymbol
     *  The exchange traded instrument associated with a Corporation object. The tickerSymbol is expressed as an exchange and an instrument name separated by a space character. For the exchange component of the tickerSymbol attribute, we reccommend using the controlled vocaulary of Market Identifier Codes (MIC) specified in ISO15022.
     * 
     *  @property tickerSymbol
     *  @type Text
     */
    prototype.tickerSymbol = null;
}, {serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Airline
 *  An organization that provides flights for passengers.
 * 
 *  @author schema.org
 *  @class Airline
 *  @module org.schema
 *  @extends Organization
 */
var Airline = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Organization.call(this);
    this.context = "http://schema.org/";
    this.type = "Airline";
};
Airline = stjs.extend(Airline, Organization, [], function(constructor, prototype) {
    /**
     *  Schema.org/iataCode
     *  IATA identifier for an airline or airport.
     * 
     *  @property iataCode
     *  @type Text
     */
    prototype.iataCode = null;
    /**
     *  Schema.org/boardingPolicy
     *  The type of boarding policy used by the airline (e.g. zone-based or group-based).
     * 
     *  @property boardingPolicy
     *  @type BoardingPolicyType
     */
    prototype.boardingPolicy = null;
}, {boardingPolicy: "BoardingPolicyType", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/EducationalOrganization
 *  An educational organization.
 * 
 *  @author schema.org
 *  @class EducationalOrganization
 *  @module org.schema
 *  @extends Organization
 */
var EducationalOrganization = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Organization.call(this);
    this.context = "http://schema.org/";
    this.type = "EducationalOrganization";
};
EducationalOrganization = stjs.extend(EducationalOrganization, Organization, [], function(constructor, prototype) {
    /**
     *  Schema.org/alumni
     *  Alumni of an organization.
     * 
     *  @property alumni
     *  @type Person
     */
    prototype.alumni = null;
}, {alumni: "Person", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/MedicalOrganization
 *  A medical organization (physical or not), such as hospital, institution or clinic.
 * 
 *  @author schema.org
 *  @class MedicalOrganization
 *  @module org.schema
 *  @extends Organization
 */
var MedicalOrganization = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Organization.call(this);
    this.context = "http://schema.org/";
    this.type = "MedicalOrganization";
};
MedicalOrganization = stjs.extend(MedicalOrganization, Organization, [], null, {serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/NGO
 *  Organization: Non-governmental Organization.
 * 
 *  @author schema.org
 *  @class NGO
 *  @module org.schema
 *  @extends Organization
 */
var NGO = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Organization.call(this);
    this.context = "http://schema.org/";
    this.type = "NGO";
};
NGO = stjs.extend(NGO, Organization, [], null, {serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/LocalBusiness
 *  A particular physical business or branch of an organization. Examples of LocalBusiness include a restaurant, a particular branch of a restaurant chain, a branch of a bank, a medical practice, a club, a bowling alley, etc.
 * 
 *  @author schema.org
 *  @class LocalBusiness
 *  @module org.schema
 *  @extends Organization
 */
var LocalBusiness = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Organization.call(this);
    this.context = "http://schema.org/";
    this.type = "LocalBusiness";
};
LocalBusiness = stjs.extend(LocalBusiness, Organization, [], function(constructor, prototype) {
    /**
     *  Schema.org/priceRange
     *  The price range of the business, for example ```$if (global.XMLHttpRequest === undefined)
	var XMLHttpRequest = require("xmlhttprequest").XMLHttpRequest;
else
	var XMLHttpRequest = global.XMLHttpRequest;

var request = require("request");
var isNodeJs = {};
require("text-encoding");
if (global.forge === undefined)
	if (typeof __webpack_require__ === 'function')
		var forge = require("forge");
	else
		var forge = require("node-forge");
else
	var forge = global.forge;
var base64 = require('base64-arraybuffer');
var FormData = require('form-data');
var antlr4 = require('antlr4/index');
var pemJwk = require('pem-jwk');

var crypto = null;
if (crypto === undefined)
try {
  crypto = {subtle:require('crypto').webcrypto};
} catch (err) {
  crypto = {subtle:null};
}

if (global.window === undefined)
	var window = {
		crypto: crypto
	};
else
	var window = global.window;
if (global.Worker === undefined)
	var Worker = null;
else
	var Worker = global.Worker;
if (global.document === undefined)
	var document = {};
else
	var document = global.document;
if (global.view === undefined)
	var view = {};
else
	var view = global.view;
if (global.localStorage === undefined)
	var localStorage = {};
else
	var localStorage = global.localStorage;

var esprima = require('esprima');
var results = [];

``.
     * 
     *  @property priceRange
     *  @type Text
     */
    prototype.priceRange = null;
    /**
     *  Schema.org/branchOf
     *  The larger organization that this local business is a branch of, if any. Not to be confused with (anatomical)[[branch]].
     * 
     *  @property branchOf
     *  @type Organization
     */
    prototype.branchOf = null;
    /**
     *  Schema.org/paymentAccepted
     *  Cash, credit card, etc.
     * 
     *  @property paymentAccepted
     *  @type Text
     */
    prototype.paymentAccepted = null;
    /**
     *  Schema.org/openingHours
     *  The general opening hours for a business. Opening hours can be specified as a weekly time range, starting with days, then times per day. Multiple days can be listed with commas ',' separating each day. Day or time ranges are specified using a hyphen '-'.\n\n* Days are specified using the following two-letter combinations: ```Mo```, ```Tu```, ```We```, ```Th```, ```Fr```, ```Sa```, ```Su```.\n* Times are specified using 24:00 time. For example, 3pm is specified as ```15:00```. \n* Here is an example: <code>&lt;time itemprop="openingHours" datetime=&quot;Tu,Th 16:00-20:00&quot;&gt;Tuesdays and Thursdays 4-8pm&lt;/time&gt;</code>.\n* If a business is open 7 days a week, then it can be specified as <code>&lt;time itemprop=&quot;openingHours&quot; datetime=&quot;Mo-Su&quot;&gt;Monday through Sunday, all day&lt;/time&gt;</code>.
     * 
     *  @property openingHours
     *  @type Text
     */
    prototype.openingHours = null;
    /**
     *  Schema.org/currenciesAccepted
     *  The currency accepted (in [ISO 4217 currency format](http://en.wikipedia.org/wiki/ISO_4217)).
     * 
     *  @property currenciesAccepted
     *  @type Text
     */
    prototype.currenciesAccepted = null;
}, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/JobPosting
 *  A listing that describes a job opening in a certain organization.
 * 
 *  @author schema.org
 *  @class JobPosting
 *  @module org.schema
 *  @extends Intangible
 */
var JobPosting = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Intangible.call(this);
    this.context = "http://schema.org/";
    this.type = "JobPosting";
};
JobPosting = stjs.extend(JobPosting, Intangible, [], function(constructor, prototype) {
    /**
     *  Schema.org/benefits
     *  Description of benefits associated with the job.
     * 
     *  @property benefits
     *  @type Text
     */
    prototype.benefits = null;
    /**
     *  Schema.org/qualifications
     *  Specific qualifications required for this role.
     * 
     *  @property qualifications
     *  @type Text
     */
    prototype.qualifications = null;
    /**
     *  Schema.org/incentiveCompensation
     *  Description of bonus and commission compensation aspects of the job.
     * 
     *  @property incentiveCompensation
     *  @type Text
     */
    prototype.incentiveCompensation = null;
    /**
     *  Schema.org/workHours
     *  The typical working hours for this job (e.g. 1st shift, night shift, 8am-5pm).
     * 
     *  @property workHours
     *  @type Text
     */
    prototype.workHours = null;
    /**
     *  Schema.org/salaryCurrency
     *  The currency (coded using [ISO 4217](http://en.wikipedia.org/wiki/ISO_4217) ) used for the main salary information in this job posting or for this employee.
     * 
     *  @property salaryCurrency
     *  @type Text
     */
    prototype.salaryCurrency = null;
    /**
     *  Schema.org/jobBenefits
     *  Description of benefits associated with the job.
     * 
     *  @property jobBenefits
     *  @type Text
     */
    prototype.jobBenefits = null;
    /**
     *  Schema.org/datePosted
     *  Publication date for the job posting.
     * 
     *  @property datePosted
     *  @type Date
     */
    prototype.datePosted = null;
    /**
     *  Schema.org/skills
     *  Skills required to fulfill this role.
     * 
     *  @property skills
     *  @type Text
     */
    prototype.skills = null;
    /**
     *  Schema.org/incentives
     *  Description of bonus and commission compensation aspects of the job.
     * 
     *  @property incentives
     *  @type Text
     */
    prototype.incentives = null;
    /**
     *  Schema.org/educationRequirements
     *  Educational background needed for the position.
     * 
     *  @property educationRequirements
     *  @type Text
     */
    prototype.educationRequirements = null;
    /**
     *  Schema.org/responsibilities
     *  Responsibilities associated with this role.
     * 
     *  @property responsibilities
     *  @type Text
     */
    prototype.responsibilities = null;
    /**
     *  Schema.org/baseSalary
     *  The base salary of the job or of an employee in an EmployeeRole.
     * 
     *  @property baseSalary
     *  @type MonetaryAmount
     */
    prototype.baseSalary = null;
    /**
     *  Schema.org/validThrough
     *  The date after when the item is not valid. For example the end of an offer, salary period, or a period of opening hours.
     * 
     *  @property validThrough
     *  @type DateTime
     */
    prototype.validThrough = null;
    /**
     *  Schema.org/hiringOrganization
     *  Organization offering the job position.
     * 
     *  @property hiringOrganization
     *  @type Organization
     */
    prototype.hiringOrganization = null;
    /**
     *  Schema.org/specialCommitments
     *  Any special commitments associated with this job posting. Valid entries include VeteranCommit, MilitarySpouseCommit, etc.
     * 
     *  @property specialCommitments
     *  @type Text
     */
    prototype.specialCommitments = null;
    /**
     *  Schema.org/occupationalCategory
     *  Category or categories describing the job. Use BLS O*NET-SOC taxonomy: http://www.onetcenter.org/taxonomy.html. Ideally includes textual label and formal code, with the property repeated for each applicable value.
     * 
     *  @property occupationalCategory
     *  @type Text
     */
    prototype.occupationalCategory = null;
    /**
     *  Schema.org/experienceRequirements
     *  Description of skills and experience needed for the position.
     * 
     *  @property experienceRequirements
     *  @type Text
     */
    prototype.experienceRequirements = null;
    /**
     *  Schema.org/employmentType
     *  Type of employment (e.g. full-time, part-time, contract, temporary, seasonal, internship).
     * 
     *  @property employmentType
     *  @type Text
     */
    prototype.employmentType = null;
    /**
     *  Schema.org/jobLocation
     *  A (typically single) geographic location associated with the job position.
     * 
     *  @property jobLocation
     *  @type Place
     */
    prototype.jobLocation = null;
    /**
     *  Schema.org/title
     *  The title of the job.
     * 
     *  @property title
     *  @type Text
     */
    prototype.title = null;
    /**
     *  Schema.org/industry
     *  The industry associated with the job position.
     * 
     *  @property industry
     *  @type Text
     */
    prototype.industry = null;
}, {baseSalary: "MonetaryAmount", hiringOrganization: "Organization", jobLocation: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Demand
 *  A demand entity represents the public, not necessarily binding, not necessarily exclusive, announcement by an organization or person to seek a certain type of goods or services. For describing demand using this type, the very same properties used for Offer apply.
 * 
 *  @author schema.org
 *  @class Demand
 *  @module org.schema
 *  @extends Intangible
 */
var Demand = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Intangible.call(this);
    this.context = "http://schema.org/";
    this.type = "Demand";
};
Demand = stjs.extend(Demand, Intangible, [], function(constructor, prototype) {
    /**
     *  Schema.org/sku
     *  The Stock Keeping Unit (SKU), i.e. a merchant-specific identifier for a product or service, or the product to which the offer refers.
     * 
     *  @property sku
     *  @type Text
     */
    prototype.sku = null;
    /**
     *  Schema.org/availabilityStarts
     *  The beginning of the availability of the product or service included in the offer.
     * 
     *  @property availabilityStarts
     *  @type DateTime
     */
    prototype.availabilityStarts = null;
    /**
     *  Schema.org/availableDeliveryMethod
     *  The delivery method(s) available for this offer.
     * 
     *  @property availableDeliveryMethod
     *  @type DeliveryMethod
     */
    prototype.availableDeliveryMethod = null;
    /**
     *  Schema.org/mpn
     *  The Manufacturer Part Number (MPN) of the product, or the product to which the offer refers.
     * 
     *  @property mpn
     *  @type Text
     */
    prototype.mpn = null;
    /**
     *  Schema.org/serialNumber
     *  The serial number or any alphanumeric identifier of a particular product. When attached to an offer, it is a shortcut for the serial number of the product included in the offer.
     * 
     *  @property serialNumber
     *  @type Text
     */
    prototype.serialNumber = null;
    /**
     *  Schema.org/ineligibleRegion
     *  The ISO 3166-1 (ISO 3166-1 alpha-2) or ISO 3166-2 code, the place, or the GeoShape for the geo-political region(s) for which the offer or delivery charge specification is not valid, e.g. a region where the transaction is not allowed.\n\nSee also [[eligibleRegion]].
     * 
     *  @property ineligibleRegion
     *  @type GeoShape
     */
    prototype.ineligibleRegion = null;
    /**
     *  Schema.org/gtin8
     *  The [GTIN-8](http://apps.gs1.org/GDD/glossary/Pages/GTIN-8.aspx) code of the product, or the product to which the offer refers. This code is also known as EAN/UCC-8 or 8-digit EAN. See [GS1 GTIN Summary](http://www.gs1.org/barcodes/technical/idkeys/gtin) for more details.
     * 
     *  @property gtin8
     *  @type Text
     */
    prototype.gtin8 = null;
    /**
     *  Schema.org/availability
     *  The availability of this item&#x2014;for example In stock, Out of stock, Pre-order, etc.
     * 
     *  @property availability
     *  @type ItemAvailability
     */
    prototype.availability = null;
    /**
     *  Schema.org/priceSpecification
     *  One or more detailed price specifications, indicating the unit price and delivery or payment charges.
     * 
     *  @property priceSpecification
     *  @type PriceSpecification
     */
    prototype.priceSpecification = null;
    /**
     *  Schema.org/inventoryLevel
     *  The current approximate inventory level for the item or items.
     * 
     *  @property inventoryLevel
     *  @type QuantitativeValue
     */
    prototype.inventoryLevel = null;
    /**
     *  Schema.org/eligibleTransactionVolume
     *  The transaction volume, in a monetary unit, for which the offer or price specification is valid, e.g. for indicating a minimal purchasing volume, to express free shipping above a certain order volume, or to limit the acceptance of credit cards to purchases to a certain minimal amount.
     * 
     *  @property eligibleTransactionVolume
     *  @type PriceSpecification
     */
    prototype.eligibleTransactionVolume = null;
    /**
     *  Schema.org/availableAtOrFrom
     *  The place(s) from which the offer can be obtained (e.g. store locations).
     * 
     *  @property availableAtOrFrom
     *  @type Place
     */
    prototype.availableAtOrFrom = null;
    /**
     *  Schema.org/warranty
     *  The warranty promise(s) included in the offer.
     * 
     *  @property warranty
     *  @type WarrantyPromise
     */
    prototype.warranty = null;
    /**
     *  Schema.org/includesObject
     *  This links to a node or nodes indicating the exact quantity of the products included in the offer.
     * 
     *  @property includesObject
     *  @type TypeAndQuantityNode
     */
    prototype.includesObject = null;
    /**
     *  Schema.org/eligibleQuantity
     *  The interval and unit of measurement of ordering quantities for which the offer or price specification is valid. This allows e.g. specifying that a certain freight charge is valid only for a certain quantity.
     * 
     *  @property eligibleQuantity
     *  @type QuantitativeValue
     */
    prototype.eligibleQuantity = null;
    /**
     *  Schema.org/validFrom
     *  The date when the item becomes valid.
     * 
     *  @property validFrom
     *  @type DateTime
     */
    prototype.validFrom = null;
    /**
     *  Schema.org/validThrough
     *  The date after when the item is not valid. For example the end of an offer, salary period, or a period of opening hours.
     * 
     *  @property validThrough
     *  @type DateTime
     */
    prototype.validThrough = null;
    /**
     *  Schema.org/gtin14
     *  The [GTIN-14](http://apps.gs1.org/GDD/glossary/Pages/GTIN-14.aspx) code of the product, or the product to which the offer refers. See [GS1 GTIN Summary](http://www.gs1.org/barcodes/technical/idkeys/gtin) for more details.
     * 
     *  @property gtin14
     *  @type Text
     */
    prototype.gtin14 = null;
    /**
     *  Schema.org/gtin13
     *  The [GTIN-13](http://apps.gs1.org/GDD/glossary/Pages/GTIN-13.aspx) code of the product, or the product to which the offer refers. This is equivalent to 13-digit ISBN codes and EAN UCC-13. Former 12-digit UPC codes can be converted into a GTIN-13 code by simply adding a preceeding zero. See [GS1 GTIN Summary](http://www.gs1.org/barcodes/technical/idkeys/gtin) for more details.
     * 
     *  @property gtin13
     *  @type Text
     */
    prototype.gtin13 = null;
    /**
     *  Schema.org/gtin12
     *  The [GTIN-12](http://apps.gs1.org/GDD/glossary/Pages/GTIN-12.aspx) code of the product, or the product to which the offer refers. The GTIN-12 is the 12-digit GS1 Identification Key composed of a U.P.C. Company Prefix, Item Reference, and Check Digit used to identify trade items. See [GS1 GTIN Summary](http://www.gs1.org/barcodes/technical/idkeys/gtin) for more details.
     * 
     *  @property gtin12
     *  @type Text
     */
    prototype.gtin12 = null;
    /**
     *  Schema.org/seller
     *  An entity which offers (sells / leases / lends / loans) the services / goods.  A seller may also be a provider.
     * 
     *  @property seller
     *  @type Person
     */
    prototype.seller = null;
    /**
     *  Schema.org/deliveryLeadTime
     *  The typical delay between the receipt of the order and the goods either leaving the warehouse or being prepared for pickup, in case the delivery method is on site pickup.
     * 
     *  @property deliveryLeadTime
     *  @type QuantitativeValue
     */
    prototype.deliveryLeadTime = null;
    /**
     *  Schema.org/availabilityEnds
     *  The end of the availability of the product or service included in the offer.
     * 
     *  @property availabilityEnds
     *  @type DateTime
     */
    prototype.availabilityEnds = null;
    /**
     *  Schema.org/eligibleCustomerType
     *  The type(s) of customers for which the given offer is valid.
     * 
     *  @property eligibleCustomerType
     *  @type BusinessEntityType
     */
    prototype.eligibleCustomerType = null;
    /**
     *  Schema.org/itemCondition
     *  A predefined value from OfferItemCondition or a textual description of the condition of the product or service, or the products or services included in the offer.
     * 
     *  @property itemCondition
     *  @type OfferItemCondition
     */
    prototype.itemCondition = null;
    /**
     *  Schema.org/itemOffered
     *  The item being offered.
     * 
     *  @property itemOffered
     *  @type Service
     */
    prototype.itemOffered = null;
    /**
     *  Schema.org/eligibleDuration
     *  The duration for which the given offer is valid.
     * 
     *  @property eligibleDuration
     *  @type QuantitativeValue
     */
    prototype.eligibleDuration = null;
    /**
     *  Schema.org/acceptedPaymentMethod
     *  The payment method(s) accepted by seller for this offer.
     * 
     *  @property acceptedPaymentMethod
     *  @type LoanOrCredit
     */
    prototype.acceptedPaymentMethod = null;
    /**
     *  Schema.org/areaServed
     *  The geographic area where a service or offered item is provided.
     * 
     *  @property areaServed
     *  @type Place
     */
    prototype.areaServed = null;
    /**
     *  Schema.org/businessFunction
     *  The business function (e.g. sell, lease, repair, dispose) of the offer or component of a bundle (TypeAndQuantityNode). The default is http://purl.org/goodrelations/v1#Sell.
     * 
     *  @property businessFunction
     *  @type BusinessFunction
     */
    prototype.businessFunction = null;
    /**
     *  Schema.org/eligibleRegion
     *  The ISO 3166-1 (ISO 3166-1 alpha-2) or ISO 3166-2 code, the place, or the GeoShape for the geo-political region(s) for which the offer or delivery charge specification is valid.\n\nSee also [[ineligibleRegion]].
     * 
     *  @property eligibleRegion
     *  @type Text
     */
    prototype.eligibleRegion = null;
    /**
     *  Schema.org/advanceBookingRequirement
     *  The amount of time that is required between accepting the offer and the actual usage of the resource or service.
     * 
     *  @property advanceBookingRequirement
     *  @type QuantitativeValue
     */
    prototype.advanceBookingRequirement = null;
}, {availableDeliveryMethod: "DeliveryMethod", ineligibleRegion: "GeoShape", availability: "ItemAvailability", priceSpecification: "PriceSpecification", inventoryLevel: "QuantitativeValue", eligibleTransactionVolume: "PriceSpecification", availableAtOrFrom: "Place", warranty: "WarrantyPromise", includesObject: "TypeAndQuantityNode", eligibleQuantity: "QuantitativeValue", seller: "Person", deliveryLeadTime: "QuantitativeValue", eligibleCustomerType: "BusinessEntityType", itemCondition: "OfferItemCondition", itemOffered: "Service", eligibleDuration: "QuantitativeValue", acceptedPaymentMethod: "LoanOrCredit", areaServed: "Place", businessFunction: "BusinessFunction", advanceBookingRequirement: "QuantitativeValue", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/BedDetails
 *  An entity holding detailed information about the available bed types, e.g. the quantity of twin beds for a hotel room. For the single case of just one bed of a certain type, you can use bed directly with a text. See also [[BedType]] (under development).
 * 
 *  @author schema.org
 *  @class BedDetails
 *  @module org.schema
 *  @extends Intangible
 */
var BedDetails = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Intangible.call(this);
    this.context = "http://schema.org/";
    this.type = "BedDetails";
};
BedDetails = stjs.extend(BedDetails, Intangible, [], function(constructor, prototype) {
    /**
     *  Schema.org/numberOfBeds
     *  The quantity of the given bed type available in the HotelRoom, Suite, House, or Apartment.
     * 
     *  @property numberOfBeds
     *  @type Number
     */
    prototype.numberOfBeds = null;
    /**
     *  Schema.org/typeOfBed
     *  The type of bed to which the BedDetail refers, i.e. the type of bed available in the quantity indicated by quantity.
     * 
     *  @property typeOfBed
     *  @type Text
     */
    prototype.typeOfBed = null;
}, {identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Language
 *  Natural languages such as Spanish, Tamil, Hindi, English, etc. Formal language code tags expressed in [BCP 47](https://en.wikipedia.org/wiki/IETF_language_tag) can be used via the [[alternateName]] property. The Language type previously also covered programming languages such as Scheme and Lisp, which are now best represented using [[ComputerLanguage]].
 * 
 *  @author schema.org
 *  @class Language
 *  @module org.schema
 *  @extends Intangible
 */
var Language = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Intangible.call(this);
    this.context = "http://schema.org/";
    this.type = "Language";
};
Language = stjs.extend(Language, Intangible, [], null, {identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Quantity
 *  Quantities such as distance, time, mass, weight, etc. Particular instances of say Mass are entities like '3 Kg' or '4 milligrams'.
 * 
 *  @author schema.org
 *  @class Quantity
 *  @module org.schema
 *  @extends Intangible
 */
var Quantity = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Intangible.call(this);
    this.context = "http://schema.org/";
    this.type = "Quantity";
};
Quantity = stjs.extend(Quantity, Intangible, [], null, {identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/DigitalDocumentPermission
 *  A permission for a particular person or group to access a particular file.
 * 
 *  @author schema.org
 *  @class DigitalDocumentPermission
 *  @module org.schema
 *  @extends Intangible
 */
var DigitalDocumentPermission = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Intangible.call(this);
    this.context = "http://schema.org/";
    this.type = "DigitalDocumentPermission";
};
DigitalDocumentPermission = stjs.extend(DigitalDocumentPermission, Intangible, [], function(constructor, prototype) {
    /**
     *  Schema.org/grantee
     *  The person, organization, contact point, or audience that has been granted this permission.
     * 
     *  @property grantee
     *  @type ContactPoint
     */
    prototype.grantee = null;
    /**
     *  Schema.org/permissionType
     *  The type of permission granted the person, organization, or audience.
     * 
     *  @property permissionType
     *  @type DigitalDocumentPermissionType
     */
    prototype.permissionType = null;
}, {grantee: "ContactPoint", permissionType: "DigitalDocumentPermissionType", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/OrderItem
 *  An order item is a line of an order. It includes the quantity and shipping details of a bought offer.
 * 
 *  @author schema.org
 *  @class OrderItem
 *  @module org.schema
 *  @extends Intangible
 */
var OrderItem = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Intangible.call(this);
    this.context = "http://schema.org/";
    this.type = "OrderItem";
};
OrderItem = stjs.extend(OrderItem, Intangible, [], function(constructor, prototype) {
    /**
     *  Schema.org/orderItemStatus
     *  The current status of the order item.
     * 
     *  @property orderItemStatus
     *  @type OrderStatus
     */
    prototype.orderItemStatus = null;
    /**
     *  Schema.org/orderQuantity
     *  The number of the item ordered. If the property is not set, assume the quantity is one.
     * 
     *  @property orderQuantity
     *  @type Number
     */
    prototype.orderQuantity = null;
    /**
     *  Schema.org/orderedItem
     *  The item ordered.
     * 
     *  @property orderedItem
     *  @type Product
     */
    prototype.orderedItem = null;
    /**
     *  Schema.org/orderDelivery
     *  The delivery of the parcel related to this order or order item.
     * 
     *  @property orderDelivery
     *  @type ParcelDelivery
     */
    prototype.orderDelivery = null;
    /**
     *  Schema.org/orderItemNumber
     *  The identifier of the order item.
     * 
     *  @property orderItemNumber
     *  @type Text
     */
    prototype.orderItemNumber = null;
}, {orderItemStatus: "OrderStatus", orderedItem: "Product", orderDelivery: "ParcelDelivery", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/EntryPoint
 *  An entry point, within some Web-based protocol.
 * 
 *  @author schema.org
 *  @class EntryPoint
 *  @module org.schema
 *  @extends Intangible
 */
var EntryPoint = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Intangible.call(this);
    this.context = "http://schema.org/";
    this.type = "EntryPoint";
};
EntryPoint = stjs.extend(EntryPoint, Intangible, [], function(constructor, prototype) {
    /**
     *  Schema.org/urlTemplate
     *  An url template (RFC6570) that will be used to construct the target of the execution of the action.
     * 
     *  @property urlTemplate
     *  @type Text
     */
    prototype.urlTemplate = null;
    /**
     *  Schema.org/actionApplication
     *  An application that can complete the request.
     * 
     *  @property actionApplication
     *  @type SoftwareApplication
     */
    prototype.actionApplication = null;
    /**
     *  Schema.org/application
     *  An application that can complete the request.
     * 
     *  @property application
     *  @type SoftwareApplication
     */
    prototype.application = null;
    /**
     *  Schema.org/actionPlatform
     *  The high level platform(s) where the Action can be performed for the given URL. To specify a specific application or operating system instance, use actionApplication.
     * 
     *  @property actionPlatform
     *  @type Text
     */
    prototype.actionPlatform = null;
    /**
     *  Schema.org/httpMethod
     *  An HTTP method that specifies the appropriate HTTP method for a request to an HTTP EntryPoint. Values are capitalized strings as used in HTTP.
     * 
     *  @property httpMethod
     *  @type Text
     */
    prototype.httpMethod = null;
    /**
     *  Schema.org/encodingType
     *  The supported encoding type(s) for an EntryPoint request.
     * 
     *  @property encodingType
     *  @type Text
     */
    prototype.encodingType = null;
    /**
     *  Schema.org/contentType
     *  The supported content type(s) for an EntryPoint response.
     * 
     *  @property contentType
     *  @type Text
     */
    prototype.contentType = null;
}, {actionApplication: "SoftwareApplication", application: "SoftwareApplication", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Invoice
 *  A statement of the money due for goods or services; a bill.
 * 
 *  @author schema.org
 *  @class Invoice
 *  @module org.schema
 *  @extends Intangible
 */
var Invoice = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Intangible.call(this);
    this.context = "http://schema.org/";
    this.type = "Invoice";
};
Invoice = stjs.extend(Invoice, Intangible, [], function(constructor, prototype) {
    /**
     *  Schema.org/provider
     *  The service provider, service operator, or service performer; the goods producer. Another party (a seller) may offer those services or goods on behalf of the provider. A provider may also serve as the seller.
     * 
     *  @property provider
     *  @type Person
     */
    prototype.provider = null;
    /**
     *  Schema.org/paymentDue
     *  The date that payment is due.
     * 
     *  @property paymentDue
     *  @type DateTime
     */
    prototype.paymentDue = null;
    /**
     *  Schema.org/billingPeriod
     *  The time interval used to compute the invoice.
     * 
     *  @property billingPeriod
     *  @type Duration
     */
    prototype.billingPeriod = null;
    /**
     *  Schema.org/confirmationNumber
     *  A number that confirms the given order or payment has been received.
     * 
     *  @property confirmationNumber
     *  @type Text
     */
    prototype.confirmationNumber = null;
    /**
     *  Schema.org/scheduledPaymentDate
     *  The date the invoice is scheduled to be paid.
     * 
     *  @property scheduledPaymentDate
     *  @type Date
     */
    prototype.scheduledPaymentDate = null;
    /**
     *  Schema.org/customer
     *  Party placing the order or paying the invoice.
     * 
     *  @property customer
     *  @type Organization
     */
    prototype.customer = null;
    /**
     *  Schema.org/category
     *  A category for the item. Greater signs or slashes can be used to informally indicate a category hierarchy.
     * 
     *  @property category
     *  @type Text
     */
    prototype.category = null;
    /**
     *  Schema.org/paymentStatus
     *  The status of payment; whether the invoice has been paid or not.
     * 
     *  @property paymentStatus
     *  @type PaymentStatusType
     */
    prototype.paymentStatus = null;
    /**
     *  Schema.org/broker
     *  An entity that arranges for an exchange between a buyer and a seller.  In most cases a broker never acquires or releases ownership of a product or service involved in an exchange.  If it is not clear whether an entity is a broker, seller, or buyer, the latter two terms are preferred.
     * 
     *  @property broker
     *  @type Person
     */
    prototype.broker = null;
    /**
     *  Schema.org/paymentMethod
     *  The name of the credit card or other method of payment for the order.
     * 
     *  @property paymentMethod
     *  @type PaymentMethod
     */
    prototype.paymentMethod = null;
    /**
     *  Schema.org/paymentMethodId
     *  An identifier for the method of payment used (e.g. the last 4 digits of the credit card).
     * 
     *  @property paymentMethodId
     *  @type Text
     */
    prototype.paymentMethodId = null;
    /**
     *  Schema.org/minimumPaymentDue
     *  The minimum payment required at this time.
     * 
     *  @property minimumPaymentDue
     *  @type MonetaryAmount
     */
    prototype.minimumPaymentDue = null;
    /**
     *  Schema.org/totalPaymentDue
     *  The total amount due.
     * 
     *  @property totalPaymentDue
     *  @type MonetaryAmount
     */
    prototype.totalPaymentDue = null;
    /**
     *  Schema.org/accountId
     *  The identifier for the account the payment will be applied to.
     * 
     *  @property accountId
     *  @type Text
     */
    prototype.accountId = null;
    /**
     *  Schema.org/referencesOrder
     *  The Order(s) related to this Invoice. One or more Orders may be combined into a single Invoice.
     * 
     *  @property referencesOrder
     *  @type Order
     */
    prototype.referencesOrder = null;
    /**
     *  Schema.org/paymentDueDate
     *  The date that payment is due.
     * 
     *  @property paymentDueDate
     *  @type DateTime
     */
    prototype.paymentDueDate = null;
}, {provider: "Person", billingPeriod: "Duration", customer: "Organization", paymentStatus: "PaymentStatusType", broker: "Person", paymentMethod: "PaymentMethod", minimumPaymentDue: "MonetaryAmount", totalPaymentDue: "MonetaryAmount", referencesOrder: "Order", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/StructuredValue
 *  Structured values are used when the value of a property has a more complex structure than simply being a textual value or a reference to another thing.
 * 
 *  @author schema.org
 *  @class StructuredValue
 *  @module org.schema
 *  @extends Intangible
 */
var StructuredValue = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Intangible.call(this);
    this.context = "http://schema.org/";
    this.type = "StructuredValue";
};
StructuredValue = stjs.extend(StructuredValue, Intangible, [], null, {identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Flight
 *  An airline flight.
 * 
 *  @author schema.org
 *  @class Flight
 *  @module org.schema
 *  @extends Intangible
 */
var Flight = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Intangible.call(this);
    this.context = "http://schema.org/";
    this.type = "Flight";
};
Flight = stjs.extend(Flight, Intangible, [], function(constructor, prototype) {
    /**
     *  Schema.org/arrivalAirport
     *  The airport where the flight terminates.
     * 
     *  @property arrivalAirport
     *  @type Airport
     */
    prototype.arrivalAirport = null;
    /**
     *  Schema.org/provider
     *  The service provider, service operator, or service performer; the goods producer. Another party (a seller) may offer those services or goods on behalf of the provider. A provider may also serve as the seller.
     * 
     *  @property provider
     *  @type Person
     */
    prototype.provider = null;
    /**
     *  Schema.org/arrivalGate
     *  Identifier of the flight's arrival gate.
     * 
     *  @property arrivalGate
     *  @type Text
     */
    prototype.arrivalGate = null;
    /**
     *  Schema.org/flightNumber
     *  The unique identifier for a flight including the airline IATA code. For example, if describing United flight 110, where the IATA code for United is 'UA', the flightNumber is 'UA110'.
     * 
     *  @property flightNumber
     *  @type Text
     */
    prototype.flightNumber = null;
    /**
     *  Schema.org/carrier
     *  'carrier' is an out-dated term indicating the 'provider' for parcel delivery and flights.
     * 
     *  @property carrier
     *  @type Organization
     */
    prototype.carrier = null;
    /**
     *  Schema.org/departureAirport
     *  The airport where the flight originates.
     * 
     *  @property departureAirport
     *  @type Airport
     */
    prototype.departureAirport = null;
    /**
     *  Schema.org/boardingPolicy
     *  The type of boarding policy used by the airline (e.g. zone-based or group-based).
     * 
     *  @property boardingPolicy
     *  @type BoardingPolicyType
     */
    prototype.boardingPolicy = null;
    /**
     *  Schema.org/aircraft
     *  The kind of aircraft (e.g., "Boeing 747").
     * 
     *  @property aircraft
     *  @type Vehicle
     */
    prototype.aircraft = null;
    /**
     *  Schema.org/arrivalTime
     *  The expected arrival time.
     * 
     *  @property arrivalTime
     *  @type DateTime
     */
    prototype.arrivalTime = null;
    /**
     *  Schema.org/seller
     *  An entity which offers (sells / leases / lends / loans) the services / goods.  A seller may also be a provider.
     * 
     *  @property seller
     *  @type Person
     */
    prototype.seller = null;
    /**
     *  Schema.org/webCheckinTime
     *  The time when a passenger can check into the flight online.
     * 
     *  @property webCheckinTime
     *  @type DateTime
     */
    prototype.webCheckinTime = null;
    /**
     *  Schema.org/mealService
     *  Description of the meals that will be provided or available for purchase.
     * 
     *  @property mealService
     *  @type Text
     */
    prototype.mealService = null;
    /**
     *  Schema.org/departureGate
     *  Identifier of the flight's departure gate.
     * 
     *  @property departureGate
     *  @type Text
     */
    prototype.departureGate = null;
    /**
     *  Schema.org/departureTerminal
     *  Identifier of the flight's departure terminal.
     * 
     *  @property departureTerminal
     *  @type Text
     */
    prototype.departureTerminal = null;
    /**
     *  Schema.org/estimatedFlightDuration
     *  The estimated time the flight will take.
     * 
     *  @property estimatedFlightDuration
     *  @type Text
     */
    prototype.estimatedFlightDuration = null;
    /**
     *  Schema.org/flightDistance
     *  The distance of the flight.
     * 
     *  @property flightDistance
     *  @type Distance
     */
    prototype.flightDistance = null;
    /**
     *  Schema.org/arrivalTerminal
     *  Identifier of the flight's arrival terminal.
     * 
     *  @property arrivalTerminal
     *  @type Text
     */
    prototype.arrivalTerminal = null;
    /**
     *  Schema.org/departureTime
     *  The expected departure time.
     * 
     *  @property departureTime
     *  @type DateTime
     */
    prototype.departureTime = null;
}, {arrivalAirport: "Airport", provider: "Person", carrier: "Organization", departureAirport: "Airport", boardingPolicy: "BoardingPolicyType", aircraft: "Vehicle", seller: "Person", flightDistance: "Distance", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Rating
 *  A rating is an evaluation on a numeric scale, such as 1 to 5 stars.
 * 
 *  @author schema.org
 *  @class Rating
 *  @module org.schema
 *  @extends Intangible
 */
var Rating = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Intangible.call(this);
    this.context = "http://schema.org/";
    this.type = "Rating";
};
Rating = stjs.extend(Rating, Intangible, [], function(constructor, prototype) {
    /**
     *  Schema.org/ratingValue
     *  The rating for the content.
     * 
     *  @property ratingValue
     *  @type Number
     */
    prototype.ratingValue = null;
    /**
     *  Schema.org/bestRating
     *  The highest value allowed in this rating system. If bestRating is omitted, 5 is assumed.
     * 
     *  @property bestRating
     *  @type Number
     */
    prototype.bestRating = null;
    /**
     *  Schema.org/author
     *  The author of this content or rating. Please note that author is special in that HTML 5 provides a special mechanism for indicating authorship via the rel tag. That is equivalent to this and may be used interchangeably.
     * 
     *  @property author
     *  @type Person
     */
    prototype.author = null;
    /**
     *  Schema.org/worstRating
     *  The lowest value allowed in this rating system. If worstRating is omitted, 1 is assumed.
     * 
     *  @property worstRating
     *  @type Text
     */
    prototype.worstRating = null;
}, {author: "Person", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Order
 *  An order is a confirmation of a transaction (a receipt), which can contain multiple line items, each represented by an Offer that has been accepted by the customer.
 * 
 *  @author schema.org
 *  @class Order
 *  @module org.schema
 *  @extends Intangible
 */
var Order = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Intangible.call(this);
    this.context = "http://schema.org/";
    this.type = "Order";
};
Order = stjs.extend(Order, Intangible, [], function(constructor, prototype) {
    /**
     *  Schema.org/orderDate
     *  Date order was placed.
     * 
     *  @property orderDate
     *  @type DateTime
     */
    prototype.orderDate = null;
    /**
     *  Schema.org/paymentDue
     *  The date that payment is due.
     * 
     *  @property paymentDue
     *  @type DateTime
     */
    prototype.paymentDue = null;
    /**
     *  Schema.org/orderNumber
     *  The identifier of the transaction.
     * 
     *  @property orderNumber
     *  @type Text
     */
    prototype.orderNumber = null;
    /**
     *  Schema.org/paymentUrl
     *  The URL for sending a payment.
     * 
     *  @property paymentUrl
     *  @type URL
     */
    prototype.paymentUrl = null;
    /**
     *  Schema.org/orderStatus
     *  The current status of the order.
     * 
     *  @property orderStatus
     *  @type OrderStatus
     */
    prototype.orderStatus = null;
    /**
     *  Schema.org/billingAddress
     *  The billing address for the order.
     * 
     *  @property billingAddress
     *  @type PostalAddress
     */
    prototype.billingAddress = null;
    /**
     *  Schema.org/partOfInvoice
     *  The order is being paid as part of the referenced Invoice.
     * 
     *  @property partOfInvoice
     *  @type Invoice
     */
    prototype.partOfInvoice = null;
    /**
     *  Schema.org/confirmationNumber
     *  A number that confirms the given order or payment has been received.
     * 
     *  @property confirmationNumber
     *  @type Text
     */
    prototype.confirmationNumber = null;
    /**
     *  Schema.org/customer
     *  Party placing the order or paying the invoice.
     * 
     *  @property customer
     *  @type Organization
     */
    prototype.customer = null;
    /**
     *  Schema.org/merchant
     *  'merchant' is an out-dated term for 'seller'.
     * 
     *  @property merchant
     *  @type Person
     */
    prototype.merchant = null;
    /**
     *  Schema.org/broker
     *  An entity that arranges for an exchange between a buyer and a seller.  In most cases a broker never acquires or releases ownership of a product or service involved in an exchange.  If it is not clear whether an entity is a broker, seller, or buyer, the latter two terms are preferred.
     * 
     *  @property broker
     *  @type Person
     */
    prototype.broker = null;
    /**
     *  Schema.org/orderedItem
     *  The item ordered.
     * 
     *  @property orderedItem
     *  @type Product
     */
    prototype.orderedItem = null;
    /**
     *  Schema.org/isGift
     *  Was the offer accepted as a gift for someone other than the buyer.
     * 
     *  @property isGift
     *  @type Boolean
     */
    prototype.isGift = null;
    /**
     *  Schema.org/paymentMethod
     *  The name of the credit card or other method of payment for the order.
     * 
     *  @property paymentMethod
     *  @type PaymentMethod
     */
    prototype.paymentMethod = null;
    /**
     *  Schema.org/seller
     *  An entity which offers (sells / leases / lends / loans) the services / goods.  A seller may also be a provider.
     * 
     *  @property seller
     *  @type Person
     */
    prototype.seller = null;
    /**
     *  Schema.org/paymentMethodId
     *  An identifier for the method of payment used (e.g. the last 4 digits of the credit card).
     * 
     *  @property paymentMethodId
     *  @type Text
     */
    prototype.paymentMethodId = null;
    /**
     *  Schema.org/discount
     *  Any discount applied (to an Order).
     * 
     *  @property discount
     *  @type Number
     */
    prototype.discount = null;
    /**
     *  Schema.org/orderDelivery
     *  The delivery of the parcel related to this order or order item.
     * 
     *  @property orderDelivery
     *  @type ParcelDelivery
     */
    prototype.orderDelivery = null;
    /**
     *  Schema.org/acceptedOffer
     *  The offer(s) -- e.g., product, quantity and price combinations -- included in the order.
     * 
     *  @property acceptedOffer
     *  @type Offer
     */
    prototype.acceptedOffer = null;
    /**
     *  Schema.org/discountCurrency
     *  The currency (in 3-letter ISO 4217 format) of the discount.
     * 
     *  @property discountCurrency
     *  @type Text
     */
    prototype.discountCurrency = null;
    /**
     *  Schema.org/paymentDueDate
     *  The date that payment is due.
     * 
     *  @property paymentDueDate
     *  @type DateTime
     */
    prototype.paymentDueDate = null;
    /**
     *  Schema.org/discountCode
     *  Code used to redeem a discount.
     * 
     *  @property discountCode
     *  @type Text
     */
    prototype.discountCode = null;
}, {orderStatus: "OrderStatus", billingAddress: "PostalAddress", partOfInvoice: "Invoice", customer: "Organization", merchant: "Person", broker: "Person", orderedItem: "Product", paymentMethod: "PaymentMethod", seller: "Person", orderDelivery: "ParcelDelivery", acceptedOffer: "Offer", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Audience
 *  Intended audience for an item, i.e. the group for whom the item was created.
 * 
 *  @author schema.org
 *  @class Audience
 *  @module org.schema
 *  @extends Intangible
 */
var Audience = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Intangible.call(this);
    this.context = "http://schema.org/";
    this.type = "Audience";
};
Audience = stjs.extend(Audience, Intangible, [], function(constructor, prototype) {
    /**
     *  Schema.org/audienceType
     *  The target group associated with a given audience (e.g. veterans, car owners, musicians, etc.).
     * 
     *  @property audienceType
     *  @type Text
     */
    prototype.audienceType = null;
    /**
     *  Schema.org/geographicArea
     *  The geographic area associated with the audience.
     * 
     *  @property geographicArea
     *  @type AdministrativeArea
     */
    prototype.geographicArea = null;
}, {geographicArea: "AdministrativeArea", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/ComputerLanguage
 *  This type covers computer programming languages such as Scheme and Lisp, as well as other language-like computer representations. Natural languages are best represented with the [[Language]] type.
 * 
 *  @author schema.org
 *  @class ComputerLanguage
 *  @module org.schema
 *  @extends Intangible
 */
var ComputerLanguage = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Intangible.call(this);
    this.context = "http://schema.org/";
    this.type = "ComputerLanguage";
};
ComputerLanguage = stjs.extend(ComputerLanguage, Intangible, [], null, {identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Seat
 *  Used to describe a seat, such as a reserved seat in an event reservation.
 * 
 *  @author schema.org
 *  @class Seat
 *  @module org.schema
 *  @extends Intangible
 */
var Seat = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Intangible.call(this);
    this.context = "http://schema.org/";
    this.type = "Seat";
};
Seat = stjs.extend(Seat, Intangible, [], function(constructor, prototype) {
    /**
     *  Schema.org/seatingType
     *  The type/class of the seat.
     * 
     *  @property seatingType
     *  @type Text
     */
    prototype.seatingType = null;
    /**
     *  Schema.org/seatSection
     *  The section location of the reserved seat (e.g. Orchestra).
     * 
     *  @property seatSection
     *  @type Text
     */
    prototype.seatSection = null;
    /**
     *  Schema.org/seatRow
     *  The row location of the reserved seat (e.g., B).
     * 
     *  @property seatRow
     *  @type Text
     */
    prototype.seatRow = null;
    /**
     *  Schema.org/seatNumber
     *  The location of the reserved seat (e.g., 27).
     * 
     *  @property seatNumber
     *  @type Text
     */
    prototype.seatNumber = null;
}, {identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/ItemList
 *  A list of items of any sort&#x2014;for example, Top 10 Movies About Weathermen, or Top 100 Party Songs. Not to be confused with HTML lists, which are often used only for formatting.
 * 
 *  @author schema.org
 *  @class ItemList
 *  @module org.schema
 *  @extends Intangible
 */
var ItemList = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Intangible.call(this);
    this.context = "http://schema.org/";
    this.type = "ItemList";
};
ItemList = stjs.extend(ItemList, Intangible, [], function(constructor, prototype) {
    /**
     *  Schema.org/itemListElement
     *  For itemListElement values, you can use simple strings (e.g. "Peter", "Paul", "Mary"), existing entities, or use ListItem.\n\nText values are best if the elements in the list are plain strings. Existing entities are best for a simple, unordered list of existing things in your data. ListItem is used with ordered lists when you want to provide additional context about the element in that list or when the same item might be in different places in different lists.\n\nNote: The order of elements in your mark-up is not sufficient for indicating the order or elements.  Use ListItem with a 'position' property in such cases.
     * 
     *  @property itemListElement
     *  @type ListItem
     */
    prototype.itemListElement = null;
    /**
     *  Schema.org/itemListOrder
     *  Type of ordering (e.g. Ascending, Descending, Unordered).
     * 
     *  @property itemListOrder
     *  @type Text
     */
    prototype.itemListOrder = null;
    /**
     *  Schema.org/numberOfItems
     *  The number of items in an ItemList. Note that some descriptions might not fully describe all items in a list (e.g., multi-page pagination); in such cases, the numberOfItems would be for the entire list.
     * 
     *  @property numberOfItems
     *  @type Integer
     */
    prototype.numberOfItems = null;
}, {itemListElement: "ListItem", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/ParcelDelivery
 *  The delivery of a parcel either via the postal service or a commercial service.
 * 
 *  @author schema.org
 *  @class ParcelDelivery
 *  @module org.schema
 *  @extends Intangible
 */
var ParcelDelivery = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Intangible.call(this);
    this.context = "http://schema.org/";
    this.type = "ParcelDelivery";
};
ParcelDelivery = stjs.extend(ParcelDelivery, Intangible, [], function(constructor, prototype) {
    /**
     *  Schema.org/provider
     *  The service provider, service operator, or service performer; the goods producer. Another party (a seller) may offer those services or goods on behalf of the provider. A provider may also serve as the seller.
     * 
     *  @property provider
     *  @type Person
     */
    prototype.provider = null;
    /**
     *  Schema.org/trackingUrl
     *  Tracking url for the parcel delivery.
     * 
     *  @property trackingUrl
     *  @type URL
     */
    prototype.trackingUrl = null;
    /**
     *  Schema.org/deliveryAddress
     *  Destination address.
     * 
     *  @property deliveryAddress
     *  @type PostalAddress
     */
    prototype.deliveryAddress = null;
    /**
     *  Schema.org/trackingNumber
     *  Shipper tracking number.
     * 
     *  @property trackingNumber
     *  @type Text
     */
    prototype.trackingNumber = null;
    /**
     *  Schema.org/hasDeliveryMethod
     *  Method used for delivery or shipping.
     * 
     *  @property hasDeliveryMethod
     *  @type DeliveryMethod
     */
    prototype.hasDeliveryMethod = null;
    /**
     *  Schema.org/deliveryStatus
     *  New entry added as the package passes through each leg of its journey (from shipment to final delivery).
     * 
     *  @property deliveryStatus
     *  @type DeliveryEvent
     */
    prototype.deliveryStatus = null;
    /**
     *  Schema.org/carrier
     *  'carrier' is an out-dated term indicating the 'provider' for parcel delivery and flights.
     * 
     *  @property carrier
     *  @type Organization
     */
    prototype.carrier = null;
    /**
     *  Schema.org/originAddress
     *  Shipper's address.
     * 
     *  @property originAddress
     *  @type PostalAddress
     */
    prototype.originAddress = null;
    /**
     *  Schema.org/itemShipped
     *  Item(s) being shipped.
     * 
     *  @property itemShipped
     *  @type Product
     */
    prototype.itemShipped = null;
    /**
     *  Schema.org/partOfOrder
     *  The overall order the items in this delivery were included in.
     * 
     *  @property partOfOrder
     *  @type Order
     */
    prototype.partOfOrder = null;
    /**
     *  Schema.org/expectedArrivalFrom
     *  The earliest date the package may arrive.
     * 
     *  @property expectedArrivalFrom
     *  @type DateTime
     */
    prototype.expectedArrivalFrom = null;
    /**
     *  Schema.org/expectedArrivalUntil
     *  The latest date the package may arrive.
     * 
     *  @property expectedArrivalUntil
     *  @type DateTime
     */
    prototype.expectedArrivalUntil = null;
}, {provider: "Person", deliveryAddress: "PostalAddress", hasDeliveryMethod: "DeliveryMethod", deliveryStatus: "DeliveryEvent", carrier: "Organization", originAddress: "PostalAddress", itemShipped: "Product", partOfOrder: "Order", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Role
 *  Represents additional information about a relationship or property. For example a Role can be used to say that a 'member' role linking some SportsTeam to a player occurred during a particular time period. Or that a Person's 'actor' role in a Movie was for some particular characterName. Such properties can be attached to a Role entity, which is then associated with the main entities using ordinary properties like 'member' or 'actor'.\n\nSee also [blog post](http://blog.schema.org/2014/06/introducing-role.html).
 * 
 *  @author schema.org
 *  @class Role
 *  @module org.schema
 *  @extends Intangible
 */
var Role = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Intangible.call(this);
    this.context = "http://schema.org/";
    this.type = "Role";
};
Role = stjs.extend(Role, Intangible, [], function(constructor, prototype) {
    /**
     *  Schema.org/endDate
     *  The end date and time of the item (in [ISO 8601 date format](http://en.wikipedia.org/wiki/ISO_8601)).
     * 
     *  @property endDate
     *  @type DateTime
     */
    prototype.endDate = null;
    /**
     *  Schema.org/startDate
     *  The start date and time of the item (in [ISO 8601 date format](http://en.wikipedia.org/wiki/ISO_8601)).
     * 
     *  @property startDate
     *  @type Date
     */
    prototype.startDate = null;
    /**
     *  Schema.org/namedPosition
     *  A position played, performed or filled by a person or organization, as part of an organization. For example, an athlete in a SportsTeam might play in the position named 'Quarterback'.
     * 
     *  @property namedPosition
     *  @type Text
     */
    prototype.namedPosition = null;
    /**
     *  Schema.org/roleName
     *  A role played, performed or filled by a person or organization. For example, the team of creators for a comic book might fill the roles named 'inker', 'penciller', and 'letterer'; or an athlete in a SportsTeam might play in the position named 'Quarterback'.
     * 
     *  @property roleName
     *  @type Text
     */
    prototype.roleName = null;
}, {identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/AlignmentObject
 *  An intangible item that describes an alignment between a learning resource and a node in an educational framework.
 * 
 *  @author schema.org
 *  @class AlignmentObject
 *  @module org.schema
 *  @extends Intangible
 */
var AlignmentObject = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Intangible.call(this);
    this.context = "http://schema.org/";
    this.type = "AlignmentObject";
};
AlignmentObject = stjs.extend(AlignmentObject, Intangible, [], function(constructor, prototype) {
    /**
     *  Schema.org/targetDescription
     *  The description of a node in an established educational framework.
     * 
     *  @property targetDescription
     *  @type Text
     */
    prototype.targetDescription = null;
    /**
     *  Schema.org/alignmentType
     *  A category of alignment between the learning resource and the framework node. Recommended values include: 'assesses', 'teaches', 'requires', 'textComplexity', 'readingLevel', 'educationalSubject', and 'educationalLevel'.
     * 
     *  @property alignmentType
     *  @type Text
     */
    prototype.alignmentType = null;
    /**
     *  Schema.org/targetUrl
     *  The URL of a node in an established educational framework.
     * 
     *  @property targetUrl
     *  @type URL
     */
    prototype.targetUrl = null;
    /**
     *  Schema.org/targetName
     *  The name of a node in an established educational framework.
     * 
     *  @property targetName
     *  @type Text
     */
    prototype.targetName = null;
    /**
     *  Schema.org/educationalFramework
     *  The framework to which the resource being described is aligned.
     * 
     *  @property educationalFramework
     *  @type Text
     */
    prototype.educationalFramework = null;
}, {identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Enumeration
 *  Lists or enumerations—for example, a list of cuisines or music genres, etc.
 * 
 *  @author schema.org
 *  @class Enumeration
 *  @module org.schema
 *  @extends Intangible
 */
var Enumeration = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Intangible.call(this);
    this.context = "http://schema.org/";
    this.type = "Enumeration";
};
Enumeration = stjs.extend(Enumeration, Intangible, [], null, {identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/DataFeedItem
 *  A single item within a larger data feed.
 * 
 *  @author schema.org
 *  @class DataFeedItem
 *  @module org.schema
 *  @extends Intangible
 */
var DataFeedItem = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Intangible.call(this);
    this.context = "http://schema.org/";
    this.type = "DataFeedItem";
};
DataFeedItem = stjs.extend(DataFeedItem, Intangible, [], function(constructor, prototype) {
    /**
     *  Schema.org/dateModified
     *  The date on which the CreativeWork was most recently modified or when the item's entry was modified within a DataFeed.
     * 
     *  @property dateModified
     *  @type DateTime
     */
    prototype.dateModified = null;
    /**
     *  Schema.org/dateDeleted
     *  The datetime the item was removed from the DataFeed.
     * 
     *  @property dateDeleted
     *  @type DateTime
     */
    prototype.dateDeleted = null;
    /**
     *  Schema.org/dateCreated
     *  The date on which the CreativeWork was created or the item was added to a DataFeed.
     * 
     *  @property dateCreated
     *  @type Date
     */
    prototype.dateCreated = null;
    /**
     *  Schema.org/item
     *  An entity represented by an entry in a list or data feed (e.g. an 'artist' in a list of 'artists')’.
     * 
     *  @property item
     *  @type Thing
     */
    prototype.item = null;
}, {item: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/BusTrip
 *  A trip on a commercial bus line.
 * 
 *  @author schema.org
 *  @class BusTrip
 *  @module org.schema
 *  @extends Intangible
 */
var BusTrip = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Intangible.call(this);
    this.context = "http://schema.org/";
    this.type = "BusTrip";
};
BusTrip = stjs.extend(BusTrip, Intangible, [], function(constructor, prototype) {
    /**
     *  Schema.org/provider
     *  The service provider, service operator, or service performer; the goods producer. Another party (a seller) may offer those services or goods on behalf of the provider. A provider may also serve as the seller.
     * 
     *  @property provider
     *  @type Person
     */
    prototype.provider = null;
    /**
     *  Schema.org/busName
     *  The name of the bus (e.g. Bolt Express).
     * 
     *  @property busName
     *  @type Text
     */
    prototype.busName = null;
    /**
     *  Schema.org/departureBusStop
     *  The stop or station from which the bus departs.
     * 
     *  @property departureBusStop
     *  @type BusStop
     */
    prototype.departureBusStop = null;
    /**
     *  Schema.org/arrivalBusStop
     *  The stop or station from which the bus arrives.
     * 
     *  @property arrivalBusStop
     *  @type BusStation
     */
    prototype.arrivalBusStop = null;
    /**
     *  Schema.org/arrivalTime
     *  The expected arrival time.
     * 
     *  @property arrivalTime
     *  @type DateTime
     */
    prototype.arrivalTime = null;
    /**
     *  Schema.org/busNumber
     *  The unique identifier for the bus.
     * 
     *  @property busNumber
     *  @type Text
     */
    prototype.busNumber = null;
    /**
     *  Schema.org/departureTime
     *  The expected departure time.
     * 
     *  @property departureTime
     *  @type DateTime
     */
    prototype.departureTime = null;
}, {provider: "Person", departureBusStop: "BusStop", arrivalBusStop: "BusStation", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/ServiceChannel
 *  A means for accessing a service, e.g. a government office location, web site, or phone number.
 * 
 *  @author schema.org
 *  @class ServiceChannel
 *  @module org.schema
 *  @extends Intangible
 */
var ServiceChannel = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Intangible.call(this);
    this.context = "http://schema.org/";
    this.type = "ServiceChannel";
};
ServiceChannel = stjs.extend(ServiceChannel, Intangible, [], function(constructor, prototype) {
    /**
     *  Schema.org/providesService
     *  The service provided by this channel.
     * 
     *  @property providesService
     *  @type Service
     */
    prototype.providesService = null;
    /**
     *  Schema.org/serviceLocation
     *  The location (e.g. civic structure, local business, etc.) where a person can go to access the service.
     * 
     *  @property serviceLocation
     *  @type Place
     */
    prototype.serviceLocation = null;
    /**
     *  Schema.org/servicePostalAddress
     *  The address for accessing the service by mail.
     * 
     *  @property servicePostalAddress
     *  @type PostalAddress
     */
    prototype.servicePostalAddress = null;
    /**
     *  Schema.org/availableLanguage
     *  A language someone may use with the item. Please use one of the language codes from the [IETF BCP 47 standard](http://tools.ietf.org/html/bcp47). See also [[inLanguage]]
     * 
     *  @property availableLanguage
     *  @type Language
     */
    prototype.availableLanguage = null;
    /**
     *  Schema.org/serviceSmsNumber
     *  The number to access the service by text message.
     * 
     *  @property serviceSmsNumber
     *  @type ContactPoint
     */
    prototype.serviceSmsNumber = null;
    /**
     *  Schema.org/serviceUrl
     *  The website to access the service.
     * 
     *  @property serviceUrl
     *  @type URL
     */
    prototype.serviceUrl = null;
    /**
     *  Schema.org/servicePhone
     *  The phone number to use to access the service.
     * 
     *  @property servicePhone
     *  @type ContactPoint
     */
    prototype.servicePhone = null;
    /**
     *  Schema.org/processingTime
     *  Estimated processing time for the service using this channel.
     * 
     *  @property processingTime
     *  @type Duration
     */
    prototype.processingTime = null;
}, {providesService: "Service", serviceLocation: "Place", servicePostalAddress: "PostalAddress", availableLanguage: "Language", serviceSmsNumber: "ContactPoint", servicePhone: "ContactPoint", processingTime: "Duration", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/ListItem
 *  An list item, e.g. a step in a checklist or how-to description.
 * 
 *  @author schema.org
 *  @class ListItem
 *  @module org.schema
 *  @extends Intangible
 */
var ListItem = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Intangible.call(this);
    this.context = "http://schema.org/";
    this.type = "ListItem";
};
ListItem = stjs.extend(ListItem, Intangible, [], function(constructor, prototype) {
    /**
     *  Schema.org/nextItem
     *  A link to the ListItem that follows the current one.
     * 
     *  @property nextItem
     *  @type ListItem
     */
    prototype.nextItem = null;
    /**
     *  Schema.org/position
     *  The position of an item in a series or sequence of items.
     * 
     *  @property position
     *  @type Integer
     */
    prototype.position = null;
    /**
     *  Schema.org/previousItem
     *  A link to the ListItem that preceeds the current one.
     * 
     *  @property previousItem
     *  @type ListItem
     */
    prototype.previousItem = null;
    /**
     *  Schema.org/item
     *  An entity represented by an entry in a list or data feed (e.g. an 'artist' in a list of 'artists')’.
     * 
     *  @property item
     *  @type Thing
     */
    prototype.item = null;
}, {nextItem: "ListItem", previousItem: "ListItem", item: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Service
 *  A service provided by an organization, e.g. delivery service, print services, etc.
 * 
 *  @author schema.org
 *  @class Service
 *  @module org.schema
 *  @extends Intangible
 */
var Service = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Intangible.call(this);
    this.context = "http://schema.org/";
    this.type = "Service";
};
Service = stjs.extend(Service, Intangible, [], function(constructor, prototype) {
    /**
     *  Schema.org/serviceAudience
     *  The audience eligible for this service.
     * 
     *  @property serviceAudience
     *  @type Audience
     */
    prototype.serviceAudience = null;
    /**
     *  Schema.org/serviceArea
     *  The geographic area where the service is provided.
     * 
     *  @property serviceArea
     *  @type GeoShape
     */
    prototype.serviceArea = null;
    /**
     *  Schema.org/provider
     *  The service provider, service operator, or service performer; the goods producer. Another party (a seller) may offer those services or goods on behalf of the provider. A provider may also serve as the seller.
     * 
     *  @property provider
     *  @type Person
     */
    prototype.provider = null;
    /**
     *  Schema.org/audience
     *  An intended audience, i.e. a group for whom something was created.
     * 
     *  @property audience
     *  @type Audience
     */
    prototype.audience = null;
    /**
     *  Schema.org/hasOfferCatalog
     *  Indicates an OfferCatalog listing for this Organization, Person, or Service.
     * 
     *  @property hasOfferCatalog
     *  @type OfferCatalog
     */
    prototype.hasOfferCatalog = null;
    /**
     *  Schema.org/hoursAvailable
     *  The hours during which this service or contact is available.
     * 
     *  @property hoursAvailable
     *  @type OpeningHoursSpecification
     */
    prototype.hoursAvailable = null;
    /**
     *  Schema.org/providerMobility
     *  Indicates the mobility of a provided service (e.g. 'static', 'dynamic').
     * 
     *  @property providerMobility
     *  @type Text
     */
    prototype.providerMobility = null;
    /**
     *  Schema.org/aggregateRating
     *  The overall rating, based on a collection of reviews or ratings, of the item.
     * 
     *  @property aggregateRating
     *  @type AggregateRating
     */
    prototype.aggregateRating = null;
    /**
     *  Schema.org/offers
     *  An offer to provide this item&#x2014;for example, an offer to sell a product, rent the DVD of a movie, perform a service, or give away tickets to an event.
     * 
     *  @property offers
     *  @type Offer
     */
    prototype.offers = null;
    /**
     *  Schema.org/award
     *  An award won by or for this item.
     * 
     *  @property award
     *  @type Text
     */
    prototype.award = null;
    /**
     *  Schema.org/category
     *  A category for the item. Greater signs or slashes can be used to informally indicate a category hierarchy.
     * 
     *  @property category
     *  @type Text
     */
    prototype.category = null;
    /**
     *  Schema.org/broker
     *  An entity that arranges for an exchange between a buyer and a seller.  In most cases a broker never acquires or releases ownership of a product or service involved in an exchange.  If it is not clear whether an entity is a broker, seller, or buyer, the latter two terms are preferred.
     * 
     *  @property broker
     *  @type Person
     */
    prototype.broker = null;
    /**
     *  Schema.org/serviceOutput
     *  The tangible thing generated by the service, e.g. a passport, permit, etc.
     * 
     *  @property serviceOutput
     *  @type Thing
     */
    prototype.serviceOutput = null;
    /**
     *  Schema.org/logo
     *  An associated logo.
     * 
     *  @property logo
     *  @type ImageObject
     */
    prototype.logo = null;
    /**
     *  Schema.org/isSimilarTo
     *  A pointer to another, functionally similar product (or multiple products).
     * 
     *  @property isSimilarTo
     *  @type Product
     */
    prototype.isSimilarTo = null;
    /**
     *  Schema.org/isRelatedTo
     *  A pointer to another, somehow related product (or multiple products).
     * 
     *  @property isRelatedTo
     *  @type Product
     */
    prototype.isRelatedTo = null;
    /**
     *  Schema.org/availableChannel
     *  A means of accessing the service (e.g. a phone bank, a web site, a location, etc.).
     * 
     *  @property availableChannel
     *  @type ServiceChannel
     */
    prototype.availableChannel = null;
    /**
     *  Schema.org/review
     *  A review of the item.
     * 
     *  @property review
     *  @type Review
     */
    prototype.review = null;
    /**
     *  Schema.org/serviceType
     *  The type of service being offered, e.g. veterans' benefits, emergency relief, etc.
     * 
     *  @property serviceType
     *  @type Text
     */
    prototype.serviceType = null;
    /**
     *  Schema.org/produces
     *  The tangible thing generated by the service, e.g. a passport, permit, etc.
     * 
     *  @property produces
     *  @type Thing
     */
    prototype.produces = null;
    /**
     *  Schema.org/brand
     *  The brand(s) associated with a product or service, or the brand(s) maintained by an organization or business person.
     * 
     *  @property brand
     *  @type Organization
     */
    prototype.brand = null;
    /**
     *  Schema.org/areaServed
     *  The geographic area where a service or offered item is provided.
     * 
     *  @property areaServed
     *  @type Place
     */
    prototype.areaServed = null;
}, {serviceAudience: "Audience", serviceArea: "GeoShape", provider: "Person", audience: "Audience", hasOfferCatalog: "OfferCatalog", hoursAvailable: "OpeningHoursSpecification", aggregateRating: "AggregateRating", offers: "Offer", broker: "Person", serviceOutput: "Thing", logo: "ImageObject", isSimilarTo: "Product", isRelatedTo: "Product", availableChannel: "ServiceChannel", review: "Review", produces: "Thing", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/GameServer
 *  Server that provides game interaction in a multiplayer game.
 * 
 *  @author schema.org
 *  @class GameServer
 *  @module org.schema
 *  @extends Intangible
 */
var GameServer = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Intangible.call(this);
    this.context = "http://schema.org/";
    this.type = "GameServer";
};
GameServer = stjs.extend(GameServer, Intangible, [], function(constructor, prototype) {
    /**
     *  Schema.org/game
     *  Video game which is played on this server.
     * 
     *  @property game
     *  @type VideoGame
     */
    prototype.game = null;
    /**
     *  Schema.org/playersOnline
     *  Number of players on the server.
     * 
     *  @property playersOnline
     *  @type Integer
     */
    prototype.playersOnline = null;
    /**
     *  Schema.org/serverStatus
     *  Status of a game server.
     * 
     *  @property serverStatus
     *  @type GameServerStatus
     */
    prototype.serverStatus = null;
}, {game: "VideoGame", serverStatus: "GameServerStatus", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/TrainTrip
 *  A trip on a commercial train line.
 * 
 *  @author schema.org
 *  @class TrainTrip
 *  @module org.schema
 *  @extends Intangible
 */
var TrainTrip = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Intangible.call(this);
    this.context = "http://schema.org/";
    this.type = "TrainTrip";
};
TrainTrip = stjs.extend(TrainTrip, Intangible, [], function(constructor, prototype) {
    /**
     *  Schema.org/departureStation
     *  The station from which the train departs.
     * 
     *  @property departureStation
     *  @type TrainStation
     */
    prototype.departureStation = null;
    /**
     *  Schema.org/provider
     *  The service provider, service operator, or service performer; the goods producer. Another party (a seller) may offer those services or goods on behalf of the provider. A provider may also serve as the seller.
     * 
     *  @property provider
     *  @type Person
     */
    prototype.provider = null;
    /**
     *  Schema.org/arrivalPlatform
     *  The platform where the train arrives.
     * 
     *  @property arrivalPlatform
     *  @type Text
     */
    prototype.arrivalPlatform = null;
    /**
     *  Schema.org/departurePlatform
     *  The platform from which the train departs.
     * 
     *  @property departurePlatform
     *  @type Text
     */
    prototype.departurePlatform = null;
    /**
     *  Schema.org/trainName
     *  The name of the train (e.g. The Orient Express).
     * 
     *  @property trainName
     *  @type Text
     */
    prototype.trainName = null;
    /**
     *  Schema.org/trainNumber
     *  The unique identifier for the train.
     * 
     *  @property trainNumber
     *  @type Text
     */
    prototype.trainNumber = null;
    /**
     *  Schema.org/arrivalStation
     *  The station where the train trip ends.
     * 
     *  @property arrivalStation
     *  @type TrainStation
     */
    prototype.arrivalStation = null;
    /**
     *  Schema.org/arrivalTime
     *  The expected arrival time.
     * 
     *  @property arrivalTime
     *  @type DateTime
     */
    prototype.arrivalTime = null;
    /**
     *  Schema.org/departureTime
     *  The expected departure time.
     * 
     *  @property departureTime
     *  @type DateTime
     */
    prototype.departureTime = null;
}, {departureStation: "TrainStation", provider: "Person", arrivalStation: "TrainStation", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/ProgramMembership
 *  Used to describe membership in a loyalty programs (e.g. "StarAliance"), traveler clubs (e.g. "AAA"), purchase clubs ("Safeway Club"), etc.
 * 
 *  @author schema.org
 *  @class ProgramMembership
 *  @module org.schema
 *  @extends Intangible
 */
var ProgramMembership = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Intangible.call(this);
    this.context = "http://schema.org/";
    this.type = "ProgramMembership";
};
ProgramMembership = stjs.extend(ProgramMembership, Intangible, [], function(constructor, prototype) {
    /**
     *  Schema.org/membershipNumber
     *  A unique identifier for the membership.
     * 
     *  @property membershipNumber
     *  @type Text
     */
    prototype.membershipNumber = null;
    /**
     *  Schema.org/members
     *  A member of this organization.
     * 
     *  @property members
     *  @type Organization
     */
    prototype.members = null;
    /**
     *  Schema.org/member
     *  A member of an Organization or a ProgramMembership. Organizations can be members of organizations; ProgramMembership is typically for individuals.
     * 
     *  @property member
     *  @type Organization
     */
    prototype.member = null;
    /**
     *  Schema.org/hostingOrganization
     *  The organization (airline, travelers' club, etc.) the membership is made with.
     * 
     *  @property hostingOrganization
     *  @type Organization
     */
    prototype.hostingOrganization = null;
    /**
     *  Schema.org/programName
     *  The program providing the membership.
     * 
     *  @property programName
     *  @type Text
     */
    prototype.programName = null;
}, {members: "Organization", member: "Organization", hostingOrganization: "Organization", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/PropertyValueSpecification
 *  A Property value specification.
 * 
 *  @author schema.org
 *  @class PropertyValueSpecification
 *  @module org.schema
 *  @extends Intangible
 */
var PropertyValueSpecification = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Intangible.call(this);
    this.context = "http://schema.org/";
    this.type = "PropertyValueSpecification";
};
PropertyValueSpecification = stjs.extend(PropertyValueSpecification, Intangible, [], function(constructor, prototype) {
    /**
     *  Schema.org/defaultValue
     *  The default value of the input.  For properties that expect a literal, the default is a literal value, for properties that expect an object, it's an ID reference to one of the current values.
     * 
     *  @property defaultValue
     *  @type Thing
     */
    prototype.defaultValue = null;
    /**
     *  Schema.org/minValue
     *  The lower value of some characteristic or property.
     * 
     *  @property minValue
     *  @type Number
     */
    prototype.minValue = null;
    /**
     *  Schema.org/valuePattern
     *  Specifies a regular expression for testing literal values according to the HTML spec.
     * 
     *  @property valuePattern
     *  @type Text
     */
    prototype.valuePattern = null;
    /**
     *  Schema.org/stepValue
     *  The stepValue attribute indicates the granularity that is expected (and required) of the value in a PropertyValueSpecification.
     * 
     *  @property stepValue
     *  @type Number
     */
    prototype.stepValue = null;
    /**
     *  Schema.org/valueMaxLength
     *  Specifies the allowed range for number of characters in a literal value.
     * 
     *  @property valueMaxLength
     *  @type Number
     */
    prototype.valueMaxLength = null;
    /**
     *  Schema.org/readonlyValue
     *  Whether or not a property is mutable.  Default is false. Specifying this for a property that also has a value makes it act similar to a "hidden" input in an HTML form.
     * 
     *  @property readonlyValue
     *  @type Boolean
     */
    prototype.readonlyValue = null;
    /**
     *  Schema.org/valueMinLength
     *  Specifies the minimum allowed range for number of characters in a literal value.
     * 
     *  @property valueMinLength
     *  @type Number
     */
    prototype.valueMinLength = null;
    /**
     *  Schema.org/maxValue
     *  The upper value of some characteristic or property.
     * 
     *  @property maxValue
     *  @type Number
     */
    prototype.maxValue = null;
    /**
     *  Schema.org/valueName
     *  Indicates the name of the PropertyValueSpecification to be used in URL templates and form encoding in a manner analogous to HTML's input@name.
     * 
     *  @property valueName
     *  @type Text
     */
    prototype.valueName = null;
    /**
     *  Schema.org/multipleValues
     *  Whether multiple values are allowed for the property.  Default is false.
     * 
     *  @property multipleValues
     *  @type Boolean
     */
    prototype.multipleValues = null;
    /**
     *  Schema.org/valueRequired
     *  Whether the property must be filled in to complete the action.  Default is false.
     * 
     *  @property valueRequired
     *  @type Boolean
     */
    prototype.valueRequired = null;
}, {defaultValue: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Ticket
 *  Used to describe a ticket to an event, a flight, a bus ride, etc.
 * 
 *  @author schema.org
 *  @class Ticket
 *  @module org.schema
 *  @extends Intangible
 */
var Ticket = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Intangible.call(this);
    this.context = "http://schema.org/";
    this.type = "Ticket";
};
Ticket = stjs.extend(Ticket, Intangible, [], function(constructor, prototype) {
    /**
     *  Schema.org/underName
     *  The person or organization the reservation or ticket is for.
     * 
     *  @property underName
     *  @type Organization
     */
    prototype.underName = null;
    /**
     *  Schema.org/totalPrice
     *  The total price for the reservation or ticket, including applicable taxes, shipping, etc.
     * 
     *  @property totalPrice
     *  @type Number
     */
    prototype.totalPrice = null;
    /**
     *  Schema.org/priceCurrency
     *  The currency (in 3-letter ISO 4217 format) of the price or a price component, when attached to [[PriceSpecification]] and its subtypes.
     * 
     *  @property priceCurrency
     *  @type Text
     */
    prototype.priceCurrency = null;
    /**
     *  Schema.org/ticketNumber
     *  The unique identifier for the ticket.
     * 
     *  @property ticketNumber
     *  @type Text
     */
    prototype.ticketNumber = null;
    /**
     *  Schema.org/issuedBy
     *  The organization issuing the ticket or permit.
     * 
     *  @property issuedBy
     *  @type Organization
     */
    prototype.issuedBy = null;
    /**
     *  Schema.org/ticketToken
     *  Reference to an asset (e.g., Barcode, QR code image or PDF) usable for entrance.
     * 
     *  @property ticketToken
     *  @type URL
     */
    prototype.ticketToken = null;
    /**
     *  Schema.org/ticketedSeat
     *  The seat associated with the ticket.
     * 
     *  @property ticketedSeat
     *  @type Seat
     */
    prototype.ticketedSeat = null;
    /**
     *  Schema.org/dateIssued
     *  The date the ticket was issued.
     * 
     *  @property dateIssued
     *  @type DateTime
     */
    prototype.dateIssued = null;
}, {underName: "Organization", issuedBy: "Organization", ticketedSeat: "Seat", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/MenuItem
 *  A food or drink item listed in a menu or menu section.
 * 
 *  @author schema.org
 *  @class MenuItem
 *  @module org.schema
 *  @extends Intangible
 */
var MenuItem = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Intangible.call(this);
    this.context = "http://schema.org/";
    this.type = "MenuItem";
};
MenuItem = stjs.extend(MenuItem, Intangible, [], function(constructor, prototype) {
    /**
     *  Schema.org/nutrition
     *  Nutrition information about the recipe or menu item.
     * 
     *  @property nutrition
     *  @type NutritionInformation
     */
    prototype.nutrition = null;
    /**
     *  Schema.org/offers
     *  An offer to provide this item&#x2014;for example, an offer to sell a product, rent the DVD of a movie, perform a service, or give away tickets to an event.
     * 
     *  @property offers
     *  @type Offer
     */
    prototype.offers = null;
    /**
     *  Schema.org/suitableForDiet
     *  Indicates a dietary restriction or guideline for which this recipe or menu item is suitable, e.g. diabetic, halal etc.
     * 
     *  @property suitableForDiet
     *  @type RestrictedDiet
     */
    prototype.suitableForDiet = null;
}, {nutrition: "NutritionInformation", offers: "Offer", suitableForDiet: "RestrictedDiet", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/BroadcastChannel
 *  A unique instance of a BroadcastService on a CableOrSatelliteService lineup.
 * 
 *  @author schema.org
 *  @class BroadcastChannel
 *  @module org.schema
 *  @extends Intangible
 */
var BroadcastChannel = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Intangible.call(this);
    this.context = "http://schema.org/";
    this.type = "BroadcastChannel";
};
BroadcastChannel = stjs.extend(BroadcastChannel, Intangible, [], function(constructor, prototype) {
    /**
     *  Schema.org/broadcastChannelId
     *  The unique address by which the BroadcastService can be identified in a provider lineup. In US, this is typically a number.
     * 
     *  @property broadcastChannelId
     *  @type Text
     */
    prototype.broadcastChannelId = null;
    /**
     *  Schema.org/broadcastServiceTier
     *  The type of service required to have access to the channel (e.g. Standard or Premium).
     * 
     *  @property broadcastServiceTier
     *  @type Text
     */
    prototype.broadcastServiceTier = null;
    /**
     *  Schema.org/inBroadcastLineup
     *  The CableOrSatelliteService offering the channel.
     * 
     *  @property inBroadcastLineup
     *  @type CableOrSatelliteService
     */
    prototype.inBroadcastLineup = null;
    /**
     *  Schema.org/providesBroadcastService
     *  The BroadcastService offered on this channel.
     * 
     *  @property providesBroadcastService
     *  @type BroadcastService
     */
    prototype.providesBroadcastService = null;
    /**
     *  Schema.org/genre
     *  Genre of the creative work, broadcast channel or group.
     * 
     *  @property genre
     *  @type URL
     */
    prototype.genre = null;
}, {inBroadcastLineup: "CableOrSatelliteService", providesBroadcastService: "BroadcastService", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Permit
 *  A permit issued by an organization, e.g. a parking pass.
 * 
 *  @author schema.org
 *  @class Permit
 *  @module org.schema
 *  @extends Intangible
 */
var Permit = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Intangible.call(this);
    this.context = "http://schema.org/";
    this.type = "Permit";
};
Permit = stjs.extend(Permit, Intangible, [], function(constructor, prototype) {
    /**
     *  Schema.org/validFor
     *  The time validity of the permit.
     * 
     *  @property validFor
     *  @type Duration
     */
    prototype.validFor = null;
    /**
     *  Schema.org/validUntil
     *  The date when the item is no longer valid.
     * 
     *  @property validUntil
     *  @type Date
     */
    prototype.validUntil = null;
    /**
     *  Schema.org/validFrom
     *  The date when the item becomes valid.
     * 
     *  @property validFrom
     *  @type DateTime
     */
    prototype.validFrom = null;
    /**
     *  Schema.org/issuedBy
     *  The organization issuing the ticket or permit.
     * 
     *  @property issuedBy
     *  @type Organization
     */
    prototype.issuedBy = null;
    /**
     *  Schema.org/issuedThrough
     *  The service through with the permit was granted.
     * 
     *  @property issuedThrough
     *  @type Service
     */
    prototype.issuedThrough = null;
    /**
     *  Schema.org/permitAudience
     *  The target audience for this permit.
     * 
     *  @property permitAudience
     *  @type Audience
     */
    prototype.permitAudience = null;
    /**
     *  Schema.org/validIn
     *  The geographic area where the permit is valid.
     * 
     *  @property validIn
     *  @type AdministrativeArea
     */
    prototype.validIn = null;
}, {validFor: "Duration", issuedBy: "Organization", issuedThrough: "Service", permitAudience: "Audience", validIn: "AdministrativeArea", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Brand
 *  A brand is a name used by an organization or business person for labeling a product, product group, or similar.
 * 
 *  @author schema.org
 *  @class Brand
 *  @module org.schema
 *  @extends Intangible
 */
var Brand = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Intangible.call(this);
    this.context = "http://schema.org/";
    this.type = "Brand";
};
Brand = stjs.extend(Brand, Intangible, [], function(constructor, prototype) {
    /**
     *  Schema.org/aggregateRating
     *  The overall rating, based on a collection of reviews or ratings, of the item.
     * 
     *  @property aggregateRating
     *  @type AggregateRating
     */
    prototype.aggregateRating = null;
    /**
     *  Schema.org/logo
     *  An associated logo.
     * 
     *  @property logo
     *  @type ImageObject
     */
    prototype.logo = null;
    /**
     *  Schema.org/review
     *  A review of the item.
     * 
     *  @property review
     *  @type Review
     */
    prototype.review = null;
}, {aggregateRating: "AggregateRating", logo: "ImageObject", review: "Review", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Offer
 *  An offer to transfer some rights to an item or to provide a service — for example, an offer to sell tickets to an event, to rent the DVD of a movie, to stream a TV show over the internet, to repair a motorcycle, or to loan a book.\n\nFor [GTIN](http://www.gs1.org/barcodes/technical/idkeys/gtin)-related fields, see [Check Digit calculator](http://www.gs1.org/barcodes/support/check_digit_calculator) and [validation guide](http://www.gs1us.org/resources/standards/gtin-validation-guide) from [GS1](http://www.gs1.org/).
 * 
 *  @author schema.org
 *  @class Offer
 *  @module org.schema
 *  @extends Intangible
 */
var Offer = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Intangible.call(this);
    this.context = "http://schema.org/";
    this.type = "Offer";
};
Offer = stjs.extend(Offer, Intangible, [], function(constructor, prototype) {
    /**
     *  Schema.org/sku
     *  The Stock Keeping Unit (SKU), i.e. a merchant-specific identifier for a product or service, or the product to which the offer refers.
     * 
     *  @property sku
     *  @type Text
     */
    prototype.sku = null;
    /**
     *  Schema.org/availabilityStarts
     *  The beginning of the availability of the product or service included in the offer.
     * 
     *  @property availabilityStarts
     *  @type DateTime
     */
    prototype.availabilityStarts = null;
    /**
     *  Schema.org/availableDeliveryMethod
     *  The delivery method(s) available for this offer.
     * 
     *  @property availableDeliveryMethod
     *  @type DeliveryMethod
     */
    prototype.availableDeliveryMethod = null;
    /**
     *  Schema.org/mpn
     *  The Manufacturer Part Number (MPN) of the product, or the product to which the offer refers.
     * 
     *  @property mpn
     *  @type Text
     */
    prototype.mpn = null;
    /**
     *  Schema.org/serialNumber
     *  The serial number or any alphanumeric identifier of a particular product. When attached to an offer, it is a shortcut for the serial number of the product included in the offer.
     * 
     *  @property serialNumber
     *  @type Text
     */
    prototype.serialNumber = null;
    /**
     *  Schema.org/ineligibleRegion
     *  The ISO 3166-1 (ISO 3166-1 alpha-2) or ISO 3166-2 code, the place, or the GeoShape for the geo-political region(s) for which the offer or delivery charge specification is not valid, e.g. a region where the transaction is not allowed.\n\nSee also [[eligibleRegion]].
     * 
     *  @property ineligibleRegion
     *  @type GeoShape
     */
    prototype.ineligibleRegion = null;
    /**
     *  Schema.org/gtin8
     *  The [GTIN-8](http://apps.gs1.org/GDD/glossary/Pages/GTIN-8.aspx) code of the product, or the product to which the offer refers. This code is also known as EAN/UCC-8 or 8-digit EAN. See [GS1 GTIN Summary](http://www.gs1.org/barcodes/technical/idkeys/gtin) for more details.
     * 
     *  @property gtin8
     *  @type Text
     */
    prototype.gtin8 = null;
    /**
     *  Schema.org/reviews
     *  Review of the item.
     * 
     *  @property reviews
     *  @type Review
     */
    prototype.reviews = null;
    /**
     *  Schema.org/availability
     *  The availability of this item&#x2014;for example In stock, Out of stock, Pre-order, etc.
     * 
     *  @property availability
     *  @type ItemAvailability
     */
    prototype.availability = null;
    /**
     *  Schema.org/priceSpecification
     *  One or more detailed price specifications, indicating the unit price and delivery or payment charges.
     * 
     *  @property priceSpecification
     *  @type PriceSpecification
     */
    prototype.priceSpecification = null;
    /**
     *  Schema.org/inventoryLevel
     *  The current approximate inventory level for the item or items.
     * 
     *  @property inventoryLevel
     *  @type QuantitativeValue
     */
    prototype.inventoryLevel = null;
    /**
     *  Schema.org/aggregateRating
     *  The overall rating, based on a collection of reviews or ratings, of the item.
     * 
     *  @property aggregateRating
     *  @type AggregateRating
     */
    prototype.aggregateRating = null;
    /**
     *  Schema.org/eligibleTransactionVolume
     *  The transaction volume, in a monetary unit, for which the offer or price specification is valid, e.g. for indicating a minimal purchasing volume, to express free shipping above a certain order volume, or to limit the acceptance of credit cards to purchases to a certain minimal amount.
     * 
     *  @property eligibleTransactionVolume
     *  @type PriceSpecification
     */
    prototype.eligibleTransactionVolume = null;
    /**
     *  Schema.org/availableAtOrFrom
     *  The place(s) from which the offer can be obtained (e.g. store locations).
     * 
     *  @property availableAtOrFrom
     *  @type Place
     */
    prototype.availableAtOrFrom = null;
    /**
     *  Schema.org/priceCurrency
     *  The currency (in 3-letter ISO 4217 format) of the price or a price component, when attached to [[PriceSpecification]] and its subtypes.
     * 
     *  @property priceCurrency
     *  @type Text
     */
    prototype.priceCurrency = null;
    /**
     *  Schema.org/category
     *  A category for the item. Greater signs or slashes can be used to informally indicate a category hierarchy.
     * 
     *  @property category
     *  @type Text
     */
    prototype.category = null;
    /**
     *  Schema.org/priceValidUntil
     *  The date after which the price is no longer available.
     * 
     *  @property priceValidUntil
     *  @type Date
     */
    prototype.priceValidUntil = null;
    /**
     *  Schema.org/addOn
     *  An additional offer that can only be obtained in combination with the first base offer (e.g. supplements and extensions that are available for a surcharge).
     * 
     *  @property addOn
     *  @type Offer
     */
    prototype.addOn = null;
    /**
     *  Schema.org/warranty
     *  The warranty promise(s) included in the offer.
     * 
     *  @property warranty
     *  @type WarrantyPromise
     */
    prototype.warranty = null;
    /**
     *  Schema.org/includesObject
     *  This links to a node or nodes indicating the exact quantity of the products included in the offer.
     * 
     *  @property includesObject
     *  @type TypeAndQuantityNode
     */
    prototype.includesObject = null;
    /**
     *  Schema.org/eligibleQuantity
     *  The interval and unit of measurement of ordering quantities for which the offer or price specification is valid. This allows e.g. specifying that a certain freight charge is valid only for a certain quantity.
     * 
     *  @property eligibleQuantity
     *  @type QuantitativeValue
     */
    prototype.eligibleQuantity = null;
    /**
     *  Schema.org/validFrom
     *  The date when the item becomes valid.
     * 
     *  @property validFrom
     *  @type DateTime
     */
    prototype.validFrom = null;
    /**
     *  Schema.org/validThrough
     *  The date after when the item is not valid. For example the end of an offer, salary period, or a period of opening hours.
     * 
     *  @property validThrough
     *  @type DateTime
     */
    prototype.validThrough = null;
    /**
     *  Schema.org/price
     *  The offer price of a product, or of a price component when attached to PriceSpecification and its subtypes.\n\nUsage guidelines:\n\n* Use the [[priceCurrency]] property (with [ISO 4217 codes](http://en.wikipedia.org/wiki/ISO_4217#Active_codes) e.g. "USD") instead of
     *  including [ambiguous symbols](http://en.wikipedia.org/wiki/Dollar_sign#Currencies_that_use_the_dollar_or_peso_sign) such as '

var decls = "";

for (var j = 0; j < results.length; j++)
	for (var i = 0; i < results[j].body.length; i++)
		if (results[j].body[i].declarations != null)
			decls += "\nglobal." + results[j].body[i].declarations[0].id.name + " = " + results[j].body[i].declarations[0].id.name;

eval(decls);

global.forge = forge;
global.FormData = FormData;
global.antlr4 = antlr4;
global.pemJwk = pemJwk;
global.stjs = stjs;
global.base64 = base64;
global.jsonld = require('jsonld');
global.UUID = require('pure-uuid'); in the value.\n* Use '.' (Unicode 'FULL STOP' (U+002E)) rather than ',' to indicate a decimal point. Avoid using these symbols as a readability separator.\n* Note that both [RDFa](http://www.w3.org/TR/xhtml-rdfa-primer/#using-the-content-attribute) and Microdata syntax allow the use of a "content=" attribute for publishing simple machine-readable values alongside more human-friendly formatting.\n* Use values from 0123456789 (Unicode 'DIGIT ZERO' (U+0030) to 'DIGIT NINE' (U+0039)) rather than superficially similiar Unicode symbols.
     * 
     *  @property price
     *  @type Number
     */
    prototype.price = null;
    /**
     *  Schema.org/gtin14
     *  The [GTIN-14](http://apps.gs1.org/GDD/glossary/Pages/GTIN-14.aspx) code of the product, or the product to which the offer refers. See [GS1 GTIN Summary](http://www.gs1.org/barcodes/technical/idkeys/gtin) for more details.
     * 
     *  @property gtin14
     *  @type Text
     */
    prototype.gtin14 = null;
    /**
     *  Schema.org/gtin13
     *  The [GTIN-13](http://apps.gs1.org/GDD/glossary/Pages/GTIN-13.aspx) code of the product, or the product to which the offer refers. This is equivalent to 13-digit ISBN codes and EAN UCC-13. Former 12-digit UPC codes can be converted into a GTIN-13 code by simply adding a preceeding zero. See [GS1 GTIN Summary](http://www.gs1.org/barcodes/technical/idkeys/gtin) for more details.
     * 
     *  @property gtin13
     *  @type Text
     */
    prototype.gtin13 = null;
    /**
     *  Schema.org/gtin12
     *  The [GTIN-12](http://apps.gs1.org/GDD/glossary/Pages/GTIN-12.aspx) code of the product, or the product to which the offer refers. The GTIN-12 is the 12-digit GS1 Identification Key composed of a U.P.C. Company Prefix, Item Reference, and Check Digit used to identify trade items. See [GS1 GTIN Summary](http://www.gs1.org/barcodes/technical/idkeys/gtin) for more details.
     * 
     *  @property gtin12
     *  @type Text
     */
    prototype.gtin12 = null;
    /**
     *  Schema.org/seller
     *  An entity which offers (sells / leases / lends / loans) the services / goods.  A seller may also be a provider.
     * 
     *  @property seller
     *  @type Person
     */
    prototype.seller = null;
    /**
     *  Schema.org/deliveryLeadTime
     *  The typical delay between the receipt of the order and the goods either leaving the warehouse or being prepared for pickup, in case the delivery method is on site pickup.
     * 
     *  @property deliveryLeadTime
     *  @type QuantitativeValue
     */
    prototype.deliveryLeadTime = null;
    /**
     *  Schema.org/availabilityEnds
     *  The end of the availability of the product or service included in the offer.
     * 
     *  @property availabilityEnds
     *  @type DateTime
     */
    prototype.availabilityEnds = null;
    /**
     *  Schema.org/review
     *  A review of the item.
     * 
     *  @property review
     *  @type Review
     */
    prototype.review = null;
    /**
     *  Schema.org/eligibleCustomerType
     *  The type(s) of customers for which the given offer is valid.
     * 
     *  @property eligibleCustomerType
     *  @type BusinessEntityType
     */
    prototype.eligibleCustomerType = null;
    /**
     *  Schema.org/itemCondition
     *  A predefined value from OfferItemCondition or a textual description of the condition of the product or service, or the products or services included in the offer.
     * 
     *  @property itemCondition
     *  @type OfferItemCondition
     */
    prototype.itemCondition = null;
    /**
     *  Schema.org/itemOffered
     *  The item being offered.
     * 
     *  @property itemOffered
     *  @type Service
     */
    prototype.itemOffered = null;
    /**
     *  Schema.org/offeredBy
     *  A pointer to the organization or person making the offer.
     * 
     *  @property offeredBy
     *  @type Organization
     */
    prototype.offeredBy = null;
    /**
     *  Schema.org/eligibleDuration
     *  The duration for which the given offer is valid.
     * 
     *  @property eligibleDuration
     *  @type QuantitativeValue
     */
    prototype.eligibleDuration = null;
    /**
     *  Schema.org/acceptedPaymentMethod
     *  The payment method(s) accepted by seller for this offer.
     * 
     *  @property acceptedPaymentMethod
     *  @type LoanOrCredit
     */
    prototype.acceptedPaymentMethod = null;
    /**
     *  Schema.org/areaServed
     *  The geographic area where a service or offered item is provided.
     * 
     *  @property areaServed
     *  @type Place
     */
    prototype.areaServed = null;
    /**
     *  Schema.org/businessFunction
     *  The business function (e.g. sell, lease, repair, dispose) of the offer or component of a bundle (TypeAndQuantityNode). The default is http://purl.org/goodrelations/v1#Sell.
     * 
     *  @property businessFunction
     *  @type BusinessFunction
     */
    prototype.businessFunction = null;
    /**
     *  Schema.org/eligibleRegion
     *  The ISO 3166-1 (ISO 3166-1 alpha-2) or ISO 3166-2 code, the place, or the GeoShape for the geo-political region(s) for which the offer or delivery charge specification is valid.\n\nSee also [[ineligibleRegion]].
     * 
     *  @property eligibleRegion
     *  @type Text
     */
    prototype.eligibleRegion = null;
    /**
     *  Schema.org/advanceBookingRequirement
     *  The amount of time that is required between accepting the offer and the actual usage of the resource or service.
     * 
     *  @property advanceBookingRequirement
     *  @type QuantitativeValue
     */
    prototype.advanceBookingRequirement = null;
}, {availableDeliveryMethod: "DeliveryMethod", ineligibleRegion: "GeoShape", reviews: "Review", availability: "ItemAvailability", priceSpecification: "PriceSpecification", inventoryLevel: "QuantitativeValue", aggregateRating: "AggregateRating", eligibleTransactionVolume: "PriceSpecification", availableAtOrFrom: "Place", addOn: "Offer", warranty: "WarrantyPromise", includesObject: "TypeAndQuantityNode", eligibleQuantity: "QuantitativeValue", seller: "Person", deliveryLeadTime: "QuantitativeValue", review: "Review", eligibleCustomerType: "BusinessEntityType", itemCondition: "OfferItemCondition", itemOffered: "Service", offeredBy: "Organization", eligibleDuration: "QuantitativeValue", acceptedPaymentMethod: "LoanOrCredit", areaServed: "Place", businessFunction: "BusinessFunction", advanceBookingRequirement: "QuantitativeValue", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Reservation
 *  Describes a reservation for travel, dining or an event. Some reservations require tickets. \n\nNote: This type is for information about actual reservations, e.g. in confirmation emails or HTML pages with individual confirmations of reservations. For offers of tickets, restaurant reservations, flights, or rental cars, use [[Offer]].
 * 
 *  @author schema.org
 *  @class Reservation
 *  @module org.schema
 *  @extends Intangible
 */
var Reservation = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Intangible.call(this);
    this.context = "http://schema.org/";
    this.type = "Reservation";
};
Reservation = stjs.extend(Reservation, Intangible, [], function(constructor, prototype) {
    /**
     *  Schema.org/provider
     *  The service provider, service operator, or service performer; the goods producer. Another party (a seller) may offer those services or goods on behalf of the provider. A provider may also serve as the seller.
     * 
     *  @property provider
     *  @type Person
     */
    prototype.provider = null;
    /**
     *  Schema.org/programMembershipUsed
     *  Any membership in a frequent flyer, hotel loyalty program, etc. being applied to the reservation.
     * 
     *  @property programMembershipUsed
     *  @type ProgramMembership
     */
    prototype.programMembershipUsed = null;
    /**
     *  Schema.org/reservationStatus
     *  The current status of the reservation.
     * 
     *  @property reservationStatus
     *  @type ReservationStatusType
     */
    prototype.reservationStatus = null;
    /**
     *  Schema.org/underName
     *  The person or organization the reservation or ticket is for.
     * 
     *  @property underName
     *  @type Organization
     */
    prototype.underName = null;
    /**
     *  Schema.org/bookingAgent
     *  'bookingAgent' is an out-dated term indicating a 'broker' that serves as a booking agent.
     * 
     *  @property bookingAgent
     *  @type Organization
     */
    prototype.bookingAgent = null;
    /**
     *  Schema.org/totalPrice
     *  The total price for the reservation or ticket, including applicable taxes, shipping, etc.
     * 
     *  @property totalPrice
     *  @type Number
     */
    prototype.totalPrice = null;
    /**
     *  Schema.org/reservationFor
     *  The thing -- flight, event, restaurant,etc. being reserved.
     * 
     *  @property reservationFor
     *  @type Thing
     */
    prototype.reservationFor = null;
    /**
     *  Schema.org/priceCurrency
     *  The currency (in 3-letter ISO 4217 format) of the price or a price component, when attached to [[PriceSpecification]] and its subtypes.
     * 
     *  @property priceCurrency
     *  @type Text
     */
    prototype.priceCurrency = null;
    /**
     *  Schema.org/broker
     *  An entity that arranges for an exchange between a buyer and a seller.  In most cases a broker never acquires or releases ownership of a product or service involved in an exchange.  If it is not clear whether an entity is a broker, seller, or buyer, the latter two terms are preferred.
     * 
     *  @property broker
     *  @type Person
     */
    prototype.broker = null;
    /**
     *  Schema.org/modifiedTime
     *  The date and time the reservation was modified.
     * 
     *  @property modifiedTime
     *  @type DateTime
     */
    prototype.modifiedTime = null;
    /**
     *  Schema.org/bookingTime
     *  The date and time the reservation was booked.
     * 
     *  @property bookingTime
     *  @type DateTime
     */
    prototype.bookingTime = null;
    /**
     *  Schema.org/reservationId
     *  A unique identifier for the reservation.
     * 
     *  @property reservationId
     *  @type Text
     */
    prototype.reservationId = null;
    /**
     *  Schema.org/reservedTicket
     *  A ticket associated with the reservation.
     * 
     *  @property reservedTicket
     *  @type Ticket
     */
    prototype.reservedTicket = null;
}, {provider: "Person", programMembershipUsed: "ProgramMembership", reservationStatus: "ReservationStatusType", underName: "Organization", bookingAgent: "Organization", reservationFor: "Thing", broker: "Person", reservedTicket: "Ticket", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/SomeProducts
 *  A placeholder for multiple similar products of the same kind.
 * 
 *  @author schema.org
 *  @class SomeProducts
 *  @module org.schema
 *  @extends Product
 */
var SomeProducts = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Product.call(this);
    this.context = "http://schema.org/";
    this.type = "SomeProducts";
};
SomeProducts = stjs.extend(SomeProducts, Product, [], function(constructor, prototype) {
    /**
     *  Schema.org/inventoryLevel
     *  The current approximate inventory level for the item or items.
     * 
     *  @property inventoryLevel
     *  @type QuantitativeValue
     */
    prototype.inventoryLevel = null;
}, {inventoryLevel: "QuantitativeValue", manufacturer: "Organization", audience: "Audience", height: "Distance", reviews: "Review", aggregateRating: "AggregateRating", isConsumableFor: "Product", offers: "Offer", width: "Distance", additionalProperty: "PropertyValue", isAccessoryOrSparePartFor: "Product", logo: "ImageObject", weight: "QuantitativeValue", depth: "Distance", isSimilarTo: "Product", isRelatedTo: "Product", review: "Review", itemCondition: "OfferItemCondition", brand: "Organization", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/ProductModel
 *  A datasheet or vendor specification of a product (in the sense of a prototypical description).
 * 
 *  @author schema.org
 *  @class ProductModel
 *  @module org.schema
 *  @extends Product
 */
var ProductModel = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Product.call(this);
    this.context = "http://schema.org/";
    this.type = "ProductModel";
};
ProductModel = stjs.extend(ProductModel, Product, [], function(constructor, prototype) {
    /**
     *  Schema.org/predecessorOf
     *  A pointer from a previous, often discontinued variant of the product to its newer variant.
     * 
     *  @property predecessorOf
     *  @type ProductModel
     */
    prototype.predecessorOf = null;
    /**
     *  Schema.org/successorOf
     *  A pointer from a newer variant of a product  to its previous, often discontinued predecessor.
     * 
     *  @property successorOf
     *  @type ProductModel
     */
    prototype.successorOf = null;
    /**
     *  Schema.org/isVariantOf
     *  A pointer to a base product from which this product is a variant. It is safe to infer that the variant inherits all product features from the base model, unless defined locally. This is not transitive.
     * 
     *  @property isVariantOf
     *  @type ProductModel
     */
    prototype.isVariantOf = null;
}, {predecessorOf: "ProductModel", successorOf: "ProductModel", isVariantOf: "ProductModel", manufacturer: "Organization", audience: "Audience", height: "Distance", reviews: "Review", aggregateRating: "AggregateRating", isConsumableFor: "Product", offers: "Offer", width: "Distance", additionalProperty: "PropertyValue", isAccessoryOrSparePartFor: "Product", logo: "ImageObject", weight: "QuantitativeValue", depth: "Distance", isSimilarTo: "Product", isRelatedTo: "Product", review: "Review", itemCondition: "OfferItemCondition", brand: "Organization", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Vehicle
 *  A vehicle is a device that is designed or used to transport people or cargo over land, water, air, or through space.
 * 
 *  @author schema.org
 *  @class Vehicle
 *  @module org.schema
 *  @extends Product
 */
var Vehicle = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Product.call(this);
    this.context = "http://schema.org/";
    this.type = "Vehicle";
};
Vehicle = stjs.extend(Vehicle, Product, [], function(constructor, prototype) {
    /**
     *  Schema.org/vehicleSpecialUsage
     *  Indicates whether the vehicle has been used for special purposes, like commercial rental, driving school, or as a taxi. The legislation in many countries requires this information to be revealed when offering a car for sale.
     * 
     *  @property vehicleSpecialUsage
     *  @type Text
     */
    prototype.vehicleSpecialUsage = null;
    /**
     *  Schema.org/productionDate
     *  The date of production of the item, e.g. vehicle.
     * 
     *  @property productionDate
     *  @type Date
     */
    prototype.productionDate = null;
    /**
     *  Schema.org/numberOfForwardGears
     *  The total number of forward gears available for the transmission system of the vehicle.\n\nTypical unit code(s): C62
     * 
     *  @property numberOfForwardGears
     *  @type Number
     */
    prototype.numberOfForwardGears = null;
    /**
     *  Schema.org/mileageFromOdometer
     *  The total distance travelled by the particular vehicle since its initial production, as read from its odometer.\n\nTypical unit code(s): KMT for kilometers, SMI for statute miles
     * 
     *  @property mileageFromOdometer
     *  @type QuantitativeValue
     */
    prototype.mileageFromOdometer = null;
    /**
     *  Schema.org/cargoVolume
     *  The available volume for cargo or luggage. For automobiles, this is usually the trunk volume.\n\nTypical unit code(s): LTR for liters, FTQ for cubic foot/feet\n\nNote: You can use [[minValue]] and [[maxValue]] to indicate ranges.
     * 
     *  @property cargoVolume
     *  @type QuantitativeValue
     */
    prototype.cargoVolume = null;
    /**
     *  Schema.org/vehicleInteriorColor
     *  The color or color combination of the interior of the vehicle.
     * 
     *  @property vehicleInteriorColor
     *  @type Text
     */
    prototype.vehicleInteriorColor = null;
    /**
     *  Schema.org/steeringPosition
     *  The position of the steering wheel or similar device (mostly for cars).
     * 
     *  @property steeringPosition
     *  @type SteeringPositionValue
     */
    prototype.steeringPosition = null;
    /**
     *  Schema.org/vehicleSeatingCapacity
     *  The number of passengers that can be seated in the vehicle, both in terms of the physical space available, and in terms of limitations set by law.\n\nTypical unit code(s): C62 for persons.
     * 
     *  @property vehicleSeatingCapacity
     *  @type QuantitativeValue
     */
    prototype.vehicleSeatingCapacity = null;
    /**
     *  Schema.org/vehicleEngine
     *  Information about the engine or engines of the vehicle.
     * 
     *  @property vehicleEngine
     *  @type EngineSpecification
     */
    prototype.vehicleEngine = null;
    /**
     *  Schema.org/vehicleModelDate
     *  The release date of a vehicle model (often used to differentiate versions of the same make and model).
     * 
     *  @property vehicleModelDate
     *  @type Date
     */
    prototype.vehicleModelDate = null;
    /**
     *  Schema.org/numberOfDoors
     *  The number of doors.\n\nTypical unit code(s): C62
     * 
     *  @property numberOfDoors
     *  @type Number
     */
    prototype.numberOfDoors = null;
    /**
     *  Schema.org/vehicleConfiguration
     *  A short text indicating the configuration of the vehicle, e.g. '5dr hatchback ST 2.5 MT 225 hp' or 'limited edition'.
     * 
     *  @property vehicleConfiguration
     *  @type Text
     */
    prototype.vehicleConfiguration = null;
    /**
     *  Schema.org/fuelType
     *  The type of fuel suitable for the engine or engines of the vehicle. If the vehicle has only one engine, this property can be attached directly to the vehicle.
     * 
     *  @property fuelType
     *  @type Text
     */
    prototype.fuelType = null;
    /**
     *  Schema.org/vehicleIdentificationNumber
     *  The Vehicle Identification Number (VIN) is a unique serial number used by the automotive industry to identify individual motor vehicles.
     * 
     *  @property vehicleIdentificationNumber
     *  @type Text
     */
    prototype.vehicleIdentificationNumber = null;
    /**
     *  Schema.org/fuelConsumption
     *  The amount of fuel consumed for traveling a particular distance or temporal duration with the given vehicle (e.g. liters per 100 km).\n\n* Note 1: There are unfortunately no standard unit codes for liters per 100 km.  Use [[unitText]] to indicate the unit of measurement, e.g. L/100 km.\n* Note 2: There are two ways of indicating the fuel consumption, [[fuelConsumption]] (e.g. 8 liters per 100 km) and [[fuelEfficiency]] (e.g. 30 miles per gallon). They are reciprocal.\n* Note 3: Often, the absolute value is useful only when related to driving speed ("at 80 km/h") or usage pattern ("city traffic"). You can use [[valueReference]] to link the value for the fuel consumption to another value.
     * 
     *  @property fuelConsumption
     *  @type QuantitativeValue
     */
    prototype.fuelConsumption = null;
    /**
     *  Schema.org/numberOfPreviousOwners
     *  The number of owners of the vehicle, including the current one.\n\nTypical unit code(s): C62
     * 
     *  @property numberOfPreviousOwners
     *  @type QuantitativeValue
     */
    prototype.numberOfPreviousOwners = null;
    /**
     *  Schema.org/fuelEfficiency
     *  The distance traveled per unit of fuel used; most commonly miles per gallon (mpg) or kilometers per liter (km/L).\n\n* Note 1: There are unfortunately no standard unit codes for miles per gallon or kilometers per liter. Use [[unitText]] to indicate the unit of measurement, e.g. mpg or km/L.\n* Note 2: There are two ways of indicating the fuel consumption, [[fuelConsumption]] (e.g. 8 liters per 100 km) and [[fuelEfficiency]] (e.g. 30 miles per gallon). They are reciprocal.\n* Note 3: Often, the absolute value is useful only when related to driving speed ("at 80 km/h") or usage pattern ("city traffic"). You can use [[valueReference]] to link the value for the fuel economy to another value.
     * 
     *  @property fuelEfficiency
     *  @type QuantitativeValue
     */
    prototype.fuelEfficiency = null;
    /**
     *  Schema.org/numberOfAxles
     *  The number of axles.\n\nTypical unit code(s): C62
     * 
     *  @property numberOfAxles
     *  @type QuantitativeValue
     */
    prototype.numberOfAxles = null;
    /**
     *  Schema.org/vehicleInteriorType
     *  The type or material of the interior of the vehicle (e.g. synthetic fabric, leather, wood, etc.). While most interior types are characterized by the material used, an interior type can also be based on vehicle usage or target audience.
     * 
     *  @property vehicleInteriorType
     *  @type Text
     */
    prototype.vehicleInteriorType = null;
    /**
     *  Schema.org/numberOfAirbags
     *  The number or type of airbags in the vehicle.
     * 
     *  @property numberOfAirbags
     *  @type Text
     */
    prototype.numberOfAirbags = null;
    /**
     *  Schema.org/vehicleTransmission
     *  The type of component used for transmitting the power from a rotating power source to the wheels or other relevant component(s) ("gearbox" for cars).
     * 
     *  @property vehicleTransmission
     *  @type Text
     */
    prototype.vehicleTransmission = null;
    /**
     *  Schema.org/dateVehicleFirstRegistered
     *  The date of the first registration of the vehicle with the respective public authorities.
     * 
     *  @property dateVehicleFirstRegistered
     *  @type Date
     */
    prototype.dateVehicleFirstRegistered = null;
    /**
     *  Schema.org/purchaseDate
     *  The date the item e.g. vehicle was purchased by the current owner.
     * 
     *  @property purchaseDate
     *  @type Date
     */
    prototype.purchaseDate = null;
    /**
     *  Schema.org/knownVehicleDamages
     *  A textual description of known damages, both repaired and unrepaired.
     * 
     *  @property knownVehicleDamages
     *  @type Text
     */
    prototype.knownVehicleDamages = null;
    /**
     *  Schema.org/driveWheelConfiguration
     *  The drive wheel configuration, i.e. which roadwheels will receive torque from the vehicle's engine via the drivetrain.
     * 
     *  @property driveWheelConfiguration
     *  @type DriveWheelConfigurationValue
     */
    prototype.driveWheelConfiguration = null;
}, {mileageFromOdometer: "QuantitativeValue", cargoVolume: "QuantitativeValue", steeringPosition: "SteeringPositionValue", vehicleSeatingCapacity: "QuantitativeValue", vehicleEngine: "EngineSpecification", fuelConsumption: "QuantitativeValue", numberOfPreviousOwners: "QuantitativeValue", fuelEfficiency: "QuantitativeValue", numberOfAxles: "QuantitativeValue", driveWheelConfiguration: "DriveWheelConfigurationValue", manufacturer: "Organization", audience: "Audience", height: "Distance", reviews: "Review", aggregateRating: "AggregateRating", isConsumableFor: "Product", offers: "Offer", width: "Distance", additionalProperty: "PropertyValue", isAccessoryOrSparePartFor: "Product", logo: "ImageObject", weight: "QuantitativeValue", depth: "Distance", isSimilarTo: "Product", isRelatedTo: "Product", review: "Review", itemCondition: "OfferItemCondition", brand: "Organization", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/IndividualProduct
 *  A single, identifiable product instance (e.g. a laptop with a particular serial number).
 * 
 *  @author schema.org
 *  @class IndividualProduct
 *  @module org.schema
 *  @extends Product
 */
var IndividualProduct = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Product.call(this);
    this.context = "http://schema.org/";
    this.type = "IndividualProduct";
};
IndividualProduct = stjs.extend(IndividualProduct, Product, [], function(constructor, prototype) {
    /**
     *  Schema.org/serialNumber
     *  The serial number or any alphanumeric identifier of a particular product. When attached to an offer, it is a shortcut for the serial number of the product included in the offer.
     * 
     *  @property serialNumber
     *  @type Text
     */
    prototype.serialNumber = null;
}, {manufacturer: "Organization", audience: "Audience", height: "Distance", reviews: "Review", aggregateRating: "AggregateRating", isConsumableFor: "Product", offers: "Offer", width: "Distance", additionalProperty: "PropertyValue", isAccessoryOrSparePartFor: "Product", logo: "ImageObject", weight: "QuantitativeValue", depth: "Distance", isSimilarTo: "Product", isRelatedTo: "Product", review: "Review", itemCondition: "OfferItemCondition", brand: "Organization", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/DigitalDocument
 *  An electronic file or document.
 * 
 *  @author schema.org
 *  @class DigitalDocument
 *  @module org.schema
 *  @extends CreativeWork
 */
var DigitalDocument = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CreativeWork.call(this);
    this.context = "http://schema.org/";
    this.type = "DigitalDocument";
};
DigitalDocument = stjs.extend(DigitalDocument, CreativeWork, [], function(constructor, prototype) {
    /**
     *  Schema.org/hasDigitalDocumentPermission
     *  A permission related to the access to this document (e.g. permission to read or write an electronic document). For a public document, specify a grantee with an Audience with audienceType equal to "public".
     * 
     *  @property hasDigitalDocumentPermission
     *  @type DigitalDocumentPermission
     */
    prototype.hasDigitalDocumentPermission = null;
}, {hasDigitalDocumentPermission: "DigitalDocumentPermission", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Season
 *  A media season e.g. tv, radio, video game etc.
 * 
 *  @author schema.org
 *  @class Season
 *  @module org.schema
 *  @extends CreativeWork
 */
var Season = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CreativeWork.call(this);
    this.context = "http://schema.org/";
    this.type = "Season";
};
Season = stjs.extend(Season, CreativeWork, [], null, {about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Clip
 *  A short TV or radio program or a segment/part of a program.
 * 
 *  @author schema.org
 *  @class Clip
 *  @module org.schema
 *  @extends CreativeWork
 */
var Clip = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CreativeWork.call(this);
    this.context = "http://schema.org/";
    this.type = "Clip";
};
Clip = stjs.extend(Clip, CreativeWork, [], function(constructor, prototype) {
    /**
     *  Schema.org/actor
     *  An actor, e.g. in tv, radio, movie, video games etc., or in an event. Actors can be associated with individual items or with a series, episode, clip.
     * 
     *  @property actor
     *  @type Person
     */
    prototype.actor = null;
    /**
     *  Schema.org/partOfSeries
     *  The series to which this episode or season belongs.
     * 
     *  @property partOfSeries
     *  @type CreativeWorkSeries
     */
    prototype.partOfSeries = null;
    /**
     *  Schema.org/partOfEpisode
     *  The episode to which this clip belongs.
     * 
     *  @property partOfEpisode
     *  @type Episode
     */
    prototype.partOfEpisode = null;
    /**
     *  Schema.org/partOfSeason
     *  The season to which this episode belongs.
     * 
     *  @property partOfSeason
     *  @type CreativeWorkSeason
     */
    prototype.partOfSeason = null;
    /**
     *  Schema.org/musicBy
     *  The composer of the soundtrack.
     * 
     *  @property musicBy
     *  @type Person
     */
    prototype.musicBy = null;
    /**
     *  Schema.org/directors
     *  A director of e.g. tv, radio, movie, video games etc. content. Directors can be associated with individual items or with a series, episode, clip.
     * 
     *  @property directors
     *  @type Person
     */
    prototype.directors = null;
    /**
     *  Schema.org/director
     *  A director of e.g. tv, radio, movie, video gaming etc. content, or of an event. Directors can be associated with individual items or with a series, episode, clip.
     * 
     *  @property director
     *  @type Person
     */
    prototype.director = null;
    /**
     *  Schema.org/actors
     *  An actor, e.g. in tv, radio, movie, video games etc. Actors can be associated with individual items or with a series, episode, clip.
     * 
     *  @property actors
     *  @type Person
     */
    prototype.actors = null;
    /**
     *  Schema.org/clipNumber
     *  Position of the clip within an ordered group of clips.
     * 
     *  @property clipNumber
     *  @type Integer
     */
    prototype.clipNumber = null;
}, {actor: "Person", partOfSeries: "CreativeWorkSeries", partOfEpisode: "Episode", partOfSeason: "CreativeWorkSeason", musicBy: "Person", directors: "Person", director: "Person", actors: "Person", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Map
 *  A map.
 * 
 *  @author schema.org
 *  @class Map
 *  @module org.schema
 *  @extends CreativeWork
 */
var SchemaMap = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CreativeWork.call(this);
    this.context = "http://schema.org/";
    this.type = "Map";
};
SchemaMap = stjs.extend(SchemaMap, CreativeWork, [], function(constructor, prototype) {
    /**
     *  Schema.org/mapType
     *  Indicates the kind of Map, from the MapCategoryType Enumeration.
     * 
     *  @property mapType
     *  @type MapCategoryType
     */
    prototype.mapType = null;
}, {mapType: "MapCategoryType", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Menu
 *  A structured representation of food or drink items available from a FoodEstablishment.
 * 
 *  @author schema.org
 *  @class Menu
 *  @module org.schema
 *  @extends CreativeWork
 */
var Menu = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CreativeWork.call(this);
    this.context = "http://schema.org/";
    this.type = "Menu";
};
Menu = stjs.extend(Menu, CreativeWork, [], function(constructor, prototype) {
    /**
     *  Schema.org/hasMenuItem
     *  A food or drink item contained in a menu or menu section.
     * 
     *  @property hasMenuItem
     *  @type MenuItem
     */
    prototype.hasMenuItem = null;
    /**
     *  Schema.org/hasMenuSection
     *  A subgrouping of the menu (by dishes, course, serving time period, etc.).
     * 
     *  @property hasMenuSection
     *  @type MenuSection
     */
    prototype.hasMenuSection = null;
}, {hasMenuItem: "MenuItem", hasMenuSection: "MenuSection", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Code
 *  Computer programming source code. Example: Full (compile ready) solutions, code snippet samples, scripts, templates.
 * 
 *  @author schema.org
 *  @class Code
 *  @module org.schema
 *  @extends CreativeWork
 */
var Code = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CreativeWork.call(this);
    this.context = "http://schema.org/";
    this.type = "Code";
};
Code = stjs.extend(Code, CreativeWork, [], null, {about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Painting
 *  A painting.
 * 
 *  @author schema.org
 *  @class Painting
 *  @module org.schema
 *  @extends CreativeWork
 */
var Painting = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CreativeWork.call(this);
    this.context = "http://schema.org/";
    this.type = "Painting";
};
Painting = stjs.extend(Painting, CreativeWork, [], null, {about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Game
 *  The Game type represents things which are games. These are typically rule-governed recreational activities, e.g. role-playing games in which players assume the role of characters in a fictional setting.
 * 
 *  @author schema.org
 *  @class Game
 *  @module org.schema
 *  @extends CreativeWork
 */
var Game = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CreativeWork.call(this);
    this.context = "http://schema.org/";
    this.type = "Game";
};
Game = stjs.extend(Game, CreativeWork, [], function(constructor, prototype) {
    /**
     *  Schema.org/gameItem
     *  An item is an object within the game world that can be collected by a player or, occasionally, a non-player character.
     * 
     *  @property gameItem
     *  @type Thing
     */
    prototype.gameItem = null;
    /**
     *  Schema.org/characterAttribute
     *  A piece of data that represents a particular aspect of a fictional character (skill, power, character points, advantage, disadvantage).
     * 
     *  @property characterAttribute
     *  @type Thing
     */
    prototype.characterAttribute = null;
    /**
     *  Schema.org/gameLocation
     *  Real or fictional location of the game (or part of game).
     * 
     *  @property gameLocation
     *  @type URL
     */
    prototype.gameLocation = null;
    /**
     *  Schema.org/quest
     *  The task that a player-controlled character, or group of characters may complete in order to gain a reward.
     * 
     *  @property quest
     *  @type Thing
     */
    prototype.quest = null;
    /**
     *  Schema.org/numberOfPlayers
     *  Indicate how many people can play this game (minimum, maximum, or range).
     * 
     *  @property numberOfPlayers
     *  @type QuantitativeValue
     */
    prototype.numberOfPlayers = null;
}, {gameItem: "Thing", characterAttribute: "Thing", quest: "Thing", numberOfPlayers: "QuantitativeValue", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/WebSite
 *  A WebSite is a set of related web pages and other items typically served from a single web domain and accessible via URLs.
 * 
 *  @author schema.org
 *  @class WebSite
 *  @module org.schema
 *  @extends CreativeWork
 */
var WebSite = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CreativeWork.call(this);
    this.context = "http://schema.org/";
    this.type = "WebSite";
};
WebSite = stjs.extend(WebSite, CreativeWork, [], null, {about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/SoftwareApplication
 *  A software application.
 * 
 *  @author schema.org
 *  @class SoftwareApplication
 *  @module org.schema
 *  @extends CreativeWork
 */
var SoftwareApplication = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CreativeWork.call(this);
    this.context = "http://schema.org/";
    this.type = "SoftwareApplication";
};
SoftwareApplication = stjs.extend(SoftwareApplication, CreativeWork, [], function(constructor, prototype) {
    /**
     *  Schema.org/downloadUrl
     *  If the file can be downloaded, URL to download the binary.
     * 
     *  @property downloadUrl
     *  @type URL
     */
    prototype.downloadUrl = null;
    /**
     *  Schema.org/softwareRequirements
     *  Component dependency requirements for application. This includes runtime environments and shared libraries that are not included in the application distribution package, but required to run the application (Examples: DirectX, Java or .NET runtime).
     * 
     *  @property softwareRequirements
     *  @type Text
     */
    prototype.softwareRequirements = null;
    /**
     *  Schema.org/permissions
     *  Permission(s) required to run the app (for example, a mobile app may require full internet access or may run only on wifi).
     * 
     *  @property permissions
     *  @type Text
     */
    prototype.permissions = null;
    /**
     *  Schema.org/processorRequirements
     *  Processor architecture required to run the application (e.g. IA64).
     * 
     *  @property processorRequirements
     *  @type Text
     */
    prototype.processorRequirements = null;
    /**
     *  Schema.org/availableOnDevice
     *  Device required to run the application. Used in cases where a specific make/model is required to run the application.
     * 
     *  @property availableOnDevice
     *  @type Text
     */
    prototype.availableOnDevice = null;
    /**
     *  Schema.org/featureList
     *  Features or modules provided by this application (and possibly required by other applications).
     * 
     *  @property featureList
     *  @type URL
     */
    prototype.featureList = null;
    /**
     *  Schema.org/applicationSubCategory
     *  Subcategory of the application, e.g. 'Arcade Game'.
     * 
     *  @property applicationSubCategory
     *  @type URL
     */
    prototype.applicationSubCategory = null;
    /**
     *  Schema.org/requirements
     *  Component dependency requirements for application. This includes runtime environments and shared libraries that are not included in the application distribution package, but required to run the application (Examples: DirectX, Java or .NET runtime).
     * 
     *  @property requirements
     *  @type Text
     */
    prototype.requirements = null;
    /**
     *  Schema.org/device
     *  Device required to run the application. Used in cases where a specific make/model is required to run the application.
     * 
     *  @property device
     *  @type Text
     */
    prototype.device = null;
    /**
     *  Schema.org/applicationCategory
     *  Type of software application, e.g. 'Game, Multimedia'.
     * 
     *  @property applicationCategory
     *  @type Text
     */
    prototype.applicationCategory = null;
    /**
     *  Schema.org/softwareVersion
     *  Version of the software instance.
     * 
     *  @property softwareVersion
     *  @type Text
     */
    prototype.softwareVersion = null;
    /**
     *  Schema.org/storageRequirements
     *  Storage requirements (free space required).
     * 
     *  @property storageRequirements
     *  @type Text
     */
    prototype.storageRequirements = null;
    /**
     *  Schema.org/applicationSuite
     *  The name of the application suite to which the application belongs (e.g. Excel belongs to Office).
     * 
     *  @property applicationSuite
     *  @type Text
     */
    prototype.applicationSuite = null;
    /**
     *  Schema.org/memoryRequirements
     *  Minimum memory requirements.
     * 
     *  @property memoryRequirements
     *  @type Text
     */
    prototype.memoryRequirements = null;
    /**
     *  Schema.org/screenshot
     *  A link to a screenshot image of the app.
     * 
     *  @property screenshot
     *  @type URL
     */
    prototype.screenshot = null;
    /**
     *  Schema.org/countriesSupported
     *  Countries for which the application is supported. You can also provide the two-letter ISO 3166-1 alpha-2 country code.
     * 
     *  @property countriesSupported
     *  @type Text
     */
    prototype.countriesSupported = null;
    /**
     *  Schema.org/softwareHelp
     *  Software application help.
     * 
     *  @property softwareHelp
     *  @type CreativeWork
     */
    prototype.softwareHelp = null;
    /**
     *  Schema.org/softwareAddOn
     *  Additional content for a software application.
     * 
     *  @property softwareAddOn
     *  @type SoftwareApplication
     */
    prototype.softwareAddOn = null;
    /**
     *  Schema.org/releaseNotes
     *  Description of what changed in this version.
     * 
     *  @property releaseNotes
     *  @type Text
     */
    prototype.releaseNotes = null;
    /**
     *  Schema.org/supportingData
     *  Supporting data for a SoftwareApplication.
     * 
     *  @property supportingData
     *  @type DataFeed
     */
    prototype.supportingData = null;
    /**
     *  Schema.org/countriesNotSupported
     *  Countries for which the application is not supported. You can also provide the two-letter ISO 3166-1 alpha-2 country code.
     * 
     *  @property countriesNotSupported
     *  @type Text
     */
    prototype.countriesNotSupported = null;
    /**
     *  Schema.org/operatingSystem
     *  Operating systems supported (Windows 7, OSX 10.6, Android 1.6).
     * 
     *  @property operatingSystem
     *  @type Text
     */
    prototype.operatingSystem = null;
    /**
     *  Schema.org/fileSize
     *  Size of the application / package (e.g. 18MB). In the absence of a unit (MB, KB etc.), KB will be assumed.
     * 
     *  @property fileSize
     *  @type Text
     */
    prototype.fileSize = null;
    /**
     *  Schema.org/installUrl
     *  URL at which the app may be installed, if different from the URL of the item.
     * 
     *  @property installUrl
     *  @type URL
     */
    prototype.installUrl = null;
}, {softwareHelp: "CreativeWork", softwareAddOn: "SoftwareApplication", supportingData: "DataFeed", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Question
 *  A specific question - e.g. from a user seeking answers online, or collected in a Frequently Asked Questions (FAQ) document.
 * 
 *  @author schema.org
 *  @class Question
 *  @module org.schema
 *  @extends CreativeWork
 */
var Question = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CreativeWork.call(this);
    this.context = "http://schema.org/";
    this.type = "Question";
};
Question = stjs.extend(Question, CreativeWork, [], function(constructor, prototype) {
    /**
     *  Schema.org/answerCount
     *  The number of answers this question has received.
     * 
     *  @property answerCount
     *  @type Integer
     */
    prototype.answerCount = null;
    /**
     *  Schema.org/acceptedAnswer
     *  The answer that has been accepted as best, typically on a Question/Answer site. Sites vary in their selection mechanisms, e.g. drawing on community opinion and/or the view of the Question author.
     * 
     *  @property acceptedAnswer
     *  @type Answer
     */
    prototype.acceptedAnswer = null;
    /**
     *  Schema.org/upvoteCount
     *  The number of upvotes this question, answer or comment has received from the community.
     * 
     *  @property upvoteCount
     *  @type Integer
     */
    prototype.upvoteCount = null;
    /**
     *  Schema.org/suggestedAnswer
     *  An answer (possibly one of several, possibly incorrect) to a Question, e.g. on a Question/Answer site.
     * 
     *  @property suggestedAnswer
     *  @type Answer
     */
    prototype.suggestedAnswer = null;
    /**
     *  Schema.org/downvoteCount
     *  The number of downvotes this question, answer or comment has received from the community.
     * 
     *  @property downvoteCount
     *  @type Integer
     */
    prototype.downvoteCount = null;
}, {acceptedAnswer: "Answer", suggestedAnswer: "Answer", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Dataset
 *  A body of structured information describing some topic(s) of interest.
 * 
 *  @author schema.org
 *  @class Dataset
 *  @module org.schema
 *  @extends CreativeWork
 */
var Dataset = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CreativeWork.call(this);
    this.context = "http://schema.org/";
    this.type = "Dataset";
};
Dataset = stjs.extend(Dataset, CreativeWork, [], function(constructor, prototype) {
    /**
     *  Schema.org/catalog
     *  A data catalog which contains this dataset.
     * 
     *  @property catalog
     *  @type DataCatalog
     */
    prototype.catalog = null;
    /**
     *  Schema.org/includedInDataCatalog
     *  A data catalog which contains this dataset.
     * 
     *  @property includedInDataCatalog
     *  @type DataCatalog
     */
    prototype.includedInDataCatalog = null;
    /**
     *  Schema.org/datasetTimeInterval
     *  The range of temporal applicability of a dataset, e.g. for a 2011 census dataset, the year 2011 (in ISO 8601 time interval format).
     * 
     *  @property datasetTimeInterval
     *  @type DateTime
     */
    prototype.datasetTimeInterval = null;
    /**
     *  Schema.org/spatial
     *  The range of spatial applicability of a dataset, e.g. for a dataset of New York weather, the state of New York.
     * 
     *  @property spatial
     *  @type Place
     */
    prototype.spatial = null;
    /**
     *  Schema.org/temporal
     *  The range of temporal applicability of a dataset, e.g. for a 2011 census dataset, the year 2011 (in ISO 8601 time interval format).
     * 
     *  @property temporal
     *  @type DateTime
     */
    prototype.temporal = null;
    /**
     *  Schema.org/includedDataCatalog
     *  A data catalog which contains this dataset (this property was previously 'catalog', preferred name is now 'includedInDataCatalog').
     * 
     *  @property includedDataCatalog
     *  @type DataCatalog
     */
    prototype.includedDataCatalog = null;
    /**
     *  Schema.org/distribution
     *  A downloadable form of this dataset, at a specific location, in a specific format.
     * 
     *  @property distribution
     *  @type DataDownload
     */
    prototype.distribution = null;
}, {catalog: "DataCatalog", includedInDataCatalog: "DataCatalog", spatial: "Place", includedDataCatalog: "DataCatalog", distribution: "DataDownload", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/VisualArtwork
 *  A work of art that is primarily visual in character.
 * 
 *  @author schema.org
 *  @class VisualArtwork
 *  @module org.schema
 *  @extends CreativeWork
 */
var VisualArtwork = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CreativeWork.call(this);
    this.context = "http://schema.org/";
    this.type = "VisualArtwork";
};
VisualArtwork = stjs.extend(VisualArtwork, CreativeWork, [], function(constructor, prototype) {
    /**
     *  Schema.org/height
     *  The height of the item.
     * 
     *  @property height
     *  @type Distance
     */
    prototype.height = null;
    /**
     *  Schema.org/artMedium
     *  The material used. (e.g. Oil, Watercolour, Acrylic, Linoprint, Marble, Cyanotype, Digital, Lithograph, DryPoint, Intaglio, Pastel, Woodcut, Pencil, Mixed Media, etc.)
     * 
     *  @property artMedium
     *  @type Text
     */
    prototype.artMedium = null;
    /**
     *  Schema.org/artform
     *  e.g. Painting, Drawing, Sculpture, Print, Photograph, Assemblage, Collage, etc.
     * 
     *  @property artform
     *  @type Text
     */
    prototype.artform = null;
    /**
     *  Schema.org/artworkSurface
     *  The supporting materials for the artwork, e.g. Canvas, Paper, Wood, Board, etc.
     * 
     *  @property artworkSurface
     *  @type Text
     */
    prototype.artworkSurface = null;
    /**
     *  Schema.org/artEdition
     *  The number of copies when multiple copies of a piece of artwork are produced - e.g. for a limited edition of 20 prints, 'artEdition' refers to the total number of copies (in this example "20").
     * 
     *  @property artEdition
     *  @type Integer
     */
    prototype.artEdition = null;
    /**
     *  Schema.org/width
     *  The width of the item.
     * 
     *  @property width
     *  @type Distance
     */
    prototype.width = null;
    /**
     *  Schema.org/surface
     *  A material used as a surface in some artwork, e.g. Canvas, Paper, Wood, Board, etc.
     * 
     *  @property surface
     *  @type Text
     */
    prototype.surface = null;
    /**
     *  Schema.org/depth
     *  The depth of the item.
     * 
     *  @property depth
     *  @type Distance
     */
    prototype.depth = null;
}, {height: "Distance", width: "Distance", depth: "Distance", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Article
 *  An article, such as a news article or piece of investigative report. Newspapers and magazines have articles of many different types and this is intended to cover them all.\n\nSee also [blog post](http://blog.schema.org/2014/09/schemaorg-support-for-bibliographic_2.html).
 * 
 *  @author schema.org
 *  @class Article
 *  @module org.schema
 *  @extends CreativeWork
 */
var Article = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CreativeWork.call(this);
    this.context = "http://schema.org/";
    this.type = "Article";
};
Article = stjs.extend(Article, CreativeWork, [], function(constructor, prototype) {
    /**
     *  Schema.org/pagination
     *  Any description of pages that is not separated into pageStart and pageEnd; for example, "1-6, 9, 55" or "10-12, 46-49".
     * 
     *  @property pagination
     *  @type Text
     */
    prototype.pagination = null;
    /**
     *  Schema.org/pageEnd
     *  The page on which the work ends; for example "138" or "xvi".
     * 
     *  @property pageEnd
     *  @type Integer
     */
    prototype.pageEnd = null;
    /**
     *  Schema.org/articleSection
     *  Articles may belong to one or more 'sections' in a magazine or newspaper, such as Sports, Lifestyle, etc.
     * 
     *  @property articleSection
     *  @type Text
     */
    prototype.articleSection = null;
    /**
     *  Schema.org/articleBody
     *  The actual body of the article.
     * 
     *  @property articleBody
     *  @type Text
     */
    prototype.articleBody = null;
    /**
     *  Schema.org/pageStart
     *  The page on which the work starts; for example "135" or "xiii".
     * 
     *  @property pageStart
     *  @type Integer
     */
    prototype.pageStart = null;
    /**
     *  Schema.org/wordCount
     *  The number of words in the text of the Article.
     * 
     *  @property wordCount
     *  @type Integer
     */
    prototype.wordCount = null;
}, {about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/TVSeries
 *  CreativeWorkSeries dedicated to TV broadcast and associated online delivery.
 * 
 *  @author schema.org
 *  @class TVSeries
 *  @module org.schema
 *  @extends CreativeWork
 */
var TVSeries = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CreativeWork.call(this);
    this.context = "http://schema.org/";
    this.type = "TVSeries";
};
TVSeries = stjs.extend(TVSeries, CreativeWork, [], function(constructor, prototype) {
    /**
     *  Schema.org/seasons
     *  A season in a media series.
     * 
     *  @property seasons
     *  @type CreativeWorkSeason
     */
    prototype.seasons = null;
    /**
     *  Schema.org/actor
     *  An actor, e.g. in tv, radio, movie, video games etc., or in an event. Actors can be associated with individual items or with a series, episode, clip.
     * 
     *  @property actor
     *  @type Person
     */
    prototype.actor = null;
    /**
     *  Schema.org/numberOfEpisodes
     *  The number of episodes in this season or series.
     * 
     *  @property numberOfEpisodes
     *  @type Integer
     */
    prototype.numberOfEpisodes = null;
    /**
     *  Schema.org/trailer
     *  The trailer of a movie or tv/radio series, season, episode, etc.
     * 
     *  @property trailer
     *  @type VideoObject
     */
    prototype.trailer = null;
    /**
     *  Schema.org/season
     *  A season in a media series.
     * 
     *  @property season
     *  @type CreativeWorkSeason
     */
    prototype.season = null;
    /**
     *  Schema.org/episodes
     *  An episode of a TV/radio series or season.
     * 
     *  @property episodes
     *  @type Episode
     */
    prototype.episodes = null;
    /**
     *  Schema.org/countryOfOrigin
     *  The country of the principal offices of the production company or individual responsible for the movie or program.
     * 
     *  @property countryOfOrigin
     *  @type Country
     */
    prototype.countryOfOrigin = null;
    /**
     *  Schema.org/musicBy
     *  The composer of the soundtrack.
     * 
     *  @property musicBy
     *  @type Person
     */
    prototype.musicBy = null;
    /**
     *  Schema.org/containsSeason
     *  A season that is part of the media series.
     * 
     *  @property containsSeason
     *  @type CreativeWorkSeason
     */
    prototype.containsSeason = null;
    /**
     *  Schema.org/directors
     *  A director of e.g. tv, radio, movie, video games etc. content. Directors can be associated with individual items or with a series, episode, clip.
     * 
     *  @property directors
     *  @type Person
     */
    prototype.directors = null;
    /**
     *  Schema.org/numberOfSeasons
     *  The number of seasons in this series.
     * 
     *  @property numberOfSeasons
     *  @type Integer
     */
    prototype.numberOfSeasons = null;
    /**
     *  Schema.org/director
     *  A director of e.g. tv, radio, movie, video gaming etc. content, or of an event. Directors can be associated with individual items or with a series, episode, clip.
     * 
     *  @property director
     *  @type Person
     */
    prototype.director = null;
    /**
     *  Schema.org/productionCompany
     *  The production company or studio responsible for the item e.g. series, video game, episode etc.
     * 
     *  @property productionCompany
     *  @type Organization
     */
    prototype.productionCompany = null;
    /**
     *  Schema.org/actors
     *  An actor, e.g. in tv, radio, movie, video games etc. Actors can be associated with individual items or with a series, episode, clip.
     * 
     *  @property actors
     *  @type Person
     */
    prototype.actors = null;
    /**
     *  Schema.org/episode
     *  An episode of a tv, radio or game media within a series or season.
     * 
     *  @property episode
     *  @type Episode
     */
    prototype.episode = null;
}, {seasons: "CreativeWorkSeason", actor: "Person", trailer: "VideoObject", season: "CreativeWorkSeason", episodes: "Episode", countryOfOrigin: "Country", musicBy: "Person", containsSeason: "CreativeWorkSeason", directors: "Person", director: "Person", productionCompany: "Organization", actors: "Person", episode: "Episode", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/MusicPlaylist
 *  A collection of music tracks in playlist form.
 * 
 *  @author schema.org
 *  @class MusicPlaylist
 *  @module org.schema
 *  @extends CreativeWork
 */
var MusicPlaylist = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CreativeWork.call(this);
    this.context = "http://schema.org/";
    this.type = "MusicPlaylist";
};
MusicPlaylist = stjs.extend(MusicPlaylist, CreativeWork, [], function(constructor, prototype) {
    /**
     *  Schema.org/track
     *  A music recording (track)&#x2014;usually a single song. If an ItemList is given, the list should contain items of type MusicRecording.
     * 
     *  @property track
     *  @type MusicRecording
     */
    prototype.track = null;
    /**
     *  Schema.org/numTracks
     *  The number of tracks in this album or playlist.
     * 
     *  @property numTracks
     *  @type Integer
     */
    prototype.numTracks = null;
    /**
     *  Schema.org/tracks
     *  A music recording (track)&#x2014;usually a single song.
     * 
     *  @property tracks
     *  @type MusicRecording
     */
    prototype.tracks = null;
}, {track: "MusicRecording", tracks: "MusicRecording", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Recipe
 *  A recipe. For dietary restrictions covered by the recipe, a few common restrictions are enumerated via [[suitableForDiet]]. The [[keywords]] property can also be used to add more detail.
 * 
 *  @author schema.org
 *  @class Recipe
 *  @module org.schema
 *  @extends CreativeWork
 */
var Recipe = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CreativeWork.call(this);
    this.context = "http://schema.org/";
    this.type = "Recipe";
};
Recipe = stjs.extend(Recipe, CreativeWork, [], function(constructor, prototype) {
    /**
     *  Schema.org/recipeYield
     *  The quantity produced by the recipe (for example, number of people served, number of servings, etc).
     * 
     *  @property recipeYield
     *  @type Text
     */
    prototype.recipeYield = null;
    /**
     *  Schema.org/recipeCategory
     *  The category of the recipe—for example, appetizer, entree, etc.
     * 
     *  @property recipeCategory
     *  @type Text
     */
    prototype.recipeCategory = null;
    /**
     *  Schema.org/prepTime
     *  The length of time it takes to prepare the recipe, in [ISO 8601 duration format](http://en.wikipedia.org/wiki/ISO_8601).
     * 
     *  @property prepTime
     *  @type Duration
     */
    prototype.prepTime = null;
    /**
     *  Schema.org/recipeIngredient
     *  A single ingredient used in the recipe, e.g. sugar, flour or garlic.
     * 
     *  @property recipeIngredient
     *  @type Text
     */
    prototype.recipeIngredient = null;
    /**
     *  Schema.org/recipeInstructions
     *  A step or instruction involved in making the recipe.
     * 
     *  @property recipeInstructions
     *  @type ItemList
     */
    prototype.recipeInstructions = null;
    /**
     *  Schema.org/nutrition
     *  Nutrition information about the recipe or menu item.
     * 
     *  @property nutrition
     *  @type NutritionInformation
     */
    prototype.nutrition = null;
    /**
     *  Schema.org/suitableForDiet
     *  Indicates a dietary restriction or guideline for which this recipe or menu item is suitable, e.g. diabetic, halal etc.
     * 
     *  @property suitableForDiet
     *  @type RestrictedDiet
     */
    prototype.suitableForDiet = null;
    /**
     *  Schema.org/recipeCuisine
     *  The cuisine of the recipe (for example, French or Ethiopian).
     * 
     *  @property recipeCuisine
     *  @type Text
     */
    prototype.recipeCuisine = null;
    /**
     *  Schema.org/cookTime
     *  The time it takes to actually cook the dish, in [ISO 8601 duration format](http://en.wikipedia.org/wiki/ISO_8601).
     * 
     *  @property cookTime
     *  @type Duration
     */
    prototype.cookTime = null;
    /**
     *  Schema.org/totalTime
     *  The total time it takes to prepare and cook the recipe, in [ISO 8601 duration format](http://en.wikipedia.org/wiki/ISO_8601).
     * 
     *  @property totalTime
     *  @type Duration
     */
    prototype.totalTime = null;
    /**
     *  Schema.org/cookingMethod
     *  The method of cooking, such as Frying, Steaming, ...
     * 
     *  @property cookingMethod
     *  @type Text
     */
    prototype.cookingMethod = null;
    /**
     *  Schema.org/ingredients
     *  A single ingredient used in the recipe, e.g. sugar, flour or garlic.
     * 
     *  @property ingredients
     *  @type Text
     */
    prototype.ingredients = null;
}, {prepTime: "Duration", recipeInstructions: "ItemList", nutrition: "NutritionInformation", suitableForDiet: "RestrictedDiet", cookTime: "Duration", totalTime: "Duration", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/MenuSection
 *  A sub-grouping of food or drink items in a menu. E.g. courses (such as 'Dinner', 'Breakfast', etc.), specific type of dishes (such as 'Meat', 'Vegan', 'Drinks', etc.), or some other classification made by the menu provider.
 * 
 *  @author schema.org
 *  @class MenuSection
 *  @module org.schema
 *  @extends CreativeWork
 */
var MenuSection = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CreativeWork.call(this);
    this.context = "http://schema.org/";
    this.type = "MenuSection";
};
MenuSection = stjs.extend(MenuSection, CreativeWork, [], function(constructor, prototype) {
    /**
     *  Schema.org/hasMenuItem
     *  A food or drink item contained in a menu or menu section.
     * 
     *  @property hasMenuItem
     *  @type MenuItem
     */
    prototype.hasMenuItem = null;
    /**
     *  Schema.org/hasMenuSection
     *  A subgrouping of the menu (by dishes, course, serving time period, etc.).
     * 
     *  @property hasMenuSection
     *  @type MenuSection
     */
    prototype.hasMenuSection = null;
}, {hasMenuItem: "MenuItem", hasMenuSection: "MenuSection", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Sculpture
 *  A piece of sculpture.
 * 
 *  @author schema.org
 *  @class Sculpture
 *  @module org.schema
 *  @extends CreativeWork
 */
var Sculpture = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CreativeWork.call(this);
    this.context = "http://schema.org/";
    this.type = "Sculpture";
};
Sculpture = stjs.extend(Sculpture, CreativeWork, [], null, {about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Blog
 *  A blog.
 * 
 *  @author schema.org
 *  @class Blog
 *  @module org.schema
 *  @extends CreativeWork
 */
var Blog = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CreativeWork.call(this);
    this.context = "http://schema.org/";
    this.type = "Blog";
};
Blog = stjs.extend(Blog, CreativeWork, [], function(constructor, prototype) {
    /**
     *  Schema.org/blogPosts
     *  The postings that are part of this blog.
     * 
     *  @property blogPosts
     *  @type BlogPosting
     */
    prototype.blogPosts = null;
    /**
     *  Schema.org/blogPost
     *  A posting that is part of this blog.
     * 
     *  @property blogPost
     *  @type BlogPosting
     */
    prototype.blogPost = null;
}, {blogPosts: "BlogPosting", blogPost: "BlogPosting", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/MusicRecording
 *  A music recording (track), usually a single song.
 * 
 *  @author schema.org
 *  @class MusicRecording
 *  @module org.schema
 *  @extends CreativeWork
 */
var MusicRecording = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CreativeWork.call(this);
    this.context = "http://schema.org/";
    this.type = "MusicRecording";
};
MusicRecording = stjs.extend(MusicRecording, CreativeWork, [], function(constructor, prototype) {
    /**
     *  Schema.org/recordingOf
     *  The composition this track is a recording of.
     * 
     *  @property recordingOf
     *  @type MusicComposition
     */
    prototype.recordingOf = null;
    /**
     *  Schema.org/isrcCode
     *  The International Standard Recording Code for the recording.
     * 
     *  @property isrcCode
     *  @type Text
     */
    prototype.isrcCode = null;
    /**
     *  Schema.org/inAlbum
     *  The album to which this recording belongs.
     * 
     *  @property inAlbum
     *  @type MusicAlbum
     */
    prototype.inAlbum = null;
    /**
     *  Schema.org/inPlaylist
     *  The playlist to which this recording belongs.
     * 
     *  @property inPlaylist
     *  @type MusicPlaylist
     */
    prototype.inPlaylist = null;
    /**
     *  Schema.org/byArtist
     *  The artist that performed this album or recording.
     * 
     *  @property byArtist
     *  @type MusicGroup
     */
    prototype.byArtist = null;
    /**
     *  Schema.org/duration
     *  The duration of the item (movie, audio recording, event, etc.) in [ISO 8601 date format](http://en.wikipedia.org/wiki/ISO_8601).
     * 
     *  @property duration
     *  @type Duration
     */
    prototype.duration = null;
}, {recordingOf: "MusicComposition", inAlbum: "MusicAlbum", inPlaylist: "MusicPlaylist", byArtist: "MusicGroup", duration: "Duration", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/SoftwareSourceCode
 *  Computer programming source code. Example: Full (compile ready) solutions, code snippet samples, scripts, templates.
 * 
 *  @author schema.org
 *  @class SoftwareSourceCode
 *  @module org.schema
 *  @extends CreativeWork
 */
var SoftwareSourceCode = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CreativeWork.call(this);
    this.context = "http://schema.org/";
    this.type = "SoftwareSourceCode";
};
SoftwareSourceCode = stjs.extend(SoftwareSourceCode, CreativeWork, [], function(constructor, prototype) {
    /**
     *  Schema.org/targetProduct
     *  Target Operating System / Product to which the code applies.  If applies to several versions, just the product name can be used.
     * 
     *  @property targetProduct
     *  @type SoftwareApplication
     */
    prototype.targetProduct = null;
    /**
     *  Schema.org/codeRepository
     *  Link to the repository where the un-compiled, human readable code and related code is located (SVN, github, CodePlex).
     * 
     *  @property codeRepository
     *  @type URL
     */
    prototype.codeRepository = null;
    /**
     *  Schema.org/programmingLanguage
     *  The computer programming language.
     * 
     *  @property programmingLanguage
     *  @type Text
     */
    prototype.programmingLanguage = null;
    /**
     *  Schema.org/codeSampleType
     *  What type of code sample: full (compile ready) solution, code snippet, inline code, scripts, template.
     * 
     *  @property codeSampleType
     *  @type Text
     */
    prototype.codeSampleType = null;
    /**
     *  Schema.org/runtimePlatform
     *  Runtime platform or script interpreter dependencies (Example - Java v1, Python2.3, .Net Framework 3.0).
     * 
     *  @property runtimePlatform
     *  @type Text
     */
    prototype.runtimePlatform = null;
    /**
     *  Schema.org/sampleType
     *  What type of code sample: full (compile ready) solution, code snippet, inline code, scripts, template.
     * 
     *  @property sampleType
     *  @type Text
     */
    prototype.sampleType = null;
    /**
     *  Schema.org/runtime
     *  Runtime platform or script interpreter dependencies (Example - Java v1, Python2.3, .Net Framework 3.0).
     * 
     *  @property runtime
     *  @type Text
     */
    prototype.runtime = null;
}, {targetProduct: "SoftwareApplication", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/WebPageElement
 *  A web page element, like a table or an image.
 * 
 *  @author schema.org
 *  @class WebPageElement
 *  @module org.schema
 *  @extends CreativeWork
 */
var WebPageElement = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CreativeWork.call(this);
    this.context = "http://schema.org/";
    this.type = "WebPageElement";
};
WebPageElement = stjs.extend(WebPageElement, CreativeWork, [], null, {about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Comment
 *  A comment on an item - for example, a comment on a blog post. The comment's content is expressed via the [[text]] property, and its topic via [[about]], properties shared with all CreativeWorks.
 * 
 *  @author schema.org
 *  @class Comment
 *  @module org.schema
 *  @extends CreativeWork
 */
var Comment = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CreativeWork.call(this);
    this.context = "http://schema.org/";
    this.type = "Comment";
};
Comment = stjs.extend(Comment, CreativeWork, [], function(constructor, prototype) {
    /**
     *  Schema.org/parentItem
     *  The parent of a question, answer or item in general.
     * 
     *  @property parentItem
     *  @type Question
     */
    prototype.parentItem = null;
    /**
     *  Schema.org/upvoteCount
     *  The number of upvotes this question, answer or comment has received from the community.
     * 
     *  @property upvoteCount
     *  @type Integer
     */
    prototype.upvoteCount = null;
    /**
     *  Schema.org/downvoteCount
     *  The number of downvotes this question, answer or comment has received from the community.
     * 
     *  @property downvoteCount
     *  @type Integer
     */
    prototype.downvoteCount = null;
}, {parentItem: "Question", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/DataCatalog
 *  A collection of datasets.
 * 
 *  @author schema.org
 *  @class DataCatalog
 *  @module org.schema
 *  @extends CreativeWork
 */
var DataCatalog = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CreativeWork.call(this);
    this.context = "http://schema.org/";
    this.type = "DataCatalog";
};
DataCatalog = stjs.extend(DataCatalog, CreativeWork, [], function(constructor, prototype) {
    /**
     *  Schema.org/dataset
     *  A dataset contained in this catalog.
     * 
     *  @property dataset
     *  @type Dataset
     */
    prototype.dataset = null;
}, {dataset: "Dataset", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/MusicComposition
 *  A musical composition.
 * 
 *  @author schema.org
 *  @class MusicComposition
 *  @module org.schema
 *  @extends CreativeWork
 */
var MusicComposition = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CreativeWork.call(this);
    this.context = "http://schema.org/";
    this.type = "MusicComposition";
};
MusicComposition = stjs.extend(MusicComposition, CreativeWork, [], function(constructor, prototype) {
    /**
     *  Schema.org/musicCompositionForm
     *  The type of composition (e.g. overture, sonata, symphony, etc.).
     * 
     *  @property musicCompositionForm
     *  @type Text
     */
    prototype.musicCompositionForm = null;
    /**
     *  Schema.org/includedComposition
     *  Smaller compositions included in this work (e.g. a movement in a symphony).
     * 
     *  @property includedComposition
     *  @type MusicComposition
     */
    prototype.includedComposition = null;
    /**
     *  Schema.org/lyricist
     *  The person who wrote the words.
     * 
     *  @property lyricist
     *  @type Person
     */
    prototype.lyricist = null;
    /**
     *  Schema.org/recordedAs
     *  An audio recording of the work.
     * 
     *  @property recordedAs
     *  @type MusicRecording
     */
    prototype.recordedAs = null;
    /**
     *  Schema.org/firstPerformance
     *  The date and place the work was first performed.
     * 
     *  @property firstPerformance
     *  @type SchemaEvent
     */
    prototype.firstPerformance = null;
    /**
     *  Schema.org/musicArrangement
     *  An arrangement derived from the composition.
     * 
     *  @property musicArrangement
     *  @type MusicComposition
     */
    prototype.musicArrangement = null;
    /**
     *  Schema.org/lyrics
     *  The words in the song.
     * 
     *  @property lyrics
     *  @type CreativeWork
     */
    prototype.lyrics = null;
    /**
     *  Schema.org/iswcCode
     *  The International Standard Musical Work Code for the composition.
     * 
     *  @property iswcCode
     *  @type Text
     */
    prototype.iswcCode = null;
    /**
     *  Schema.org/composer
     *  The person or organization who wrote a composition, or who is the composer of a work performed at some event.
     * 
     *  @property composer
     *  @type Organization
     */
    prototype.composer = null;
    /**
     *  Schema.org/musicalKey
     *  The key, mode, or scale this composition uses.
     * 
     *  @property musicalKey
     *  @type Text
     */
    prototype.musicalKey = null;
}, {includedComposition: "MusicComposition", lyricist: "Person", recordedAs: "MusicRecording", firstPerformance: "SchemaEvent", musicArrangement: "MusicComposition", lyrics: "CreativeWork", composer: "Organization", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Movie
 *  A movie.
 * 
 *  @author schema.org
 *  @class Movie
 *  @module org.schema
 *  @extends CreativeWork
 */
var Movie = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CreativeWork.call(this);
    this.context = "http://schema.org/";
    this.type = "Movie";
};
Movie = stjs.extend(Movie, CreativeWork, [], function(constructor, prototype) {
    /**
     *  Schema.org/actor
     *  An actor, e.g. in tv, radio, movie, video games etc., or in an event. Actors can be associated with individual items or with a series, episode, clip.
     * 
     *  @property actor
     *  @type Person
     */
    prototype.actor = null;
    /**
     *  Schema.org/trailer
     *  The trailer of a movie or tv/radio series, season, episode, etc.
     * 
     *  @property trailer
     *  @type VideoObject
     */
    prototype.trailer = null;
    /**
     *  Schema.org/subtitleLanguage
     *  Languages in which subtitles/captions are available, in [IETF BCP 47 standard format](http://tools.ietf.org/html/bcp47).
     * 
     *  @property subtitleLanguage
     *  @type Text
     */
    prototype.subtitleLanguage = null;
    /**
     *  Schema.org/countryOfOrigin
     *  The country of the principal offices of the production company or individual responsible for the movie or program.
     * 
     *  @property countryOfOrigin
     *  @type Country
     */
    prototype.countryOfOrigin = null;
    /**
     *  Schema.org/musicBy
     *  The composer of the soundtrack.
     * 
     *  @property musicBy
     *  @type Person
     */
    prototype.musicBy = null;
    /**
     *  Schema.org/directors
     *  A director of e.g. tv, radio, movie, video games etc. content. Directors can be associated with individual items or with a series, episode, clip.
     * 
     *  @property directors
     *  @type Person
     */
    prototype.directors = null;
    /**
     *  Schema.org/director
     *  A director of e.g. tv, radio, movie, video gaming etc. content, or of an event. Directors can be associated with individual items or with a series, episode, clip.
     * 
     *  @property director
     *  @type Person
     */
    prototype.director = null;
    /**
     *  Schema.org/productionCompany
     *  The production company or studio responsible for the item e.g. series, video game, episode etc.
     * 
     *  @property productionCompany
     *  @type Organization
     */
    prototype.productionCompany = null;
    /**
     *  Schema.org/duration
     *  The duration of the item (movie, audio recording, event, etc.) in [ISO 8601 date format](http://en.wikipedia.org/wiki/ISO_8601).
     * 
     *  @property duration
     *  @type Duration
     */
    prototype.duration = null;
    /**
     *  Schema.org/actors
     *  An actor, e.g. in tv, radio, movie, video games etc. Actors can be associated with individual items or with a series, episode, clip.
     * 
     *  @property actors
     *  @type Person
     */
    prototype.actors = null;
}, {actor: "Person", trailer: "VideoObject", countryOfOrigin: "Country", musicBy: "Person", directors: "Person", director: "Person", productionCompany: "Organization", duration: "Duration", actors: "Person", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Message
 *  A single message from a sender to one or more organizations or people.
 * 
 *  @author schema.org
 *  @class Message
 *  @module org.schema
 *  @extends CreativeWork
 */
var Message = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CreativeWork.call(this);
    this.context = "http://schema.org/";
    this.type = "Message";
};
Message = stjs.extend(Message, CreativeWork, [], function(constructor, prototype) {
    /**
     *  Schema.org/dateRead
     *  The date/time at which the message has been read by the recipient if a single recipient exists.
     * 
     *  @property dateRead
     *  @type DateTime
     */
    prototype.dateRead = null;
    /**
     *  Schema.org/dateSent
     *  The date/time at which the message was sent.
     * 
     *  @property dateSent
     *  @type DateTime
     */
    prototype.dateSent = null;
    /**
     *  Schema.org/recipient
     *  A sub property of participant. The participant who is at the receiving end of the action.
     * 
     *  @property recipient
     *  @type Organization
     */
    prototype.recipient = null;
    /**
     *  Schema.org/messageAttachment
     *  A CreativeWork attached to the message.
     * 
     *  @property messageAttachment
     *  @type CreativeWork
     */
    prototype.messageAttachment = null;
    /**
     *  Schema.org/dateReceived
     *  The date/time the message was received if a single recipient exists.
     * 
     *  @property dateReceived
     *  @type DateTime
     */
    prototype.dateReceived = null;
    /**
     *  Schema.org/sender
     *  A sub property of participant. The participant who is at the sending end of the action.
     * 
     *  @property sender
     *  @type Audience
     */
    prototype.sender = null;
}, {recipient: "Organization", messageAttachment: "CreativeWork", sender: "Audience", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Photograph
 *  A photograph.
 * 
 *  @author schema.org
 *  @class Photograph
 *  @module org.schema
 *  @extends CreativeWork
 */
var Photograph = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CreativeWork.call(this);
    this.context = "http://schema.org/";
    this.type = "Photograph";
};
Photograph = stjs.extend(Photograph, CreativeWork, [], null, {about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/PublicationVolume
 *  A part of a successively published publication such as a periodical or multi-volume work, often numbered. It may represent a time span, such as a year.
 *  <p>
 *  <br/><br/>See also <a href="http://blog.schema.org/2014/09/schemaorg-support-for-bibliographic_2.html">blog post</a>.
 * 
 *  @author schema.org
 *  @class PublicationVolume
 *  @module org.schema
 *  @extends CreativeWork
 */
var PublicationVolume = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CreativeWork.call(this);
    this.context = "http://schema.org/";
    this.type = "PublicationVolume";
};
PublicationVolume = stjs.extend(PublicationVolume, CreativeWork, [], function(constructor, prototype) {
    /**
     *  Schema.org/pagination
     *  Any description of pages that is not separated into pageStart and pageEnd; for example, "1-6, 9, 55" or "10-12, 46-49".
     * 
     *  @property pagination
     *  @type Text
     */
    prototype.pagination = null;
    /**
     *  Schema.org/pageEnd
     *  The page on which the work ends; for example "138" or "xvi".
     * 
     *  @property pageEnd
     *  @type Integer
     */
    prototype.pageEnd = null;
    /**
     *  Schema.org/volumeNumber
     *  Identifies the volume of publication or multi-part work; for example, "iii" or "2".
     * 
     *  @property volumeNumber
     *  @type Integer
     */
    prototype.volumeNumber = null;
    /**
     *  Schema.org/pageStart
     *  The page on which the work starts; for example "135" or "xiii".
     * 
     *  @property pageStart
     *  @type Integer
     */
    prototype.pageStart = null;
}, {about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Review
 *  A review of an item - for example, of a restaurant, movie, or store.
 * 
 *  @author schema.org
 *  @class Review
 *  @module org.schema
 *  @extends CreativeWork
 */
var Review = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CreativeWork.call(this);
    this.context = "http://schema.org/";
    this.type = "Review";
};
Review = stjs.extend(Review, CreativeWork, [], function(constructor, prototype) {
    /**
     *  Schema.org/reviewRating
     *  The rating given in this review. Note that reviews can themselves be rated. The ```reviewRating``` applies to rating given by the review. The [[aggregateRating]] property applies to the review itself, as a creative work.
     * 
     *  @property reviewRating
     *  @type Rating
     */
    prototype.reviewRating = null;
    /**
     *  Schema.org/itemReviewed
     *  The item that is being reviewed/rated.
     * 
     *  @property itemReviewed
     *  @type Thing
     */
    prototype.itemReviewed = null;
    /**
     *  Schema.org/reviewBody
     *  The actual body of the review.
     * 
     *  @property reviewBody
     *  @type Text
     */
    prototype.reviewBody = null;
}, {reviewRating: "Rating", itemReviewed: "Thing", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Episode
 *  A media episode (e.g. TV, radio, video game) which can be part of a series or season.
 * 
 *  @author schema.org
 *  @class Episode
 *  @module org.schema
 *  @extends CreativeWork
 */
var Episode = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CreativeWork.call(this);
    this.context = "http://schema.org/";
    this.type = "Episode";
};
Episode = stjs.extend(Episode, CreativeWork, [], function(constructor, prototype) {
    /**
     *  Schema.org/actor
     *  An actor, e.g. in tv, radio, movie, video games etc., or in an event. Actors can be associated with individual items or with a series, episode, clip.
     * 
     *  @property actor
     *  @type Person
     */
    prototype.actor = null;
    /**
     *  Schema.org/partOfSeries
     *  The series to which this episode or season belongs.
     * 
     *  @property partOfSeries
     *  @type CreativeWorkSeries
     */
    prototype.partOfSeries = null;
    /**
     *  Schema.org/trailer
     *  The trailer of a movie or tv/radio series, season, episode, etc.
     * 
     *  @property trailer
     *  @type VideoObject
     */
    prototype.trailer = null;
    /**
     *  Schema.org/partOfSeason
     *  The season to which this episode belongs.
     * 
     *  @property partOfSeason
     *  @type CreativeWorkSeason
     */
    prototype.partOfSeason = null;
    /**
     *  Schema.org/musicBy
     *  The composer of the soundtrack.
     * 
     *  @property musicBy
     *  @type Person
     */
    prototype.musicBy = null;
    /**
     *  Schema.org/directors
     *  A director of e.g. tv, radio, movie, video games etc. content. Directors can be associated with individual items or with a series, episode, clip.
     * 
     *  @property directors
     *  @type Person
     */
    prototype.directors = null;
    /**
     *  Schema.org/episodeNumber
     *  Position of the episode within an ordered group of episodes.
     * 
     *  @property episodeNumber
     *  @type Integer
     */
    prototype.episodeNumber = null;
    /**
     *  Schema.org/director
     *  A director of e.g. tv, radio, movie, video gaming etc. content, or of an event. Directors can be associated with individual items or with a series, episode, clip.
     * 
     *  @property director
     *  @type Person
     */
    prototype.director = null;
    /**
     *  Schema.org/productionCompany
     *  The production company or studio responsible for the item e.g. series, video game, episode etc.
     * 
     *  @property productionCompany
     *  @type Organization
     */
    prototype.productionCompany = null;
    /**
     *  Schema.org/actors
     *  An actor, e.g. in tv, radio, movie, video games etc. Actors can be associated with individual items or with a series, episode, clip.
     * 
     *  @property actors
     *  @type Person
     */
    prototype.actors = null;
}, {actor: "Person", partOfSeries: "CreativeWorkSeries", trailer: "VideoObject", partOfSeason: "CreativeWorkSeason", musicBy: "Person", directors: "Person", director: "Person", productionCompany: "Organization", actors: "Person", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/TVSeason
 *  Season dedicated to TV broadcast and associated online delivery.
 * 
 *  @author schema.org
 *  @class TVSeason
 *  @module org.schema
 *  @extends CreativeWork
 */
var TVSeason = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CreativeWork.call(this);
    this.context = "http://schema.org/";
    this.type = "TVSeason";
};
TVSeason = stjs.extend(TVSeason, CreativeWork, [], function(constructor, prototype) {
    /**
     *  Schema.org/partOfTVSeries
     *  The TV series to which this episode or season belongs.
     * 
     *  @property partOfTVSeries
     *  @type TVSeries
     */
    prototype.partOfTVSeries = null;
    /**
     *  Schema.org/countryOfOrigin
     *  The country of the principal offices of the production company or individual responsible for the movie or program.
     * 
     *  @property countryOfOrigin
     *  @type Country
     */
    prototype.countryOfOrigin = null;
}, {partOfTVSeries: "TVSeries", countryOfOrigin: "Country", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/MediaObject
 *  A media object, such as an image, video, or audio object embedded in a web page or a downloadable dataset i.e. DataDownload. Note that a creative work may have many media objects associated with it on the same web page. For example, a page about a single song (MusicRecording) may have a music video (VideoObject), and a high and low bandwidth audio stream (2 AudioObject's).
 * 
 *  @author schema.org
 *  @class MediaObject
 *  @module org.schema
 *  @extends CreativeWork
 */
var MediaObject = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CreativeWork.call(this);
    this.context = "http://schema.org/";
    this.type = "MediaObject";
};
MediaObject = stjs.extend(MediaObject, CreativeWork, [], function(constructor, prototype) {
    /**
     *  Schema.org/uploadDate
     *  Date when this media object was uploaded to this site.
     * 
     *  @property uploadDate
     *  @type Date
     */
    prototype.uploadDate = null;
    /**
     *  Schema.org/playerType
     *  Player type required&#x2014;for example, Flash or Silverlight.
     * 
     *  @property playerType
     *  @type Text
     */
    prototype.playerType = null;
    /**
     *  Schema.org/height
     *  The height of the item.
     * 
     *  @property height
     *  @type Distance
     */
    prototype.height = null;
    /**
     *  Schema.org/bitrate
     *  The bitrate of the media object.
     * 
     *  @property bitrate
     *  @type Text
     */
    prototype.bitrate = null;
    /**
     *  Schema.org/requiresSubscription
     *  Indicates if use of the media require a subscription  (either paid or free). Allowed values are ```true``` or ```false``` (note that an earlier version had 'yes', 'no').
     * 
     *  @property requiresSubscription
     *  @type Boolean
     */
    prototype.requiresSubscription = null;
    /**
     *  Schema.org/regionsAllowed
     *  The regions where the media is allowed. If not specified, then it's assumed to be allowed everywhere. Specify the countries in [ISO 3166 format](http://en.wikipedia.org/wiki/ISO_3166).
     * 
     *  @property regionsAllowed
     *  @type Place
     */
    prototype.regionsAllowed = null;
    /**
     *  Schema.org/expires
     *  Date the content expires and is no longer useful or available. Useful for videos.
     * 
     *  @property expires
     *  @type Date
     */
    prototype.expires = null;
    /**
     *  Schema.org/contentSize
     *  File size in (mega/kilo) bytes.
     * 
     *  @property contentSize
     *  @type Text
     */
    prototype.contentSize = null;
    /**
     *  Schema.org/embedUrl
     *  A URL pointing to a player for a specific video. In general, this is the information in the ```src``` element of an ```embed``` tag and should not be the same as the content of the ```loc``` tag.
     * 
     *  @property embedUrl
     *  @type URL
     */
    prototype.embedUrl = null;
    /**
     *  Schema.org/width
     *  The width of the item.
     * 
     *  @property width
     *  @type Distance
     */
    prototype.width = null;
    /**
     *  Schema.org/contentUrl
     *  Actual bytes of the media object, for example the image file or video file.
     * 
     *  @property contentUrl
     *  @type URL
     */
    prototype.contentUrl = null;
    /**
     *  Schema.org/associatedArticle
     *  A NewsArticle associated with the Media Object.
     * 
     *  @property associatedArticle
     *  @type NewsArticle
     */
    prototype.associatedArticle = null;
    /**
     *  Schema.org/productionCompany
     *  The production company or studio responsible for the item e.g. series, video game, episode etc.
     * 
     *  @property productionCompany
     *  @type Organization
     */
    prototype.productionCompany = null;
    /**
     *  Schema.org/duration
     *  The duration of the item (movie, audio recording, event, etc.) in [ISO 8601 date format](http://en.wikipedia.org/wiki/ISO_8601).
     * 
     *  @property duration
     *  @type Duration
     */
    prototype.duration = null;
    /**
     *  Schema.org/encodesCreativeWork
     *  The CreativeWork encoded by this media object.
     * 
     *  @property encodesCreativeWork
     *  @type CreativeWork
     */
    prototype.encodesCreativeWork = null;
    /**
     *  Schema.org/encodingFormat
     *  mp3, mpeg4, etc.
     * 
     *  @property encodingFormat
     *  @type Text
     */
    prototype.encodingFormat = null;
}, {height: "Distance", regionsAllowed: "Place", width: "Distance", associatedArticle: "NewsArticle", productionCompany: "Organization", duration: "Duration", encodesCreativeWork: "CreativeWork", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Conversation
 *  One or more messages between organizations or people on a particular topic. Individual messages can be linked to the conversation with isPartOf or hasPart properties.
 * 
 *  @author schema.org
 *  @class Conversation
 *  @module org.schema
 *  @extends CreativeWork
 */
var Conversation = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CreativeWork.call(this);
    this.context = "http://schema.org/";
    this.type = "Conversation";
};
Conversation = stjs.extend(Conversation, CreativeWork, [], null, {about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/PublicationIssue
 *  A part of a successively published publication such as a periodical or publication volume, often numbered, usually containing a grouping of works such as articles.\n\n[blog post](http://blog.schema.org/2014/09/schemaorg-support-for-bibliographic_2.html).
 * 
 *  @author schema.org
 *  @class PublicationIssue
 *  @module org.schema
 *  @extends CreativeWork
 */
var PublicationIssue = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CreativeWork.call(this);
    this.context = "http://schema.org/";
    this.type = "PublicationIssue";
};
PublicationIssue = stjs.extend(PublicationIssue, CreativeWork, [], function(constructor, prototype) {
    /**
     *  Schema.org/pagination
     *  Any description of pages that is not separated into pageStart and pageEnd; for example, "1-6, 9, 55" or "10-12, 46-49".
     * 
     *  @property pagination
     *  @type Text
     */
    prototype.pagination = null;
    /**
     *  Schema.org/issueNumber
     *  Identifies the issue of publication; for example, "iii" or "2".
     * 
     *  @property issueNumber
     *  @type Text
     */
    prototype.issueNumber = null;
    /**
     *  Schema.org/pageEnd
     *  The page on which the work ends; for example "138" or "xvi".
     * 
     *  @property pageEnd
     *  @type Integer
     */
    prototype.pageEnd = null;
    /**
     *  Schema.org/pageStart
     *  The page on which the work starts; for example "135" or "xiii".
     * 
     *  @property pageStart
     *  @type Integer
     */
    prototype.pageStart = null;
}, {about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Course
 *  A description of an educational course which may be offered as distinct instances at which take place at different times or take place at different locations, or be offered through different media or modes of study. An educational course is a sequence of one or more educational events and/or creative works which aims to build knowledge, competence or ability of learners.
 * 
 *  @author schema.org
 *  @class Course
 *  @module org.schema
 *  @extends CreativeWork
 */
var Course = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CreativeWork.call(this);
    this.context = "http://schema.org/";
    this.type = "Course";
};
Course = stjs.extend(Course, CreativeWork, [], function(constructor, prototype) {
    /**
     *  Schema.org/courseCode
     *  The identifier for the [[Course]] used by the course [[provider]] (e.g. CS101 or 6.001).
     * 
     *  @property courseCode
     *  @type Text
     */
    prototype.courseCode = null;
    /**
     *  Schema.org/coursePrerequisites
     *  Requirements for taking the Course. May be completion of another [[Course]] or a textual description like "permission of instructor". Requirements may be a pre-requisite competency, referenced using [[AlignmentObject]].
     * 
     *  @property coursePrerequisites
     *  @type Text
     */
    prototype.coursePrerequisites = null;
    /**
     *  Schema.org/hasCourseInstance
     *  An offering of the course at a specific time and place or through specific media or mode of study or to a specific section of students.
     * 
     *  @property hasCourseInstance
     *  @type CourseInstance
     */
    prototype.hasCourseInstance = null;
}, {hasCourseInstance: "CourseInstance", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/WebPage
 *  A web page. Every web page is implicitly assumed to be declared to be of type WebPage, so the various properties about that webpage, such as <code>breadcrumb</code> may be used. We recommend explicit declaration if these properties are specified, but if they are found outside of an itemscope, they will be assumed to be about the page.
 * 
 *  @author schema.org
 *  @class WebPage
 *  @module org.schema
 *  @extends CreativeWork
 */
var WebPage = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CreativeWork.call(this);
    this.context = "http://schema.org/";
    this.type = "WebPage";
};
WebPage = stjs.extend(WebPage, CreativeWork, [], function(constructor, prototype) {
    /**
     *  Schema.org/lastReviewed
     *  Date on which the content on this web page was last reviewed for accuracy and/or completeness.
     * 
     *  @property lastReviewed
     *  @type Date
     */
    prototype.lastReviewed = null;
    /**
     *  Schema.org/breadcrumb
     *  A set of links that can help a user understand and navigate a website hierarchy.
     * 
     *  @property breadcrumb
     *  @type Text
     */
    prototype.breadcrumb = null;
    /**
     *  Schema.org/significantLink
     *  One of the more significant URLs on the page. Typically, these are the non-navigation links that are clicked on the most.
     * 
     *  @property significantLink
     *  @type URL
     */
    prototype.significantLink = null;
    /**
     *  Schema.org/relatedLink
     *  A link related to this web page, for example to other related web pages.
     * 
     *  @property relatedLink
     *  @type URL
     */
    prototype.relatedLink = null;
    /**
     *  Schema.org/mainContentOfPage
     *  Indicates if this web page element is the main subject of the page.
     * 
     *  @property mainContentOfPage
     *  @type WebPageElement
     */
    prototype.mainContentOfPage = null;
    /**
     *  Schema.org/reviewedBy
     *  People or organizations that have reviewed the content on this web page for accuracy and/or completeness.
     * 
     *  @property reviewedBy
     *  @type Organization
     */
    prototype.reviewedBy = null;
    /**
     *  Schema.org/primaryImageOfPage
     *  Indicates the main image on the page.
     * 
     *  @property primaryImageOfPage
     *  @type ImageObject
     */
    prototype.primaryImageOfPage = null;
    /**
     *  Schema.org/significantLinks
     *  The most significant URLs on the page. Typically, these are the non-navigation links that are clicked on the most.
     * 
     *  @property significantLinks
     *  @type URL
     */
    prototype.significantLinks = null;
    /**
     *  Schema.org/specialty
     *  One of the domain specialities to which this web page's content applies.
     * 
     *  @property specialty
     *  @type Specialty
     */
    prototype.specialty = null;
}, {mainContentOfPage: "WebPageElement", reviewedBy: "Organization", primaryImageOfPage: "ImageObject", specialty: "Specialty", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/CreativeWorkSeries
 *  A CreativeWorkSeries in schema.org is a group of related items, typically but not necessarily of the same kind. CreativeWorkSeries are usually organized into some order, often chronological. Unlike [[ItemList]] which is a general purpose data structure for lists of things, the emphasis with CreativeWorkSeries is on published materials (written e.g. books and periodicals, or media such as tv, radio and games).\n\nSpecific subtypes are available for describing [[TVSeries]], [[RadioSeries]], [[MovieSeries]], [[BookSeries]], [[Periodical]] and [[VideoGameSeries]]. In each case, the [[hasPart]] / [[isPartOf]] properties can be used to relate the CreativeWorkSeries to its parts. The general CreativeWorkSeries type serves largely just to organize these more specific and practical subtypes.\n\nIt is common for properties applicable to an item from the series to be usefully applied to the containing group. Schema.org attempts to anticipate some of these cases, but publishers should be free to apply properties of the series parts to the series as a whole wherever they seem appropriate.
 * 
 *  @author schema.org
 *  @class CreativeWorkSeries
 *  @module org.schema
 *  @extends CreativeWork
 */
var CreativeWorkSeries = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CreativeWork.call(this);
    this.context = "http://schema.org/";
    this.type = "CreativeWorkSeries";
};
CreativeWorkSeries = stjs.extend(CreativeWorkSeries, CreativeWork, [], function(constructor, prototype) {
    /**
     *  Schema.org/endDate
     *  The end date and time of the item (in [ISO 8601 date format](http://en.wikipedia.org/wiki/ISO_8601)).
     * 
     *  @property endDate
     *  @type DateTime
     */
    prototype.endDate = null;
    /**
     *  Schema.org/startDate
     *  The start date and time of the item (in [ISO 8601 date format](http://en.wikipedia.org/wiki/ISO_8601)).
     * 
     *  @property startDate
     *  @type Date
     */
    prototype.startDate = null;
}, {about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Book
 *  A book.
 * 
 *  @author schema.org
 *  @class Book
 *  @module org.schema
 *  @extends CreativeWork
 */
var Book = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CreativeWork.call(this);
    this.context = "http://schema.org/";
    this.type = "Book";
};
Book = stjs.extend(Book, CreativeWork, [], function(constructor, prototype) {
    /**
     *  Schema.org/isbn
     *  The ISBN of the book.
     * 
     *  @property isbn
     *  @type Text
     */
    prototype.isbn = null;
    /**
     *  Schema.org/bookEdition
     *  The edition of the book.
     * 
     *  @property bookEdition
     *  @type Text
     */
    prototype.bookEdition = null;
    /**
     *  Schema.org/bookFormat
     *  The format of the book.
     * 
     *  @property bookFormat
     *  @type BookFormatType
     */
    prototype.bookFormat = null;
    /**
     *  Schema.org/numberOfPages
     *  The number of pages in the book.
     * 
     *  @property numberOfPages
     *  @type Integer
     */
    prototype.numberOfPages = null;
    /**
     *  Schema.org/illustrator
     *  The illustrator of the book.
     * 
     *  @property illustrator
     *  @type Person
     */
    prototype.illustrator = null;
}, {bookFormat: "BookFormatType", illustrator: "Person", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/CreativeWorkSeason
 *  A media season e.g. tv, radio, video game etc.
 * 
 *  @author schema.org
 *  @class CreativeWorkSeason
 *  @module org.schema
 *  @extends CreativeWork
 */
var CreativeWorkSeason = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CreativeWork.call(this);
    this.context = "http://schema.org/";
    this.type = "CreativeWorkSeason";
};
CreativeWorkSeason = stjs.extend(CreativeWorkSeason, CreativeWork, [], function(constructor, prototype) {
    /**
     *  Schema.org/actor
     *  An actor, e.g. in tv, radio, movie, video games etc., or in an event. Actors can be associated with individual items or with a series, episode, clip.
     * 
     *  @property actor
     *  @type Person
     */
    prototype.actor = null;
    /**
     *  Schema.org/partOfSeries
     *  The series to which this episode or season belongs.
     * 
     *  @property partOfSeries
     *  @type CreativeWorkSeries
     */
    prototype.partOfSeries = null;
    /**
     *  Schema.org/numberOfEpisodes
     *  The number of episodes in this season or series.
     * 
     *  @property numberOfEpisodes
     *  @type Integer
     */
    prototype.numberOfEpisodes = null;
    /**
     *  Schema.org/trailer
     *  The trailer of a movie or tv/radio series, season, episode, etc.
     * 
     *  @property trailer
     *  @type VideoObject
     */
    prototype.trailer = null;
    /**
     *  Schema.org/endDate
     *  The end date and time of the item (in [ISO 8601 date format](http://en.wikipedia.org/wiki/ISO_8601)).
     * 
     *  @property endDate
     *  @type DateTime
     */
    prototype.endDate = null;
    /**
     *  Schema.org/episodes
     *  An episode of a TV/radio series or season.
     * 
     *  @property episodes
     *  @type Episode
     */
    prototype.episodes = null;
    /**
     *  Schema.org/startDate
     *  The start date and time of the item (in [ISO 8601 date format](http://en.wikipedia.org/wiki/ISO_8601)).
     * 
     *  @property startDate
     *  @type Date
     */
    prototype.startDate = null;
    /**
     *  Schema.org/director
     *  A director of e.g. tv, radio, movie, video gaming etc. content, or of an event. Directors can be associated with individual items or with a series, episode, clip.
     * 
     *  @property director
     *  @type Person
     */
    prototype.director = null;
    /**
     *  Schema.org/productionCompany
     *  The production company or studio responsible for the item e.g. series, video game, episode etc.
     * 
     *  @property productionCompany
     *  @type Organization
     */
    prototype.productionCompany = null;
    /**
     *  Schema.org/episode
     *  An episode of a tv, radio or game media within a series or season.
     * 
     *  @property episode
     *  @type Episode
     */
    prototype.episode = null;
    /**
     *  Schema.org/seasonNumber
     *  Position of the season within an ordered group of seasons.
     * 
     *  @property seasonNumber
     *  @type Text
     */
    prototype.seasonNumber = null;
}, {actor: "Person", partOfSeries: "CreativeWorkSeries", trailer: "VideoObject", episodes: "Episode", director: "Person", productionCompany: "Organization", episode: "Episode", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Series
 *  <p>
 *  A Series in schema.org is a group of related items, typically but not necessarily of the same kind.
 * 
 *  @author schema.org
 *  @class Series
 *  @module org.schema
 *  @extends CreativeWork
 */
var Series = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CreativeWork.call(this);
    this.context = "http://schema.org/";
    this.type = "Series";
};
Series = stjs.extend(Series, CreativeWork, [], null, {about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/UserComments
 *  UserInteraction and its subtypes is an old way of talking about users interacting with pages. It is generally better to use [[Action]]-based vocabulary, alongside types such as [[Comment]].
 * 
 *  @author schema.org
 *  @class UserComments
 *  @module org.schema
 *  @extends UserInteraction
 */
var UserComments = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    UserInteraction.call(this);
    this.context = "http://schema.org/";
    this.type = "UserComments";
};
UserComments = stjs.extend(UserComments, UserInteraction, [], function(constructor, prototype) {
    /**
     *  Schema.org/discusses
     *  Specifies the CreativeWork associated with the UserComment.
     * 
     *  @property discusses
     *  @type CreativeWork
     */
    prototype.discusses = null;
    /**
     *  Schema.org/commentText
     *  The text of the UserComment.
     * 
     *  @property commentText
     *  @type Text
     */
    prototype.commentText = null;
    /**
     *  Schema.org/commentTime
     *  The time at which the UserComment was made.
     * 
     *  @property commentTime
     *  @type Date
     */
    prototype.commentTime = null;
    /**
     *  Schema.org/creator
     *  The creator/author of this CreativeWork. This is the same as the Author property for CreativeWork.
     * 
     *  @property creator
     *  @type Person
     */
    prototype.creator = null;
    /**
     *  Schema.org/replyToUrl
     *  The URL at which a reply may be posted to the specified UserComment.
     * 
     *  @property replyToUrl
     *  @type URL
     */
    prototype.replyToUrl = null;
}, {discusses: "CreativeWork", creator: "Person", about: "Thing", funder: "Person", workFeatured: "CreativeWork", audience: "Audience", actor: "Person", performers: "Organization", contributor: "Organization", organizer: "Person", attendees: "Person", aggregateRating: "AggregateRating", subEvent: "SchemaEvent", subEvents: "SchemaEvent", offers: "Offer", attendee: "Organization", workPerformed: "CreativeWork", eventStatus: "EventStatusType", director: "Person", superEvent: "SchemaEvent", duration: "Duration", translator: "Person", inLanguage: "Language", review: "Review", sponsor: "Organization", location: "PostalAddress", recordedIn: "CreativeWork", composer: "Organization", performer: "Person", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/UserCheckins
 *  UserInteraction and its subtypes is an old way of talking about users interacting with pages. It is generally better to use [[Action]]-based vocabulary, alongside types such as [[Comment]].
 * 
 *  @author schema.org
 *  @class UserCheckins
 *  @module org.schema
 *  @extends UserInteraction
 */
var UserCheckins = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    UserInteraction.call(this);
    this.context = "http://schema.org/";
    this.type = "UserCheckins";
};
UserCheckins = stjs.extend(UserCheckins, UserInteraction, [], null, {about: "Thing", funder: "Person", workFeatured: "CreativeWork", audience: "Audience", actor: "Person", performers: "Organization", contributor: "Organization", organizer: "Person", attendees: "Person", aggregateRating: "AggregateRating", subEvent: "SchemaEvent", subEvents: "SchemaEvent", offers: "Offer", attendee: "Organization", workPerformed: "CreativeWork", eventStatus: "EventStatusType", director: "Person", superEvent: "SchemaEvent", duration: "Duration", translator: "Person", inLanguage: "Language", review: "Review", sponsor: "Organization", location: "PostalAddress", recordedIn: "CreativeWork", composer: "Organization", performer: "Person", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/UserLikes
 *  UserInteraction and its subtypes is an old way of talking about users interacting with pages. It is generally better to use [[Action]]-based vocabulary, alongside types such as [[Comment]].
 * 
 *  @author schema.org
 *  @class UserLikes
 *  @module org.schema
 *  @extends UserInteraction
 */
var UserLikes = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    UserInteraction.call(this);
    this.context = "http://schema.org/";
    this.type = "UserLikes";
};
UserLikes = stjs.extend(UserLikes, UserInteraction, [], null, {about: "Thing", funder: "Person", workFeatured: "CreativeWork", audience: "Audience", actor: "Person", performers: "Organization", contributor: "Organization", organizer: "Person", attendees: "Person", aggregateRating: "AggregateRating", subEvent: "SchemaEvent", subEvents: "SchemaEvent", offers: "Offer", attendee: "Organization", workPerformed: "CreativeWork", eventStatus: "EventStatusType", director: "Person", superEvent: "SchemaEvent", duration: "Duration", translator: "Person", inLanguage: "Language", review: "Review", sponsor: "Organization", location: "PostalAddress", recordedIn: "CreativeWork", composer: "Organization", performer: "Person", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/UserBlocks
 *  UserInteraction and its subtypes is an old way of talking about users interacting with pages. It is generally better to use [[Action]]-based vocabulary, alongside types such as [[Comment]].
 * 
 *  @author schema.org
 *  @class UserBlocks
 *  @module org.schema
 *  @extends UserInteraction
 */
var UserBlocks = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    UserInteraction.call(this);
    this.context = "http://schema.org/";
    this.type = "UserBlocks";
};
UserBlocks = stjs.extend(UserBlocks, UserInteraction, [], null, {about: "Thing", funder: "Person", workFeatured: "CreativeWork", audience: "Audience", actor: "Person", performers: "Organization", contributor: "Organization", organizer: "Person", attendees: "Person", aggregateRating: "AggregateRating", subEvent: "SchemaEvent", subEvents: "SchemaEvent", offers: "Offer", attendee: "Organization", workPerformed: "CreativeWork", eventStatus: "EventStatusType", director: "Person", superEvent: "SchemaEvent", duration: "Duration", translator: "Person", inLanguage: "Language", review: "Review", sponsor: "Organization", location: "PostalAddress", recordedIn: "CreativeWork", composer: "Organization", performer: "Person", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/UserPlays
 *  UserInteraction and its subtypes is an old way of talking about users interacting with pages. It is generally better to use [[Action]]-based vocabulary, alongside types such as [[Comment]].
 * 
 *  @author schema.org
 *  @class UserPlays
 *  @module org.schema
 *  @extends UserInteraction
 */
var UserPlays = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    UserInteraction.call(this);
    this.context = "http://schema.org/";
    this.type = "UserPlays";
};
UserPlays = stjs.extend(UserPlays, UserInteraction, [], null, {about: "Thing", funder: "Person", workFeatured: "CreativeWork", audience: "Audience", actor: "Person", performers: "Organization", contributor: "Organization", organizer: "Person", attendees: "Person", aggregateRating: "AggregateRating", subEvent: "SchemaEvent", subEvents: "SchemaEvent", offers: "Offer", attendee: "Organization", workPerformed: "CreativeWork", eventStatus: "EventStatusType", director: "Person", superEvent: "SchemaEvent", duration: "Duration", translator: "Person", inLanguage: "Language", review: "Review", sponsor: "Organization", location: "PostalAddress", recordedIn: "CreativeWork", composer: "Organization", performer: "Person", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/UserPlusOnes
 *  UserInteraction and its subtypes is an old way of talking about users interacting with pages. It is generally better to use [[Action]]-based vocabulary, alongside types such as [[Comment]].
 * 
 *  @author schema.org
 *  @class UserPlusOnes
 *  @module org.schema
 *  @extends UserInteraction
 */
var UserPlusOnes = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    UserInteraction.call(this);
    this.context = "http://schema.org/";
    this.type = "UserPlusOnes";
};
UserPlusOnes = stjs.extend(UserPlusOnes, UserInteraction, [], null, {about: "Thing", funder: "Person", workFeatured: "CreativeWork", audience: "Audience", actor: "Person", performers: "Organization", contributor: "Organization", organizer: "Person", attendees: "Person", aggregateRating: "AggregateRating", subEvent: "SchemaEvent", subEvents: "SchemaEvent", offers: "Offer", attendee: "Organization", workPerformed: "CreativeWork", eventStatus: "EventStatusType", director: "Person", superEvent: "SchemaEvent", duration: "Duration", translator: "Person", inLanguage: "Language", review: "Review", sponsor: "Organization", location: "PostalAddress", recordedIn: "CreativeWork", composer: "Organization", performer: "Person", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/UserPageVisits
 *  UserInteraction and its subtypes is an old way of talking about users interacting with pages. It is generally better to use [[Action]]-based vocabulary, alongside types such as [[Comment]].
 * 
 *  @author schema.org
 *  @class UserPageVisits
 *  @module org.schema
 *  @extends UserInteraction
 */
var UserPageVisits = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    UserInteraction.call(this);
    this.context = "http://schema.org/";
    this.type = "UserPageVisits";
};
UserPageVisits = stjs.extend(UserPageVisits, UserInteraction, [], null, {about: "Thing", funder: "Person", workFeatured: "CreativeWork", audience: "Audience", actor: "Person", performers: "Organization", contributor: "Organization", organizer: "Person", attendees: "Person", aggregateRating: "AggregateRating", subEvent: "SchemaEvent", subEvents: "SchemaEvent", offers: "Offer", attendee: "Organization", workPerformed: "CreativeWork", eventStatus: "EventStatusType", director: "Person", superEvent: "SchemaEvent", duration: "Duration", translator: "Person", inLanguage: "Language", review: "Review", sponsor: "Organization", location: "PostalAddress", recordedIn: "CreativeWork", composer: "Organization", performer: "Person", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/UserDownloads
 *  UserInteraction and its subtypes is an old way of talking about users interacting with pages. It is generally better to use [[Action]]-based vocabulary, alongside types such as [[Comment]].
 * 
 *  @author schema.org
 *  @class UserDownloads
 *  @module org.schema
 *  @extends UserInteraction
 */
var UserDownloads = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    UserInteraction.call(this);
    this.context = "http://schema.org/";
    this.type = "UserDownloads";
};
UserDownloads = stjs.extend(UserDownloads, UserInteraction, [], null, {about: "Thing", funder: "Person", workFeatured: "CreativeWork", audience: "Audience", actor: "Person", performers: "Organization", contributor: "Organization", organizer: "Person", attendees: "Person", aggregateRating: "AggregateRating", subEvent: "SchemaEvent", subEvents: "SchemaEvent", offers: "Offer", attendee: "Organization", workPerformed: "CreativeWork", eventStatus: "EventStatusType", director: "Person", superEvent: "SchemaEvent", duration: "Duration", translator: "Person", inLanguage: "Language", review: "Review", sponsor: "Organization", location: "PostalAddress", recordedIn: "CreativeWork", composer: "Organization", performer: "Person", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/UserTweets
 *  UserInteraction and its subtypes is an old way of talking about users interacting with pages. It is generally better to use [[Action]]-based vocabulary, alongside types such as [[Comment]].
 * 
 *  @author schema.org
 *  @class UserTweets
 *  @module org.schema
 *  @extends UserInteraction
 */
var UserTweets = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    UserInteraction.call(this);
    this.context = "http://schema.org/";
    this.type = "UserTweets";
};
UserTweets = stjs.extend(UserTweets, UserInteraction, [], null, {about: "Thing", funder: "Person", workFeatured: "CreativeWork", audience: "Audience", actor: "Person", performers: "Organization", contributor: "Organization", organizer: "Person", attendees: "Person", aggregateRating: "AggregateRating", subEvent: "SchemaEvent", subEvents: "SchemaEvent", offers: "Offer", attendee: "Organization", workPerformed: "CreativeWork", eventStatus: "EventStatusType", director: "Person", superEvent: "SchemaEvent", duration: "Duration", translator: "Person", inLanguage: "Language", review: "Review", sponsor: "Organization", location: "PostalAddress", recordedIn: "CreativeWork", composer: "Organization", performer: "Person", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/BroadcastEvent
 *  An over the air or online broadcast event.
 * 
 *  @author schema.org
 *  @class BroadcastEvent
 *  @module org.schema
 *  @extends PublicationEvent
 */
var BroadcastEvent = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    PublicationEvent.call(this);
    this.context = "http://schema.org/";
    this.type = "BroadcastEvent";
};
BroadcastEvent = stjs.extend(BroadcastEvent, PublicationEvent, [], function(constructor, prototype) {
    /**
     *  Schema.org/videoFormat
     *  The type of screening or video broadcast used (e.g. IMAX, 3D, SD, HD, etc.).
     * 
     *  @property videoFormat
     *  @type Text
     */
    prototype.videoFormat = null;
    /**
     *  Schema.org/isLiveBroadcast
     *  True is the broadcast is of a live event.
     * 
     *  @property isLiveBroadcast
     *  @type Boolean
     */
    prototype.isLiveBroadcast = null;
    /**
     *  Schema.org/broadcastOfEvent
     *  The event being broadcast such as a sporting event or awards ceremony.
     * 
     *  @property broadcastOfEvent
     *  @type SchemaEvent
     */
    prototype.broadcastOfEvent = null;
}, {broadcastOfEvent: "SchemaEvent", publishedOn: "BroadcastService", about: "Thing", funder: "Person", workFeatured: "CreativeWork", audience: "Audience", actor: "Person", performers: "Organization", contributor: "Organization", organizer: "Person", attendees: "Person", aggregateRating: "AggregateRating", subEvent: "SchemaEvent", subEvents: "SchemaEvent", offers: "Offer", attendee: "Organization", workPerformed: "CreativeWork", eventStatus: "EventStatusType", director: "Person", superEvent: "SchemaEvent", duration: "Duration", translator: "Person", inLanguage: "Language", review: "Review", sponsor: "Organization", location: "PostalAddress", recordedIn: "CreativeWork", composer: "Organization", performer: "Person", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/OnDemandEvent
 *  A publication event e.g. catch-up TV or radio podcast, during which a program is available on-demand.
 * 
 *  @author schema.org
 *  @class OnDemandEvent
 *  @module org.schema
 *  @extends PublicationEvent
 */
var OnDemandEvent = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    PublicationEvent.call(this);
    this.context = "http://schema.org/";
    this.type = "OnDemandEvent";
};
OnDemandEvent = stjs.extend(OnDemandEvent, PublicationEvent, [], null, {publishedOn: "BroadcastService", about: "Thing", funder: "Person", workFeatured: "CreativeWork", audience: "Audience", actor: "Person", performers: "Organization", contributor: "Organization", organizer: "Person", attendees: "Person", aggregateRating: "AggregateRating", subEvent: "SchemaEvent", subEvents: "SchemaEvent", offers: "Offer", attendee: "Organization", workPerformed: "CreativeWork", eventStatus: "EventStatusType", director: "Person", superEvent: "SchemaEvent", duration: "Duration", translator: "Person", inLanguage: "Language", review: "Review", sponsor: "Organization", location: "PostalAddress", recordedIn: "CreativeWork", composer: "Organization", performer: "Person", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/State
 *  A state or province of a country.
 * 
 *  @author schema.org
 *  @class State
 *  @module org.schema
 *  @extends AdministrativeArea
 */
var State = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    AdministrativeArea.call(this);
    this.context = "http://schema.org/";
    this.type = "State";
};
State = stjs.extend(State, AdministrativeArea, [], null, {photo: "ImageObject", address: "PostalAddress", openingHoursSpecification: "OpeningHoursSpecification", containedInPlace: "Place", reviews: "Review", aggregateRating: "AggregateRating", photos: "Photograph", hasMap: "SchemaMap", additionalProperty: "PropertyValue", events: "SchemaEvent", specialOpeningHoursSpecification: "OpeningHoursSpecification", amenityFeature: "LocationFeatureSpecification", logo: "ImageObject", geo: "GeoCoordinates", review: "Review", event: "SchemaEvent", containsPlace: "Place", containedIn: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Country
 *  A country.
 * 
 *  @author schema.org
 *  @class Country
 *  @module org.schema
 *  @extends AdministrativeArea
 */
var Country = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    AdministrativeArea.call(this);
    this.context = "http://schema.org/";
    this.type = "Country";
};
Country = stjs.extend(Country, AdministrativeArea, [], null, {photo: "ImageObject", address: "PostalAddress", openingHoursSpecification: "OpeningHoursSpecification", containedInPlace: "Place", reviews: "Review", aggregateRating: "AggregateRating", photos: "Photograph", hasMap: "SchemaMap", additionalProperty: "PropertyValue", events: "SchemaEvent", specialOpeningHoursSpecification: "OpeningHoursSpecification", amenityFeature: "LocationFeatureSpecification", logo: "ImageObject", geo: "GeoCoordinates", review: "Review", event: "SchemaEvent", containsPlace: "Place", containedIn: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/City
 *  A city or town.
 * 
 *  @author schema.org
 *  @class City
 *  @module org.schema
 *  @extends AdministrativeArea
 */
var City = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    AdministrativeArea.call(this);
    this.context = "http://schema.org/";
    this.type = "City";
};
City = stjs.extend(City, AdministrativeArea, [], null, {photo: "ImageObject", address: "PostalAddress", openingHoursSpecification: "OpeningHoursSpecification", containedInPlace: "Place", reviews: "Review", aggregateRating: "AggregateRating", photos: "Photograph", hasMap: "SchemaMap", additionalProperty: "PropertyValue", events: "SchemaEvent", specialOpeningHoursSpecification: "OpeningHoursSpecification", amenityFeature: "LocationFeatureSpecification", logo: "ImageObject", geo: "GeoCoordinates", review: "Review", event: "SchemaEvent", containsPlace: "Place", containedIn: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/TaxiStand
 *  A taxi stand.
 * 
 *  @author schema.org
 *  @class TaxiStand
 *  @module org.schema
 *  @extends CivicStructure
 */
var TaxiStand = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CivicStructure.call(this);
    this.context = "http://schema.org/";
    this.type = "TaxiStand";
};
TaxiStand = stjs.extend(TaxiStand, CivicStructure, [], null, {photo: "ImageObject", address: "PostalAddress", openingHoursSpecification: "OpeningHoursSpecification", containedInPlace: "Place", reviews: "Review", aggregateRating: "AggregateRating", photos: "Photograph", hasMap: "SchemaMap", additionalProperty: "PropertyValue", events: "SchemaEvent", specialOpeningHoursSpecification: "OpeningHoursSpecification", amenityFeature: "LocationFeatureSpecification", logo: "ImageObject", geo: "GeoCoordinates", review: "Review", event: "SchemaEvent", containsPlace: "Place", containedIn: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Hospital
 *  A hospital.
 * 
 *  @author schema.org
 *  @class Hospital
 *  @module org.schema
 *  @extends CivicStructure
 */
var Hospital = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CivicStructure.call(this);
    this.context = "http://schema.org/";
    this.type = "Hospital";
};
Hospital = stjs.extend(Hospital, CivicStructure, [], null, {photo: "ImageObject", address: "PostalAddress", openingHoursSpecification: "OpeningHoursSpecification", containedInPlace: "Place", reviews: "Review", aggregateRating: "AggregateRating", photos: "Photograph", hasMap: "SchemaMap", additionalProperty: "PropertyValue", events: "SchemaEvent", specialOpeningHoursSpecification: "OpeningHoursSpecification", amenityFeature: "LocationFeatureSpecification", logo: "ImageObject", geo: "GeoCoordinates", review: "Review", event: "SchemaEvent", containsPlace: "Place", containedIn: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Museum
 *  A museum.
 * 
 *  @author schema.org
 *  @class Museum
 *  @module org.schema
 *  @extends CivicStructure
 */
var Museum = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CivicStructure.call(this);
    this.context = "http://schema.org/";
    this.type = "Museum";
};
Museum = stjs.extend(Museum, CivicStructure, [], null, {photo: "ImageObject", address: "PostalAddress", openingHoursSpecification: "OpeningHoursSpecification", containedInPlace: "Place", reviews: "Review", aggregateRating: "AggregateRating", photos: "Photograph", hasMap: "SchemaMap", additionalProperty: "PropertyValue", events: "SchemaEvent", specialOpeningHoursSpecification: "OpeningHoursSpecification", amenityFeature: "LocationFeatureSpecification", logo: "ImageObject", geo: "GeoCoordinates", review: "Review", event: "SchemaEvent", containsPlace: "Place", containedIn: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/RVPark
 *  A place offering space for "Recreational Vehicles", Caravans, mobile homes and the like.
 * 
 *  @author schema.org
 *  @class RVPark
 *  @module org.schema
 *  @extends CivicStructure
 */
var RVPark = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CivicStructure.call(this);
    this.context = "http://schema.org/";
    this.type = "RVPark";
};
RVPark = stjs.extend(RVPark, CivicStructure, [], null, {photo: "ImageObject", address: "PostalAddress", openingHoursSpecification: "OpeningHoursSpecification", containedInPlace: "Place", reviews: "Review", aggregateRating: "AggregateRating", photos: "Photograph", hasMap: "SchemaMap", additionalProperty: "PropertyValue", events: "SchemaEvent", specialOpeningHoursSpecification: "OpeningHoursSpecification", amenityFeature: "LocationFeatureSpecification", logo: "ImageObject", geo: "GeoCoordinates", review: "Review", event: "SchemaEvent", containsPlace: "Place", containedIn: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Aquarium
 *  Aquarium.
 * 
 *  @author schema.org
 *  @class Aquarium
 *  @module org.schema
 *  @extends CivicStructure
 */
var Aquarium = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CivicStructure.call(this);
    this.context = "http://schema.org/";
    this.type = "Aquarium";
};
Aquarium = stjs.extend(Aquarium, CivicStructure, [], null, {photo: "ImageObject", address: "PostalAddress", openingHoursSpecification: "OpeningHoursSpecification", containedInPlace: "Place", reviews: "Review", aggregateRating: "AggregateRating", photos: "Photograph", hasMap: "SchemaMap", additionalProperty: "PropertyValue", events: "SchemaEvent", specialOpeningHoursSpecification: "OpeningHoursSpecification", amenityFeature: "LocationFeatureSpecification", logo: "ImageObject", geo: "GeoCoordinates", review: "Review", event: "SchemaEvent", containsPlace: "Place", containedIn: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Airport
 *  An airport.
 * 
 *  @author schema.org
 *  @class Airport
 *  @module org.schema
 *  @extends CivicStructure
 */
var Airport = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CivicStructure.call(this);
    this.context = "http://schema.org/";
    this.type = "Airport";
};
Airport = stjs.extend(Airport, CivicStructure, [], function(constructor, prototype) {
    /**
     *  Schema.org/iataCode
     *  IATA identifier for an airline or airport.
     * 
     *  @property iataCode
     *  @type Text
     */
    prototype.iataCode = null;
    /**
     *  Schema.org/icaoCode
     *  ICAO identifier for an airport.
     * 
     *  @property icaoCode
     *  @type Text
     */
    prototype.icaoCode = null;
}, {photo: "ImageObject", address: "PostalAddress", openingHoursSpecification: "OpeningHoursSpecification", containedInPlace: "Place", reviews: "Review", aggregateRating: "AggregateRating", photos: "Photograph", hasMap: "SchemaMap", additionalProperty: "PropertyValue", events: "SchemaEvent", specialOpeningHoursSpecification: "OpeningHoursSpecification", amenityFeature: "LocationFeatureSpecification", logo: "ImageObject", geo: "GeoCoordinates", review: "Review", event: "SchemaEvent", containsPlace: "Place", containedIn: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Beach
 *  Beach.
 * 
 *  @author schema.org
 *  @class Beach
 *  @module org.schema
 *  @extends CivicStructure
 */
var Beach = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CivicStructure.call(this);
    this.context = "http://schema.org/";
    this.type = "Beach";
};
Beach = stjs.extend(Beach, CivicStructure, [], null, {photo: "ImageObject", address: "PostalAddress", openingHoursSpecification: "OpeningHoursSpecification", containedInPlace: "Place", reviews: "Review", aggregateRating: "AggregateRating", photos: "Photograph", hasMap: "SchemaMap", additionalProperty: "PropertyValue", events: "SchemaEvent", specialOpeningHoursSpecification: "OpeningHoursSpecification", amenityFeature: "LocationFeatureSpecification", logo: "ImageObject", geo: "GeoCoordinates", review: "Review", event: "SchemaEvent", containsPlace: "Place", containedIn: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/EventVenue
 *  An event venue.
 * 
 *  @author schema.org
 *  @class EventVenue
 *  @module org.schema
 *  @extends CivicStructure
 */
var EventVenue = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CivicStructure.call(this);
    this.context = "http://schema.org/";
    this.type = "EventVenue";
};
EventVenue = stjs.extend(EventVenue, CivicStructure, [], null, {photo: "ImageObject", address: "PostalAddress", openingHoursSpecification: "OpeningHoursSpecification", containedInPlace: "Place", reviews: "Review", aggregateRating: "AggregateRating", photos: "Photograph", hasMap: "SchemaMap", additionalProperty: "PropertyValue", events: "SchemaEvent", specialOpeningHoursSpecification: "OpeningHoursSpecification", amenityFeature: "LocationFeatureSpecification", logo: "ImageObject", geo: "GeoCoordinates", review: "Review", event: "SchemaEvent", containsPlace: "Place", containedIn: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/ParkingFacility
 *  A parking lot or other parking facility.
 * 
 *  @author schema.org
 *  @class ParkingFacility
 *  @module org.schema
 *  @extends CivicStructure
 */
var ParkingFacility = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CivicStructure.call(this);
    this.context = "http://schema.org/";
    this.type = "ParkingFacility";
};
ParkingFacility = stjs.extend(ParkingFacility, CivicStructure, [], null, {photo: "ImageObject", address: "PostalAddress", openingHoursSpecification: "OpeningHoursSpecification", containedInPlace: "Place", reviews: "Review", aggregateRating: "AggregateRating", photos: "Photograph", hasMap: "SchemaMap", additionalProperty: "PropertyValue", events: "SchemaEvent", specialOpeningHoursSpecification: "OpeningHoursSpecification", amenityFeature: "LocationFeatureSpecification", logo: "ImageObject", geo: "GeoCoordinates", review: "Review", event: "SchemaEvent", containsPlace: "Place", containedIn: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/GovernmentBuilding
 *  A government building.
 * 
 *  @author schema.org
 *  @class GovernmentBuilding
 *  @module org.schema
 *  @extends CivicStructure
 */
var GovernmentBuilding = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CivicStructure.call(this);
    this.context = "http://schema.org/";
    this.type = "GovernmentBuilding";
};
GovernmentBuilding = stjs.extend(GovernmentBuilding, CivicStructure, [], null, {photo: "ImageObject", address: "PostalAddress", openingHoursSpecification: "OpeningHoursSpecification", containedInPlace: "Place", reviews: "Review", aggregateRating: "AggregateRating", photos: "Photograph", hasMap: "SchemaMap", additionalProperty: "PropertyValue", events: "SchemaEvent", specialOpeningHoursSpecification: "OpeningHoursSpecification", amenityFeature: "LocationFeatureSpecification", logo: "ImageObject", geo: "GeoCoordinates", review: "Review", event: "SchemaEvent", containsPlace: "Place", containedIn: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Campground
 *  A camping site, campsite, or campground is a place used for overnight stay in the outdoors. In British English a campsite is an area, usually divided into a number of pitches, where people can camp overnight using tents or camper vans or caravans; this British English use of the word is synonymous with the American English expression campground. In American English the term campsite generally means an area where an individual, family, group, or military unit can pitch a tent or parks a camper; a campground may contain many campsites (Source: Wikipedia, the free encyclopedia, see <a href="http://en.wikipedia.org/wiki/Campsite">http://en.wikipedia.org/wiki/Campsite</a>).
 *  <br /><br />
 *  See also the <a href="/docs/hotels.html">dedicated document on the use of schema.org for marking up hotels and other forms of accommodations</a>.
 * 
 *  @author schema.org
 *  @class Campground
 *  @module org.schema
 *  @extends CivicStructure
 */
var Campground = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CivicStructure.call(this);
    this.context = "http://schema.org/";
    this.type = "Campground";
};
Campground = stjs.extend(Campground, CivicStructure, [], null, {photo: "ImageObject", address: "PostalAddress", openingHoursSpecification: "OpeningHoursSpecification", containedInPlace: "Place", reviews: "Review", aggregateRating: "AggregateRating", photos: "Photograph", hasMap: "SchemaMap", additionalProperty: "PropertyValue", events: "SchemaEvent", specialOpeningHoursSpecification: "OpeningHoursSpecification", amenityFeature: "LocationFeatureSpecification", logo: "ImageObject", geo: "GeoCoordinates", review: "Review", event: "SchemaEvent", containsPlace: "Place", containedIn: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/MovieTheater
 *  A movie theater.
 * 
 *  @author schema.org
 *  @class MovieTheater
 *  @module org.schema
 *  @extends CivicStructure
 */
var MovieTheater = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CivicStructure.call(this);
    this.context = "http://schema.org/";
    this.type = "MovieTheater";
};
MovieTheater = stjs.extend(MovieTheater, CivicStructure, [], function(constructor, prototype) {
    /**
     *  Schema.org/screenCount
     *  The number of screens in the movie theater.
     * 
     *  @property screenCount
     *  @type Number
     */
    prototype.screenCount = null;
}, {photo: "ImageObject", address: "PostalAddress", openingHoursSpecification: "OpeningHoursSpecification", containedInPlace: "Place", reviews: "Review", aggregateRating: "AggregateRating", photos: "Photograph", hasMap: "SchemaMap", additionalProperty: "PropertyValue", events: "SchemaEvent", specialOpeningHoursSpecification: "OpeningHoursSpecification", amenityFeature: "LocationFeatureSpecification", logo: "ImageObject", geo: "GeoCoordinates", review: "Review", event: "SchemaEvent", containsPlace: "Place", containedIn: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/PlaceOfWorship
 *  Place of worship, such as a church, synagogue, or mosque.
 * 
 *  @author schema.org
 *  @class PlaceOfWorship
 *  @module org.schema
 *  @extends CivicStructure
 */
var PlaceOfWorship = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CivicStructure.call(this);
    this.context = "http://schema.org/";
    this.type = "PlaceOfWorship";
};
PlaceOfWorship = stjs.extend(PlaceOfWorship, CivicStructure, [], null, {photo: "ImageObject", address: "PostalAddress", openingHoursSpecification: "OpeningHoursSpecification", containedInPlace: "Place", reviews: "Review", aggregateRating: "AggregateRating", photos: "Photograph", hasMap: "SchemaMap", additionalProperty: "PropertyValue", events: "SchemaEvent", specialOpeningHoursSpecification: "OpeningHoursSpecification", amenityFeature: "LocationFeatureSpecification", logo: "ImageObject", geo: "GeoCoordinates", review: "Review", event: "SchemaEvent", containsPlace: "Place", containedIn: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/BusStop
 *  A bus stop.
 * 
 *  @author schema.org
 *  @class BusStop
 *  @module org.schema
 *  @extends CivicStructure
 */
var BusStop = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CivicStructure.call(this);
    this.context = "http://schema.org/";
    this.type = "BusStop";
};
BusStop = stjs.extend(BusStop, CivicStructure, [], null, {photo: "ImageObject", address: "PostalAddress", openingHoursSpecification: "OpeningHoursSpecification", containedInPlace: "Place", reviews: "Review", aggregateRating: "AggregateRating", photos: "Photograph", hasMap: "SchemaMap", additionalProperty: "PropertyValue", events: "SchemaEvent", specialOpeningHoursSpecification: "OpeningHoursSpecification", amenityFeature: "LocationFeatureSpecification", logo: "ImageObject", geo: "GeoCoordinates", review: "Review", event: "SchemaEvent", containsPlace: "Place", containedIn: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/FireStation
 *  A fire station. With firemen.
 * 
 *  @author schema.org
 *  @class FireStation
 *  @module org.schema
 *  @extends CivicStructure
 */
var FireStation = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CivicStructure.call(this);
    this.context = "http://schema.org/";
    this.type = "FireStation";
};
FireStation = stjs.extend(FireStation, CivicStructure, [], null, {photo: "ImageObject", address: "PostalAddress", openingHoursSpecification: "OpeningHoursSpecification", containedInPlace: "Place", reviews: "Review", aggregateRating: "AggregateRating", photos: "Photograph", hasMap: "SchemaMap", additionalProperty: "PropertyValue", events: "SchemaEvent", specialOpeningHoursSpecification: "OpeningHoursSpecification", amenityFeature: "LocationFeatureSpecification", logo: "ImageObject", geo: "GeoCoordinates", review: "Review", event: "SchemaEvent", containsPlace: "Place", containedIn: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Bridge
 *  A bridge.
 * 
 *  @author schema.org
 *  @class Bridge
 *  @module org.schema
 *  @extends CivicStructure
 */
var Bridge = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CivicStructure.call(this);
    this.context = "http://schema.org/";
    this.type = "Bridge";
};
Bridge = stjs.extend(Bridge, CivicStructure, [], null, {photo: "ImageObject", address: "PostalAddress", openingHoursSpecification: "OpeningHoursSpecification", containedInPlace: "Place", reviews: "Review", aggregateRating: "AggregateRating", photos: "Photograph", hasMap: "SchemaMap", additionalProperty: "PropertyValue", events: "SchemaEvent", specialOpeningHoursSpecification: "OpeningHoursSpecification", amenityFeature: "LocationFeatureSpecification", logo: "ImageObject", geo: "GeoCoordinates", review: "Review", event: "SchemaEvent", containsPlace: "Place", containedIn: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Cemetery
 *  A graveyard.
 * 
 *  @author schema.org
 *  @class Cemetery
 *  @module org.schema
 *  @extends CivicStructure
 */
var Cemetery = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CivicStructure.call(this);
    this.context = "http://schema.org/";
    this.type = "Cemetery";
};
Cemetery = stjs.extend(Cemetery, CivicStructure, [], null, {photo: "ImageObject", address: "PostalAddress", openingHoursSpecification: "OpeningHoursSpecification", containedInPlace: "Place", reviews: "Review", aggregateRating: "AggregateRating", photos: "Photograph", hasMap: "SchemaMap", additionalProperty: "PropertyValue", events: "SchemaEvent", specialOpeningHoursSpecification: "OpeningHoursSpecification", amenityFeature: "LocationFeatureSpecification", logo: "ImageObject", geo: "GeoCoordinates", review: "Review", event: "SchemaEvent", containsPlace: "Place", containedIn: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/BusStation
 *  A bus station.
 * 
 *  @author schema.org
 *  @class BusStation
 *  @module org.schema
 *  @extends CivicStructure
 */
var BusStation = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CivicStructure.call(this);
    this.context = "http://schema.org/";
    this.type = "BusStation";
};
BusStation = stjs.extend(BusStation, CivicStructure, [], null, {photo: "ImageObject", address: "PostalAddress", openingHoursSpecification: "OpeningHoursSpecification", containedInPlace: "Place", reviews: "Review", aggregateRating: "AggregateRating", photos: "Photograph", hasMap: "SchemaMap", additionalProperty: "PropertyValue", events: "SchemaEvent", specialOpeningHoursSpecification: "OpeningHoursSpecification", amenityFeature: "LocationFeatureSpecification", logo: "ImageObject", geo: "GeoCoordinates", review: "Review", event: "SchemaEvent", containsPlace: "Place", containedIn: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Crematorium
 *  A crematorium.
 * 
 *  @author schema.org
 *  @class Crematorium
 *  @module org.schema
 *  @extends CivicStructure
 */
var Crematorium = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CivicStructure.call(this);
    this.context = "http://schema.org/";
    this.type = "Crematorium";
};
Crematorium = stjs.extend(Crematorium, CivicStructure, [], null, {photo: "ImageObject", address: "PostalAddress", openingHoursSpecification: "OpeningHoursSpecification", containedInPlace: "Place", reviews: "Review", aggregateRating: "AggregateRating", photos: "Photograph", hasMap: "SchemaMap", additionalProperty: "PropertyValue", events: "SchemaEvent", specialOpeningHoursSpecification: "OpeningHoursSpecification", amenityFeature: "LocationFeatureSpecification", logo: "ImageObject", geo: "GeoCoordinates", review: "Review", event: "SchemaEvent", containsPlace: "Place", containedIn: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/TrainStation
 *  A train station.
 * 
 *  @author schema.org
 *  @class TrainStation
 *  @module org.schema
 *  @extends CivicStructure
 */
var TrainStation = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CivicStructure.call(this);
    this.context = "http://schema.org/";
    this.type = "TrainStation";
};
TrainStation = stjs.extend(TrainStation, CivicStructure, [], null, {photo: "ImageObject", address: "PostalAddress", openingHoursSpecification: "OpeningHoursSpecification", containedInPlace: "Place", reviews: "Review", aggregateRating: "AggregateRating", photos: "Photograph", hasMap: "SchemaMap", additionalProperty: "PropertyValue", events: "SchemaEvent", specialOpeningHoursSpecification: "OpeningHoursSpecification", amenityFeature: "LocationFeatureSpecification", logo: "ImageObject", geo: "GeoCoordinates", review: "Review", event: "SchemaEvent", containsPlace: "Place", containedIn: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/PoliceStation
 *  A police station.
 * 
 *  @author schema.org
 *  @class PoliceStation
 *  @module org.schema
 *  @extends CivicStructure
 */
var PoliceStation = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CivicStructure.call(this);
    this.context = "http://schema.org/";
    this.type = "PoliceStation";
};
PoliceStation = stjs.extend(PoliceStation, CivicStructure, [], null, {photo: "ImageObject", address: "PostalAddress", openingHoursSpecification: "OpeningHoursSpecification", containedInPlace: "Place", reviews: "Review", aggregateRating: "AggregateRating", photos: "Photograph", hasMap: "SchemaMap", additionalProperty: "PropertyValue", events: "SchemaEvent", specialOpeningHoursSpecification: "OpeningHoursSpecification", amenityFeature: "LocationFeatureSpecification", logo: "ImageObject", geo: "GeoCoordinates", review: "Review", event: "SchemaEvent", containsPlace: "Place", containedIn: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Zoo
 *  A zoo.
 * 
 *  @author schema.org
 *  @class Zoo
 *  @module org.schema
 *  @extends CivicStructure
 */
var Zoo = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CivicStructure.call(this);
    this.context = "http://schema.org/";
    this.type = "Zoo";
};
Zoo = stjs.extend(Zoo, CivicStructure, [], null, {photo: "ImageObject", address: "PostalAddress", openingHoursSpecification: "OpeningHoursSpecification", containedInPlace: "Place", reviews: "Review", aggregateRating: "AggregateRating", photos: "Photograph", hasMap: "SchemaMap", additionalProperty: "PropertyValue", events: "SchemaEvent", specialOpeningHoursSpecification: "OpeningHoursSpecification", amenityFeature: "LocationFeatureSpecification", logo: "ImageObject", geo: "GeoCoordinates", review: "Review", event: "SchemaEvent", containsPlace: "Place", containedIn: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/PerformingArtsTheater
 *  A theater or other performing art center.
 * 
 *  @author schema.org
 *  @class PerformingArtsTheater
 *  @module org.schema
 *  @extends CivicStructure
 */
var PerformingArtsTheater = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CivicStructure.call(this);
    this.context = "http://schema.org/";
    this.type = "PerformingArtsTheater";
};
PerformingArtsTheater = stjs.extend(PerformingArtsTheater, CivicStructure, [], null, {photo: "ImageObject", address: "PostalAddress", openingHoursSpecification: "OpeningHoursSpecification", containedInPlace: "Place", reviews: "Review", aggregateRating: "AggregateRating", photos: "Photograph", hasMap: "SchemaMap", additionalProperty: "PropertyValue", events: "SchemaEvent", specialOpeningHoursSpecification: "OpeningHoursSpecification", amenityFeature: "LocationFeatureSpecification", logo: "ImageObject", geo: "GeoCoordinates", review: "Review", event: "SchemaEvent", containsPlace: "Place", containedIn: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/MusicVenue
 *  A music venue.
 * 
 *  @author schema.org
 *  @class MusicVenue
 *  @module org.schema
 *  @extends CivicStructure
 */
var MusicVenue = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CivicStructure.call(this);
    this.context = "http://schema.org/";
    this.type = "MusicVenue";
};
MusicVenue = stjs.extend(MusicVenue, CivicStructure, [], null, {photo: "ImageObject", address: "PostalAddress", openingHoursSpecification: "OpeningHoursSpecification", containedInPlace: "Place", reviews: "Review", aggregateRating: "AggregateRating", photos: "Photograph", hasMap: "SchemaMap", additionalProperty: "PropertyValue", events: "SchemaEvent", specialOpeningHoursSpecification: "OpeningHoursSpecification", amenityFeature: "LocationFeatureSpecification", logo: "ImageObject", geo: "GeoCoordinates", review: "Review", event: "SchemaEvent", containsPlace: "Place", containedIn: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Playground
 *  A playground.
 * 
 *  @author schema.org
 *  @class Playground
 *  @module org.schema
 *  @extends CivicStructure
 */
var Playground = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CivicStructure.call(this);
    this.context = "http://schema.org/";
    this.type = "Playground";
};
Playground = stjs.extend(Playground, CivicStructure, [], null, {photo: "ImageObject", address: "PostalAddress", openingHoursSpecification: "OpeningHoursSpecification", containedInPlace: "Place", reviews: "Review", aggregateRating: "AggregateRating", photos: "Photograph", hasMap: "SchemaMap", additionalProperty: "PropertyValue", events: "SchemaEvent", specialOpeningHoursSpecification: "OpeningHoursSpecification", amenityFeature: "LocationFeatureSpecification", logo: "ImageObject", geo: "GeoCoordinates", review: "Review", event: "SchemaEvent", containsPlace: "Place", containedIn: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Park
 *  A park.
 * 
 *  @author schema.org
 *  @class Park
 *  @module org.schema
 *  @extends CivicStructure
 */
var Park = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CivicStructure.call(this);
    this.context = "http://schema.org/";
    this.type = "Park";
};
Park = stjs.extend(Park, CivicStructure, [], null, {photo: "ImageObject", address: "PostalAddress", openingHoursSpecification: "OpeningHoursSpecification", containedInPlace: "Place", reviews: "Review", aggregateRating: "AggregateRating", photos: "Photograph", hasMap: "SchemaMap", additionalProperty: "PropertyValue", events: "SchemaEvent", specialOpeningHoursSpecification: "OpeningHoursSpecification", amenityFeature: "LocationFeatureSpecification", logo: "ImageObject", geo: "GeoCoordinates", review: "Review", event: "SchemaEvent", containsPlace: "Place", containedIn: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/SubwayStation
 *  A subway station.
 * 
 *  @author schema.org
 *  @class SubwayStation
 *  @module org.schema
 *  @extends CivicStructure
 */
var SubwayStation = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CivicStructure.call(this);
    this.context = "http://schema.org/";
    this.type = "SubwayStation";
};
SubwayStation = stjs.extend(SubwayStation, CivicStructure, [], null, {photo: "ImageObject", address: "PostalAddress", openingHoursSpecification: "OpeningHoursSpecification", containedInPlace: "Place", reviews: "Review", aggregateRating: "AggregateRating", photos: "Photograph", hasMap: "SchemaMap", additionalProperty: "PropertyValue", events: "SchemaEvent", specialOpeningHoursSpecification: "OpeningHoursSpecification", amenityFeature: "LocationFeatureSpecification", logo: "ImageObject", geo: "GeoCoordinates", review: "Review", event: "SchemaEvent", containsPlace: "Place", containedIn: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Apartment
 *  An apartment (in American English) or flat (in British English) is a self-contained housing unit (a type of residential real estate) that occupies only part of a building (Source: Wikipedia, the free encyclopedia, see <a href="http://en.wikipedia.org/wiki/Apartment">http://en.wikipedia.org/wiki/Apartment</a>).
 * 
 *  @author schema.org
 *  @class Apartment
 *  @module org.schema
 *  @extends Accommodation
 */
var Apartment = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Accommodation.call(this);
    this.context = "http://schema.org/";
    this.type = "Apartment";
};
Apartment = stjs.extend(Apartment, Accommodation, [], function(constructor, prototype) {
    /**
     *  Schema.org/occupancy
     *  The allowed total occupancy for the accommodation in persons (including infants etc). For individual accommodations, this is not necessarily the legal maximum but defines the permitted usage as per the contractual agreement (e.g. a double room used by a single person).
     *  Typical unit code(s): C62 for person
     * 
     *  @property occupancy
     *  @type QuantitativeValue
     */
    prototype.occupancy = null;
    /**
     *  Schema.org/numberOfRooms
     *  The number of rooms (excluding bathrooms and closets) of the acccommodation or lodging business.
     *  Typical unit code(s): ROM for room or C62 for no unit. The type of room can be put in the unitText property of the QuantitativeValue.
     * 
     *  @property numberOfRooms
     *  @type Number
     */
    prototype.numberOfRooms = null;
}, {occupancy: "QuantitativeValue", floorSize: "QuantitativeValue", amenityFeature: "LocationFeatureSpecification", photo: "ImageObject", address: "PostalAddress", openingHoursSpecification: "OpeningHoursSpecification", containedInPlace: "Place", reviews: "Review", aggregateRating: "AggregateRating", photos: "Photograph", hasMap: "SchemaMap", additionalProperty: "PropertyValue", events: "SchemaEvent", specialOpeningHoursSpecification: "OpeningHoursSpecification", amenityFeature: "LocationFeatureSpecification", logo: "ImageObject", geo: "GeoCoordinates", review: "Review", event: "SchemaEvent", containsPlace: "Place", containedIn: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Room
 *  A room is a distinguishable space within a structure, usually separated from other spaces by interior walls. (Source: Wikipedia, the free encyclopedia, see <a href="http://en.wikipedia.org/wiki/Room">http://en.wikipedia.org/wiki/Room</a>).
 *  <br /><br />
 *  See also the <a href="/docs/hotels.html">dedicated document on the use of schema.org for marking up hotels and other forms of accommodations</a>.
 * 
 *  @author schema.org
 *  @class Room
 *  @module org.schema
 *  @extends Accommodation
 */
var Room = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Accommodation.call(this);
    this.context = "http://schema.org/";
    this.type = "Room";
};
Room = stjs.extend(Room, Accommodation, [], null, {floorSize: "QuantitativeValue", amenityFeature: "LocationFeatureSpecification", photo: "ImageObject", address: "PostalAddress", openingHoursSpecification: "OpeningHoursSpecification", containedInPlace: "Place", reviews: "Review", aggregateRating: "AggregateRating", photos: "Photograph", hasMap: "SchemaMap", additionalProperty: "PropertyValue", events: "SchemaEvent", specialOpeningHoursSpecification: "OpeningHoursSpecification", amenityFeature: "LocationFeatureSpecification", logo: "ImageObject", geo: "GeoCoordinates", review: "Review", event: "SchemaEvent", containsPlace: "Place", containedIn: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/House
 *  A house is a building or structure that has the ability to be occupied for habitation by humans or other creatures (Source: Wikipedia, the free encyclopedia, see <a href="http://en.wikipedia.org/wiki/House">http://en.wikipedia.org/wiki/House</a>).
 * 
 *  @author schema.org
 *  @class House
 *  @module org.schema
 *  @extends Accommodation
 */
var House = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Accommodation.call(this);
    this.context = "http://schema.org/";
    this.type = "House";
};
House = stjs.extend(House, Accommodation, [], function(constructor, prototype) {
    /**
     *  Schema.org/numberOfRooms
     *  The number of rooms (excluding bathrooms and closets) of the acccommodation or lodging business.
     *  Typical unit code(s): ROM for room or C62 for no unit. The type of room can be put in the unitText property of the QuantitativeValue.
     * 
     *  @property numberOfRooms
     *  @type Number
     */
    prototype.numberOfRooms = null;
}, {floorSize: "QuantitativeValue", amenityFeature: "LocationFeatureSpecification", photo: "ImageObject", address: "PostalAddress", openingHoursSpecification: "OpeningHoursSpecification", containedInPlace: "Place", reviews: "Review", aggregateRating: "AggregateRating", photos: "Photograph", hasMap: "SchemaMap", additionalProperty: "PropertyValue", events: "SchemaEvent", specialOpeningHoursSpecification: "OpeningHoursSpecification", amenityFeature: "LocationFeatureSpecification", logo: "ImageObject", geo: "GeoCoordinates", review: "Review", event: "SchemaEvent", containsPlace: "Place", containedIn: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Suite
 *  A suite in a hotel or other public accommodation, denotes a class of luxury accommodations, the key feature of which is multiple rooms (Source: Wikipedia, the free encyclopedia, see <a href="http://en.wikipedia.org/wiki/Suite_(hotel)">http://en.wikipedia.org/wiki/Suite_(hotel)</a>).
 *  <br /><br />
 *  See also the <a href="/docs/hotels.html">dedicated document on the use of schema.org for marking up hotels and other forms of accommodations</a>.
 * 
 *  @author schema.org
 *  @class Suite
 *  @module org.schema
 *  @extends Accommodation
 */
var Suite = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Accommodation.call(this);
    this.context = "http://schema.org/";
    this.type = "Suite";
};
Suite = stjs.extend(Suite, Accommodation, [], function(constructor, prototype) {
    /**
     *  Schema.org/occupancy
     *  The allowed total occupancy for the accommodation in persons (including infants etc). For individual accommodations, this is not necessarily the legal maximum but defines the permitted usage as per the contractual agreement (e.g. a double room used by a single person).
     *  Typical unit code(s): C62 for person
     * 
     *  @property occupancy
     *  @type QuantitativeValue
     */
    prototype.occupancy = null;
    /**
     *  Schema.org/bed
     *  The type of bed or beds included in the accommodation. For the single case of just one bed of a certain type, you use bed directly with a text.
     *  If you want to indicate the quantity of a certain kind of bed, use an instance of BedDetails. For more detailed information, use the amenityFeature property.
     * 
     *  @property bed
     *  @type BedDetails
     */
    prototype.bed = null;
    /**
     *  Schema.org/numberOfRooms
     *  The number of rooms (excluding bathrooms and closets) of the acccommodation or lodging business.
     *  Typical unit code(s): ROM for room or C62 for no unit. The type of room can be put in the unitText property of the QuantitativeValue.
     * 
     *  @property numberOfRooms
     *  @type Number
     */
    prototype.numberOfRooms = null;
}, {occupancy: "QuantitativeValue", bed: "BedDetails", floorSize: "QuantitativeValue", amenityFeature: "LocationFeatureSpecification", photo: "ImageObject", address: "PostalAddress", openingHoursSpecification: "OpeningHoursSpecification", containedInPlace: "Place", reviews: "Review", aggregateRating: "AggregateRating", photos: "Photograph", hasMap: "SchemaMap", additionalProperty: "PropertyValue", events: "SchemaEvent", specialOpeningHoursSpecification: "OpeningHoursSpecification", amenityFeature: "LocationFeatureSpecification", logo: "ImageObject", geo: "GeoCoordinates", review: "Review", event: "SchemaEvent", containsPlace: "Place", containedIn: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/CampingPitch
 *  A camping pitch is an individual place for overnight stay in the outdoors, typically being part of a larger camping site.
 *  <br /><br />
 *  See also the <a href="/docs/hotels.html">dedicated document on the use of schema.org for marking up hotels and other forms of accommodations</a>.
 * 
 *  @author schema.org
 *  @class CampingPitch
 *  @module org.schema
 *  @extends Accommodation
 */
var CampingPitch = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Accommodation.call(this);
    this.context = "http://schema.org/";
    this.type = "CampingPitch";
};
CampingPitch = stjs.extend(CampingPitch, Accommodation, [], null, {floorSize: "QuantitativeValue", amenityFeature: "LocationFeatureSpecification", photo: "ImageObject", address: "PostalAddress", openingHoursSpecification: "OpeningHoursSpecification", containedInPlace: "Place", reviews: "Review", aggregateRating: "AggregateRating", photos: "Photograph", hasMap: "SchemaMap", additionalProperty: "PropertyValue", events: "SchemaEvent", specialOpeningHoursSpecification: "OpeningHoursSpecification", amenityFeature: "LocationFeatureSpecification", logo: "ImageObject", geo: "GeoCoordinates", review: "Review", event: "SchemaEvent", containsPlace: "Place", containedIn: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Continent
 *  One of the continents (for example, Europe or Africa).
 * 
 *  @author schema.org
 *  @class Continent
 *  @module org.schema
 *  @extends Landform
 */
var Continent = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Landform.call(this);
    this.context = "http://schema.org/";
    this.type = "Continent";
};
Continent = stjs.extend(Continent, Landform, [], null, {photo: "ImageObject", address: "PostalAddress", openingHoursSpecification: "OpeningHoursSpecification", containedInPlace: "Place", reviews: "Review", aggregateRating: "AggregateRating", photos: "Photograph", hasMap: "SchemaMap", additionalProperty: "PropertyValue", events: "SchemaEvent", specialOpeningHoursSpecification: "OpeningHoursSpecification", amenityFeature: "LocationFeatureSpecification", logo: "ImageObject", geo: "GeoCoordinates", review: "Review", event: "SchemaEvent", containsPlace: "Place", containedIn: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/BodyOfWater
 *  A body of water, such as a sea, ocean, or lake.
 * 
 *  @author schema.org
 *  @class BodyOfWater
 *  @module org.schema
 *  @extends Landform
 */
var BodyOfWater = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Landform.call(this);
    this.context = "http://schema.org/";
    this.type = "BodyOfWater";
};
BodyOfWater = stjs.extend(BodyOfWater, Landform, [], null, {photo: "ImageObject", address: "PostalAddress", openingHoursSpecification: "OpeningHoursSpecification", containedInPlace: "Place", reviews: "Review", aggregateRating: "AggregateRating", photos: "Photograph", hasMap: "SchemaMap", additionalProperty: "PropertyValue", events: "SchemaEvent", specialOpeningHoursSpecification: "OpeningHoursSpecification", amenityFeature: "LocationFeatureSpecification", logo: "ImageObject", geo: "GeoCoordinates", review: "Review", event: "SchemaEvent", containsPlace: "Place", containedIn: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Volcano
 *  A volcano, like Fuji san.
 * 
 *  @author schema.org
 *  @class Volcano
 *  @module org.schema
 *  @extends Landform
 */
var Volcano = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Landform.call(this);
    this.context = "http://schema.org/";
    this.type = "Volcano";
};
Volcano = stjs.extend(Volcano, Landform, [], null, {photo: "ImageObject", address: "PostalAddress", openingHoursSpecification: "OpeningHoursSpecification", containedInPlace: "Place", reviews: "Review", aggregateRating: "AggregateRating", photos: "Photograph", hasMap: "SchemaMap", additionalProperty: "PropertyValue", events: "SchemaEvent", specialOpeningHoursSpecification: "OpeningHoursSpecification", amenityFeature: "LocationFeatureSpecification", logo: "ImageObject", geo: "GeoCoordinates", review: "Review", event: "SchemaEvent", containsPlace: "Place", containedIn: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Mountain
 *  A mountain, like Mount Whitney or Mount Everest.
 * 
 *  @author schema.org
 *  @class Mountain
 *  @module org.schema
 *  @extends Landform
 */
var Mountain = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Landform.call(this);
    this.context = "http://schema.org/";
    this.type = "Mountain";
};
Mountain = stjs.extend(Mountain, Landform, [], null, {photo: "ImageObject", address: "PostalAddress", openingHoursSpecification: "OpeningHoursSpecification", containedInPlace: "Place", reviews: "Review", aggregateRating: "AggregateRating", photos: "Photograph", hasMap: "SchemaMap", additionalProperty: "PropertyValue", events: "SchemaEvent", specialOpeningHoursSpecification: "OpeningHoursSpecification", amenityFeature: "LocationFeatureSpecification", logo: "ImageObject", geo: "GeoCoordinates", review: "Review", event: "SchemaEvent", containsPlace: "Place", containedIn: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/ApartmentComplex
 *  Residence type: Apartment complex.
 * 
 *  @author schema.org
 *  @class ApartmentComplex
 *  @module org.schema
 *  @extends Residence
 */
var ApartmentComplex = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Residence.call(this);
    this.context = "http://schema.org/";
    this.type = "ApartmentComplex";
};
ApartmentComplex = stjs.extend(ApartmentComplex, Residence, [], null, {photo: "ImageObject", address: "PostalAddress", openingHoursSpecification: "OpeningHoursSpecification", containedInPlace: "Place", reviews: "Review", aggregateRating: "AggregateRating", photos: "Photograph", hasMap: "SchemaMap", additionalProperty: "PropertyValue", events: "SchemaEvent", specialOpeningHoursSpecification: "OpeningHoursSpecification", amenityFeature: "LocationFeatureSpecification", logo: "ImageObject", geo: "GeoCoordinates", review: "Review", event: "SchemaEvent", containsPlace: "Place", containedIn: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/GatedResidenceCommunity
 *  Residence type: Gated community.
 * 
 *  @author schema.org
 *  @class GatedResidenceCommunity
 *  @module org.schema
 *  @extends Residence
 */
var GatedResidenceCommunity = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Residence.call(this);
    this.context = "http://schema.org/";
    this.type = "GatedResidenceCommunity";
};
GatedResidenceCommunity = stjs.extend(GatedResidenceCommunity, Residence, [], null, {photo: "ImageObject", address: "PostalAddress", openingHoursSpecification: "OpeningHoursSpecification", containedInPlace: "Place", reviews: "Review", aggregateRating: "AggregateRating", photos: "Photograph", hasMap: "SchemaMap", additionalProperty: "PropertyValue", events: "SchemaEvent", specialOpeningHoursSpecification: "OpeningHoursSpecification", amenityFeature: "LocationFeatureSpecification", logo: "ImageObject", geo: "GeoCoordinates", review: "Review", event: "SchemaEvent", containsPlace: "Place", containedIn: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/AddAction
 *  The act of editing by adding an object to a collection.
 * 
 *  @author schema.org
 *  @class AddAction
 *  @module org.schema
 *  @extends UpdateAction
 */
var AddAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    UpdateAction.call(this);
    this.context = "http://schema.org/";
    this.type = "AddAction";
};
AddAction = stjs.extend(AddAction, UpdateAction, [], null, {collection: "Thing", targetCollection: "Thing", result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/ReplaceAction
 *  The act of editing a recipient by replacing an old object with a new object.
 * 
 *  @author schema.org
 *  @class ReplaceAction
 *  @module org.schema
 *  @extends UpdateAction
 */
var ReplaceAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    UpdateAction.call(this);
    this.context = "http://schema.org/";
    this.type = "ReplaceAction";
};
ReplaceAction = stjs.extend(ReplaceAction, UpdateAction, [], function(constructor, prototype) {
    /**
     *  Schema.org/replacee
     *  A sub property of object. The object that is being replaced.
     * 
     *  @property replacee
     *  @type Thing
     */
    prototype.replacee = null;
    /**
     *  Schema.org/replacer
     *  A sub property of object. The object that replaces.
     * 
     *  @property replacer
     *  @type Thing
     */
    prototype.replacer = null;
}, {replacee: "Thing", replacer: "Thing", collection: "Thing", targetCollection: "Thing", result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/DeleteAction
 *  The act of editing a recipient by removing one of its objects.
 * 
 *  @author schema.org
 *  @class DeleteAction
 *  @module org.schema
 *  @extends UpdateAction
 */
var DeleteAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    UpdateAction.call(this);
    this.context = "http://schema.org/";
    this.type = "DeleteAction";
};
DeleteAction = stjs.extend(DeleteAction, UpdateAction, [], null, {collection: "Thing", targetCollection: "Thing", result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/DonateAction
 *  The act of providing goods, services, or money without compensation, often for philanthropic reasons.
 * 
 *  @author schema.org
 *  @class DonateAction
 *  @module org.schema
 *  @extends TradeAction
 */
var DonateAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    TradeAction.call(this);
    this.context = "http://schema.org/";
    this.type = "DonateAction";
};
DonateAction = stjs.extend(DonateAction, TradeAction, [], function(constructor, prototype) {
    /**
     *  Schema.org/recipient
     *  A sub property of participant. The participant who is at the receiving end of the action.
     * 
     *  @property recipient
     *  @type Organization
     */
    prototype.recipient = null;
}, {recipient: "Organization", priceSpecification: "PriceSpecification", result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/OrderAction
 *  An agent orders an object/product/service to be delivered/sent.
 * 
 *  @author schema.org
 *  @class OrderAction
 *  @module org.schema
 *  @extends TradeAction
 */
var OrderAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    TradeAction.call(this);
    this.context = "http://schema.org/";
    this.type = "OrderAction";
};
OrderAction = stjs.extend(OrderAction, TradeAction, [], function(constructor, prototype) {
    /**
     *  Schema.org/deliveryMethod
     *  A sub property of instrument. The method of delivery.
     * 
     *  @property deliveryMethod
     *  @type DeliveryMethod
     */
    prototype.deliveryMethod = null;
}, {deliveryMethod: "DeliveryMethod", priceSpecification: "PriceSpecification", result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/SellAction
 *  The act of taking money from a buyer in exchange for goods or services rendered. An agent sells an object, product, or service to a buyer for a price. Reciprocal of BuyAction.
 * 
 *  @author schema.org
 *  @class SellAction
 *  @module org.schema
 *  @extends TradeAction
 */
var SellAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    TradeAction.call(this);
    this.context = "http://schema.org/";
    this.type = "SellAction";
};
SellAction = stjs.extend(SellAction, TradeAction, [], function(constructor, prototype) {
    /**
     *  Schema.org/buyer
     *  A sub property of participant. The participant/person/organization that bought the object.
     * 
     *  @property buyer
     *  @type Person
     */
    prototype.buyer = null;
    /**
     *  Schema.org/warrantyPromise
     *  The warranty promise(s) included in the offer.
     * 
     *  @property warrantyPromise
     *  @type WarrantyPromise
     */
    prototype.warrantyPromise = null;
}, {buyer: "Person", warrantyPromise: "WarrantyPromise", priceSpecification: "PriceSpecification", result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/BuyAction
 *  The act of giving money to a seller in exchange for goods or services rendered. An agent buys an object, product, or service from a seller for a price. Reciprocal of SellAction.
 * 
 *  @author schema.org
 *  @class BuyAction
 *  @module org.schema
 *  @extends TradeAction
 */
var BuyAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    TradeAction.call(this);
    this.context = "http://schema.org/";
    this.type = "BuyAction";
};
BuyAction = stjs.extend(BuyAction, TradeAction, [], function(constructor, prototype) {
    /**
     *  Schema.org/vendor
     *  'vendor' is an earlier term for 'seller'.
     * 
     *  @property vendor
     *  @type Organization
     */
    prototype.vendor = null;
    /**
     *  Schema.org/seller
     *  An entity which offers (sells / leases / lends / loans) the services / goods.  A seller may also be a provider.
     * 
     *  @property seller
     *  @type Person
     */
    prototype.seller = null;
    /**
     *  Schema.org/warrantyPromise
     *  The warranty promise(s) included in the offer.
     * 
     *  @property warrantyPromise
     *  @type WarrantyPromise
     */
    prototype.warrantyPromise = null;
}, {vendor: "Organization", seller: "Person", warrantyPromise: "WarrantyPromise", priceSpecification: "PriceSpecification", result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/TipAction
 *  The act of giving money voluntarily to a beneficiary in recognition of services rendered.
 * 
 *  @author schema.org
 *  @class TipAction
 *  @module org.schema
 *  @extends TradeAction
 */
var TipAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    TradeAction.call(this);
    this.context = "http://schema.org/";
    this.type = "TipAction";
};
TipAction = stjs.extend(TipAction, TradeAction, [], function(constructor, prototype) {
    /**
     *  Schema.org/recipient
     *  A sub property of participant. The participant who is at the receiving end of the action.
     * 
     *  @property recipient
     *  @type Organization
     */
    prototype.recipient = null;
}, {recipient: "Organization", priceSpecification: "PriceSpecification", result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/PayAction
 *  An agent pays a price to a participant.
 * 
 *  @author schema.org
 *  @class PayAction
 *  @module org.schema
 *  @extends TradeAction
 */
var PayAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    TradeAction.call(this);
    this.context = "http://schema.org/";
    this.type = "PayAction";
};
PayAction = stjs.extend(PayAction, TradeAction, [], function(constructor, prototype) {
    /**
     *  Schema.org/recipient
     *  A sub property of participant. The participant who is at the receiving end of the action.
     * 
     *  @property recipient
     *  @type Organization
     */
    prototype.recipient = null;
}, {recipient: "Organization", priceSpecification: "PriceSpecification", result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/RentAction
 *  The act of giving money in return for temporary use, but not ownership, of an object such as a vehicle or property. For example, an agent rents a property from a landlord in exchange for a periodic payment.
 * 
 *  @author schema.org
 *  @class RentAction
 *  @module org.schema
 *  @extends TradeAction
 */
var RentAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    TradeAction.call(this);
    this.context = "http://schema.org/";
    this.type = "RentAction";
};
RentAction = stjs.extend(RentAction, TradeAction, [], function(constructor, prototype) {
    /**
     *  Schema.org/landlord
     *  A sub property of participant. The owner of the real estate property.
     * 
     *  @property landlord
     *  @type Organization
     */
    prototype.landlord = null;
    /**
     *  Schema.org/realEstateAgent
     *  A sub property of participant. The real estate agent involved in the action.
     * 
     *  @property realEstateAgent
     *  @type RealEstateAgent
     */
    prototype.realEstateAgent = null;
}, {landlord: "Organization", realEstateAgent: "RealEstateAgent", priceSpecification: "PriceSpecification", result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/QuoteAction
 *  An agent quotes/estimates/appraises an object/product/service with a price at a location/store.
 * 
 *  @author schema.org
 *  @class QuoteAction
 *  @module org.schema
 *  @extends TradeAction
 */
var QuoteAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    TradeAction.call(this);
    this.context = "http://schema.org/";
    this.type = "QuoteAction";
};
QuoteAction = stjs.extend(QuoteAction, TradeAction, [], null, {priceSpecification: "PriceSpecification", result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/GiveAction
 *  The act of transferring ownership of an object to a destination. Reciprocal of TakeAction.\n\nRelated actions:\n\n* [[TakeAction]]: Reciprocal of GiveAction.\n* [[SendAction]]: Unlike SendAction, GiveAction implies that ownership is being transferred (e.g. I may send my laptop to you, but that doesn't mean I'm giving it to you).
 * 
 *  @author schema.org
 *  @class GiveAction
 *  @module org.schema
 *  @extends TransferAction
 */
var GiveAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    TransferAction.call(this);
    this.context = "http://schema.org/";
    this.type = "GiveAction";
};
GiveAction = stjs.extend(GiveAction, TransferAction, [], function(constructor, prototype) {
    /**
     *  Schema.org/recipient
     *  A sub property of participant. The participant who is at the receiving end of the action.
     * 
     *  @property recipient
     *  @type Organization
     */
    prototype.recipient = null;
}, {recipient: "Organization", toLocation: "Place", fromLocation: "Place", result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/ReceiveAction
 *  The act of physically/electronically taking delivery of an object thathas been transferred from an origin to a destination. Reciprocal of SendAction.\n\nRelated actions:\n\n* [[SendAction]]: The reciprocal of ReceiveAction.\n* [[TakeAction]]: Unlike TakeAction, ReceiveAction does not imply that the ownership has been transfered (e.g. I can receive a package, but it does not mean the package is now mine).
 * 
 *  @author schema.org
 *  @class ReceiveAction
 *  @module org.schema
 *  @extends TransferAction
 */
var ReceiveAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    TransferAction.call(this);
    this.context = "http://schema.org/";
    this.type = "ReceiveAction";
};
ReceiveAction = stjs.extend(ReceiveAction, TransferAction, [], function(constructor, prototype) {
    /**
     *  Schema.org/deliveryMethod
     *  A sub property of instrument. The method of delivery.
     * 
     *  @property deliveryMethod
     *  @type DeliveryMethod
     */
    prototype.deliveryMethod = null;
    /**
     *  Schema.org/sender
     *  A sub property of participant. The participant who is at the sending end of the action.
     * 
     *  @property sender
     *  @type Audience
     */
    prototype.sender = null;
}, {deliveryMethod: "DeliveryMethod", sender: "Audience", toLocation: "Place", fromLocation: "Place", result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/BorrowAction
 *  The act of obtaining an object under an agreement to return it at a later date. Reciprocal of LendAction.\n\nRelated actions:\n\n* [[LendAction]]: Reciprocal of BorrowAction.
 * 
 *  @author schema.org
 *  @class BorrowAction
 *  @module org.schema
 *  @extends TransferAction
 */
var BorrowAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    TransferAction.call(this);
    this.context = "http://schema.org/";
    this.type = "BorrowAction";
};
BorrowAction = stjs.extend(BorrowAction, TransferAction, [], function(constructor, prototype) {
    /**
     *  Schema.org/lender
     *  A sub property of participant. The person that lends the object being borrowed.
     * 
     *  @property lender
     *  @type Organization
     */
    prototype.lender = null;
}, {lender: "Organization", toLocation: "Place", fromLocation: "Place", result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/DownloadAction
 *  The act of downloading an object.
 * 
 *  @author schema.org
 *  @class DownloadAction
 *  @module org.schema
 *  @extends TransferAction
 */
var DownloadAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    TransferAction.call(this);
    this.context = "http://schema.org/";
    this.type = "DownloadAction";
};
DownloadAction = stjs.extend(DownloadAction, TransferAction, [], null, {toLocation: "Place", fromLocation: "Place", result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/SendAction
 *  The act of physically/electronically dispatching an object for transfer from an origin to a destination.Related actions:\n\n* [[ReceiveAction]]: The reciprocal of SendAction.\n* [[GiveAction]]: Unlike GiveAction, SendAction does not imply the transfer of ownership (e.g. I can send you my laptop, but I'm not necessarily giving it to you).
 * 
 *  @author schema.org
 *  @class SendAction
 *  @module org.schema
 *  @extends TransferAction
 */
var SendAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    TransferAction.call(this);
    this.context = "http://schema.org/";
    this.type = "SendAction";
};
SendAction = stjs.extend(SendAction, TransferAction, [], function(constructor, prototype) {
    /**
     *  Schema.org/recipient
     *  A sub property of participant. The participant who is at the receiving end of the action.
     * 
     *  @property recipient
     *  @type Organization
     */
    prototype.recipient = null;
    /**
     *  Schema.org/deliveryMethod
     *  A sub property of instrument. The method of delivery.
     * 
     *  @property deliveryMethod
     *  @type DeliveryMethod
     */
    prototype.deliveryMethod = null;
}, {recipient: "Organization", deliveryMethod: "DeliveryMethod", toLocation: "Place", fromLocation: "Place", result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/TakeAction
 *  The act of gaining ownership of an object from an origin. Reciprocal of GiveAction.\n\nRelated actions:\n\n* [[GiveAction]]: The reciprocal of TakeAction.\n* [[ReceiveAction]]: Unlike ReceiveAction, TakeAction implies that ownership has been transfered.
 * 
 *  @author schema.org
 *  @class TakeAction
 *  @module org.schema
 *  @extends TransferAction
 */
var TakeAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    TransferAction.call(this);
    this.context = "http://schema.org/";
    this.type = "TakeAction";
};
TakeAction = stjs.extend(TakeAction, TransferAction, [], null, {toLocation: "Place", fromLocation: "Place", result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/LendAction
 *  The act of providing an object under an agreement that it will be returned at a later date. Reciprocal of BorrowAction.\n\nRelated actions:\n\n* [[BorrowAction]]: Reciprocal of LendAction.
 * 
 *  @author schema.org
 *  @class LendAction
 *  @module org.schema
 *  @extends TransferAction
 */
var LendAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    TransferAction.call(this);
    this.context = "http://schema.org/";
    this.type = "LendAction";
};
LendAction = stjs.extend(LendAction, TransferAction, [], function(constructor, prototype) {
    /**
     *  Schema.org/borrower
     *  A sub property of participant. The person that borrows the object being lent.
     * 
     *  @property borrower
     *  @type Person
     */
    prototype.borrower = null;
}, {borrower: "Person", toLocation: "Place", fromLocation: "Place", result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/ReturnAction
 *  The act of returning to the origin that which was previously received (concrete objects) or taken (ownership).
 * 
 *  @author schema.org
 *  @class ReturnAction
 *  @module org.schema
 *  @extends TransferAction
 */
var ReturnAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    TransferAction.call(this);
    this.context = "http://schema.org/";
    this.type = "ReturnAction";
};
ReturnAction = stjs.extend(ReturnAction, TransferAction, [], function(constructor, prototype) {
    /**
     *  Schema.org/recipient
     *  A sub property of participant. The participant who is at the receiving end of the action.
     * 
     *  @property recipient
     *  @type Organization
     */
    prototype.recipient = null;
}, {recipient: "Organization", toLocation: "Place", fromLocation: "Place", result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/DepartAction
 *  The act of  departing from a place. An agent departs from an fromLocation for a destination, optionally with participants.
 * 
 *  @author schema.org
 *  @class DepartAction
 *  @module org.schema
 *  @extends MoveAction
 */
var DepartAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    MoveAction.call(this);
    this.context = "http://schema.org/";
    this.type = "DepartAction";
};
DepartAction = stjs.extend(DepartAction, MoveAction, [], null, {toLocation: "Place", fromLocation: "Place", result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/TravelAction
 *  The act of traveling from an fromLocation to a destination by a specified mode of transport, optionally with participants.
 * 
 *  @author schema.org
 *  @class TravelAction
 *  @module org.schema
 *  @extends MoveAction
 */
var TravelAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    MoveAction.call(this);
    this.context = "http://schema.org/";
    this.type = "TravelAction";
};
TravelAction = stjs.extend(TravelAction, MoveAction, [], function(constructor, prototype) {
    /**
     *  Schema.org/distance
     *  The distance travelled, e.g. exercising or travelling.
     * 
     *  @property distance
     *  @type Distance
     */
    prototype.distance = null;
}, {distance: "Distance", toLocation: "Place", fromLocation: "Place", result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/ArriveAction
 *  The act of arriving at a place. An agent arrives at a destination from a fromLocation, optionally with participants.
 * 
 *  @author schema.org
 *  @class ArriveAction
 *  @module org.schema
 *  @extends MoveAction
 */
var ArriveAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    MoveAction.call(this);
    this.context = "http://schema.org/";
    this.type = "ArriveAction";
};
ArriveAction = stjs.extend(ArriveAction, MoveAction, [], null, {toLocation: "Place", fromLocation: "Place", result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/BefriendAction
 *  The act of forming a personal connection with someone (object) mutually/bidirectionally/symmetrically.\n\nRelated actions:\n\n* [[FollowAction]]: Unlike FollowAction, BefriendAction implies that the connection is reciprocal.
 * 
 *  @author schema.org
 *  @class BefriendAction
 *  @module org.schema
 *  @extends InteractAction
 */
var BefriendAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    InteractAction.call(this);
    this.context = "http://schema.org/";
    this.type = "BefriendAction";
};
BefriendAction = stjs.extend(BefriendAction, InteractAction, [], null, {result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/MarryAction
 *  The act of marrying a person.
 * 
 *  @author schema.org
 *  @class MarryAction
 *  @module org.schema
 *  @extends InteractAction
 */
var MarryAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    InteractAction.call(this);
    this.context = "http://schema.org/";
    this.type = "MarryAction";
};
MarryAction = stjs.extend(MarryAction, InteractAction, [], null, {result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/SubscribeAction
 *  The act of forming a personal connection with someone/something (object) unidirectionally/asymmetrically to get updates pushed to.\n\nRelated actions:\n\n* [[FollowAction]]: Unlike FollowAction, SubscribeAction implies that the subscriber acts as a passive agent being constantly/actively pushed for updates.\n* [[RegisterAction]]: Unlike RegisterAction, SubscribeAction implies that the agent is interested in continuing receiving updates from the object.\n* [[JoinAction]]: Unlike JoinAction, SubscribeAction implies that the agent is interested in continuing receiving updates from the object.
 * 
 *  @author schema.org
 *  @class SubscribeAction
 *  @module org.schema
 *  @extends InteractAction
 */
var SubscribeAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    InteractAction.call(this);
    this.context = "http://schema.org/";
    this.type = "SubscribeAction";
};
SubscribeAction = stjs.extend(SubscribeAction, InteractAction, [], null, {result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/UnRegisterAction
 *  The act of un-registering from a service.\n\nRelated actions:\n\n* [[RegisterAction]]: antonym of UnRegisterAction.\n* [[Leave]]: Unlike LeaveAction, UnRegisterAction implies that you are unregistering from a service you werer previously registered, rather than leaving a team/group of people.
 * 
 *  @author schema.org
 *  @class UnRegisterAction
 *  @module org.schema
 *  @extends InteractAction
 */
var UnRegisterAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    InteractAction.call(this);
    this.context = "http://schema.org/";
    this.type = "UnRegisterAction";
};
UnRegisterAction = stjs.extend(UnRegisterAction, InteractAction, [], null, {result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/RegisterAction
 *  The act of registering to be a user of a service, product or web page.\n\nRelated actions:\n\n* [[JoinAction]]: Unlike JoinAction, RegisterAction implies you are registering to be a user of a service, *not* a group/team of people.\n* [FollowAction]]: Unlike FollowAction, RegisterAction doesn't imply that the agent is expecting to poll for updates from the object.\n* [[SubscribeAction]]: Unlike SubscribeAction, RegisterAction doesn't imply that the agent is expecting updates from the object.
 * 
 *  @author schema.org
 *  @class RegisterAction
 *  @module org.schema
 *  @extends InteractAction
 */
var RegisterAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    InteractAction.call(this);
    this.context = "http://schema.org/";
    this.type = "RegisterAction";
};
RegisterAction = stjs.extend(RegisterAction, InteractAction, [], null, {result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/FollowAction
 *  The act of forming a personal connection with someone/something (object) unidirectionally/asymmetrically to get updates polled from.\n\nRelated actions:\n\n* [[BefriendAction]]: Unlike BefriendAction, FollowAction implies that the connection is *not* necessarily reciprocal.\n* [[SubscribeAction]]: Unlike SubscribeAction, FollowAction implies that the follower acts as an active agent constantly/actively polling for updates.\n* [[RegisterAction]]: Unlike RegisterAction, FollowAction implies that the agent is interested in continuing receiving updates from the object.\n* [[JoinAction]]: Unlike JoinAction, FollowAction implies that the agent is interested in getting updates from the object.\n* [[TrackAction]]: Unlike TrackAction, FollowAction refers to the polling of updates of all aspects of animate objects rather than the location of inanimate objects (e.g. you track a package, but you don't follow it).
 * 
 *  @author schema.org
 *  @class FollowAction
 *  @module org.schema
 *  @extends InteractAction
 */
var FollowAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    InteractAction.call(this);
    this.context = "http://schema.org/";
    this.type = "FollowAction";
};
FollowAction = stjs.extend(FollowAction, InteractAction, [], function(constructor, prototype) {
    /**
     *  Schema.org/followee
     *  A sub property of object. The person or organization being followed.
     * 
     *  @property followee
     *  @type Person
     */
    prototype.followee = null;
}, {followee: "Person", result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/LeaveAction
 *  An agent leaves an event / group with participants/friends at a location.\n\nRelated actions:\n\n* [[JoinAction]]: The antonym of LeaveAction.\n* [[UnRegisterAction]]: Unlike UnRegisterAction, LeaveAction implies leaving a group/team of people rather than a service.
 * 
 *  @author schema.org
 *  @class LeaveAction
 *  @module org.schema
 *  @extends InteractAction
 */
var LeaveAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    InteractAction.call(this);
    this.context = "http://schema.org/";
    this.type = "LeaveAction";
};
LeaveAction = stjs.extend(LeaveAction, InteractAction, [], function(constructor, prototype) {
    /**
     *  Schema.org/event
     *  Upcoming or past event associated with this place, organization, or action.
     * 
     *  @property event
     *  @type SchemaEvent
     */
    prototype.event = null;
}, {event: "SchemaEvent", result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/JoinAction
 *  An agent joins an event/group with participants/friends at a location.\n\nRelated actions:\n\n* [[RegisterAction]]: Unlike RegisterAction, JoinAction refers to joining a group/team of people.\n* [[SubscribeAction]]: Unlike SubscribeAction, JoinAction does not imply that you'll be receiving updates.\n* [[FollowAction]]: Unlike FollowAction, JoinAction does not imply that you'll be polling for updates.
 * 
 *  @author schema.org
 *  @class JoinAction
 *  @module org.schema
 *  @extends InteractAction
 */
var JoinAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    InteractAction.call(this);
    this.context = "http://schema.org/";
    this.type = "JoinAction";
};
JoinAction = stjs.extend(JoinAction, InteractAction, [], function(constructor, prototype) {
    /**
     *  Schema.org/event
     *  Upcoming or past event associated with this place, organization, or action.
     * 
     *  @property event
     *  @type SchemaEvent
     */
    prototype.event = null;
}, {event: "SchemaEvent", result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/CommunicateAction
 *  The act of conveying information to another person via a communication medium (instrument) such as speech, email, or telephone conversation.
 * 
 *  @author schema.org
 *  @class CommunicateAction
 *  @module org.schema
 *  @extends InteractAction
 */
var CommunicateAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    InteractAction.call(this);
    this.context = "http://schema.org/";
    this.type = "CommunicateAction";
};
CommunicateAction = stjs.extend(CommunicateAction, InteractAction, [], function(constructor, prototype) {
    /**
     *  Schema.org/about
     *  The subject matter of the content.
     * 
     *  @property about
     *  @type Thing
     */
    prototype.about = null;
    /**
     *  Schema.org/recipient
     *  A sub property of participant. The participant who is at the receiving end of the action.
     * 
     *  @property recipient
     *  @type Organization
     */
    prototype.recipient = null;
    /**
     *  Schema.org/inLanguage
     *  The language of the content or performance or used in an action. Please use one of the language codes from the [IETF BCP 47 standard](http://tools.ietf.org/html/bcp47). See also [[availableLanguage]].
     * 
     *  @property inLanguage
     *  @type Language
     */
    prototype.inLanguage = null;
    /**
     *  Schema.org/language
     *  A sub property of instrument. The language used on this action.
     * 
     *  @property language
     *  @type Language
     */
    prototype.language = null;
}, {about: "Thing", recipient: "Organization", inLanguage: "Language", language: "Language", result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/PerformAction
 *  The act of participating in performance arts.
 * 
 *  @author schema.org
 *  @class PerformAction
 *  @module org.schema
 *  @extends PlayAction
 */
var PerformAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    PlayAction.call(this);
    this.context = "http://schema.org/";
    this.type = "PerformAction";
};
PerformAction = stjs.extend(PerformAction, PlayAction, [], function(constructor, prototype) {
    /**
     *  Schema.org/entertainmentBusiness
     *  A sub property of location. The entertainment business where the action occurred.
     * 
     *  @property entertainmentBusiness
     *  @type EntertainmentBusiness
     */
    prototype.entertainmentBusiness = null;
}, {entertainmentBusiness: "EntertainmentBusiness", audience: "Audience", event: "SchemaEvent", result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/ExerciseAction
 *  The act of participating in exertive activity for the purposes of improving health and fitness.
 * 
 *  @author schema.org
 *  @class ExerciseAction
 *  @module org.schema
 *  @extends PlayAction
 */
var ExerciseAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    PlayAction.call(this);
    this.context = "http://schema.org/";
    this.type = "ExerciseAction";
};
ExerciseAction = stjs.extend(ExerciseAction, PlayAction, [], function(constructor, prototype) {
    /**
     *  Schema.org/course
     *  A sub property of location. The course where this action was taken.
     * 
     *  @property course
     *  @type Place
     */
    prototype.course = null;
    /**
     *  Schema.org/sportsTeam
     *  A sub property of participant. The sports team that participated on this action.
     * 
     *  @property sportsTeam
     *  @type SportsTeam
     */
    prototype.sportsTeam = null;
    /**
     *  Schema.org/sportsEvent
     *  A sub property of location. The sports event where this action occurred.
     * 
     *  @property sportsEvent
     *  @type SportsEvent
     */
    prototype.sportsEvent = null;
    /**
     *  Schema.org/distance
     *  The distance travelled, e.g. exercising or travelling.
     * 
     *  @property distance
     *  @type Distance
     */
    prototype.distance = null;
    /**
     *  Schema.org/opponent
     *  A sub property of participant. The opponent on this action.
     * 
     *  @property opponent
     *  @type Person
     */
    prototype.opponent = null;
    /**
     *  Schema.org/sportsActivityLocation
     *  A sub property of location. The sports activity location where this action occurred.
     * 
     *  @property sportsActivityLocation
     *  @type SportsActivityLocation
     */
    prototype.sportsActivityLocation = null;
    /**
     *  Schema.org/toLocation
     *  A sub property of location. The final location of the object or the agent after the action.
     * 
     *  @property toLocation
     *  @type Place
     */
    prototype.toLocation = null;
    /**
     *  Schema.org/fromLocation
     *  A sub property of location. The original location of the object or the agent before the action.
     * 
     *  @property fromLocation
     *  @type Place
     */
    prototype.fromLocation = null;
    /**
     *  Schema.org/exerciseCourse
     *  A sub property of location. The course where this action was taken.
     * 
     *  @property exerciseCourse
     *  @type Place
     */
    prototype.exerciseCourse = null;
}, {course: "Place", sportsTeam: "SportsTeam", sportsEvent: "SportsEvent", distance: "Distance", opponent: "Person", sportsActivityLocation: "SportsActivityLocation", toLocation: "Place", fromLocation: "Place", exerciseCourse: "Place", audience: "Audience", event: "SchemaEvent", result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/ApplyAction
 *  The act of registering to an organization/service without the guarantee to receive it.\n\nRelated actions:\n\n* [[RegisterAction]]: Unlike RegisterAction, ApplyAction has no guarantees that the application will be accepted.
 * 
 *  @author schema.org
 *  @class ApplyAction
 *  @module org.schema
 *  @extends OrganizeAction
 */
var ApplyAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    OrganizeAction.call(this);
    this.context = "http://schema.org/";
    this.type = "ApplyAction";
};
ApplyAction = stjs.extend(ApplyAction, OrganizeAction, [], null, {result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/BookmarkAction
 *  An agent bookmarks/flags/labels/tags/marks an object.
 * 
 *  @author schema.org
 *  @class BookmarkAction
 *  @module org.schema
 *  @extends OrganizeAction
 */
var BookmarkAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    OrganizeAction.call(this);
    this.context = "http://schema.org/";
    this.type = "BookmarkAction";
};
BookmarkAction = stjs.extend(BookmarkAction, OrganizeAction, [], null, {result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/AllocateAction
 *  The act of organizing tasks/objects/events by associating resources to it.
 * 
 *  @author schema.org
 *  @class AllocateAction
 *  @module org.schema
 *  @extends OrganizeAction
 */
var AllocateAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    OrganizeAction.call(this);
    this.context = "http://schema.org/";
    this.type = "AllocateAction";
};
AllocateAction = stjs.extend(AllocateAction, OrganizeAction, [], null, {result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/PlanAction
 *  The act of planning the execution of an event/task/action/reservation/plan to a future date.
 * 
 *  @author schema.org
 *  @class PlanAction
 *  @module org.schema
 *  @extends OrganizeAction
 */
var PlanAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    OrganizeAction.call(this);
    this.context = "http://schema.org/";
    this.type = "PlanAction";
};
PlanAction = stjs.extend(PlanAction, OrganizeAction, [], function(constructor, prototype) {
    /**
     *  Schema.org/scheduledTime
     *  The time the object is scheduled to.
     * 
     *  @property scheduledTime
     *  @type DateTime
     */
    prototype.scheduledTime = null;
}, {result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/ActivateAction
 *  The act of starting or activating a device or application (e.g. starting a timer or turning on a flashlight).
 * 
 *  @author schema.org
 *  @class ActivateAction
 *  @module org.schema
 *  @extends ControlAction
 */
var ActivateAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    ControlAction.call(this);
    this.context = "http://schema.org/";
    this.type = "ActivateAction";
};
ActivateAction = stjs.extend(ActivateAction, ControlAction, [], null, {result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/DeactivateAction
 *  The act of stopping or deactivating a device or application (e.g. stopping a timer or turning off a flashlight).
 * 
 *  @author schema.org
 *  @class DeactivateAction
 *  @module org.schema
 *  @extends ControlAction
 */
var DeactivateAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    ControlAction.call(this);
    this.context = "http://schema.org/";
    this.type = "DeactivateAction";
};
DeactivateAction = stjs.extend(DeactivateAction, ControlAction, [], null, {result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/ResumeAction
 *  The act of resuming a device or application which was formerly paused (e.g. resume music playback or resume a timer).
 * 
 *  @author schema.org
 *  @class ResumeAction
 *  @module org.schema
 *  @extends ControlAction
 */
var ResumeAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    ControlAction.call(this);
    this.context = "http://schema.org/";
    this.type = "ResumeAction";
};
ResumeAction = stjs.extend(ResumeAction, ControlAction, [], null, {result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/SuspendAction
 *  The act of momentarily pausing a device or application (e.g. pause music playback or pause a timer).
 * 
 *  @author schema.org
 *  @class SuspendAction
 *  @module org.schema
 *  @extends ControlAction
 */
var SuspendAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    ControlAction.call(this);
    this.context = "http://schema.org/";
    this.type = "SuspendAction";
};
SuspendAction = stjs.extend(SuspendAction, ControlAction, [], null, {result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/ReviewAction
 *  The act of producing a balanced opinion about the object for an audience. An agent reviews an object with participants resulting in a review.
 * 
 *  @author schema.org
 *  @class ReviewAction
 *  @module org.schema
 *  @extends AssessAction
 */
var ReviewAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    AssessAction.call(this);
    this.context = "http://schema.org/";
    this.type = "ReviewAction";
};
ReviewAction = stjs.extend(ReviewAction, AssessAction, [], function(constructor, prototype) {
    /**
     *  Schema.org/resultReview
     *  A sub property of result. The review that resulted in the performing of the action.
     * 
     *  @property resultReview
     *  @type Review
     */
    prototype.resultReview = null;
}, {resultReview: "Review", result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/IgnoreAction
 *  The act of intentionally disregarding the object. An agent ignores an object.
 * 
 *  @author schema.org
 *  @class IgnoreAction
 *  @module org.schema
 *  @extends AssessAction
 */
var IgnoreAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    AssessAction.call(this);
    this.context = "http://schema.org/";
    this.type = "IgnoreAction";
};
IgnoreAction = stjs.extend(IgnoreAction, AssessAction, [], null, {result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/ChooseAction
 *  The act of expressing a preference from a set of options or a large or unbounded set of choices/options.
 * 
 *  @author schema.org
 *  @class ChooseAction
 *  @module org.schema
 *  @extends AssessAction
 */
var ChooseAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    AssessAction.call(this);
    this.context = "http://schema.org/";
    this.type = "ChooseAction";
};
ChooseAction = stjs.extend(ChooseAction, AssessAction, [], function(constructor, prototype) {
    /**
     *  Schema.org/actionOption
     *  A sub property of object. The options subject to this action.
     * 
     *  @property actionOption
     *  @type Text
     */
    prototype.actionOption = null;
    /**
     *  Schema.org/option
     *  A sub property of object. The options subject to this action.
     * 
     *  @property option
     *  @type Text
     */
    prototype.option = null;
}, {result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/ReactAction
 *  The act of responding instinctively and emotionally to an object, expressing a sentiment.
 * 
 *  @author schema.org
 *  @class ReactAction
 *  @module org.schema
 *  @extends AssessAction
 */
var ReactAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    AssessAction.call(this);
    this.context = "http://schema.org/";
    this.type = "ReactAction";
};
ReactAction = stjs.extend(ReactAction, AssessAction, [], null, {result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/UseAction
 *  The act of applying an object to its intended purpose.
 * 
 *  @author schema.org
 *  @class UseAction
 *  @module org.schema
 *  @extends ConsumeAction
 */
var UseAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    ConsumeAction.call(this);
    this.context = "http://schema.org/";
    this.type = "UseAction";
};
UseAction = stjs.extend(UseAction, ConsumeAction, [], null, {expectsAcceptanceOf: "Offer", result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/ReadAction
 *  The act of consuming written content.
 * 
 *  @author schema.org
 *  @class ReadAction
 *  @module org.schema
 *  @extends ConsumeAction
 */
var ReadAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    ConsumeAction.call(this);
    this.context = "http://schema.org/";
    this.type = "ReadAction";
};
ReadAction = stjs.extend(ReadAction, ConsumeAction, [], null, {expectsAcceptanceOf: "Offer", result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/DrinkAction
 *  The act of swallowing liquids.
 * 
 *  @author schema.org
 *  @class DrinkAction
 *  @module org.schema
 *  @extends ConsumeAction
 */
var DrinkAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    ConsumeAction.call(this);
    this.context = "http://schema.org/";
    this.type = "DrinkAction";
};
DrinkAction = stjs.extend(DrinkAction, ConsumeAction, [], null, {expectsAcceptanceOf: "Offer", result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/ViewAction
 *  The act of consuming static visual content.
 * 
 *  @author schema.org
 *  @class ViewAction
 *  @module org.schema
 *  @extends ConsumeAction
 */
var ViewAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    ConsumeAction.call(this);
    this.context = "http://schema.org/";
    this.type = "ViewAction";
};
ViewAction = stjs.extend(ViewAction, ConsumeAction, [], null, {expectsAcceptanceOf: "Offer", result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/WatchAction
 *  The act of consuming dynamic/moving visual content.
 * 
 *  @author schema.org
 *  @class WatchAction
 *  @module org.schema
 *  @extends ConsumeAction
 */
var WatchAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    ConsumeAction.call(this);
    this.context = "http://schema.org/";
    this.type = "WatchAction";
};
WatchAction = stjs.extend(WatchAction, ConsumeAction, [], null, {expectsAcceptanceOf: "Offer", result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/InstallAction
 *  The act of installing an application.
 * 
 *  @author schema.org
 *  @class InstallAction
 *  @module org.schema
 *  @extends ConsumeAction
 */
var InstallAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    ConsumeAction.call(this);
    this.context = "http://schema.org/";
    this.type = "InstallAction";
};
InstallAction = stjs.extend(InstallAction, ConsumeAction, [], null, {expectsAcceptanceOf: "Offer", result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/ListenAction
 *  The act of consuming audio content.
 * 
 *  @author schema.org
 *  @class ListenAction
 *  @module org.schema
 *  @extends ConsumeAction
 */
var ListenAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    ConsumeAction.call(this);
    this.context = "http://schema.org/";
    this.type = "ListenAction";
};
ListenAction = stjs.extend(ListenAction, ConsumeAction, [], null, {expectsAcceptanceOf: "Offer", result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/EatAction
 *  The act of swallowing solid objects.
 * 
 *  @author schema.org
 *  @class EatAction
 *  @module org.schema
 *  @extends ConsumeAction
 */
var EatAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    ConsumeAction.call(this);
    this.context = "http://schema.org/";
    this.type = "EatAction";
};
EatAction = stjs.extend(EatAction, ConsumeAction, [], null, {expectsAcceptanceOf: "Offer", result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/CookAction
 *  The act of producing/preparing food.
 * 
 *  @author schema.org
 *  @class CookAction
 *  @module org.schema
 *  @extends CreateAction
 */
var CookAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CreateAction.call(this);
    this.context = "http://schema.org/";
    this.type = "CookAction";
};
CookAction = stjs.extend(CookAction, CreateAction, [], function(constructor, prototype) {
    /**
     *  Schema.org/recipe
     *  A sub property of instrument. The recipe/instructions used to perform the action.
     * 
     *  @property recipe
     *  @type Recipe
     */
    prototype.recipe = null;
    /**
     *  Schema.org/foodEvent
     *  A sub property of location. The specific food event where the action occurred.
     * 
     *  @property foodEvent
     *  @type FoodEvent
     */
    prototype.foodEvent = null;
    /**
     *  Schema.org/foodEstablishment
     *  A sub property of location. The specific food establishment where the action occurred.
     * 
     *  @property foodEstablishment
     *  @type FoodEstablishment
     */
    prototype.foodEstablishment = null;
}, {recipe: "Recipe", foodEvent: "FoodEvent", foodEstablishment: "FoodEstablishment", result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/PaintAction
 *  The act of producing a painting, typically with paint and canvas as instruments.
 * 
 *  @author schema.org
 *  @class PaintAction
 *  @module org.schema
 *  @extends CreateAction
 */
var PaintAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CreateAction.call(this);
    this.context = "http://schema.org/";
    this.type = "PaintAction";
};
PaintAction = stjs.extend(PaintAction, CreateAction, [], null, {result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/PhotographAction
 *  The act of capturing still images of objects using a camera.
 * 
 *  @author schema.org
 *  @class PhotographAction
 *  @module org.schema
 *  @extends CreateAction
 */
var PhotographAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CreateAction.call(this);
    this.context = "http://schema.org/";
    this.type = "PhotographAction";
};
PhotographAction = stjs.extend(PhotographAction, CreateAction, [], null, {result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/FilmAction
 *  The act of capturing sound and moving images on film, video, or digitally.
 * 
 *  @author schema.org
 *  @class FilmAction
 *  @module org.schema
 *  @extends CreateAction
 */
var FilmAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CreateAction.call(this);
    this.context = "http://schema.org/";
    this.type = "FilmAction";
};
FilmAction = stjs.extend(FilmAction, CreateAction, [], null, {result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/WriteAction
 *  The act of authoring written creative content.
 * 
 *  @author schema.org
 *  @class WriteAction
 *  @module org.schema
 *  @extends CreateAction
 */
var WriteAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CreateAction.call(this);
    this.context = "http://schema.org/";
    this.type = "WriteAction";
};
WriteAction = stjs.extend(WriteAction, CreateAction, [], function(constructor, prototype) {
    /**
     *  Schema.org/inLanguage
     *  The language of the content or performance or used in an action. Please use one of the language codes from the [IETF BCP 47 standard](http://tools.ietf.org/html/bcp47). See also [[availableLanguage]].
     * 
     *  @property inLanguage
     *  @type Language
     */
    prototype.inLanguage = null;
    /**
     *  Schema.org/language
     *  A sub property of instrument. The language used on this action.
     * 
     *  @property language
     *  @type Language
     */
    prototype.language = null;
}, {inLanguage: "Language", language: "Language", result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/DrawAction
 *  The act of producing a visual/graphical representation of an object, typically with a pen/pencil and paper as instruments.
 * 
 *  @author schema.org
 *  @class DrawAction
 *  @module org.schema
 *  @extends CreateAction
 */
var DrawAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CreateAction.call(this);
    this.context = "http://schema.org/";
    this.type = "DrawAction";
};
DrawAction = stjs.extend(DrawAction, CreateAction, [], null, {result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/WinAction
 *  The act of achieving victory in a competitive activity.
 * 
 *  @author schema.org
 *  @class WinAction
 *  @module org.schema
 *  @extends AchieveAction
 */
var WinAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    AchieveAction.call(this);
    this.context = "http://schema.org/";
    this.type = "WinAction";
};
WinAction = stjs.extend(WinAction, AchieveAction, [], function(constructor, prototype) {
    /**
     *  Schema.org/loser
     *  A sub property of participant. The loser of the action.
     * 
     *  @property loser
     *  @type Person
     */
    prototype.loser = null;
}, {loser: "Person", result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/LoseAction
 *  The act of being defeated in a competitive activity.
 * 
 *  @author schema.org
 *  @class LoseAction
 *  @module org.schema
 *  @extends AchieveAction
 */
var LoseAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    AchieveAction.call(this);
    this.context = "http://schema.org/";
    this.type = "LoseAction";
};
LoseAction = stjs.extend(LoseAction, AchieveAction, [], function(constructor, prototype) {
    /**
     *  Schema.org/winner
     *  A sub property of participant. The winner of the action.
     * 
     *  @property winner
     *  @type Person
     */
    prototype.winner = null;
}, {winner: "Person", result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/TieAction
 *  The act of reaching a draw in a competitive activity.
 * 
 *  @author schema.org
 *  @class TieAction
 *  @module org.schema
 *  @extends AchieveAction
 */
var TieAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    AchieveAction.call(this);
    this.context = "http://schema.org/";
    this.type = "TieAction";
};
TieAction = stjs.extend(TieAction, AchieveAction, [], null, {result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/CheckAction
 *  An agent inspects, determines, investigates, inquires, or examines an object's accuracy, quality, condition, or state.
 * 
 *  @author schema.org
 *  @class CheckAction
 *  @module org.schema
 *  @extends FindAction
 */
var CheckAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    FindAction.call(this);
    this.context = "http://schema.org/";
    this.type = "CheckAction";
};
CheckAction = stjs.extend(CheckAction, FindAction, [], null, {result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/TrackAction
 *  An agent tracks an object for updates.\n\nRelated actions:\n\n* [[FollowAction]]: Unlike FollowAction, TrackAction refers to the interest on the location of innanimates objects.\n* [[SubscribeAction]]: Unlike SubscribeAction, TrackAction refers to  the interest on the location of innanimate objects.
 * 
 *  @author schema.org
 *  @class TrackAction
 *  @module org.schema
 *  @extends FindAction
 */
var TrackAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    FindAction.call(this);
    this.context = "http://schema.org/";
    this.type = "TrackAction";
};
TrackAction = stjs.extend(TrackAction, FindAction, [], function(constructor, prototype) {
    /**
     *  Schema.org/deliveryMethod
     *  A sub property of instrument. The method of delivery.
     * 
     *  @property deliveryMethod
     *  @type DeliveryMethod
     */
    prototype.deliveryMethod = null;
}, {deliveryMethod: "DeliveryMethod", result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/DiscoverAction
 *  The act of discovering/finding an object.
 * 
 *  @author schema.org
 *  @class DiscoverAction
 *  @module org.schema
 *  @extends FindAction
 */
var DiscoverAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    FindAction.call(this);
    this.context = "http://schema.org/";
    this.type = "DiscoverAction";
};
DiscoverAction = stjs.extend(DiscoverAction, FindAction, [], null, {result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/SportsTeam
 *  Organization: Sports team.
 * 
 *  @author schema.org
 *  @class SportsTeam
 *  @module org.schema
 *  @extends SportsOrganization
 */
var SportsTeam = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    SportsOrganization.call(this);
    this.context = "http://schema.org/";
    this.type = "SportsTeam";
};
SportsTeam = stjs.extend(SportsTeam, SportsOrganization, [], function(constructor, prototype) {
    /**
     *  Schema.org/athlete
     *  A person that acts as performing member of a sports team; a player as opposed to a coach.
     * 
     *  @property athlete
     *  @type Person
     */
    prototype.athlete = null;
    /**
     *  Schema.org/coach
     *  A person that acts in a coaching role for a sports team.
     * 
     *  @property coach
     *  @type Person
     */
    prototype.coach = null;
}, {athlete: "Person", coach: "Person", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/DanceGroup
 *  A dance group&#x2014;for example, the Alvin Ailey Dance Theater or Riverdance.
 * 
 *  @author schema.org
 *  @class DanceGroup
 *  @module org.schema
 *  @extends PerformingGroup
 */
var DanceGroup = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    PerformingGroup.call(this);
    this.context = "http://schema.org/";
    this.type = "DanceGroup";
};
DanceGroup = stjs.extend(DanceGroup, PerformingGroup, [], null, {serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/TheaterGroup
 *  A theater group or company, for example, the Royal Shakespeare Company or Druid Theatre.
 * 
 *  @author schema.org
 *  @class TheaterGroup
 *  @module org.schema
 *  @extends PerformingGroup
 */
var TheaterGroup = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    PerformingGroup.call(this);
    this.context = "http://schema.org/";
    this.type = "TheaterGroup";
};
TheaterGroup = stjs.extend(TheaterGroup, PerformingGroup, [], null, {serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/MusicGroup
 *  A musical group, such as a band, an orchestra, or a choir. Can also be a solo musician.
 * 
 *  @author schema.org
 *  @class MusicGroup
 *  @module org.schema
 *  @extends PerformingGroup
 */
var MusicGroup = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    PerformingGroup.call(this);
    this.context = "http://schema.org/";
    this.type = "MusicGroup";
};
MusicGroup = stjs.extend(MusicGroup, PerformingGroup, [], function(constructor, prototype) {
    /**
     *  Schema.org/albums
     *  A collection of music albums.
     * 
     *  @property albums
     *  @type MusicAlbum
     */
    prototype.albums = null;
    /**
     *  Schema.org/track
     *  A music recording (track)&#x2014;usually a single song. If an ItemList is given, the list should contain items of type MusicRecording.
     * 
     *  @property track
     *  @type MusicRecording
     */
    prototype.track = null;
    /**
     *  Schema.org/genre
     *  Genre of the creative work, broadcast channel or group.
     * 
     *  @property genre
     *  @type URL
     */
    prototype.genre = null;
    /**
     *  Schema.org/tracks
     *  A music recording (track)&#x2014;usually a single song.
     * 
     *  @property tracks
     *  @type MusicRecording
     */
    prototype.tracks = null;
    /**
     *  Schema.org/musicGroupMember
     *  A member of a music group&#x2014;for example, John, Paul, George, or Ringo.
     * 
     *  @property musicGroupMember
     *  @type Person
     */
    prototype.musicGroupMember = null;
    /**
     *  Schema.org/album
     *  A music album.
     * 
     *  @property album
     *  @type MusicAlbum
     */
    prototype.album = null;
}, {albums: "MusicAlbum", track: "MusicRecording", tracks: "MusicRecording", musicGroupMember: "Person", album: "MusicAlbum", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Preschool
 *  A preschool.
 * 
 *  @author schema.org
 *  @class Preschool
 *  @module org.schema
 *  @extends EducationalOrganization
 */
var Preschool = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    EducationalOrganization.call(this);
    this.context = "http://schema.org/";
    this.type = "Preschool";
};
Preschool = stjs.extend(Preschool, EducationalOrganization, [], null, {alumni: "Person", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/MiddleSchool
 *  A middle school (typically for children aged around 11-14, although this varies somewhat).
 * 
 *  @author schema.org
 *  @class MiddleSchool
 *  @module org.schema
 *  @extends EducationalOrganization
 */
var MiddleSchool = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    EducationalOrganization.call(this);
    this.context = "http://schema.org/";
    this.type = "MiddleSchool";
};
MiddleSchool = stjs.extend(MiddleSchool, EducationalOrganization, [], null, {alumni: "Person", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/ElementarySchool
 *  An elementary school.
 * 
 *  @author schema.org
 *  @class ElementarySchool
 *  @module org.schema
 *  @extends EducationalOrganization
 */
var ElementarySchool = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    EducationalOrganization.call(this);
    this.context = "http://schema.org/";
    this.type = "ElementarySchool";
};
ElementarySchool = stjs.extend(ElementarySchool, EducationalOrganization, [], null, {alumni: "Person", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/HighSchool
 *  A high school.
 * 
 *  @author schema.org
 *  @class HighSchool
 *  @module org.schema
 *  @extends EducationalOrganization
 */
var HighSchool = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    EducationalOrganization.call(this);
    this.context = "http://schema.org/";
    this.type = "HighSchool";
};
HighSchool = stjs.extend(HighSchool, EducationalOrganization, [], null, {alumni: "Person", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/CollegeOrUniversity
 *  A college, university, or other third-level educational institution.
 * 
 *  @author schema.org
 *  @class CollegeOrUniversity
 *  @module org.schema
 *  @extends EducationalOrganization
 */
var CollegeOrUniversity = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    EducationalOrganization.call(this);
    this.context = "http://schema.org/";
    this.type = "CollegeOrUniversity";
};
CollegeOrUniversity = stjs.extend(CollegeOrUniversity, EducationalOrganization, [], null, {alumni: "Person", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/School
 *  A school.
 * 
 *  @author schema.org
 *  @class School
 *  @module org.schema
 *  @extends EducationalOrganization
 */
var School = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    EducationalOrganization.call(this);
    this.context = "http://schema.org/";
    this.type = "School";
};
School = stjs.extend(School, EducationalOrganization, [], null, {alumni: "Person", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Dentist
 *  A dentist.
 * 
 *  @author schema.org
 *  @class Dentist
 *  @module org.schema
 *  @extends MedicalOrganization
 */
var Dentist = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    MedicalOrganization.call(this);
    this.context = "http://schema.org/";
    this.type = "Dentist";
};
Dentist = stjs.extend(Dentist, MedicalOrganization, [], null, {serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Pharmacy
 *  A pharmacy or drugstore.
 * 
 *  @author schema.org
 *  @class Pharmacy
 *  @module org.schema
 *  @extends MedicalOrganization
 */
var Pharmacy = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    MedicalOrganization.call(this);
    this.context = "http://schema.org/";
    this.type = "Pharmacy";
};
Pharmacy = stjs.extend(Pharmacy, MedicalOrganization, [], null, {serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Physician
 *  A doctor's office.
 * 
 *  @author schema.org
 *  @class Physician
 *  @module org.schema
 *  @extends MedicalOrganization
 */
var Physician = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    MedicalOrganization.call(this);
    this.context = "http://schema.org/";
    this.type = "Physician";
};
Physician = stjs.extend(Physician, MedicalOrganization, [], null, {serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/GovernmentOffice
 *  A government office&#x2014;for example, an IRS or DMV office.
 * 
 *  @author schema.org
 *  @class GovernmentOffice
 *  @module org.schema
 *  @extends LocalBusiness
 */
var GovernmentOffice = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    LocalBusiness.call(this);
    this.context = "http://schema.org/";
    this.type = "GovernmentOffice";
};
GovernmentOffice = stjs.extend(GovernmentOffice, LocalBusiness, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/SelfStorage
 *  A self-storage facility.
 * 
 *  @author schema.org
 *  @class SelfStorage
 *  @module org.schema
 *  @extends LocalBusiness
 */
var SelfStorage = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    LocalBusiness.call(this);
    this.context = "http://schema.org/";
    this.type = "SelfStorage";
};
SelfStorage = stjs.extend(SelfStorage, LocalBusiness, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/RealEstateAgent
 *  A real-estate agent.
 * 
 *  @author schema.org
 *  @class RealEstateAgent
 *  @module org.schema
 *  @extends LocalBusiness
 */
var RealEstateAgent = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    LocalBusiness.call(this);
    this.context = "http://schema.org/";
    this.type = "RealEstateAgent";
};
RealEstateAgent = stjs.extend(RealEstateAgent, LocalBusiness, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/FoodEstablishment
 *  A food-related business.
 * 
 *  @author schema.org
 *  @class FoodEstablishment
 *  @module org.schema
 *  @extends LocalBusiness
 */
var FoodEstablishment = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    LocalBusiness.call(this);
    this.context = "http://schema.org/";
    this.type = "FoodEstablishment";
};
FoodEstablishment = stjs.extend(FoodEstablishment, LocalBusiness, [], function(constructor, prototype) {
    /**
     *  Schema.org/servesCuisine
     *  The cuisine of the restaurant.
     * 
     *  @property servesCuisine
     *  @type Text
     */
    prototype.servesCuisine = null;
    /**
     *  Schema.org/hasMenu
     *  Either the actual menu as a structured representation, as text, or a URL of the menu.
     * 
     *  @property hasMenu
     *  @type URL
     */
    prototype.hasMenu = null;
    /**
     *  Schema.org/menu
     *  Either the actual menu as a structured representation, as text, or a URL of the menu.
     * 
     *  @property menu
     *  @type Menu
     */
    prototype.menu = null;
    /**
     *  Schema.org/starRating
     *  An official rating for a lodging business or food establishment, e.g. from national associations or standards bodies. Use the author property to indicate the rating organization, e.g. as an Organization with name such as (e.g. HOTREC, DEHOGA, WHR, or Hotelstars).
     * 
     *  @property starRating
     *  @type Rating
     */
    prototype.starRating = null;
    /**
     *  Schema.org/acceptsReservations
     *  Indicates whether a FoodEstablishment accepts reservations. Values can be Boolean, an URL at which reservations can be made or (for backwards compatibility) the strings ```Yes``` or ```No```.
     * 
     *  @property acceptsReservations
     *  @type URL
     */
    prototype.acceptsReservations = null;
}, {menu: "Menu", starRating: "Rating", branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/TouristInformationCenter
 *  A tourist information center.
 * 
 *  @author schema.org
 *  @class TouristInformationCenter
 *  @module org.schema
 *  @extends LocalBusiness
 */
var TouristInformationCenter = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    LocalBusiness.call(this);
    this.context = "http://schema.org/";
    this.type = "TouristInformationCenter";
};
TouristInformationCenter = stjs.extend(TouristInformationCenter, LocalBusiness, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/EmploymentAgency
 *  An employment agency.
 * 
 *  @author schema.org
 *  @class EmploymentAgency
 *  @module org.schema
 *  @extends LocalBusiness
 */
var EmploymentAgency = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    LocalBusiness.call(this);
    this.context = "http://schema.org/";
    this.type = "EmploymentAgency";
};
EmploymentAgency = stjs.extend(EmploymentAgency, LocalBusiness, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/ChildCare
 *  A Childcare center.
 * 
 *  @author schema.org
 *  @class ChildCare
 *  @module org.schema
 *  @extends LocalBusiness
 */
var ChildCare = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    LocalBusiness.call(this);
    this.context = "http://schema.org/";
    this.type = "ChildCare";
};
ChildCare = stjs.extend(ChildCare, LocalBusiness, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/SportsActivityLocation
 *  A sports location, such as a playing field.
 * 
 *  @author schema.org
 *  @class SportsActivityLocation
 *  @module org.schema
 *  @extends LocalBusiness
 */
var SportsActivityLocation = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    LocalBusiness.call(this);
    this.context = "http://schema.org/";
    this.type = "SportsActivityLocation";
};
SportsActivityLocation = stjs.extend(SportsActivityLocation, LocalBusiness, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/LegalService
 *  A LegalService is a business that provides legally-oriented services, advice and representation, e.g. law firms.\n\nAs a [[LocalBusiness]] it can be described as a [[provider]] of one or more [[Service]]\(s).
 * 
 *  @author schema.org
 *  @class LegalService
 *  @module org.schema
 *  @extends LocalBusiness
 */
var LegalService = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    LocalBusiness.call(this);
    this.context = "http://schema.org/";
    this.type = "LegalService";
};
LegalService = stjs.extend(LegalService, LocalBusiness, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/HealthAndBeautyBusiness
 *  Health and beauty.
 * 
 *  @author schema.org
 *  @class HealthAndBeautyBusiness
 *  @module org.schema
 *  @extends LocalBusiness
 */
var HealthAndBeautyBusiness = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    LocalBusiness.call(this);
    this.context = "http://schema.org/";
    this.type = "HealthAndBeautyBusiness";
};
HealthAndBeautyBusiness = stjs.extend(HealthAndBeautyBusiness, LocalBusiness, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/TelevisionStation
 *  A television station.
 * 
 *  @author schema.org
 *  @class TelevisionStation
 *  @module org.schema
 *  @extends LocalBusiness
 */
var TelevisionStation = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    LocalBusiness.call(this);
    this.context = "http://schema.org/";
    this.type = "TelevisionStation";
};
TelevisionStation = stjs.extend(TelevisionStation, LocalBusiness, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/LodgingBusiness
 *  A lodging business, such as a motel, hotel, or inn.
 * 
 *  @author schema.org
 *  @class LodgingBusiness
 *  @module org.schema
 *  @extends LocalBusiness
 */
var LodgingBusiness = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    LocalBusiness.call(this);
    this.context = "http://schema.org/";
    this.type = "LodgingBusiness";
};
LodgingBusiness = stjs.extend(LodgingBusiness, LocalBusiness, [], function(constructor, prototype) {
    /**
     *  Schema.org/audience
     *  An intended audience, i.e. a group for whom something was created.
     * 
     *  @property audience
     *  @type Audience
     */
    prototype.audience = null;
    /**
     *  Schema.org/checkinTime
     *  The earliest someone may check into a lodging establishment.
     * 
     *  @property checkinTime
     *  @type DateTime
     */
    prototype.checkinTime = null;
    /**
     *  Schema.org/petsAllowed
     *  Indicates whether pets are allowed to enter the accommodation or lodging business. More detailed information can be put in a text value.
     * 
     *  @property petsAllowed
     *  @type Boolean
     */
    prototype.petsAllowed = null;
    /**
     *  Schema.org/availableLanguage
     *  A language someone may use with the item. Please use one of the language codes from the [IETF BCP 47 standard](http://tools.ietf.org/html/bcp47). See also [[inLanguage]]
     * 
     *  @property availableLanguage
     *  @type Language
     */
    prototype.availableLanguage = null;
    /**
     *  Schema.org/amenityFeature
     *  An amenity feature (e.g. a characteristic or service) of the Accommodation. This generic property does not make a statement about whether the feature is included in an offer for the main accommodation or available at extra costs.
     * 
     *  @property amenityFeature
     *  @type LocationFeatureSpecification
     */
    prototype.amenityFeature = null;
    /**
     *  Schema.org/starRating
     *  An official rating for a lodging business or food establishment, e.g. from national associations or standards bodies. Use the author property to indicate the rating organization, e.g. as an Organization with name such as (e.g. HOTREC, DEHOGA, WHR, or Hotelstars).
     * 
     *  @property starRating
     *  @type Rating
     */
    prototype.starRating = null;
    /**
     *  Schema.org/checkoutTime
     *  The latest someone may check out of a lodging establishment.
     * 
     *  @property checkoutTime
     *  @type DateTime
     */
    prototype.checkoutTime = null;
}, {audience: "Audience", availableLanguage: "Language", amenityFeature: "LocationFeatureSpecification", starRating: "Rating", branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/FinancialService
 *  Financial services business.
 * 
 *  @author schema.org
 *  @class FinancialService
 *  @module org.schema
 *  @extends LocalBusiness
 */
var FinancialService = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    LocalBusiness.call(this);
    this.context = "http://schema.org/";
    this.type = "FinancialService";
};
FinancialService = stjs.extend(FinancialService, LocalBusiness, [], function(constructor, prototype) {
    /**
     *  Schema.org/feesAndCommissionsSpecification
     *  Description of fees, commissions, and other terms applied either to a class of financial product, or by a financial service organization.
     * 
     *  @property feesAndCommissionsSpecification
     *  @type Text
     */
    prototype.feesAndCommissionsSpecification = null;
}, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Store
 *  A retail good store.
 * 
 *  @author schema.org
 *  @class Store
 *  @module org.schema
 *  @extends LocalBusiness
 */
var Store = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    LocalBusiness.call(this);
    this.context = "http://schema.org/";
    this.type = "Store";
};
Store = stjs.extend(Store, LocalBusiness, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/ShoppingCenter
 *  A shopping center or mall.
 * 
 *  @author schema.org
 *  @class ShoppingCenter
 *  @module org.schema
 *  @extends LocalBusiness
 */
var ShoppingCenter = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    LocalBusiness.call(this);
    this.context = "http://schema.org/";
    this.type = "ShoppingCenter";
};
ShoppingCenter = stjs.extend(ShoppingCenter, LocalBusiness, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/AutomotiveBusiness
 *  Car repair, sales, or parts.
 * 
 *  @author schema.org
 *  @class AutomotiveBusiness
 *  @module org.schema
 *  @extends LocalBusiness
 */
var AutomotiveBusiness = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    LocalBusiness.call(this);
    this.context = "http://schema.org/";
    this.type = "AutomotiveBusiness";
};
AutomotiveBusiness = stjs.extend(AutomotiveBusiness, LocalBusiness, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/EntertainmentBusiness
 *  A business providing entertainment.
 * 
 *  @author schema.org
 *  @class EntertainmentBusiness
 *  @module org.schema
 *  @extends LocalBusiness
 */
var EntertainmentBusiness = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    LocalBusiness.call(this);
    this.context = "http://schema.org/";
    this.type = "EntertainmentBusiness";
};
EntertainmentBusiness = stjs.extend(EntertainmentBusiness, LocalBusiness, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Library
 *  A library.
 * 
 *  @author schema.org
 *  @class Library
 *  @module org.schema
 *  @extends LocalBusiness
 */
var Library = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    LocalBusiness.call(this);
    this.context = "http://schema.org/";
    this.type = "Library";
};
Library = stjs.extend(Library, LocalBusiness, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/RecyclingCenter
 *  A recycling center.
 * 
 *  @author schema.org
 *  @class RecyclingCenter
 *  @module org.schema
 *  @extends LocalBusiness
 */
var RecyclingCenter = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    LocalBusiness.call(this);
    this.context = "http://schema.org/";
    this.type = "RecyclingCenter";
};
RecyclingCenter = stjs.extend(RecyclingCenter, LocalBusiness, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/InternetCafe
 *  An internet cafe.
 * 
 *  @author schema.org
 *  @class InternetCafe
 *  @module org.schema
 *  @extends LocalBusiness
 */
var InternetCafe = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    LocalBusiness.call(this);
    this.context = "http://schema.org/";
    this.type = "InternetCafe";
};
InternetCafe = stjs.extend(InternetCafe, LocalBusiness, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/AnimalShelter
 *  Animal shelter.
 * 
 *  @author schema.org
 *  @class AnimalShelter
 *  @module org.schema
 *  @extends LocalBusiness
 */
var AnimalShelter = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    LocalBusiness.call(this);
    this.context = "http://schema.org/";
    this.type = "AnimalShelter";
};
AnimalShelter = stjs.extend(AnimalShelter, LocalBusiness, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/EmergencyService
 *  An emergency service, such as a fire station or ER.
 * 
 *  @author schema.org
 *  @class EmergencyService
 *  @module org.schema
 *  @extends LocalBusiness
 */
var EmergencyService = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    LocalBusiness.call(this);
    this.context = "http://schema.org/";
    this.type = "EmergencyService";
};
EmergencyService = stjs.extend(EmergencyService, LocalBusiness, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/HomeAndConstructionBusiness
 *  A construction business.\n\nA HomeAndConstructionBusiness is a [[LocalBusiness]] that provides services around homes and buildings.\n\nAs a [[LocalBusiness]] it can be described as a [[provider]] of one or more [[Service]]\(s).
 * 
 *  @author schema.org
 *  @class HomeAndConstructionBusiness
 *  @module org.schema
 *  @extends LocalBusiness
 */
var HomeAndConstructionBusiness = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    LocalBusiness.call(this);
    this.context = "http://schema.org/";
    this.type = "HomeAndConstructionBusiness";
};
HomeAndConstructionBusiness = stjs.extend(HomeAndConstructionBusiness, LocalBusiness, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/TravelAgency
 *  A travel agency.
 * 
 *  @author schema.org
 *  @class TravelAgency
 *  @module org.schema
 *  @extends LocalBusiness
 */
var TravelAgency = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    LocalBusiness.call(this);
    this.context = "http://schema.org/";
    this.type = "TravelAgency";
};
TravelAgency = stjs.extend(TravelAgency, LocalBusiness, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/RadioStation
 *  A radio station.
 * 
 *  @author schema.org
 *  @class RadioStation
 *  @module org.schema
 *  @extends LocalBusiness
 */
var RadioStation = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    LocalBusiness.call(this);
    this.context = "http://schema.org/";
    this.type = "RadioStation";
};
RadioStation = stjs.extend(RadioStation, LocalBusiness, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/DryCleaningOrLaundry
 *  A dry-cleaning business.
 * 
 *  @author schema.org
 *  @class DryCleaningOrLaundry
 *  @module org.schema
 *  @extends LocalBusiness
 */
var DryCleaningOrLaundry = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    LocalBusiness.call(this);
    this.context = "http://schema.org/";
    this.type = "DryCleaningOrLaundry";
};
DryCleaningOrLaundry = stjs.extend(DryCleaningOrLaundry, LocalBusiness, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/ProfessionalService
 *  Original definition: "provider of professional services."\n\nThe general [[ProfessionalService]] type for local businesses was deprecated due to confusion with [[Service]]. For reference, the types that it included were: [[Dentist]],
 *  [[AccountingService]], [[Attorney]], [[Notary]], as well as types for several kinds of [[HomeAndConstructionBusiness]]: [[Electrician]], [[GeneralContractor]],
 *  [[HousePainter]], [[Locksmith]], [[Plumber]], [[RoofingContractor]]. [[LegalService]] was introduced as a more inclusive supertype of [[Attorney]].
 * 
 *  @author schema.org
 *  @class ProfessionalService
 *  @module org.schema
 *  @extends LocalBusiness
 */
var ProfessionalService = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    LocalBusiness.call(this);
    this.context = "http://schema.org/";
    this.type = "ProfessionalService";
};
ProfessionalService = stjs.extend(ProfessionalService, LocalBusiness, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Mass
 *  Properties that take Mass as values are of the form '&lt;Number&gt; &lt;Mass unit of measure&gt;'. E.g., '7 kg'.
 * 
 *  @author schema.org
 *  @class Mass
 *  @module org.schema
 *  @extends Quantity
 */
var Mass = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Quantity.call(this);
    this.context = "http://schema.org/";
    this.type = "Mass";
};
Mass = stjs.extend(Mass, Quantity, [], null, {identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Energy
 *  Properties that take Energy as values are of the form '&lt;Number&gt; &lt;Energy unit of measure&gt;'.
 * 
 *  @author schema.org
 *  @class Energy
 *  @module org.schema
 *  @extends Quantity
 */
var Energy = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Quantity.call(this);
    this.context = "http://schema.org/";
    this.type = "Energy";
};
Energy = stjs.extend(Energy, Quantity, [], null, {identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Duration
 *  Quantity: Duration (use [ISO 8601 duration format](http://en.wikipedia.org/wiki/ISO_8601)).
 * 
 *  @author schema.org
 *  @class Duration
 *  @module org.schema
 *  @extends Quantity
 */
var Duration = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Quantity.call(this);
    this.context = "http://schema.org/";
    this.type = "Duration";
};
Duration = stjs.extend(Duration, Quantity, [], null, {identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Distance
 *  Properties that take Distances as values are of the form '&lt;Number&gt; &lt;Length unit of measure&gt;'. E.g., '7 ft'.
 * 
 *  @author schema.org
 *  @class Distance
 *  @module org.schema
 *  @extends Quantity
 */
var Distance = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Quantity.call(this);
    this.context = "http://schema.org/";
    this.type = "Distance";
};
Distance = stjs.extend(Distance, Quantity, [], null, {identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/GeoCoordinates
 *  The geographic coordinates of a place or event.
 * 
 *  @author schema.org
 *  @class GeoCoordinates
 *  @module org.schema
 *  @extends StructuredValue
 */
var GeoCoordinates = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    StructuredValue.call(this);
    this.context = "http://schema.org/";
    this.type = "GeoCoordinates";
};
GeoCoordinates = stjs.extend(GeoCoordinates, StructuredValue, [], function(constructor, prototype) {
    /**
     *  Schema.org/address
     *  Physical address of the item.
     * 
     *  @property address
     *  @type PostalAddress
     */
    prototype.address = null;
    /**
     *  Schema.org/latitude
     *  The latitude of a location. For example ```37.42242``` ([WGS 84](https://en.wikipedia.org/wiki/World_Geodetic_System)).
     * 
     *  @property latitude
     *  @type Text
     */
    prototype.latitude = null;
    /**
     *  Schema.org/longitude
     *  The longitude of a location. For example ```-122.08585``` ([WGS 84](https://en.wikipedia.org/wiki/World_Geodetic_System)).
     * 
     *  @property longitude
     *  @type Text
     */
    prototype.longitude = null;
    /**
     *  Schema.org/addressCountry
     *  The country. For example, USA. You can also provide the two-letter [ISO 3166-1 alpha-2 country code](http://en.wikipedia.org/wiki/ISO_3166-1).
     * 
     *  @property addressCountry
     *  @type Text
     */
    prototype.addressCountry = null;
    /**
     *  Schema.org/postalCode
     *  The postal code. For example, 94043.
     * 
     *  @property postalCode
     *  @type Text
     */
    prototype.postalCode = null;
    /**
     *  Schema.org/elevation
     *  The elevation of a location ([WGS 84](https://en.wikipedia.org/wiki/World_Geodetic_System)).
     * 
     *  @property elevation
     *  @type Text
     */
    prototype.elevation = null;
}, {address: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/PropertyValue
 *  A property-value pair, e.g. representing a feature of a product or place. Use the 'name' property for the name of the property. If there is an additional human-readable version of the value, put that into the 'description' property.\n\n Always use specific schema.org properties when a) they exist and b) you can populate them. Using PropertyValue as a substitute will typically not trigger the same effect as using the original, specific property.
 * 
 *  @author schema.org
 *  @class PropertyValue
 *  @module org.schema
 *  @extends StructuredValue
 */
var PropertyValue = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    StructuredValue.call(this);
    this.context = "http://schema.org/";
    this.type = "PropertyValue";
};
PropertyValue = stjs.extend(PropertyValue, StructuredValue, [], function(constructor, prototype) {
    /**
     *  Schema.org/unitCode
     *  The unit of measurement given using the UN/CEFACT Common Code (3 characters) or a URL. Other codes than the UN/CEFACT Common Code may be used with a prefix followed by a colon.
     * 
     *  @property unitCode
     *  @type Text
     */
    prototype.unitCode = null;
    /**
     *  Schema.org/minValue
     *  The lower value of some characteristic or property.
     * 
     *  @property minValue
     *  @type Number
     */
    prototype.minValue = null;
    /**
     *  Schema.org/propertyID
     *  A commonly used identifier for the characteristic represented by the property, e.g. a manufacturer or a standard code for a property. propertyID can be
     *  (1) a prefixed string, mainly meant to be used with standards for product properties; (2) a site-specific, non-prefixed string (e.g. the primary key of the property or the vendor-specific id of the property), or (3)
     *  a URL indicating the type of the property, either pointing to an external vocabulary, or a Web resource that describes the property (e.g. a glossary entry).
     *  Standards bodies should promote a standard prefix for the identifiers of properties from their standards.
     * 
     *  @property propertyID
     *  @type Text
     */
    prototype.propertyID = null;
    /**
     *  Schema.org/value
     *  The value of the quantitative value or property value node.\n\n* For [[QuantitativeValue]] and [[MonetaryAmount]], the recommended type for values is 'Number'.\n* For [[PropertyValue]], it can be 'Text;', 'Number', 'Boolean', or 'StructuredValue'.
     * 
     *  @property value
     *  @type StructuredValue
     */
    prototype.value = null;
    /**
     *  Schema.org/valueReference
     *  A pointer to a secondary value that provides additional information on the original value, e.g. a reference temperature.
     * 
     *  @property valueReference
     *  @type StructuredValue
     */
    prototype.valueReference = null;
    /**
     *  Schema.org/maxValue
     *  The upper value of some characteristic or property.
     * 
     *  @property maxValue
     *  @type Number
     */
    prototype.maxValue = null;
    /**
     *  Schema.org/unitText
     *  A string or text indicating the unit of measurement. Useful if you cannot provide a standard unit code for
     *  <a href='unitCode'>unitCode</a>.
     * 
     *  @property unitText
     *  @type Text
     */
    prototype.unitText = null;
}, {value: "StructuredValue", valueReference: "StructuredValue", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/NutritionInformation
 *  Nutritional information about the recipe.
 * 
 *  @author schema.org
 *  @class NutritionInformation
 *  @module org.schema
 *  @extends StructuredValue
 */
var NutritionInformation = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    StructuredValue.call(this);
    this.context = "http://schema.org/";
    this.type = "NutritionInformation";
};
NutritionInformation = stjs.extend(NutritionInformation, StructuredValue, [], function(constructor, prototype) {
    /**
     *  Schema.org/saturatedFatContent
     *  The number of grams of saturated fat.
     * 
     *  @property saturatedFatContent
     *  @type Mass
     */
    prototype.saturatedFatContent = null;
    /**
     *  Schema.org/fatContent
     *  The number of grams of fat.
     * 
     *  @property fatContent
     *  @type Mass
     */
    prototype.fatContent = null;
    /**
     *  Schema.org/unsaturatedFatContent
     *  The number of grams of unsaturated fat.
     * 
     *  @property unsaturatedFatContent
     *  @type Mass
     */
    prototype.unsaturatedFatContent = null;
    /**
     *  Schema.org/sugarContent
     *  The number of grams of sugar.
     * 
     *  @property sugarContent
     *  @type Mass
     */
    prototype.sugarContent = null;
    /**
     *  Schema.org/cholesterolContent
     *  The number of milligrams of cholesterol.
     * 
     *  @property cholesterolContent
     *  @type Mass
     */
    prototype.cholesterolContent = null;
    /**
     *  Schema.org/carbohydrateContent
     *  The number of grams of carbohydrates.
     * 
     *  @property carbohydrateContent
     *  @type Mass
     */
    prototype.carbohydrateContent = null;
    /**
     *  Schema.org/proteinContent
     *  The number of grams of protein.
     * 
     *  @property proteinContent
     *  @type Mass
     */
    prototype.proteinContent = null;
    /**
     *  Schema.org/sodiumContent
     *  The number of milligrams of sodium.
     * 
     *  @property sodiumContent
     *  @type Mass
     */
    prototype.sodiumContent = null;
    /**
     *  Schema.org/transFatContent
     *  The number of grams of trans fat.
     * 
     *  @property transFatContent
     *  @type Mass
     */
    prototype.transFatContent = null;
    /**
     *  Schema.org/fiberContent
     *  The number of grams of fiber.
     * 
     *  @property fiberContent
     *  @type Mass
     */
    prototype.fiberContent = null;
    /**
     *  Schema.org/calories
     *  The number of calories.
     * 
     *  @property calories
     *  @type Energy
     */
    prototype.calories = null;
    /**
     *  Schema.org/servingSize
     *  The serving size, in terms of the number of volume or mass.
     * 
     *  @property servingSize
     *  @type Text
     */
    prototype.servingSize = null;
}, {saturatedFatContent: "Mass", fatContent: "Mass", unsaturatedFatContent: "Mass", sugarContent: "Mass", cholesterolContent: "Mass", carbohydrateContent: "Mass", proteinContent: "Mass", sodiumContent: "Mass", transFatContent: "Mass", fiberContent: "Mass", calories: "Energy", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/QuantitativeValue
 *  A point value or interval for product characteristics and other purposes.
 * 
 *  @author schema.org
 *  @class QuantitativeValue
 *  @module org.schema
 *  @extends StructuredValue
 */
var QuantitativeValue = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    StructuredValue.call(this);
    this.context = "http://schema.org/";
    this.type = "QuantitativeValue";
};
QuantitativeValue = stjs.extend(QuantitativeValue, StructuredValue, [], function(constructor, prototype) {
    /**
     *  Schema.org/unitCode
     *  The unit of measurement given using the UN/CEFACT Common Code (3 characters) or a URL. Other codes than the UN/CEFACT Common Code may be used with a prefix followed by a colon.
     * 
     *  @property unitCode
     *  @type Text
     */
    prototype.unitCode = null;
    /**
     *  Schema.org/minValue
     *  The lower value of some characteristic or property.
     * 
     *  @property minValue
     *  @type Number
     */
    prototype.minValue = null;
    /**
     *  Schema.org/value
     *  The value of the quantitative value or property value node.\n\n* For [[QuantitativeValue]] and [[MonetaryAmount]], the recommended type for values is 'Number'.\n* For [[PropertyValue]], it can be 'Text;', 'Number', 'Boolean', or 'StructuredValue'.
     * 
     *  @property value
     *  @type StructuredValue
     */
    prototype.value = null;
    /**
     *  Schema.org/additionalProperty
     *  A property-value pair representing an additional characteristics of the entitity, e.g. a product feature or another characteristic for which there is no matching property in schema.org.\n\nNote: Publishers should be aware that applications designed to use specific schema.org properties (e.g. schema:width, schema:color, schema:gtin13, ...) will typically expect such data to be provided using those properties, rather than using the generic property/value mechanism.
     * 
     *  @property additionalProperty
     *  @type PropertyValue
     */
    prototype.additionalProperty = null;
    /**
     *  Schema.org/valueReference
     *  A pointer to a secondary value that provides additional information on the original value, e.g. a reference temperature.
     * 
     *  @property valueReference
     *  @type StructuredValue
     */
    prototype.valueReference = null;
    /**
     *  Schema.org/maxValue
     *  The upper value of some characteristic or property.
     * 
     *  @property maxValue
     *  @type Number
     */
    prototype.maxValue = null;
    /**
     *  Schema.org/unitText
     *  A string or text indicating the unit of measurement. Useful if you cannot provide a standard unit code for
     *  <a href='unitCode'>unitCode</a>.
     * 
     *  @property unitText
     *  @type Text
     */
    prototype.unitText = null;
}, {value: "StructuredValue", additionalProperty: "PropertyValue", valueReference: "StructuredValue", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/WarrantyPromise
 *  A structured value representing the duration and scope of services that will be provided to a customer free of charge in case of a defect or malfunction of a product.
 * 
 *  @author schema.org
 *  @class WarrantyPromise
 *  @module org.schema
 *  @extends StructuredValue
 */
var WarrantyPromise = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    StructuredValue.call(this);
    this.context = "http://schema.org/";
    this.type = "WarrantyPromise";
};
WarrantyPromise = stjs.extend(WarrantyPromise, StructuredValue, [], function(constructor, prototype) {
    /**
     *  Schema.org/durationOfWarranty
     *  The duration of the warranty promise. Common unitCode values are ANN for year, MON for months, or DAY for days.
     * 
     *  @property durationOfWarranty
     *  @type QuantitativeValue
     */
    prototype.durationOfWarranty = null;
    /**
     *  Schema.org/warrantyScope
     *  The scope of the warranty promise.
     * 
     *  @property warrantyScope
     *  @type WarrantyScope
     */
    prototype.warrantyScope = null;
}, {durationOfWarranty: "QuantitativeValue", warrantyScope: "WarrantyScope", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/InteractionCounter
 *  A summary of how users have interacted with this CreativeWork. In most cases, authors will use a subtype to specify the specific type of interaction.
 * 
 *  @author schema.org
 *  @class InteractionCounter
 *  @module org.schema
 *  @extends StructuredValue
 */
var InteractionCounter = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    StructuredValue.call(this);
    this.context = "http://schema.org/";
    this.type = "InteractionCounter";
};
InteractionCounter = stjs.extend(InteractionCounter, StructuredValue, [], function(constructor, prototype) {
    /**
     *  Schema.org/interactionService
     *  The WebSite or SoftwareApplication where the interactions took place.
     * 
     *  @property interactionService
     *  @type SoftwareApplication
     */
    prototype.interactionService = null;
    /**
     *  Schema.org/userInteractionCount
     *  The number of interactions for the CreativeWork using the WebSite or SoftwareApplication.
     * 
     *  @property userInteractionCount
     *  @type Integer
     */
    prototype.userInteractionCount = null;
    /**
     *  Schema.org/interactionType
     *  The Action representing the type of interaction. For up votes, +1s, etc. use [[LikeAction]]. For down votes use [[DislikeAction]]. Otherwise, use the most specific Action.
     * 
     *  @property interactionType
     *  @type Action
     */
    prototype.interactionType = null;
}, {interactionService: "SoftwareApplication", interactionType: "Action", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/OwnershipInfo
 *  A structured value providing information about when a certain organization or person owned a certain product.
 * 
 *  @author schema.org
 *  @class OwnershipInfo
 *  @module org.schema
 *  @extends StructuredValue
 */
var OwnershipInfo = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    StructuredValue.call(this);
    this.context = "http://schema.org/";
    this.type = "OwnershipInfo";
};
OwnershipInfo = stjs.extend(OwnershipInfo, StructuredValue, [], function(constructor, prototype) {
    /**
     *  Schema.org/typeOfGood
     *  The product that this structured value is referring to.
     * 
     *  @property typeOfGood
     *  @type Service
     */
    prototype.typeOfGood = null;
    /**
     *  Schema.org/ownedFrom
     *  The date and time of obtaining the product.
     * 
     *  @property ownedFrom
     *  @type DateTime
     */
    prototype.ownedFrom = null;
    /**
     *  Schema.org/ownedThrough
     *  The date and time of giving up ownership on the product.
     * 
     *  @property ownedThrough
     *  @type DateTime
     */
    prototype.ownedThrough = null;
    /**
     *  Schema.org/acquiredFrom
     *  The organization or person from which the product was acquired.
     * 
     *  @property acquiredFrom
     *  @type Person
     */
    prototype.acquiredFrom = null;
}, {typeOfGood: "Service", acquiredFrom: "Person", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/PriceSpecification
 *  A structured value representing a price or price range. Typically, only the subclasses of this type are used for markup. It is recommended to use [[MonetaryAmount]] to describe independent amounts of money such as a salary, credit card limits, etc.
 * 
 *  @author schema.org
 *  @class PriceSpecification
 *  @module org.schema
 *  @extends StructuredValue
 */
var PriceSpecification = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    StructuredValue.call(this);
    this.context = "http://schema.org/";
    this.type = "PriceSpecification";
};
PriceSpecification = stjs.extend(PriceSpecification, StructuredValue, [], function(constructor, prototype) {
    /**
     *  Schema.org/minPrice
     *  The lowest price if the price is a range.
     * 
     *  @property minPrice
     *  @type Number
     */
    prototype.minPrice = null;
    /**
     *  Schema.org/eligibleTransactionVolume
     *  The transaction volume, in a monetary unit, for which the offer or price specification is valid, e.g. for indicating a minimal purchasing volume, to express free shipping above a certain order volume, or to limit the acceptance of credit cards to purchases to a certain minimal amount.
     * 
     *  @property eligibleTransactionVolume
     *  @type PriceSpecification
     */
    prototype.eligibleTransactionVolume = null;
    /**
     *  Schema.org/maxPrice
     *  The highest price if the price is a range.
     * 
     *  @property maxPrice
     *  @type Number
     */
    prototype.maxPrice = null;
    /**
     *  Schema.org/priceCurrency
     *  The currency (in 3-letter ISO 4217 format) of the price or a price component, when attached to [[PriceSpecification]] and its subtypes.
     * 
     *  @property priceCurrency
     *  @type Text
     */
    prototype.priceCurrency = null;
    /**
     *  Schema.org/eligibleQuantity
     *  The interval and unit of measurement of ordering quantities for which the offer or price specification is valid. This allows e.g. specifying that a certain freight charge is valid only for a certain quantity.
     * 
     *  @property eligibleQuantity
     *  @type QuantitativeValue
     */
    prototype.eligibleQuantity = null;
    /**
     *  Schema.org/validFrom
     *  The date when the item becomes valid.
     * 
     *  @property validFrom
     *  @type DateTime
     */
    prototype.validFrom = null;
    /**
     *  Schema.org/validThrough
     *  The date after when the item is not valid. For example the end of an offer, salary period, or a period of opening hours.
     * 
     *  @property validThrough
     *  @type DateTime
     */
    prototype.validThrough = null;
    /**
     *  Schema.org/price
     *  The offer price of a product, or of a price component when attached to PriceSpecification and its subtypes.\n\nUsage guidelines:\n\n* Use the [[priceCurrency]] property (with [ISO 4217 codes](http://en.wikipedia.org/wiki/ISO_4217#Active_codes) e.g. "USD") instead of
     *  including [ambiguous symbols](http://en.wikipedia.org/wiki/Dollar_sign#Currencies_that_use_the_dollar_or_peso_sign) such as '

var decls = "";

for (var j = 0; j < results.length; j++)
	for (var i = 0; i < results[j].body.length; i++)
		if (results[j].body[i].declarations != null)
			decls += "\nglobal." + results[j].body[i].declarations[0].id.name + " = " + results[j].body[i].declarations[0].id.name;

eval(decls);

global.forge = forge;
global.FormData = FormData;
global.antlr4 = antlr4;
global.pemJwk = pemJwk;
global.stjs = stjs;
global.base64 = base64;
global.jsonld = require('jsonld');
global.UUID = require('pure-uuid'); in the value.\n* Use '.' (Unicode 'FULL STOP' (U+002E)) rather than ',' to indicate a decimal point. Avoid using these symbols as a readability separator.\n* Note that both [RDFa](http://www.w3.org/TR/xhtml-rdfa-primer/#using-the-content-attribute) and Microdata syntax allow the use of a "content=" attribute for publishing simple machine-readable values alongside more human-friendly formatting.\n* Use values from 0123456789 (Unicode 'DIGIT ZERO' (U+0030) to 'DIGIT NINE' (U+0039)) rather than superficially similiar Unicode symbols.
     * 
     *  @property price
     *  @type Number
     */
    prototype.price = null;
    /**
     *  Schema.org/valueAddedTaxIncluded
     *  Specifies whether the applicable value-added tax (VAT) is included in the price specification or not.
     * 
     *  @property valueAddedTaxIncluded
     *  @type Boolean
     */
    prototype.valueAddedTaxIncluded = null;
}, {eligibleTransactionVolume: "PriceSpecification", eligibleQuantity: "QuantitativeValue", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/GeoShape
 *  The geographic shape of a place. A GeoShape can be described using several properties whose values are based on latitude/longitude pairs. Either whitespace or commas can be used to separate latitude and longitude; whitespace should be used when writing a list of several such points.
 * 
 *  @author schema.org
 *  @class GeoShape
 *  @module org.schema
 *  @extends StructuredValue
 */
var GeoShape = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    StructuredValue.call(this);
    this.context = "http://schema.org/";
    this.type = "GeoShape";
};
GeoShape = stjs.extend(GeoShape, StructuredValue, [], function(constructor, prototype) {
    /**
     *  Schema.org/address
     *  Physical address of the item.
     * 
     *  @property address
     *  @type PostalAddress
     */
    prototype.address = null;
    /**
     *  Schema.org/circle
     *  A circle is the circular region of a specified radius centered at a specified latitude and longitude. A circle is expressed as a pair followed by a radius in meters.
     * 
     *  @property circle
     *  @type Text
     */
    prototype.circle = null;
    /**
     *  Schema.org/box
     *  A box is the area enclosed by the rectangle formed by two points. The first point is the lower corner, the second point is the upper corner. A box is expressed as two points separated by a space character.
     * 
     *  @property box
     *  @type Text
     */
    prototype.box = null;
    /**
     *  Schema.org/addressCountry
     *  The country. For example, USA. You can also provide the two-letter [ISO 3166-1 alpha-2 country code](http://en.wikipedia.org/wiki/ISO_3166-1).
     * 
     *  @property addressCountry
     *  @type Text
     */
    prototype.addressCountry = null;
    /**
     *  Schema.org/postalCode
     *  The postal code. For example, 94043.
     * 
     *  @property postalCode
     *  @type Text
     */
    prototype.postalCode = null;
    /**
     *  Schema.org/elevation
     *  The elevation of a location ([WGS 84](https://en.wikipedia.org/wiki/World_Geodetic_System)).
     * 
     *  @property elevation
     *  @type Text
     */
    prototype.elevation = null;
    /**
     *  Schema.org/polygon
     *  A polygon is the area enclosed by a point-to-point path for which the starting and ending points are the same. A polygon is expressed as a series of four or more space delimited points where the first and final points are identical.
     * 
     *  @property polygon
     *  @type Text
     */
    prototype.polygon = null;
    /**
     *  Schema.org/line
     *  A line is a point-to-point path consisting of two or more points. A line is expressed as a series of two or more point objects separated by space.
     * 
     *  @property line
     *  @type Text
     */
    prototype.line = null;
}, {address: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/OpeningHoursSpecification
 *  A structured value providing information about the opening hours of a place or a certain service inside a place.\n\n
 *  The place is __open__ if the [[opens]] property is specified, and __closed__ otherwise.\n\nIf the value for the [[closes]] property is less than the value for the [[opens]] property then the hour range is assumed to span over the next day.
 * 
 *  @author schema.org
 *  @class OpeningHoursSpecification
 *  @module org.schema
 *  @extends StructuredValue
 */
var OpeningHoursSpecification = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    StructuredValue.call(this);
    this.context = "http://schema.org/";
    this.type = "OpeningHoursSpecification";
};
OpeningHoursSpecification = stjs.extend(OpeningHoursSpecification, StructuredValue, [], function(constructor, prototype) {
    /**
     *  Schema.org/validFrom
     *  The date when the item becomes valid.
     * 
     *  @property validFrom
     *  @type DateTime
     */
    prototype.validFrom = null;
    /**
     *  Schema.org/validThrough
     *  The date after when the item is not valid. For example the end of an offer, salary period, or a period of opening hours.
     * 
     *  @property validThrough
     *  @type DateTime
     */
    prototype.validThrough = null;
    /**
     *  Schema.org/opens
     *  The opening hour of the place or service on the given day(s) of the week.
     * 
     *  @property opens
     *  @type Time
     */
    prototype.opens = null;
    /**
     *  Schema.org/closes
     *  The closing hour of the place or service on the given day(s) of the week.
     * 
     *  @property closes
     *  @type Time
     */
    prototype.closes = null;
    /**
     *  Schema.org/dayOfWeek
     *  The day of the week for which these opening hours are valid.
     * 
     *  @property dayOfWeek
     *  @type DayOfWeek
     */
    prototype.dayOfWeek = null;
}, {dayOfWeek: "DayOfWeek", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/DatedMoneySpecification
 *  A DatedMoneySpecification represents monetary values with optional start and end dates. For example, this could represent an employee's salary over a specific period of time. __Note:__ This type has been superseded by [[MonetaryAmount]] use of that type is recommended
 * 
 *  @author schema.org
 *  @class DatedMoneySpecification
 *  @module org.schema
 *  @extends StructuredValue
 */
var DatedMoneySpecification = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    StructuredValue.call(this);
    this.context = "http://schema.org/";
    this.type = "DatedMoneySpecification";
};
DatedMoneySpecification = stjs.extend(DatedMoneySpecification, StructuredValue, [], function(constructor, prototype) {
    /**
     *  Schema.org/endDate
     *  The end date and time of the item (in [ISO 8601 date format](http://en.wikipedia.org/wiki/ISO_8601)).
     * 
     *  @property endDate
     *  @type DateTime
     */
    prototype.endDate = null;
    /**
     *  Schema.org/amount
     *  The amount of money.
     * 
     *  @property amount
     *  @type Number
     */
    prototype.amount = null;
    /**
     *  Schema.org/startDate
     *  The start date and time of the item (in [ISO 8601 date format](http://en.wikipedia.org/wiki/ISO_8601)).
     * 
     *  @property startDate
     *  @type Date
     */
    prototype.startDate = null;
    /**
     *  Schema.org/currency
     *  The currency in which the monetary amount is expressed (in 3-letter [ISO 4217](http://en.wikipedia.org/wiki/ISO_4217) format).
     * 
     *  @property currency
     *  @type Text
     */
    prototype.currency = null;
}, {identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/ContactPoint
 *  A contact point&#x2014;for example, a Customer Complaints department.
 * 
 *  @author schema.org
 *  @class ContactPoint
 *  @module org.schema
 *  @extends StructuredValue
 */
var ContactPoint = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    StructuredValue.call(this);
    this.context = "http://schema.org/";
    this.type = "ContactPoint";
};
ContactPoint = stjs.extend(ContactPoint, StructuredValue, [], function(constructor, prototype) {
    /**
     *  Schema.org/serviceArea
     *  The geographic area where the service is provided.
     * 
     *  @property serviceArea
     *  @type GeoShape
     */
    prototype.serviceArea = null;
    /**
     *  Schema.org/hoursAvailable
     *  The hours during which this service or contact is available.
     * 
     *  @property hoursAvailable
     *  @type OpeningHoursSpecification
     */
    prototype.hoursAvailable = null;
    /**
     *  Schema.org/contactOption
     *  An option available on this contact point (e.g. a toll-free number or support for hearing-impaired callers).
     * 
     *  @property contactOption
     *  @type ContactPointOption
     */
    prototype.contactOption = null;
    /**
     *  Schema.org/availableLanguage
     *  A language someone may use with the item. Please use one of the language codes from the [IETF BCP 47 standard](http://tools.ietf.org/html/bcp47). See also [[inLanguage]]
     * 
     *  @property availableLanguage
     *  @type Language
     */
    prototype.availableLanguage = null;
    /**
     *  Schema.org/telephone
     *  The telephone number.
     * 
     *  @property telephone
     *  @type Text
     */
    prototype.telephone = null;
    /**
     *  Schema.org/email
     *  Email address.
     * 
     *  @property email
     *  @type Text
     */
    prototype.email = null;
    /**
     *  Schema.org/contactType
     *  A person or organization can have different contact points, for different purposes. For example, a sales contact point, a PR contact point and so on. This property is used to specify the kind of contact point.
     * 
     *  @property contactType
     *  @type Text
     */
    prototype.contactType = null;
    /**
     *  Schema.org/productSupported
     *  The product or service this support contact point is related to (such as product support for a particular product line). This can be a specific product or product line (e.g. "iPhone") or a general category of products or services (e.g. "smartphones").
     * 
     *  @property productSupported
     *  @type Text
     */
    prototype.productSupported = null;
    /**
     *  Schema.org/faxNumber
     *  The fax number.
     * 
     *  @property faxNumber
     *  @type Text
     */
    prototype.faxNumber = null;
    /**
     *  Schema.org/areaServed
     *  The geographic area where a service or offered item is provided.
     * 
     *  @property areaServed
     *  @type Place
     */
    prototype.areaServed = null;
}, {serviceArea: "GeoShape", hoursAvailable: "OpeningHoursSpecification", contactOption: "ContactPointOption", availableLanguage: "Language", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/MonetaryAmount
 *  A monetary value or range. This type can be used to describe an amount of money such as $50 USD, or a range as in describing a bank account being suitable for a balance between £1,000 and £1,000,000 GBP, or the value of a salary, etc. It is recommended to use [[PriceSpecification]] Types to describe the price of an Offer, Invoice, etc.
 * 
 *  @author schema.org
 *  @class MonetaryAmount
 *  @module org.schema
 *  @extends StructuredValue
 */
var MonetaryAmount = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    StructuredValue.call(this);
    this.context = "http://schema.org/";
    this.type = "MonetaryAmount";
};
MonetaryAmount = stjs.extend(MonetaryAmount, StructuredValue, [], function(constructor, prototype) {
    /**
     *  Schema.org/minValue
     *  The lower value of some characteristic or property.
     * 
     *  @property minValue
     *  @type Number
     */
    prototype.minValue = null;
    /**
     *  Schema.org/value
     *  The value of the quantitative value or property value node.\n\n* For [[QuantitativeValue]] and [[MonetaryAmount]], the recommended type for values is 'Number'.\n* For [[PropertyValue]], it can be 'Text;', 'Number', 'Boolean', or 'StructuredValue'.
     * 
     *  @property value
     *  @type StructuredValue
     */
    prototype.value = null;
    /**
     *  Schema.org/validFrom
     *  The date when the item becomes valid.
     * 
     *  @property validFrom
     *  @type DateTime
     */
    prototype.validFrom = null;
    /**
     *  Schema.org/validThrough
     *  The date after when the item is not valid. For example the end of an offer, salary period, or a period of opening hours.
     * 
     *  @property validThrough
     *  @type DateTime
     */
    prototype.validThrough = null;
    /**
     *  Schema.org/maxValue
     *  The upper value of some characteristic or property.
     * 
     *  @property maxValue
     *  @type Number
     */
    prototype.maxValue = null;
    /**
     *  Schema.org/currency
     *  The currency in which the monetary amount is expressed (in 3-letter [ISO 4217](http://en.wikipedia.org/wiki/ISO_4217) format).
     * 
     *  @property currency
     *  @type Text
     */
    prototype.currency = null;
}, {value: "StructuredValue", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/TypeAndQuantityNode
 *  A structured value indicating the quantity, unit of measurement, and business function of goods included in a bundle offer.
 * 
 *  @author schema.org
 *  @class TypeAndQuantityNode
 *  @module org.schema
 *  @extends StructuredValue
 */
var TypeAndQuantityNode = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    StructuredValue.call(this);
    this.context = "http://schema.org/";
    this.type = "TypeAndQuantityNode";
};
TypeAndQuantityNode = stjs.extend(TypeAndQuantityNode, StructuredValue, [], function(constructor, prototype) {
    /**
     *  Schema.org/unitCode
     *  The unit of measurement given using the UN/CEFACT Common Code (3 characters) or a URL. Other codes than the UN/CEFACT Common Code may be used with a prefix followed by a colon.
     * 
     *  @property unitCode
     *  @type Text
     */
    prototype.unitCode = null;
    /**
     *  Schema.org/typeOfGood
     *  The product that this structured value is referring to.
     * 
     *  @property typeOfGood
     *  @type Service
     */
    prototype.typeOfGood = null;
    /**
     *  Schema.org/amountOfThisGood
     *  The quantity of the goods included in the offer.
     * 
     *  @property amountOfThisGood
     *  @type Number
     */
    prototype.amountOfThisGood = null;
    /**
     *  Schema.org/unitText
     *  A string or text indicating the unit of measurement. Useful if you cannot provide a standard unit code for
     *  <a href='unitCode'>unitCode</a>.
     * 
     *  @property unitText
     *  @type Text
     */
    prototype.unitText = null;
    /**
     *  Schema.org/businessFunction
     *  The business function (e.g. sell, lease, repair, dispose) of the offer or component of a bundle (TypeAndQuantityNode). The default is http://purl.org/goodrelations/v1#Sell.
     * 
     *  @property businessFunction
     *  @type BusinessFunction
     */
    prototype.businessFunction = null;
}, {typeOfGood: "Service", businessFunction: "BusinessFunction", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/EngineSpecification
 *  Information about the engine of the vehicle. A vehicle can have multiple engines represented by multiple engine specification entities.
 * 
 *  @author schema.org
 *  @class EngineSpecification
 *  @module org.schema
 *  @extends StructuredValue
 */
var EngineSpecification = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    StructuredValue.call(this);
    this.context = "http://schema.org/";
    this.type = "EngineSpecification";
};
EngineSpecification = stjs.extend(EngineSpecification, StructuredValue, [], function(constructor, prototype) {
    /**
     *  Schema.org/fuelType
     *  The type of fuel suitable for the engine or engines of the vehicle. If the vehicle has only one engine, this property can be attached directly to the vehicle.
     * 
     *  @property fuelType
     *  @type Text
     */
    prototype.fuelType = null;
}, {identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/AggregateRating
 *  The average rating based on multiple ratings or reviews.
 * 
 *  @author schema.org
 *  @class AggregateRating
 *  @module org.schema
 *  @extends Rating
 */
var AggregateRating = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Rating.call(this);
    this.context = "http://schema.org/";
    this.type = "AggregateRating";
};
AggregateRating = stjs.extend(AggregateRating, Rating, [], function(constructor, prototype) {
    /**
     *  Schema.org/itemReviewed
     *  The item that is being reviewed/rated.
     * 
     *  @property itemReviewed
     *  @type Thing
     */
    prototype.itemReviewed = null;
    /**
     *  Schema.org/reviewCount
     *  The count of total number of reviews.
     * 
     *  @property reviewCount
     *  @type Integer
     */
    prototype.reviewCount = null;
    /**
     *  Schema.org/ratingCount
     *  The count of total number of ratings.
     * 
     *  @property ratingCount
     *  @type Integer
     */
    prototype.ratingCount = null;
}, {itemReviewed: "Thing", author: "Person", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/BusinessAudience
 *  A set of characteristics belonging to businesses, e.g. who compose an item's target audience.
 * 
 *  @author schema.org
 *  @class BusinessAudience
 *  @module org.schema
 *  @extends Audience
 */
var BusinessAudience = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Audience.call(this);
    this.context = "http://schema.org/";
    this.type = "BusinessAudience";
};
BusinessAudience = stjs.extend(BusinessAudience, Audience, [], function(constructor, prototype) {
    /**
     *  Schema.org/yearsInOperation
     *  The age of the business.
     * 
     *  @property yearsInOperation
     *  @type QuantitativeValue
     */
    prototype.yearsInOperation = null;
    /**
     *  Schema.org/yearlyRevenue
     *  The size of the business in annual revenue.
     * 
     *  @property yearlyRevenue
     *  @type QuantitativeValue
     */
    prototype.yearlyRevenue = null;
    /**
     *  Schema.org/numberOfEmployees
     *  The number of employees in an organization e.g. business.
     * 
     *  @property numberOfEmployees
     *  @type QuantitativeValue
     */
    prototype.numberOfEmployees = null;
}, {yearsInOperation: "QuantitativeValue", yearlyRevenue: "QuantitativeValue", numberOfEmployees: "QuantitativeValue", geographicArea: "AdministrativeArea", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/EducationalAudience
 *  An EducationalAudience.
 * 
 *  @author schema.org
 *  @class EducationalAudience
 *  @module org.schema
 *  @extends Audience
 */
var EducationalAudience = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Audience.call(this);
    this.context = "http://schema.org/";
    this.type = "EducationalAudience";
};
EducationalAudience = stjs.extend(EducationalAudience, Audience, [], function(constructor, prototype) {
    /**
     *  Schema.org/educationalRole
     *  An educationalRole of an EducationalAudience.
     * 
     *  @property educationalRole
     *  @type Text
     */
    prototype.educationalRole = null;
}, {geographicArea: "AdministrativeArea", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/PeopleAudience
 *  A set of characteristics belonging to people, e.g. who compose an item's target audience.
 * 
 *  @author schema.org
 *  @class PeopleAudience
 *  @module org.schema
 *  @extends Audience
 */
var PeopleAudience = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Audience.call(this);
    this.context = "http://schema.org/";
    this.type = "PeopleAudience";
};
PeopleAudience = stjs.extend(PeopleAudience, Audience, [], function(constructor, prototype) {
    /**
     *  Schema.org/suggestedMaxAge
     *  Maximal age recommended for viewing content.
     * 
     *  @property suggestedMaxAge
     *  @type Number
     */
    prototype.suggestedMaxAge = null;
    /**
     *  Schema.org/requiredMinAge
     *  Audiences defined by a person's minimum age.
     * 
     *  @property requiredMinAge
     *  @type Integer
     */
    prototype.requiredMinAge = null;
    /**
     *  Schema.org/requiredGender
     *  Audiences defined by a person's gender.
     * 
     *  @property requiredGender
     *  @type Text
     */
    prototype.requiredGender = null;
    /**
     *  Schema.org/suggestedGender
     *  The gender of the person or audience.
     * 
     *  @property suggestedGender
     *  @type Text
     */
    prototype.suggestedGender = null;
    /**
     *  Schema.org/requiredMaxAge
     *  Audiences defined by a person's maximum age.
     * 
     *  @property requiredMaxAge
     *  @type Integer
     */
    prototype.requiredMaxAge = null;
    /**
     *  Schema.org/suggestedMinAge
     *  Minimal age recommended for viewing content.
     * 
     *  @property suggestedMinAge
     *  @type Number
     */
    prototype.suggestedMinAge = null;
}, {geographicArea: "AdministrativeArea", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/OfferCatalog
 *  An OfferCatalog is an ItemList that contains related Offers and/or further OfferCatalogs that are offeredBy the same provider.
 * 
 *  @author schema.org
 *  @class OfferCatalog
 *  @module org.schema
 *  @extends ItemList
 */
var OfferCatalog = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    ItemList.call(this);
    this.context = "http://schema.org/";
    this.type = "OfferCatalog";
};
OfferCatalog = stjs.extend(OfferCatalog, ItemList, [], null, {itemListElement: "ListItem", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/BreadcrumbList
 *  A BreadcrumbList is an ItemList consisting of a chain of linked Web pages, typically described using at least their URL and their name, and typically ending with the current page.\n\nThe [[position]] property is used to reconstruct the order of the items in a BreadcrumbList The convention is that a breadcrumb list has an [[itemListOrder]] of [[ItemListOrderAscending]] (lower values listed first), and that the first items in this list correspond to the "top" or beginning of the breadcrumb trail, e.g. with a site or section homepage. The specific values of 'position' are not assigned meaning for a BreadcrumbList, but they should be integers, e.g. beginning with '1' for the first item in the list.
 * 
 *  @author schema.org
 *  @class BreadcrumbList
 *  @module org.schema
 *  @extends ItemList
 */
var BreadcrumbList = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    ItemList.call(this);
    this.context = "http://schema.org/";
    this.type = "BreadcrumbList";
};
BreadcrumbList = stjs.extend(BreadcrumbList, ItemList, [], null, {itemListElement: "ListItem", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/PerformanceRole
 *  A PerformanceRole is a Role that some entity places with regard to a theatrical performance, e.g. in a Movie, TVSeries etc.
 * 
 *  @author schema.org
 *  @class PerformanceRole
 *  @module org.schema
 *  @extends Role
 */
var PerformanceRole = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Role.call(this);
    this.context = "http://schema.org/";
    this.type = "PerformanceRole";
};
PerformanceRole = stjs.extend(PerformanceRole, Role, [], function(constructor, prototype) {
    /**
     *  Schema.org/characterName
     *  The name of a character played in some acting or performing role, i.e. in a PerformanceRole.
     * 
     *  @property characterName
     *  @type Text
     */
    prototype.characterName = null;
}, {identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/OrganizationRole
 *  A subclass of Role used to describe roles within organizations.
 * 
 *  @author schema.org
 *  @class OrganizationRole
 *  @module org.schema
 *  @extends Role
 */
var OrganizationRole = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Role.call(this);
    this.context = "http://schema.org/";
    this.type = "OrganizationRole";
};
OrganizationRole = stjs.extend(OrganizationRole, Role, [], function(constructor, prototype) {
    /**
     *  Schema.org/numberedPosition
     *  A number associated with a role in an organization, for example, the number on an athlete's jersey.
     * 
     *  @property numberedPosition
     *  @type Number
     */
    prototype.numberedPosition = null;
}, {identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/ItemListOrderType
 *  Enumerated for values for itemListOrder for indicating how an ordered ItemList is organized.
 * 
 *  @author schema.org
 *  @class ItemListOrderType
 *  @module org.schema
 *  @extends Enumeration
 */
var ItemListOrderType = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Enumeration.call(this);
    this.context = "http://schema.org/";
    this.type = "ItemListOrderType";
};
ItemListOrderType = stjs.extend(ItemListOrderType, Enumeration, [], null, {identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/DayOfWeek
 *  The day of the week, e.g. used to specify to which day the opening hours of an OpeningHoursSpecification refer.
 *  <p>
 *  Originally, URLs from [GoodRelations](http://purl.org/goodrelations/v1) were used (for [[Monday]], [[Tuesday]], [[Wednesday]], [[Thursday]], [[Friday]], [[Saturday]], [[Sunday]] plus a special entry for [[PublicHolidays]]); these have now been integrated directly into schema.org.
 * 
 *  @author schema.org
 *  @class DayOfWeek
 *  @module org.schema
 *  @extends Enumeration
 */
var DayOfWeek = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Enumeration.call(this);
    this.context = "http://schema.org/";
    this.type = "DayOfWeek";
};
DayOfWeek = stjs.extend(DayOfWeek, Enumeration, [], null, {identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/RestrictedDiet
 *  A diet restricted to certain foods or preparations for cultural, religious, health or lifestyle reasons.
 * 
 *  @author schema.org
 *  @class RestrictedDiet
 *  @module org.schema
 *  @extends Enumeration
 */
var RestrictedDiet = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Enumeration.call(this);
    this.context = "http://schema.org/";
    this.type = "RestrictedDiet";
};
RestrictedDiet = stjs.extend(RestrictedDiet, Enumeration, [], null, {identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/ReservationStatusType
 *  Enumerated status values for Reservation.
 * 
 *  @author schema.org
 *  @class ReservationStatusType
 *  @module org.schema
 *  @extends Enumeration
 */
var ReservationStatusType = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Enumeration.call(this);
    this.context = "http://schema.org/";
    this.type = "ReservationStatusType";
};
ReservationStatusType = stjs.extend(ReservationStatusType, Enumeration, [], null, {identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/PaymentStatusType
 *  A specific payment status. For example, PaymentDue, PaymentComplete, etc.
 * 
 *  @author schema.org
 *  @class PaymentStatusType
 *  @module org.schema
 *  @extends Enumeration
 */
var PaymentStatusType = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Enumeration.call(this);
    this.context = "http://schema.org/";
    this.type = "PaymentStatusType";
};
PaymentStatusType = stjs.extend(PaymentStatusType, Enumeration, [], null, {identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/ActionStatusType
 *  The status of an Action.
 * 
 *  @author schema.org
 *  @class ActionStatusType
 *  @module org.schema
 *  @extends Enumeration
 */
var ActionStatusType = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Enumeration.call(this);
    this.context = "http://schema.org/";
    this.type = "ActionStatusType";
};
ActionStatusType = stjs.extend(ActionStatusType, Enumeration, [], null, {identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/MapCategoryType
 *  An enumeration of several kinds of Map.
 * 
 *  @author schema.org
 *  @class MapCategoryType
 *  @module org.schema
 *  @extends Enumeration
 */
var MapCategoryType = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Enumeration.call(this);
    this.context = "http://schema.org/";
    this.type = "MapCategoryType";
};
MapCategoryType = stjs.extend(MapCategoryType, Enumeration, [], null, {identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/GenderType
 *  An enumeration of genders.
 * 
 *  @author schema.org
 *  @class GenderType
 *  @module org.schema
 *  @extends Enumeration
 */
var GenderType = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Enumeration.call(this);
    this.context = "http://schema.org/";
    this.type = "GenderType";
};
GenderType = stjs.extend(GenderType, Enumeration, [], null, {identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/BusinessFunction
 *  The business function specifies the type of activity or access (i.e., the bundle of rights) offered by the organization or business person through the offer. Typical are sell, rental or lease, maintenance or repair, manufacture / produce, recycle / dispose, engineering / construction, or installation. Proprietary specifications of access rights are also instances of this class.\n\nCommonly used values:\n\n* http://purl.org/goodrelations/v1#ConstructionInstallation\n* http://purl.org/goodrelations/v1#Dispose\n* http://purl.org/goodrelations/v1#LeaseOut\n* http://purl.org/goodrelations/v1#Maintain\n* http://purl.org/goodrelations/v1#ProvideService\n* http://purl.org/goodrelations/v1#Repair\n* http://purl.org/goodrelations/v1#Sell\n* http://purl.org/goodrelations/v1#Buy
 * 
 *  @author schema.org
 *  @class BusinessFunction
 *  @module org.schema
 *  @extends Enumeration
 */
var BusinessFunction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Enumeration.call(this);
    this.context = "http://schema.org/";
    this.type = "BusinessFunction";
};
BusinessFunction = stjs.extend(BusinessFunction, Enumeration, [], null, {identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/PaymentMethod
 *  A payment method is a standardized procedure for transferring the monetary amount for a purchase. Payment methods are characterized by the legal and technical structures used, and by the organization or group carrying out the transaction.\n\nCommonly used values:\n\n* http://purl.org/goodrelations/v1#ByBankTransferInAdvance\n* http://purl.org/goodrelations/v1#ByInvoice\n* http://purl.org/goodrelations/v1#Cash\n* http://purl.org/goodrelations/v1#CheckInAdvance\n* http://purl.org/goodrelations/v1#COD\n* http://purl.org/goodrelations/v1#DirectDebit\n* http://purl.org/goodrelations/v1#GoogleCheckout\n* http://purl.org/goodrelations/v1#PayPal\n* http://purl.org/goodrelations/v1#PaySwarm
 * 
 *  @author schema.org
 *  @class PaymentMethod
 *  @module org.schema
 *  @extends Enumeration
 */
var PaymentMethod = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Enumeration.call(this);
    this.context = "http://schema.org/";
    this.type = "PaymentMethod";
};
PaymentMethod = stjs.extend(PaymentMethod, Enumeration, [], null, {identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/MusicAlbumProductionType
 *  Classification of the album by it's type of content: soundtrack, live album, studio album, etc.
 * 
 *  @author schema.org
 *  @class MusicAlbumProductionType
 *  @module org.schema
 *  @extends Enumeration
 */
var MusicAlbumProductionType = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Enumeration.call(this);
    this.context = "http://schema.org/";
    this.type = "MusicAlbumProductionType";
};
MusicAlbumProductionType = stjs.extend(MusicAlbumProductionType, Enumeration, [], null, {identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/ItemAvailability
 *  A list of possible product availability options.
 * 
 *  @author schema.org
 *  @class ItemAvailability
 *  @module org.schema
 *  @extends Enumeration
 */
var ItemAvailability = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Enumeration.call(this);
    this.context = "http://schema.org/";
    this.type = "ItemAvailability";
};
ItemAvailability = stjs.extend(ItemAvailability, Enumeration, [], null, {identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/OrderStatus
 *  Enumerated status values for Order.
 * 
 *  @author schema.org
 *  @class OrderStatus
 *  @module org.schema
 *  @extends Enumeration
 */
var OrderStatus = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Enumeration.call(this);
    this.context = "http://schema.org/";
    this.type = "OrderStatus";
};
OrderStatus = stjs.extend(OrderStatus, Enumeration, [], null, {identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/RsvpResponseType
 *  RsvpResponseType is an enumeration type whose instances represent responding to an RSVP request.
 * 
 *  @author schema.org
 *  @class RsvpResponseType
 *  @module org.schema
 *  @extends Enumeration
 */
var RsvpResponseType = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Enumeration.call(this);
    this.context = "http://schema.org/";
    this.type = "RsvpResponseType";
};
RsvpResponseType = stjs.extend(RsvpResponseType, Enumeration, [], null, {identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/EventStatusType
 *  EventStatusType is an enumeration type whose instances represent several states that an SchemaEvent may be in.
 * 
 *  @author schema.org
 *  @class EventStatusType
 *  @module org.schema
 *  @extends Enumeration
 */
var EventStatusType = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Enumeration.call(this);
    this.context = "http://schema.org/";
    this.type = "EventStatusType";
};
EventStatusType = stjs.extend(EventStatusType, Enumeration, [], null, {identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/ContactPointOption
 *  Enumerated options related to a ContactPoint.
 * 
 *  @author schema.org
 *  @class ContactPointOption
 *  @module org.schema
 *  @extends Enumeration
 */
var ContactPointOption = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Enumeration.call(this);
    this.context = "http://schema.org/";
    this.type = "ContactPointOption";
};
ContactPointOption = stjs.extend(ContactPointOption, Enumeration, [], null, {identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Specialty
 *  Any branch of a field in which people typically develop specific expertise, usually after significant study, time, and effort.
 * 
 *  @author schema.org
 *  @class Specialty
 *  @module org.schema
 *  @extends Enumeration
 */
var Specialty = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Enumeration.call(this);
    this.context = "http://schema.org/";
    this.type = "Specialty";
};
Specialty = stjs.extend(Specialty, Enumeration, [], null, {identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/MusicReleaseFormatType
 *  Format of this release (the type of recording media used, ie. compact disc, digital media, LP, etc.).
 * 
 *  @author schema.org
 *  @class MusicReleaseFormatType
 *  @module org.schema
 *  @extends Enumeration
 */
var MusicReleaseFormatType = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Enumeration.call(this);
    this.context = "http://schema.org/";
    this.type = "MusicReleaseFormatType";
};
MusicReleaseFormatType = stjs.extend(MusicReleaseFormatType, Enumeration, [], null, {identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/DeliveryMethod
 *  A delivery method is a standardized procedure for transferring the product or service to the destination of fulfillment chosen by the customer. Delivery methods are characterized by the means of transportation used, and by the organization or group that is the contracting party for the sending organization or person.\n\nCommonly used values:\n\n* http://purl.org/goodrelations/v1#DeliveryModeDirectDownload\n* http://purl.org/goodrelations/v1#DeliveryModeFreight\n* http://purl.org/goodrelations/v1#DeliveryModeMail\n* http://purl.org/goodrelations/v1#DeliveryModeOwnFleet\n* http://purl.org/goodrelations/v1#DeliveryModePickUp\n* http://purl.org/goodrelations/v1#DHL\n* http://purl.org/goodrelations/v1#FederalExpress\n* http://purl.org/goodrelations/v1#UPS
 * 
 *  @author schema.org
 *  @class DeliveryMethod
 *  @module org.schema
 *  @extends Enumeration
 */
var DeliveryMethod = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Enumeration.call(this);
    this.context = "http://schema.org/";
    this.type = "DeliveryMethod";
};
DeliveryMethod = stjs.extend(DeliveryMethod, Enumeration, [], null, {identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/MusicAlbumReleaseType
 *  The kind of release which this album is: single, EP or album.
 * 
 *  @author schema.org
 *  @class MusicAlbumReleaseType
 *  @module org.schema
 *  @extends Enumeration
 */
var MusicAlbumReleaseType = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Enumeration.call(this);
    this.context = "http://schema.org/";
    this.type = "MusicAlbumReleaseType";
};
MusicAlbumReleaseType = stjs.extend(MusicAlbumReleaseType, Enumeration, [], null, {identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/WarrantyScope
 *  A range of of services that will be provided to a customer free of charge in case of a defect or malfunction of a product.\n\nCommonly used values:\n\n* http://purl.org/goodrelations/v1#Labor-BringIn\n* http://purl.org/goodrelations/v1#PartsAndLabor-BringIn\n* http://purl.org/goodrelations/v1#PartsAndLabor-PickUp
 * 
 *  @author schema.org
 *  @class WarrantyScope
 *  @module org.schema
 *  @extends Enumeration
 */
var WarrantyScope = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Enumeration.call(this);
    this.context = "http://schema.org/";
    this.type = "WarrantyScope";
};
WarrantyScope = stjs.extend(WarrantyScope, Enumeration, [], null, {identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/DigitalDocumentPermissionType
 *  A type of permission which can be granted for accessing a digital document.
 * 
 *  @author schema.org
 *  @class DigitalDocumentPermissionType
 *  @module org.schema
 *  @extends Enumeration
 */
var DigitalDocumentPermissionType = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Enumeration.call(this);
    this.context = "http://schema.org/";
    this.type = "DigitalDocumentPermissionType";
};
DigitalDocumentPermissionType = stjs.extend(DigitalDocumentPermissionType, Enumeration, [], null, {identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/OfferItemCondition
 *  A list of possible conditions for the item.
 * 
 *  @author schema.org
 *  @class OfferItemCondition
 *  @module org.schema
 *  @extends Enumeration
 */
var OfferItemCondition = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Enumeration.call(this);
    this.context = "http://schema.org/";
    this.type = "OfferItemCondition";
};
OfferItemCondition = stjs.extend(OfferItemCondition, Enumeration, [], null, {identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/GameServerStatus
 *  Status of a game server.
 * 
 *  @author schema.org
 *  @class GameServerStatus
 *  @module org.schema
 *  @extends Enumeration
 */
var GameServerStatus = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Enumeration.call(this);
    this.context = "http://schema.org/";
    this.type = "GameServerStatus";
};
GameServerStatus = stjs.extend(GameServerStatus, Enumeration, [], null, {identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/BoardingPolicyType
 *  A type of boarding policy used by an airline.
 * 
 *  @author schema.org
 *  @class BoardingPolicyType
 *  @module org.schema
 *  @extends Enumeration
 */
var BoardingPolicyType = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Enumeration.call(this);
    this.context = "http://schema.org/";
    this.type = "BoardingPolicyType";
};
BoardingPolicyType = stjs.extend(BoardingPolicyType, Enumeration, [], null, {identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/QualitativeValue
 *  A predefined value for a product characteristic, e.g. the power cord plug type 'US' or the garment sizes 'S', 'M', 'L', and 'XL'.
 * 
 *  @author schema.org
 *  @class QualitativeValue
 *  @module org.schema
 *  @extends Enumeration
 */
var QualitativeValue = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Enumeration.call(this);
    this.context = "http://schema.org/";
    this.type = "QualitativeValue";
};
QualitativeValue = stjs.extend(QualitativeValue, Enumeration, [], function(constructor, prototype) {
    /**
     *  Schema.org/greater
     *  This ordering relation for qualitative values indicates that the subject is greater than the object.
     * 
     *  @property greater
     *  @type QualitativeValue
     */
    prototype.greater = null;
    /**
     *  Schema.org/equal
     *  This ordering relation for qualitative values indicates that the subject is equal to the object.
     * 
     *  @property equal
     *  @type QualitativeValue
     */
    prototype.equal = null;
    /**
     *  Schema.org/nonEqual
     *  This ordering relation for qualitative values indicates that the subject is not equal to the object.
     * 
     *  @property nonEqual
     *  @type QualitativeValue
     */
    prototype.nonEqual = null;
    /**
     *  Schema.org/additionalProperty
     *  A property-value pair representing an additional characteristics of the entitity, e.g. a product feature or another characteristic for which there is no matching property in schema.org.\n\nNote: Publishers should be aware that applications designed to use specific schema.org properties (e.g. schema:width, schema:color, schema:gtin13, ...) will typically expect such data to be provided using those properties, rather than using the generic property/value mechanism.
     * 
     *  @property additionalProperty
     *  @type PropertyValue
     */
    prototype.additionalProperty = null;
    /**
     *  Schema.org/lesser
     *  This ordering relation for qualitative values indicates that the subject is lesser than the object.
     * 
     *  @property lesser
     *  @type QualitativeValue
     */
    prototype.lesser = null;
    /**
     *  Schema.org/valueReference
     *  A pointer to a secondary value that provides additional information on the original value, e.g. a reference temperature.
     * 
     *  @property valueReference
     *  @type StructuredValue
     */
    prototype.valueReference = null;
    /**
     *  Schema.org/lesserOrEqual
     *  This ordering relation for qualitative values indicates that the subject is lesser than or equal to the object.
     * 
     *  @property lesserOrEqual
     *  @type QualitativeValue
     */
    prototype.lesserOrEqual = null;
    /**
     *  Schema.org/greaterOrEqual
     *  This ordering relation for qualitative values indicates that the subject is greater than or equal to the object.
     * 
     *  @property greaterOrEqual
     *  @type QualitativeValue
     */
    prototype.greaterOrEqual = null;
}, {greater: "QualitativeValue", equal: "QualitativeValue", nonEqual: "QualitativeValue", additionalProperty: "PropertyValue", lesser: "QualitativeValue", valueReference: "StructuredValue", lesserOrEqual: "QualitativeValue", greaterOrEqual: "QualitativeValue", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/BusinessEntityType
 *  A business entity type is a conceptual entity representing the legal form, the size, the main line of business, the position in the value chain, or any combination thereof, of an organization or business person.\n\nCommonly used values:\n\n* http://purl.org/goodrelations/v1#Business\n* http://purl.org/goodrelations/v1#Enduser\n* http://purl.org/goodrelations/v1#PublicInstitution\n* http://purl.org/goodrelations/v1#Reseller
 * 
 *  @author schema.org
 *  @class BusinessEntityType
 *  @module org.schema
 *  @extends Enumeration
 */
var BusinessEntityType = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Enumeration.call(this);
    this.context = "http://schema.org/";
    this.type = "BusinessEntityType";
};
BusinessEntityType = stjs.extend(BusinessEntityType, Enumeration, [], null, {identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/BookFormatType
 *  The publication format of the book.
 * 
 *  @author schema.org
 *  @class BookFormatType
 *  @module org.schema
 *  @extends Enumeration
 */
var BookFormatType = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Enumeration.call(this);
    this.context = "http://schema.org/";
    this.type = "BookFormatType";
};
BookFormatType = stjs.extend(BookFormatType, Enumeration, [], null, {identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/GamePlayMode
 *  Indicates whether this game is multi-player, co-op or single-player.
 * 
 *  @author schema.org
 *  @class GamePlayMode
 *  @module org.schema
 *  @extends Enumeration
 */
var GamePlayMode = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Enumeration.call(this);
    this.context = "http://schema.org/";
    this.type = "GamePlayMode";
};
GamePlayMode = stjs.extend(GamePlayMode, Enumeration, [], null, {identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/CableOrSatelliteService
 *  A service which provides access to media programming like TV or radio. Access may be via cable or satellite.
 * 
 *  @author schema.org
 *  @class CableOrSatelliteService
 *  @module org.schema
 *  @extends Service
 */
var CableOrSatelliteService = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Service.call(this);
    this.context = "http://schema.org/";
    this.type = "CableOrSatelliteService";
};
CableOrSatelliteService = stjs.extend(CableOrSatelliteService, Service, [], null, {serviceAudience: "Audience", serviceArea: "GeoShape", provider: "Person", audience: "Audience", hasOfferCatalog: "OfferCatalog", hoursAvailable: "OpeningHoursSpecification", aggregateRating: "AggregateRating", offers: "Offer", broker: "Person", serviceOutput: "Thing", logo: "ImageObject", isSimilarTo: "Product", isRelatedTo: "Product", availableChannel: "ServiceChannel", review: "Review", produces: "Thing", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/TaxiService
 *  A service for a vehicle for hire with a driver for local travel. Fares are usually calculated based on distance traveled.
 * 
 *  @author schema.org
 *  @class TaxiService
 *  @module org.schema
 *  @extends Service
 */
var TaxiService = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Service.call(this);
    this.context = "http://schema.org/";
    this.type = "TaxiService";
};
TaxiService = stjs.extend(TaxiService, Service, [], null, {serviceAudience: "Audience", serviceArea: "GeoShape", provider: "Person", audience: "Audience", hasOfferCatalog: "OfferCatalog", hoursAvailable: "OpeningHoursSpecification", aggregateRating: "AggregateRating", offers: "Offer", broker: "Person", serviceOutput: "Thing", logo: "ImageObject", isSimilarTo: "Product", isRelatedTo: "Product", availableChannel: "ServiceChannel", review: "Review", produces: "Thing", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/GovernmentService
 *  A service provided by a government organization, e.g. food stamps, veterans benefits, etc.
 * 
 *  @author schema.org
 *  @class GovernmentService
 *  @module org.schema
 *  @extends Service
 */
var GovernmentService = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Service.call(this);
    this.context = "http://schema.org/";
    this.type = "GovernmentService";
};
GovernmentService = stjs.extend(GovernmentService, Service, [], function(constructor, prototype) {
    /**
     *  Schema.org/serviceOperator
     *  The operating organization, if different from the provider.  This enables the representation of services that are provided by an organization, but operated by another organization like a subcontractor.
     * 
     *  @property serviceOperator
     *  @type Organization
     */
    prototype.serviceOperator = null;
}, {serviceOperator: "Organization", serviceAudience: "Audience", serviceArea: "GeoShape", provider: "Person", audience: "Audience", hasOfferCatalog: "OfferCatalog", hoursAvailable: "OpeningHoursSpecification", aggregateRating: "AggregateRating", offers: "Offer", broker: "Person", serviceOutput: "Thing", logo: "ImageObject", isSimilarTo: "Product", isRelatedTo: "Product", availableChannel: "ServiceChannel", review: "Review", produces: "Thing", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/FoodService
 *  A food service, like breakfast, lunch, or dinner.
 * 
 *  @author schema.org
 *  @class FoodService
 *  @module org.schema
 *  @extends Service
 */
var FoodService = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Service.call(this);
    this.context = "http://schema.org/";
    this.type = "FoodService";
};
FoodService = stjs.extend(FoodService, Service, [], null, {serviceAudience: "Audience", serviceArea: "GeoShape", provider: "Person", audience: "Audience", hasOfferCatalog: "OfferCatalog", hoursAvailable: "OpeningHoursSpecification", aggregateRating: "AggregateRating", offers: "Offer", broker: "Person", serviceOutput: "Thing", logo: "ImageObject", isSimilarTo: "Product", isRelatedTo: "Product", availableChannel: "ServiceChannel", review: "Review", produces: "Thing", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/BroadcastService
 *  A delivery service through which content is provided via broadcast over the air or online.
 * 
 *  @author schema.org
 *  @class BroadcastService
 *  @module org.schema
 *  @extends Service
 */
var BroadcastService = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Service.call(this);
    this.context = "http://schema.org/";
    this.type = "BroadcastService";
};
BroadcastService = stjs.extend(BroadcastService, Service, [], function(constructor, prototype) {
    /**
     *  Schema.org/broadcastTimezone
     *  The timezone in [ISO 8601 format](http://en.wikipedia.org/wiki/ISO_8601) for which the service bases its broadcasts
     * 
     *  @property broadcastTimezone
     *  @type Text
     */
    prototype.broadcastTimezone = null;
    /**
     *  Schema.org/videoFormat
     *  The type of screening or video broadcast used (e.g. IMAX, 3D, SD, HD, etc.).
     * 
     *  @property videoFormat
     *  @type Text
     */
    prototype.videoFormat = null;
    /**
     *  Schema.org/broadcastAffiliateOf
     *  The media network(s) whose content is broadcast on this station.
     * 
     *  @property broadcastAffiliateOf
     *  @type Organization
     */
    prototype.broadcastAffiliateOf = null;
    /**
     *  Schema.org/parentService
     *  A broadcast service to which the broadcast service may belong to such as regional variations of a national channel.
     * 
     *  @property parentService
     *  @type BroadcastService
     */
    prototype.parentService = null;
    /**
     *  Schema.org/broadcastDisplayName
     *  The name displayed in the channel guide. For many US affiliates, it is the network name.
     * 
     *  @property broadcastDisplayName
     *  @type Text
     */
    prototype.broadcastDisplayName = null;
    /**
     *  Schema.org/area
     *  The area within which users can expect to reach the broadcast service.
     * 
     *  @property area
     *  @type Place
     */
    prototype.area = null;
    /**
     *  Schema.org/broadcaster
     *  The organization owning or operating the broadcast service.
     * 
     *  @property broadcaster
     *  @type Organization
     */
    prototype.broadcaster = null;
}, {broadcastAffiliateOf: "Organization", parentService: "BroadcastService", area: "Place", broadcaster: "Organization", serviceAudience: "Audience", serviceArea: "GeoShape", provider: "Person", audience: "Audience", hasOfferCatalog: "OfferCatalog", hoursAvailable: "OpeningHoursSpecification", aggregateRating: "AggregateRating", offers: "Offer", broker: "Person", serviceOutput: "Thing", logo: "ImageObject", isSimilarTo: "Product", isRelatedTo: "Product", availableChannel: "ServiceChannel", review: "Review", produces: "Thing", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/FinancialProduct
 *  A product provided to consumers and businesses by financial institutions such as banks, insurance companies, brokerage firms, consumer finance companies, and investment companies which comprise the financial services industry.
 * 
 *  @author schema.org
 *  @class FinancialProduct
 *  @module org.schema
 *  @extends Service
 */
var FinancialProduct = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Service.call(this);
    this.context = "http://schema.org/";
    this.type = "FinancialProduct";
};
FinancialProduct = stjs.extend(FinancialProduct, Service, [], function(constructor, prototype) {
    /**
     *  Schema.org/annualPercentageRate
     *  The annual rate that is charged for borrowing (or made by investing), expressed as a single percentage number that represents the actual yearly cost of funds over the term of a loan. This includes any fees or additional costs associated with the transaction.
     * 
     *  @property annualPercentageRate
     *  @type Number
     */
    prototype.annualPercentageRate = null;
    /**
     *  Schema.org/interestRate
     *  The interest rate, charged or paid, applicable to the financial product. Note: This is different from the calculated annualPercentageRate.
     * 
     *  @property interestRate
     *  @type Number
     */
    prototype.interestRate = null;
    /**
     *  Schema.org/feesAndCommissionsSpecification
     *  Description of fees, commissions, and other terms applied either to a class of financial product, or by a financial service organization.
     * 
     *  @property feesAndCommissionsSpecification
     *  @type Text
     */
    prototype.feesAndCommissionsSpecification = null;
}, {serviceAudience: "Audience", serviceArea: "GeoShape", provider: "Person", audience: "Audience", hasOfferCatalog: "OfferCatalog", hoursAvailable: "OpeningHoursSpecification", aggregateRating: "AggregateRating", offers: "Offer", broker: "Person", serviceOutput: "Thing", logo: "ImageObject", isSimilarTo: "Product", isRelatedTo: "Product", availableChannel: "ServiceChannel", review: "Review", produces: "Thing", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Taxi
 *  A taxi.
 * 
 *  @author schema.org
 *  @class Taxi
 *  @module org.schema
 *  @extends Service
 */
var Taxi = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Service.call(this);
    this.context = "http://schema.org/";
    this.type = "Taxi";
};
Taxi = stjs.extend(Taxi, Service, [], null, {serviceAudience: "Audience", serviceArea: "GeoShape", provider: "Person", audience: "Audience", hasOfferCatalog: "OfferCatalog", hoursAvailable: "OpeningHoursSpecification", aggregateRating: "AggregateRating", offers: "Offer", broker: "Person", serviceOutput: "Thing", logo: "ImageObject", isSimilarTo: "Product", isRelatedTo: "Product", availableChannel: "ServiceChannel", review: "Review", produces: "Thing", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/RadioChannel
 *  A unique instance of a radio BroadcastService on a CableOrSatelliteService lineup.
 * 
 *  @author schema.org
 *  @class RadioChannel
 *  @module org.schema
 *  @extends BroadcastChannel
 */
var RadioChannel = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    BroadcastChannel.call(this);
    this.context = "http://schema.org/";
    this.type = "RadioChannel";
};
RadioChannel = stjs.extend(RadioChannel, BroadcastChannel, [], null, {inBroadcastLineup: "CableOrSatelliteService", providesBroadcastService: "BroadcastService", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/TelevisionChannel
 *  A unique instance of a television BroadcastService on a CableOrSatelliteService lineup.
 * 
 *  @author schema.org
 *  @class TelevisionChannel
 *  @module org.schema
 *  @extends BroadcastChannel
 */
var TelevisionChannel = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    BroadcastChannel.call(this);
    this.context = "http://schema.org/";
    this.type = "TelevisionChannel";
};
TelevisionChannel = stjs.extend(TelevisionChannel, BroadcastChannel, [], null, {inBroadcastLineup: "CableOrSatelliteService", providesBroadcastService: "BroadcastService", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/GovernmentPermit
 *  A permit issued by a government agency.
 * 
 *  @author schema.org
 *  @class GovernmentPermit
 *  @module org.schema
 *  @extends Permit
 */
var GovernmentPermit = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Permit.call(this);
    this.context = "http://schema.org/";
    this.type = "GovernmentPermit";
};
GovernmentPermit = stjs.extend(GovernmentPermit, Permit, [], null, {validFor: "Duration", issuedBy: "Organization", issuedThrough: "Service", permitAudience: "Audience", validIn: "AdministrativeArea", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/AggregateOffer
 *  When a single product is associated with multiple offers (for example, the same pair of shoes is offered by different merchants), then AggregateOffer can be used.
 * 
 *  @author schema.org
 *  @class AggregateOffer
 *  @module org.schema
 *  @extends Offer
 */
var AggregateOffer = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Offer.call(this);
    this.context = "http://schema.org/";
    this.type = "AggregateOffer";
};
AggregateOffer = stjs.extend(AggregateOffer, Offer, [], function(constructor, prototype) {
    /**
     *  Schema.org/offers
     *  An offer to provide this item&#x2014;for example, an offer to sell a product, rent the DVD of a movie, perform a service, or give away tickets to an event.
     * 
     *  @property offers
     *  @type Offer
     */
    prototype.offers = null;
    /**
     *  Schema.org/offerCount
     *  The number of offers for the product.
     * 
     *  @property offerCount
     *  @type Integer
     */
    prototype.offerCount = null;
    /**
     *  Schema.org/lowPrice
     *  The lowest price of all offers available.
     * 
     *  @property lowPrice
     *  @type Text
     */
    prototype.lowPrice = null;
    /**
     *  Schema.org/highPrice
     *  The highest price of all offers available.
     * 
     *  @property highPrice
     *  @type Number
     */
    prototype.highPrice = null;
}, {offers: "Offer", availableDeliveryMethod: "DeliveryMethod", ineligibleRegion: "GeoShape", reviews: "Review", availability: "ItemAvailability", priceSpecification: "PriceSpecification", inventoryLevel: "QuantitativeValue", aggregateRating: "AggregateRating", eligibleTransactionVolume: "PriceSpecification", availableAtOrFrom: "Place", addOn: "Offer", warranty: "WarrantyPromise", includesObject: "TypeAndQuantityNode", eligibleQuantity: "QuantitativeValue", seller: "Person", deliveryLeadTime: "QuantitativeValue", review: "Review", eligibleCustomerType: "BusinessEntityType", itemCondition: "OfferItemCondition", itemOffered: "Service", offeredBy: "Organization", eligibleDuration: "QuantitativeValue", acceptedPaymentMethod: "LoanOrCredit", areaServed: "Place", businessFunction: "BusinessFunction", advanceBookingRequirement: "QuantitativeValue", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/BusReservation
 *  A reservation for bus travel. \n\nNote: This type is for information about actual reservations, e.g. in confirmation emails or HTML pages with individual confirmations of reservations. For offers of tickets, use [[Offer]].
 * 
 *  @author schema.org
 *  @class BusReservation
 *  @module org.schema
 *  @extends Reservation
 */
var BusReservation = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Reservation.call(this);
    this.context = "http://schema.org/";
    this.type = "BusReservation";
};
BusReservation = stjs.extend(BusReservation, Reservation, [], null, {provider: "Person", programMembershipUsed: "ProgramMembership", reservationStatus: "ReservationStatusType", underName: "Organization", bookingAgent: "Organization", reservationFor: "Thing", broker: "Person", reservedTicket: "Ticket", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/FlightReservation
 *  A reservation for air travel.\n\nNote: This type is for information about actual reservations, e.g. in confirmation emails or HTML pages with individual confirmations of reservations. For offers of tickets, use [[Offer]].
 * 
 *  @author schema.org
 *  @class FlightReservation
 *  @module org.schema
 *  @extends Reservation
 */
var FlightReservation = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Reservation.call(this);
    this.context = "http://schema.org/";
    this.type = "FlightReservation";
};
FlightReservation = stjs.extend(FlightReservation, Reservation, [], function(constructor, prototype) {
    /**
     *  Schema.org/passengerSequenceNumber
     *  The passenger's sequence number as assigned by the airline.
     * 
     *  @property passengerSequenceNumber
     *  @type Text
     */
    prototype.passengerSequenceNumber = null;
    /**
     *  Schema.org/securityScreening
     *  The type of security screening the passenger is subject to.
     * 
     *  @property securityScreening
     *  @type Text
     */
    prototype.securityScreening = null;
    /**
     *  Schema.org/passengerPriorityStatus
     *  The priority status assigned to a passenger for security or boarding (e.g. FastTrack or Priority).
     * 
     *  @property passengerPriorityStatus
     *  @type QualitativeValue
     */
    prototype.passengerPriorityStatus = null;
    /**
     *  Schema.org/boardingGroup
     *  The airline-specific indicator of boarding order / preference.
     * 
     *  @property boardingGroup
     *  @type Text
     */
    prototype.boardingGroup = null;
}, {passengerPriorityStatus: "QualitativeValue", provider: "Person", programMembershipUsed: "ProgramMembership", reservationStatus: "ReservationStatusType", underName: "Organization", bookingAgent: "Organization", reservationFor: "Thing", broker: "Person", reservedTicket: "Ticket", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/RentalCarReservation
 *  A reservation for a rental car.\n\nNote: This type is for information about actual reservations, e.g. in confirmation emails or HTML pages with individual confirmations of reservations.
 * 
 *  @author schema.org
 *  @class RentalCarReservation
 *  @module org.schema
 *  @extends Reservation
 */
var RentalCarReservation = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Reservation.call(this);
    this.context = "http://schema.org/";
    this.type = "RentalCarReservation";
};
RentalCarReservation = stjs.extend(RentalCarReservation, Reservation, [], function(constructor, prototype) {
    /**
     *  Schema.org/pickupTime
     *  When a taxi will pickup a passenger or a rental car can be picked up.
     * 
     *  @property pickupTime
     *  @type DateTime
     */
    prototype.pickupTime = null;
    /**
     *  Schema.org/dropoffTime
     *  When a rental car can be dropped off.
     * 
     *  @property dropoffTime
     *  @type DateTime
     */
    prototype.dropoffTime = null;
    /**
     *  Schema.org/dropoffLocation
     *  Where a rental car can be dropped off.
     * 
     *  @property dropoffLocation
     *  @type Place
     */
    prototype.dropoffLocation = null;
    /**
     *  Schema.org/pickupLocation
     *  Where a taxi will pick up a passenger or a rental car can be picked up.
     * 
     *  @property pickupLocation
     *  @type Place
     */
    prototype.pickupLocation = null;
}, {dropoffLocation: "Place", pickupLocation: "Place", provider: "Person", programMembershipUsed: "ProgramMembership", reservationStatus: "ReservationStatusType", underName: "Organization", bookingAgent: "Organization", reservationFor: "Thing", broker: "Person", reservedTicket: "Ticket", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/TrainReservation
 *  A reservation for train travel.\n\nNote: This type is for information about actual reservations, e.g. in confirmation emails or HTML pages with individual confirmations of reservations. For offers of tickets, use [[Offer]].
 * 
 *  @author schema.org
 *  @class TrainReservation
 *  @module org.schema
 *  @extends Reservation
 */
var TrainReservation = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Reservation.call(this);
    this.context = "http://schema.org/";
    this.type = "TrainReservation";
};
TrainReservation = stjs.extend(TrainReservation, Reservation, [], null, {provider: "Person", programMembershipUsed: "ProgramMembership", reservationStatus: "ReservationStatusType", underName: "Organization", bookingAgent: "Organization", reservationFor: "Thing", broker: "Person", reservedTicket: "Ticket", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/FoodEstablishmentReservation
 *  A reservation to dine at a food-related business.Note: This type is for information about actual reservations, e.g. in confirmation emails or HTML pages with individual confirmations of reservations.
 * 
 *  @author schema.org
 *  @class FoodEstablishmentReservation
 *  @module org.schema
 *  @extends Reservation
 */
var FoodEstablishmentReservation = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Reservation.call(this);
    this.context = "http://schema.org/";
    this.type = "FoodEstablishmentReservation";
};
FoodEstablishmentReservation = stjs.extend(FoodEstablishmentReservation, Reservation, [], function(constructor, prototype) {
    /**
     *  Schema.org/startTime
     *  The startTime of something. For a reserved event or service (e.g. FoodEstablishmentReservation), the time that it is expected to start. For actions that span a period of time, when the action was performed. e.g. John wrote a book from *January* to December.\n\nNote that SchemaEvent uses startDate/endDate instead of startTime/endTime, even when describing dates with times. This situation may be clarified in future revisions.
     * 
     *  @property startTime
     *  @type DateTime
     */
    prototype.startTime = null;
    /**
     *  Schema.org/endTime
     *  The endTime of something. For a reserved event or service (e.g. FoodEstablishmentReservation), the time that it is expected to end. For actions that span a period of time, when the action was performed. e.g. John wrote a book from January to *December*.\n\nNote that SchemaEvent uses startDate/endDate instead of startTime/endTime, even when describing dates with times. This situation may be clarified in future revisions.
     * 
     *  @property endTime
     *  @type DateTime
     */
    prototype.endTime = null;
    /**
     *  Schema.org/partySize
     *  Number of people the reservation should accommodate.
     * 
     *  @property partySize
     *  @type Integer
     */
    prototype.partySize = null;
}, {provider: "Person", programMembershipUsed: "ProgramMembership", reservationStatus: "ReservationStatusType", underName: "Organization", bookingAgent: "Organization", reservationFor: "Thing", broker: "Person", reservedTicket: "Ticket", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/LodgingReservation
 *  A reservation for lodging at a hotel, motel, inn, etc.\n\nNote: This type is for information about actual reservations, e.g. in confirmation emails or HTML pages with individual confirmations of reservations.
 * 
 *  @author schema.org
 *  @class LodgingReservation
 *  @module org.schema
 *  @extends Reservation
 */
var LodgingReservation = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Reservation.call(this);
    this.context = "http://schema.org/";
    this.type = "LodgingReservation";
};
LodgingReservation = stjs.extend(LodgingReservation, Reservation, [], function(constructor, prototype) {
    /**
     *  Schema.org/checkinTime
     *  The earliest someone may check into a lodging establishment.
     * 
     *  @property checkinTime
     *  @type DateTime
     */
    prototype.checkinTime = null;
    /**
     *  Schema.org/numChildren
     *  The number of children staying in the unit.
     * 
     *  @property numChildren
     *  @type Integer
     */
    prototype.numChildren = null;
    /**
     *  Schema.org/lodgingUnitDescription
     *  A full description of the lodging unit.
     * 
     *  @property lodgingUnitDescription
     *  @type Text
     */
    prototype.lodgingUnitDescription = null;
    /**
     *  Schema.org/checkoutTime
     *  The latest someone may check out of a lodging establishment.
     * 
     *  @property checkoutTime
     *  @type DateTime
     */
    prototype.checkoutTime = null;
    /**
     *  Schema.org/lodgingUnitType
     *  Textual description of the unit type (including suite vs. room, size of bed, etc.).
     * 
     *  @property lodgingUnitType
     *  @type Text
     */
    prototype.lodgingUnitType = null;
    /**
     *  Schema.org/numAdults
     *  The number of adults staying in the unit.
     * 
     *  @property numAdults
     *  @type Integer
     */
    prototype.numAdults = null;
}, {provider: "Person", programMembershipUsed: "ProgramMembership", reservationStatus: "ReservationStatusType", underName: "Organization", bookingAgent: "Organization", reservationFor: "Thing", broker: "Person", reservedTicket: "Ticket", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/ReservationPackage
 *  A group of multiple reservations with common values for all sub-reservations.
 * 
 *  @author schema.org
 *  @class ReservationPackage
 *  @module org.schema
 *  @extends Reservation
 */
var ReservationPackage = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Reservation.call(this);
    this.context = "http://schema.org/";
    this.type = "ReservationPackage";
};
ReservationPackage = stjs.extend(ReservationPackage, Reservation, [], function(constructor, prototype) {
    /**
     *  Schema.org/subReservation
     *  The individual reservations included in the package. Typically a repeated property.
     * 
     *  @property subReservation
     *  @type Reservation
     */
    prototype.subReservation = null;
}, {subReservation: "Reservation", provider: "Person", programMembershipUsed: "ProgramMembership", reservationStatus: "ReservationStatusType", underName: "Organization", bookingAgent: "Organization", reservationFor: "Thing", broker: "Person", reservedTicket: "Ticket", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/EventReservation
 *  A reservation for an event like a concert, sporting event, or lecture.\n\nNote: This type is for information about actual reservations, e.g. in confirmation emails or HTML pages with individual confirmations of reservations. For offers of tickets, use [[Offer]].
 * 
 *  @author schema.org
 *  @class EventReservation
 *  @module org.schema
 *  @extends Reservation
 */
var EventReservation = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Reservation.call(this);
    this.context = "http://schema.org/";
    this.type = "EventReservation";
};
EventReservation = stjs.extend(EventReservation, Reservation, [], null, {provider: "Person", programMembershipUsed: "ProgramMembership", reservationStatus: "ReservationStatusType", underName: "Organization", bookingAgent: "Organization", reservationFor: "Thing", broker: "Person", reservedTicket: "Ticket", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/TaxiReservation
 *  A reservation for a taxi.\n\nNote: This type is for information about actual reservations, e.g. in confirmation emails or HTML pages with individual confirmations of reservations. For offers of tickets, use [[Offer]].
 * 
 *  @author schema.org
 *  @class TaxiReservation
 *  @module org.schema
 *  @extends Reservation
 */
var TaxiReservation = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Reservation.call(this);
    this.context = "http://schema.org/";
    this.type = "TaxiReservation";
};
TaxiReservation = stjs.extend(TaxiReservation, Reservation, [], function(constructor, prototype) {
    /**
     *  Schema.org/pickupTime
     *  When a taxi will pickup a passenger or a rental car can be picked up.
     * 
     *  @property pickupTime
     *  @type DateTime
     */
    prototype.pickupTime = null;
    /**
     *  Schema.org/partySize
     *  Number of people the reservation should accommodate.
     * 
     *  @property partySize
     *  @type Integer
     */
    prototype.partySize = null;
    /**
     *  Schema.org/pickupLocation
     *  Where a taxi will pick up a passenger or a rental car can be picked up.
     * 
     *  @property pickupLocation
     *  @type Place
     */
    prototype.pickupLocation = null;
}, {pickupLocation: "Place", provider: "Person", programMembershipUsed: "ProgramMembership", reservationStatus: "ReservationStatusType", underName: "Organization", bookingAgent: "Organization", reservationFor: "Thing", broker: "Person", reservedTicket: "Ticket", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Car
 *  A car is a wheeled, self-powered motor vehicle used for transportation.
 * 
 *  @author schema.org
 *  @class Car
 *  @module org.schema
 *  @extends Vehicle
 */
var Car = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Vehicle.call(this);
    this.context = "http://schema.org/";
    this.type = "Car";
};
Car = stjs.extend(Car, Vehicle, [], null, {mileageFromOdometer: "QuantitativeValue", cargoVolume: "QuantitativeValue", steeringPosition: "SteeringPositionValue", vehicleSeatingCapacity: "QuantitativeValue", vehicleEngine: "EngineSpecification", fuelConsumption: "QuantitativeValue", numberOfPreviousOwners: "QuantitativeValue", fuelEfficiency: "QuantitativeValue", numberOfAxles: "QuantitativeValue", driveWheelConfiguration: "DriveWheelConfigurationValue", manufacturer: "Organization", audience: "Audience", height: "Distance", reviews: "Review", aggregateRating: "AggregateRating", isConsumableFor: "Product", offers: "Offer", width: "Distance", additionalProperty: "PropertyValue", isAccessoryOrSparePartFor: "Product", logo: "ImageObject", weight: "QuantitativeValue", depth: "Distance", isSimilarTo: "Product", isRelatedTo: "Product", review: "Review", itemCondition: "OfferItemCondition", brand: "Organization", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/SpreadsheetDigitalDocument
 *  A spreadsheet file.
 * 
 *  @author schema.org
 *  @class SpreadsheetDigitalDocument
 *  @module org.schema
 *  @extends DigitalDocument
 */
var SpreadsheetDigitalDocument = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    DigitalDocument.call(this);
    this.context = "http://schema.org/";
    this.type = "SpreadsheetDigitalDocument";
};
SpreadsheetDigitalDocument = stjs.extend(SpreadsheetDigitalDocument, DigitalDocument, [], null, {hasDigitalDocumentPermission: "DigitalDocumentPermission", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/NoteDigitalDocument
 *  A file containing a note, primarily for the author.
 * 
 *  @author schema.org
 *  @class NoteDigitalDocument
 *  @module org.schema
 *  @extends DigitalDocument
 */
var NoteDigitalDocument = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    DigitalDocument.call(this);
    this.context = "http://schema.org/";
    this.type = "NoteDigitalDocument";
};
NoteDigitalDocument = stjs.extend(NoteDigitalDocument, DigitalDocument, [], null, {hasDigitalDocumentPermission: "DigitalDocumentPermission", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/PresentationDigitalDocument
 *  A file containing slides or used for a presentation.
 * 
 *  @author schema.org
 *  @class PresentationDigitalDocument
 *  @module org.schema
 *  @extends DigitalDocument
 */
var PresentationDigitalDocument = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    DigitalDocument.call(this);
    this.context = "http://schema.org/";
    this.type = "PresentationDigitalDocument";
};
PresentationDigitalDocument = stjs.extend(PresentationDigitalDocument, DigitalDocument, [], null, {hasDigitalDocumentPermission: "DigitalDocumentPermission", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/TextDigitalDocument
 *  A file composed primarily of text.
 * 
 *  @author schema.org
 *  @class TextDigitalDocument
 *  @module org.schema
 *  @extends DigitalDocument
 */
var TextDigitalDocument = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    DigitalDocument.call(this);
    this.context = "http://schema.org/";
    this.type = "TextDigitalDocument";
};
TextDigitalDocument = stjs.extend(TextDigitalDocument, DigitalDocument, [], null, {hasDigitalDocumentPermission: "DigitalDocumentPermission", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/MovieClip
 *  A short segment/part of a movie.
 * 
 *  @author schema.org
 *  @class MovieClip
 *  @module org.schema
 *  @extends Clip
 */
var MovieClip = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Clip.call(this);
    this.context = "http://schema.org/";
    this.type = "MovieClip";
};
MovieClip = stjs.extend(MovieClip, Clip, [], null, {actor: "Person", partOfSeries: "CreativeWorkSeries", partOfEpisode: "Episode", partOfSeason: "CreativeWorkSeason", musicBy: "Person", directors: "Person", director: "Person", actors: "Person", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/VideoGameClip
 *  A short segment/part of a video game.
 * 
 *  @author schema.org
 *  @class VideoGameClip
 *  @module org.schema
 *  @extends Clip
 */
var VideoGameClip = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Clip.call(this);
    this.context = "http://schema.org/";
    this.type = "VideoGameClip";
};
VideoGameClip = stjs.extend(VideoGameClip, Clip, [], null, {actor: "Person", partOfSeries: "CreativeWorkSeries", partOfEpisode: "Episode", partOfSeason: "CreativeWorkSeason", musicBy: "Person", directors: "Person", director: "Person", actors: "Person", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/RadioClip
 *  A short radio program or a segment/part of a radio program.
 * 
 *  @author schema.org
 *  @class RadioClip
 *  @module org.schema
 *  @extends Clip
 */
var RadioClip = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Clip.call(this);
    this.context = "http://schema.org/";
    this.type = "RadioClip";
};
RadioClip = stjs.extend(RadioClip, Clip, [], null, {actor: "Person", partOfSeries: "CreativeWorkSeries", partOfEpisode: "Episode", partOfSeason: "CreativeWorkSeason", musicBy: "Person", directors: "Person", director: "Person", actors: "Person", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/TVClip
 *  A short TV program or a segment/part of a TV program.
 * 
 *  @author schema.org
 *  @class TVClip
 *  @module org.schema
 *  @extends Clip
 */
var TVClip = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Clip.call(this);
    this.context = "http://schema.org/";
    this.type = "TVClip";
};
TVClip = stjs.extend(TVClip, Clip, [], function(constructor, prototype) {
    /**
     *  Schema.org/partOfTVSeries
     *  The TV series to which this episode or season belongs.
     * 
     *  @property partOfTVSeries
     *  @type TVSeries
     */
    prototype.partOfTVSeries = null;
}, {partOfTVSeries: "TVSeries", actor: "Person", partOfSeries: "CreativeWorkSeries", partOfEpisode: "Episode", partOfSeason: "CreativeWorkSeason", musicBy: "Person", directors: "Person", director: "Person", actors: "Person", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/WebApplication
 *  Web applications.
 * 
 *  @author schema.org
 *  @class WebApplication
 *  @module org.schema
 *  @extends SoftwareApplication
 */
var WebApplication = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    SoftwareApplication.call(this);
    this.context = "http://schema.org/";
    this.type = "WebApplication";
};
WebApplication = stjs.extend(WebApplication, SoftwareApplication, [], function(constructor, prototype) {
    /**
     *  Schema.org/browserRequirements
     *  Specifies browser requirements in human-readable text. For example, 'requires HTML5 support'.
     * 
     *  @property browserRequirements
     *  @type Text
     */
    prototype.browserRequirements = null;
}, {softwareHelp: "CreativeWork", softwareAddOn: "SoftwareApplication", supportingData: "DataFeed", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/MobileApplication
 *  A software application designed specifically to work well on a mobile device such as a telephone.
 * 
 *  @author schema.org
 *  @class MobileApplication
 *  @module org.schema
 *  @extends SoftwareApplication
 */
var MobileApplication = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    SoftwareApplication.call(this);
    this.context = "http://schema.org/";
    this.type = "MobileApplication";
};
MobileApplication = stjs.extend(MobileApplication, SoftwareApplication, [], function(constructor, prototype) {
    /**
     *  Schema.org/carrierRequirements
     *  Specifies specific carrier(s) requirements for the application (e.g. an application may only work on a specific carrier network).
     * 
     *  @property carrierRequirements
     *  @type Text
     */
    prototype.carrierRequirements = null;
}, {softwareHelp: "CreativeWork", softwareAddOn: "SoftwareApplication", supportingData: "DataFeed", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/VideoGame
 *  A video game is an electronic game that involves human interaction with a user interface to generate visual feedback on a video device.
 * 
 *  @author schema.org
 *  @class VideoGame
 *  @module org.schema
 *  @extends SoftwareApplication
 */
var VideoGame = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    SoftwareApplication.call(this);
    this.context = "http://schema.org/";
    this.type = "VideoGame";
};
VideoGame = stjs.extend(VideoGame, SoftwareApplication, [], function(constructor, prototype) {
    /**
     *  Schema.org/gamePlatform
     *  The electronic systems used to play <a href="http://en.wikipedia.org/wiki/Category:Video_game_platforms">video games</a>.
     * 
     *  @property gamePlatform
     *  @type Text
     */
    prototype.gamePlatform = null;
    /**
     *  Schema.org/gameServer
     *  The server on which  it is possible to play the game.
     * 
     *  @property gameServer
     *  @type GameServer
     */
    prototype.gameServer = null;
    /**
     *  Schema.org/actor
     *  An actor, e.g. in tv, radio, movie, video games etc., or in an event. Actors can be associated with individual items or with a series, episode, clip.
     * 
     *  @property actor
     *  @type Person
     */
    prototype.actor = null;
    /**
     *  Schema.org/trailer
     *  The trailer of a movie or tv/radio series, season, episode, etc.
     * 
     *  @property trailer
     *  @type VideoObject
     */
    prototype.trailer = null;
    /**
     *  Schema.org/cheatCode
     *  Cheat codes to the game.
     * 
     *  @property cheatCode
     *  @type CreativeWork
     */
    prototype.cheatCode = null;
    /**
     *  Schema.org/gameTip
     *  Links to tips, tactics, etc.
     * 
     *  @property gameTip
     *  @type CreativeWork
     */
    prototype.gameTip = null;
    /**
     *  Schema.org/musicBy
     *  The composer of the soundtrack.
     * 
     *  @property musicBy
     *  @type Person
     */
    prototype.musicBy = null;
    /**
     *  Schema.org/directors
     *  A director of e.g. tv, radio, movie, video games etc. content. Directors can be associated with individual items or with a series, episode, clip.
     * 
     *  @property directors
     *  @type Person
     */
    prototype.directors = null;
    /**
     *  Schema.org/playMode
     *  Indicates whether this game is multi-player, co-op or single-player.  The game can be marked as multi-player, co-op and single-player at the same time.
     * 
     *  @property playMode
     *  @type GamePlayMode
     */
    prototype.playMode = null;
    /**
     *  Schema.org/director
     *  A director of e.g. tv, radio, movie, video gaming etc. content, or of an event. Directors can be associated with individual items or with a series, episode, clip.
     * 
     *  @property director
     *  @type Person
     */
    prototype.director = null;
    /**
     *  Schema.org/actors
     *  An actor, e.g. in tv, radio, movie, video games etc. Actors can be associated with individual items or with a series, episode, clip.
     * 
     *  @property actors
     *  @type Person
     */
    prototype.actors = null;
}, {gameServer: "GameServer", actor: "Person", trailer: "VideoObject", cheatCode: "CreativeWork", gameTip: "CreativeWork", musicBy: "Person", directors: "Person", playMode: "GamePlayMode", director: "Person", actors: "Person", softwareHelp: "CreativeWork", softwareAddOn: "SoftwareApplication", supportingData: "DataFeed", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/DataFeed
 *  A single feed providing structured information about one or more entities or topics.
 * 
 *  @author schema.org
 *  @class DataFeed
 *  @module org.schema
 *  @extends Dataset
 */
var DataFeed = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Dataset.call(this);
    this.context = "http://schema.org/";
    this.type = "DataFeed";
};
DataFeed = stjs.extend(DataFeed, Dataset, [], function(constructor, prototype) {
    /**
     *  Schema.org/dataFeedElement
     *  An item within in a data feed. Data feeds may have many elements.
     * 
     *  @property dataFeedElement
     *  @type Text
     */
    prototype.dataFeedElement = null;
}, {catalog: "DataCatalog", includedInDataCatalog: "DataCatalog", spatial: "Place", includedDataCatalog: "DataCatalog", distribution: "DataDownload", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/NewsArticle
 *  A news article.
 * 
 *  @author schema.org
 *  @class NewsArticle
 *  @module org.schema
 *  @extends Article
 */
var NewsArticle = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Article.call(this);
    this.context = "http://schema.org/";
    this.type = "NewsArticle";
};
NewsArticle = stjs.extend(NewsArticle, Article, [], function(constructor, prototype) {
    /**
     *  Schema.org/printColumn
     *  The number of the column in which the NewsArticle appears in the print edition.
     * 
     *  @property printColumn
     *  @type Text
     */
    prototype.printColumn = null;
    /**
     *  Schema.org/printEdition
     *  The edition of the print product in which the NewsArticle appears.
     * 
     *  @property printEdition
     *  @type Text
     */
    prototype.printEdition = null;
    /**
     *  Schema.org/printSection
     *  If this NewsArticle appears in print, this field indicates the print section in which the article appeared.
     * 
     *  @property printSection
     *  @type Text
     */
    prototype.printSection = null;
    /**
     *  Schema.org/printPage
     *  If this NewsArticle appears in print, this field indicates the name of the page on which the article is found. Please note that this field is intended for the exact page name (e.g. A5, B18).
     * 
     *  @property printPage
     *  @type Text
     */
    prototype.printPage = null;
    /**
     *  Schema.org/dateline
     *  The location where the NewsArticle was produced.
     * 
     *  @property dateline
     *  @type Text
     */
    prototype.dateline = null;
}, {about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/TechArticle
 *  A technical article - Example: How-to (task) topics, step-by-step, procedural troubleshooting, specifications, etc.
 * 
 *  @author schema.org
 *  @class TechArticle
 *  @module org.schema
 *  @extends Article
 */
var TechArticle = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Article.call(this);
    this.context = "http://schema.org/";
    this.type = "TechArticle";
};
TechArticle = stjs.extend(TechArticle, Article, [], function(constructor, prototype) {
    /**
     *  Schema.org/dependencies
     *  Prerequisites needed to fulfill steps in article.
     * 
     *  @property dependencies
     *  @type Text
     */
    prototype.dependencies = null;
    /**
     *  Schema.org/proficiencyLevel
     *  Proficiency needed for this content; expected values: 'Beginner', 'Expert'.
     * 
     *  @property proficiencyLevel
     *  @type Text
     */
    prototype.proficiencyLevel = null;
}, {about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/SocialMediaPosting
 *  A post to a social media platform, including blog posts, tweets, Facebook posts, etc.
 * 
 *  @author schema.org
 *  @class SocialMediaPosting
 *  @module org.schema
 *  @extends Article
 */
var SocialMediaPosting = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Article.call(this);
    this.context = "http://schema.org/";
    this.type = "SocialMediaPosting";
};
SocialMediaPosting = stjs.extend(SocialMediaPosting, Article, [], function(constructor, prototype) {
    /**
     *  Schema.org/sharedContent
     *  A CreativeWork such as an image, video, or audio clip shared as part of this posting.
     * 
     *  @property sharedContent
     *  @type CreativeWork
     */
    prototype.sharedContent = null;
}, {sharedContent: "CreativeWork", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Report
 *  A Report generated by governmental or non-governmental organization.
 * 
 *  @author schema.org
 *  @class Report
 *  @module org.schema
 *  @extends Article
 */
var Report = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Article.call(this);
    this.context = "http://schema.org/";
    this.type = "Report";
};
Report = stjs.extend(Report, Article, [], function(constructor, prototype) {
    /**
     *  Schema.org/reportNumber
     *  The number or other unique designator assigned to a Report by the publishing organization.
     * 
     *  @property reportNumber
     *  @type Text
     */
    prototype.reportNumber = null;
}, {about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/ScholarlyArticle
 *  A scholarly article.
 * 
 *  @author schema.org
 *  @class ScholarlyArticle
 *  @module org.schema
 *  @extends Article
 */
var ScholarlyArticle = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Article.call(this);
    this.context = "http://schema.org/";
    this.type = "ScholarlyArticle";
};
ScholarlyArticle = stjs.extend(ScholarlyArticle, Article, [], null, {about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/MusicRelease
 *  A MusicRelease is a specific release of a music album.
 * 
 *  @author schema.org
 *  @class MusicRelease
 *  @module org.schema
 *  @extends MusicPlaylist
 */
var MusicRelease = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    MusicPlaylist.call(this);
    this.context = "http://schema.org/";
    this.type = "MusicRelease";
};
MusicRelease = stjs.extend(MusicRelease, MusicPlaylist, [], function(constructor, prototype) {
    /**
     *  Schema.org/recordLabel
     *  The label that issued the release.
     * 
     *  @property recordLabel
     *  @type Organization
     */
    prototype.recordLabel = null;
    /**
     *  Schema.org/catalogNumber
     *  The catalog number for the release.
     * 
     *  @property catalogNumber
     *  @type Text
     */
    prototype.catalogNumber = null;
    /**
     *  Schema.org/creditedTo
     *  The group the release is credited to if different than the byArtist. For example, Red and Blue is credited to "Stefani Germanotta Band", but by Lady Gaga.
     * 
     *  @property creditedTo
     *  @type Organization
     */
    prototype.creditedTo = null;
    /**
     *  Schema.org/releaseOf
     *  The album this is a release of.
     * 
     *  @property releaseOf
     *  @type MusicAlbum
     */
    prototype.releaseOf = null;
    /**
     *  Schema.org/duration
     *  The duration of the item (movie, audio recording, event, etc.) in [ISO 8601 date format](http://en.wikipedia.org/wiki/ISO_8601).
     * 
     *  @property duration
     *  @type Duration
     */
    prototype.duration = null;
    /**
     *  Schema.org/musicReleaseFormat
     *  Format of this release (the type of recording media used, ie. compact disc, digital media, LP, etc.).
     * 
     *  @property musicReleaseFormat
     *  @type MusicReleaseFormatType
     */
    prototype.musicReleaseFormat = null;
}, {recordLabel: "Organization", creditedTo: "Organization", releaseOf: "MusicAlbum", duration: "Duration", musicReleaseFormat: "MusicReleaseFormatType", track: "MusicRecording", tracks: "MusicRecording", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/MusicAlbum
 *  A collection of music tracks.
 * 
 *  @author schema.org
 *  @class MusicAlbum
 *  @module org.schema
 *  @extends MusicPlaylist
 */
var MusicAlbum = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    MusicPlaylist.call(this);
    this.context = "http://schema.org/";
    this.type = "MusicAlbum";
};
MusicAlbum = stjs.extend(MusicAlbum, MusicPlaylist, [], function(constructor, prototype) {
    /**
     *  Schema.org/albumProductionType
     *  Classification of the album by it's type of content: soundtrack, live album, studio album, etc.
     * 
     *  @property albumProductionType
     *  @type MusicAlbumProductionType
     */
    prototype.albumProductionType = null;
    /**
     *  Schema.org/albumReleaseType
     *  The kind of release which this album is: single, EP or album.
     * 
     *  @property albumReleaseType
     *  @type MusicAlbumReleaseType
     */
    prototype.albumReleaseType = null;
    /**
     *  Schema.org/byArtist
     *  The artist that performed this album or recording.
     * 
     *  @property byArtist
     *  @type MusicGroup
     */
    prototype.byArtist = null;
    /**
     *  Schema.org/albumRelease
     *  A release of this album.
     * 
     *  @property albumRelease
     *  @type MusicRelease
     */
    prototype.albumRelease = null;
}, {albumProductionType: "MusicAlbumProductionType", albumReleaseType: "MusicAlbumReleaseType", byArtist: "MusicGroup", albumRelease: "MusicRelease", track: "MusicRecording", tracks: "MusicRecording", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Table
 *  A table on a Web page.
 * 
 *  @author schema.org
 *  @class Table
 *  @module org.schema
 *  @extends WebPageElement
 */
var Table = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    WebPageElement.call(this);
    this.context = "http://schema.org/";
    this.type = "Table";
};
Table = stjs.extend(Table, WebPageElement, [], null, {about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/WPSideBar
 *  A sidebar section of the page.
 * 
 *  @author schema.org
 *  @class WPSideBar
 *  @module org.schema
 *  @extends WebPageElement
 */
var WPSideBar = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    WebPageElement.call(this);
    this.context = "http://schema.org/";
    this.type = "WPSideBar";
};
WPSideBar = stjs.extend(WPSideBar, WebPageElement, [], null, {about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/WPAdBlock
 *  An advertising section of the page.
 * 
 *  @author schema.org
 *  @class WPAdBlock
 *  @module org.schema
 *  @extends WebPageElement
 */
var WPAdBlock = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    WebPageElement.call(this);
    this.context = "http://schema.org/";
    this.type = "WPAdBlock";
};
WPAdBlock = stjs.extend(WPAdBlock, WebPageElement, [], null, {about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/WPHeader
 *  The header section of the page.
 * 
 *  @author schema.org
 *  @class WPHeader
 *  @module org.schema
 *  @extends WebPageElement
 */
var WPHeader = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    WebPageElement.call(this);
    this.context = "http://schema.org/";
    this.type = "WPHeader";
};
WPHeader = stjs.extend(WPHeader, WebPageElement, [], null, {about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/SiteNavigationElement
 *  A navigation element of the page.
 * 
 *  @author schema.org
 *  @class SiteNavigationElement
 *  @module org.schema
 *  @extends WebPageElement
 */
var SiteNavigationElement = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    WebPageElement.call(this);
    this.context = "http://schema.org/";
    this.type = "SiteNavigationElement";
};
SiteNavigationElement = stjs.extend(SiteNavigationElement, WebPageElement, [], null, {about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/WPFooter
 *  The footer section of the page.
 * 
 *  @author schema.org
 *  @class WPFooter
 *  @module org.schema
 *  @extends WebPageElement
 */
var WPFooter = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    WebPageElement.call(this);
    this.context = "http://schema.org/";
    this.type = "WPFooter";
};
WPFooter = stjs.extend(WPFooter, WebPageElement, [], null, {about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Answer
 *  An answer offered to a question; perhaps correct, perhaps opinionated or wrong.
 * 
 *  @author schema.org
 *  @class Answer
 *  @module org.schema
 *  @extends Comment
 */
var Answer = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Comment.call(this);
    this.context = "http://schema.org/";
    this.type = "Answer";
};
Answer = stjs.extend(Answer, Comment, [], null, {parentItem: "Question", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/EmailMessage
 *  An email message.
 * 
 *  @author schema.org
 *  @class EmailMessage
 *  @module org.schema
 *  @extends Message
 */
var EmailMessage = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Message.call(this);
    this.context = "http://schema.org/";
    this.type = "EmailMessage";
};
EmailMessage = stjs.extend(EmailMessage, Message, [], null, {recipient: "Organization", messageAttachment: "CreativeWork", sender: "Audience", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/ClaimReview
 *  A fact-checking review of claims made (or reported) in some creative work (referenced via itemReviewed).
 * 
 *  @author schema.org
 *  @class ClaimReview
 *  @module org.schema
 *  @extends Review
 */
var ClaimReview = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Review.call(this);
    this.context = "http://schema.org/";
    this.type = "ClaimReview";
};
ClaimReview = stjs.extend(ClaimReview, Review, [], function(constructor, prototype) {
    /**
     *  Schema.org/claimReviewed
     *  A short summary of the specific claims reviewed in a ClaimReview.
     * 
     *  @property claimReviewed
     *  @type Text
     */
    prototype.claimReviewed = null;
}, {reviewRating: "Rating", itemReviewed: "Thing", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/RadioEpisode
 *  A radio episode which can be part of a series or season.
 * 
 *  @author schema.org
 *  @class RadioEpisode
 *  @module org.schema
 *  @extends Episode
 */
var RadioEpisode = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Episode.call(this);
    this.context = "http://schema.org/";
    this.type = "RadioEpisode";
};
RadioEpisode = stjs.extend(RadioEpisode, Episode, [], null, {actor: "Person", partOfSeries: "CreativeWorkSeries", trailer: "VideoObject", partOfSeason: "CreativeWorkSeason", musicBy: "Person", directors: "Person", director: "Person", productionCompany: "Organization", actors: "Person", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/TVEpisode
 *  A TV episode which can be part of a series or season.
 * 
 *  @author schema.org
 *  @class TVEpisode
 *  @module org.schema
 *  @extends Episode
 */
var TVEpisode = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Episode.call(this);
    this.context = "http://schema.org/";
    this.type = "TVEpisode";
};
TVEpisode = stjs.extend(TVEpisode, Episode, [], function(constructor, prototype) {
    /**
     *  Schema.org/partOfTVSeries
     *  The TV series to which this episode or season belongs.
     * 
     *  @property partOfTVSeries
     *  @type TVSeries
     */
    prototype.partOfTVSeries = null;
    /**
     *  Schema.org/subtitleLanguage
     *  Languages in which subtitles/captions are available, in [IETF BCP 47 standard format](http://tools.ietf.org/html/bcp47).
     * 
     *  @property subtitleLanguage
     *  @type Text
     */
    prototype.subtitleLanguage = null;
    /**
     *  Schema.org/countryOfOrigin
     *  The country of the principal offices of the production company or individual responsible for the movie or program.
     * 
     *  @property countryOfOrigin
     *  @type Country
     */
    prototype.countryOfOrigin = null;
}, {partOfTVSeries: "TVSeries", countryOfOrigin: "Country", actor: "Person", partOfSeries: "CreativeWorkSeries", trailer: "VideoObject", partOfSeason: "CreativeWorkSeason", musicBy: "Person", directors: "Person", director: "Person", productionCompany: "Organization", actors: "Person", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/DataDownload
 *  A dataset in downloadable form.
 * 
 *  @author schema.org
 *  @class DataDownload
 *  @module org.schema
 *  @extends MediaObject
 */
var DataDownload = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    MediaObject.call(this);
    this.context = "http://schema.org/";
    this.type = "DataDownload";
};
DataDownload = stjs.extend(DataDownload, MediaObject, [], null, {height: "Distance", regionsAllowed: "Place", width: "Distance", associatedArticle: "NewsArticle", productionCompany: "Organization", duration: "Duration", encodesCreativeWork: "CreativeWork", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/MusicVideoObject
 *  A music video file.
 * 
 *  @author schema.org
 *  @class MusicVideoObject
 *  @module org.schema
 *  @extends MediaObject
 */
var MusicVideoObject = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    MediaObject.call(this);
    this.context = "http://schema.org/";
    this.type = "MusicVideoObject";
};
MusicVideoObject = stjs.extend(MusicVideoObject, MediaObject, [], null, {height: "Distance", regionsAllowed: "Place", width: "Distance", associatedArticle: "NewsArticle", productionCompany: "Organization", duration: "Duration", encodesCreativeWork: "CreativeWork", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/AudioObject
 *  An audio file.
 * 
 *  @author schema.org
 *  @class AudioObject
 *  @module org.schema
 *  @extends MediaObject
 */
var AudioObject = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    MediaObject.call(this);
    this.context = "http://schema.org/";
    this.type = "AudioObject";
};
AudioObject = stjs.extend(AudioObject, MediaObject, [], function(constructor, prototype) {
    /**
     *  Schema.org/transcript
     *  If this MediaObject is an AudioObject or VideoObject, the transcript of that object.
     * 
     *  @property transcript
     *  @type Text
     */
    prototype.transcript = null;
}, {height: "Distance", regionsAllowed: "Place", width: "Distance", associatedArticle: "NewsArticle", productionCompany: "Organization", duration: "Duration", encodesCreativeWork: "CreativeWork", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/ImageObject
 *  An image file.
 * 
 *  @author schema.org
 *  @class ImageObject
 *  @module org.schema
 *  @extends MediaObject
 */
var ImageObject = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    MediaObject.call(this);
    this.context = "http://schema.org/";
    this.type = "ImageObject";
};
ImageObject = stjs.extend(ImageObject, MediaObject, [], function(constructor, prototype) {
    /**
     *  Schema.org/exifData
     *  exif data for this object.
     * 
     *  @property exifData
     *  @type Text
     */
    prototype.exifData = null;
    /**
     *  Schema.org/representativeOfPage
     *  Indicates whether this image is representative of the content of the page.
     * 
     *  @property representativeOfPage
     *  @type Boolean
     */
    prototype.representativeOfPage = null;
    /**
     *  Schema.org/thumbnail
     *  Thumbnail image for an image or video.
     * 
     *  @property thumbnail
     *  @type ImageObject
     */
    prototype.thumbnail = null;
    /**
     *  Schema.org/caption
     *  The caption for this object.
     * 
     *  @property caption
     *  @type Text
     */
    prototype.caption = null;
}, {thumbnail: "ImageObject", height: "Distance", regionsAllowed: "Place", width: "Distance", associatedArticle: "NewsArticle", productionCompany: "Organization", duration: "Duration", encodesCreativeWork: "CreativeWork", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/VideoObject
 *  A video file.
 * 
 *  @author schema.org
 *  @class VideoObject
 *  @module org.schema
 *  @extends MediaObject
 */
var VideoObject = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    MediaObject.call(this);
    this.context = "http://schema.org/";
    this.type = "VideoObject";
};
VideoObject = stjs.extend(VideoObject, MediaObject, [], function(constructor, prototype) {
    /**
     *  Schema.org/actor
     *  An actor, e.g. in tv, radio, movie, video games etc., or in an event. Actors can be associated with individual items or with a series, episode, clip.
     * 
     *  @property actor
     *  @type Person
     */
    prototype.actor = null;
    /**
     *  Schema.org/videoFrameSize
     *  The frame size of the video.
     * 
     *  @property videoFrameSize
     *  @type Text
     */
    prototype.videoFrameSize = null;
    /**
     *  Schema.org/musicBy
     *  The composer of the soundtrack.
     * 
     *  @property musicBy
     *  @type Person
     */
    prototype.musicBy = null;
    /**
     *  Schema.org/directors
     *  A director of e.g. tv, radio, movie, video games etc. content. Directors can be associated with individual items or with a series, episode, clip.
     * 
     *  @property directors
     *  @type Person
     */
    prototype.directors = null;
    /**
     *  Schema.org/director
     *  A director of e.g. tv, radio, movie, video gaming etc. content, or of an event. Directors can be associated with individual items or with a series, episode, clip.
     * 
     *  @property director
     *  @type Person
     */
    prototype.director = null;
    /**
     *  Schema.org/transcript
     *  If this MediaObject is an AudioObject or VideoObject, the transcript of that object.
     * 
     *  @property transcript
     *  @type Text
     */
    prototype.transcript = null;
    /**
     *  Schema.org/videoQuality
     *  The quality of the video.
     * 
     *  @property videoQuality
     *  @type Text
     */
    prototype.videoQuality = null;
    /**
     *  Schema.org/thumbnail
     *  Thumbnail image for an image or video.
     * 
     *  @property thumbnail
     *  @type ImageObject
     */
    prototype.thumbnail = null;
    /**
     *  Schema.org/caption
     *  The caption for this object.
     * 
     *  @property caption
     *  @type Text
     */
    prototype.caption = null;
    /**
     *  Schema.org/actors
     *  An actor, e.g. in tv, radio, movie, video games etc. Actors can be associated with individual items or with a series, episode, clip.
     * 
     *  @property actors
     *  @type Person
     */
    prototype.actors = null;
}, {actor: "Person", musicBy: "Person", directors: "Person", director: "Person", thumbnail: "ImageObject", actors: "Person", height: "Distance", regionsAllowed: "Place", width: "Distance", associatedArticle: "NewsArticle", productionCompany: "Organization", duration: "Duration", encodesCreativeWork: "CreativeWork", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/ItemPage
 *  A page devoted to a single item, such as a particular product or hotel.
 * 
 *  @author schema.org
 *  @class ItemPage
 *  @module org.schema
 *  @extends WebPage
 */
var ItemPage = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    WebPage.call(this);
    this.context = "http://schema.org/";
    this.type = "ItemPage";
};
ItemPage = stjs.extend(ItemPage, WebPage, [], null, {mainContentOfPage: "WebPageElement", reviewedBy: "Organization", primaryImageOfPage: "ImageObject", specialty: "Specialty", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/ContactPage
 *  Web page type: Contact page.
 * 
 *  @author schema.org
 *  @class ContactPage
 *  @module org.schema
 *  @extends WebPage
 */
var ContactPage = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    WebPage.call(this);
    this.context = "http://schema.org/";
    this.type = "ContactPage";
};
ContactPage = stjs.extend(ContactPage, WebPage, [], null, {mainContentOfPage: "WebPageElement", reviewedBy: "Organization", primaryImageOfPage: "ImageObject", specialty: "Specialty", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/CheckoutPage
 *  Web page type: Checkout page.
 * 
 *  @author schema.org
 *  @class CheckoutPage
 *  @module org.schema
 *  @extends WebPage
 */
var CheckoutPage = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    WebPage.call(this);
    this.context = "http://schema.org/";
    this.type = "CheckoutPage";
};
CheckoutPage = stjs.extend(CheckoutPage, WebPage, [], null, {mainContentOfPage: "WebPageElement", reviewedBy: "Organization", primaryImageOfPage: "ImageObject", specialty: "Specialty", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/QAPage
 *  A QAPage is a WebPage focussed on a specific Question and its Answer(s), e.g. in a question answering site or documenting Frequently Asked Questions (FAQs).
 * 
 *  @author schema.org
 *  @class QAPage
 *  @module org.schema
 *  @extends WebPage
 */
var QAPage = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    WebPage.call(this);
    this.context = "http://schema.org/";
    this.type = "QAPage";
};
QAPage = stjs.extend(QAPage, WebPage, [], null, {mainContentOfPage: "WebPageElement", reviewedBy: "Organization", primaryImageOfPage: "ImageObject", specialty: "Specialty", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/CollectionPage
 *  Web page type: Collection page.
 * 
 *  @author schema.org
 *  @class CollectionPage
 *  @module org.schema
 *  @extends WebPage
 */
var CollectionPage = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    WebPage.call(this);
    this.context = "http://schema.org/";
    this.type = "CollectionPage";
};
CollectionPage = stjs.extend(CollectionPage, WebPage, [], null, {mainContentOfPage: "WebPageElement", reviewedBy: "Organization", primaryImageOfPage: "ImageObject", specialty: "Specialty", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/SearchResultsPage
 *  Web page type: Search results page.
 * 
 *  @author schema.org
 *  @class SearchResultsPage
 *  @module org.schema
 *  @extends WebPage
 */
var SearchResultsPage = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    WebPage.call(this);
    this.context = "http://schema.org/";
    this.type = "SearchResultsPage";
};
SearchResultsPage = stjs.extend(SearchResultsPage, WebPage, [], null, {mainContentOfPage: "WebPageElement", reviewedBy: "Organization", primaryImageOfPage: "ImageObject", specialty: "Specialty", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/ProfilePage
 *  Web page type: Profile page.
 * 
 *  @author schema.org
 *  @class ProfilePage
 *  @module org.schema
 *  @extends WebPage
 */
var ProfilePage = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    WebPage.call(this);
    this.context = "http://schema.org/";
    this.type = "ProfilePage";
};
ProfilePage = stjs.extend(ProfilePage, WebPage, [], null, {mainContentOfPage: "WebPageElement", reviewedBy: "Organization", primaryImageOfPage: "ImageObject", specialty: "Specialty", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/AboutPage
 *  Web page type: About page.
 * 
 *  @author schema.org
 *  @class AboutPage
 *  @module org.schema
 *  @extends WebPage
 */
var AboutPage = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    WebPage.call(this);
    this.context = "http://schema.org/";
    this.type = "AboutPage";
};
AboutPage = stjs.extend(AboutPage, WebPage, [], null, {mainContentOfPage: "WebPageElement", reviewedBy: "Organization", primaryImageOfPage: "ImageObject", specialty: "Specialty", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/BookSeries
 *  A series of books. Included books can be indicated with the hasPart property.
 * 
 *  @author schema.org
 *  @class BookSeries
 *  @module org.schema
 *  @extends CreativeWorkSeries
 */
var BookSeries = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CreativeWorkSeries.call(this);
    this.context = "http://schema.org/";
    this.type = "BookSeries";
};
BookSeries = stjs.extend(BookSeries, CreativeWorkSeries, [], null, {about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/VideoGameSeries
 *  A video game series.
 * 
 *  @author schema.org
 *  @class VideoGameSeries
 *  @module org.schema
 *  @extends CreativeWorkSeries
 */
var VideoGameSeries = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CreativeWorkSeries.call(this);
    this.context = "http://schema.org/";
    this.type = "VideoGameSeries";
};
VideoGameSeries = stjs.extend(VideoGameSeries, CreativeWorkSeries, [], function(constructor, prototype) {
    /**
     *  Schema.org/gameItem
     *  An item is an object within the game world that can be collected by a player or, occasionally, a non-player character.
     * 
     *  @property gameItem
     *  @type Thing
     */
    prototype.gameItem = null;
    /**
     *  Schema.org/seasons
     *  A season in a media series.
     * 
     *  @property seasons
     *  @type CreativeWorkSeason
     */
    prototype.seasons = null;
    /**
     *  Schema.org/gamePlatform
     *  The electronic systems used to play <a href="http://en.wikipedia.org/wiki/Category:Video_game_platforms">video games</a>.
     * 
     *  @property gamePlatform
     *  @type Text
     */
    prototype.gamePlatform = null;
    /**
     *  Schema.org/actor
     *  An actor, e.g. in tv, radio, movie, video games etc., or in an event. Actors can be associated with individual items or with a series, episode, clip.
     * 
     *  @property actor
     *  @type Person
     */
    prototype.actor = null;
    /**
     *  Schema.org/numberOfEpisodes
     *  The number of episodes in this season or series.
     * 
     *  @property numberOfEpisodes
     *  @type Integer
     */
    prototype.numberOfEpisodes = null;
    /**
     *  Schema.org/trailer
     *  The trailer of a movie or tv/radio series, season, episode, etc.
     * 
     *  @property trailer
     *  @type VideoObject
     */
    prototype.trailer = null;
    /**
     *  Schema.org/season
     *  A season in a media series.
     * 
     *  @property season
     *  @type CreativeWorkSeason
     */
    prototype.season = null;
    /**
     *  Schema.org/episodes
     *  An episode of a TV/radio series or season.
     * 
     *  @property episodes
     *  @type Episode
     */
    prototype.episodes = null;
    /**
     *  Schema.org/cheatCode
     *  Cheat codes to the game.
     * 
     *  @property cheatCode
     *  @type CreativeWork
     */
    prototype.cheatCode = null;
    /**
     *  Schema.org/characterAttribute
     *  A piece of data that represents a particular aspect of a fictional character (skill, power, character points, advantage, disadvantage).
     * 
     *  @property characterAttribute
     *  @type Thing
     */
    prototype.characterAttribute = null;
    /**
     *  Schema.org/gameLocation
     *  Real or fictional location of the game (or part of game).
     * 
     *  @property gameLocation
     *  @type URL
     */
    prototype.gameLocation = null;
    /**
     *  Schema.org/musicBy
     *  The composer of the soundtrack.
     * 
     *  @property musicBy
     *  @type Person
     */
    prototype.musicBy = null;
    /**
     *  Schema.org/containsSeason
     *  A season that is part of the media series.
     * 
     *  @property containsSeason
     *  @type CreativeWorkSeason
     */
    prototype.containsSeason = null;
    /**
     *  Schema.org/directors
     *  A director of e.g. tv, radio, movie, video games etc. content. Directors can be associated with individual items or with a series, episode, clip.
     * 
     *  @property directors
     *  @type Person
     */
    prototype.directors = null;
    /**
     *  Schema.org/quest
     *  The task that a player-controlled character, or group of characters may complete in order to gain a reward.
     * 
     *  @property quest
     *  @type Thing
     */
    prototype.quest = null;
    /**
     *  Schema.org/playMode
     *  Indicates whether this game is multi-player, co-op or single-player.  The game can be marked as multi-player, co-op and single-player at the same time.
     * 
     *  @property playMode
     *  @type GamePlayMode
     */
    prototype.playMode = null;
    /**
     *  Schema.org/numberOfSeasons
     *  The number of seasons in this series.
     * 
     *  @property numberOfSeasons
     *  @type Integer
     */
    prototype.numberOfSeasons = null;
    /**
     *  Schema.org/director
     *  A director of e.g. tv, radio, movie, video gaming etc. content, or of an event. Directors can be associated with individual items or with a series, episode, clip.
     * 
     *  @property director
     *  @type Person
     */
    prototype.director = null;
    /**
     *  Schema.org/productionCompany
     *  The production company or studio responsible for the item e.g. series, video game, episode etc.
     * 
     *  @property productionCompany
     *  @type Organization
     */
    prototype.productionCompany = null;
    /**
     *  Schema.org/numberOfPlayers
     *  Indicate how many people can play this game (minimum, maximum, or range).
     * 
     *  @property numberOfPlayers
     *  @type QuantitativeValue
     */
    prototype.numberOfPlayers = null;
    /**
     *  Schema.org/actors
     *  An actor, e.g. in tv, radio, movie, video games etc. Actors can be associated with individual items or with a series, episode, clip.
     * 
     *  @property actors
     *  @type Person
     */
    prototype.actors = null;
    /**
     *  Schema.org/episode
     *  An episode of a tv, radio or game media within a series or season.
     * 
     *  @property episode
     *  @type Episode
     */
    prototype.episode = null;
}, {gameItem: "Thing", seasons: "CreativeWorkSeason", actor: "Person", trailer: "VideoObject", season: "CreativeWorkSeason", episodes: "Episode", cheatCode: "CreativeWork", characterAttribute: "Thing", musicBy: "Person", containsSeason: "CreativeWorkSeason", directors: "Person", quest: "Thing", playMode: "GamePlayMode", director: "Person", productionCompany: "Organization", numberOfPlayers: "QuantitativeValue", actors: "Person", episode: "Episode", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/MovieSeries
 *  A series of movies. Included movies can be indicated with the hasPart property.
 * 
 *  @author schema.org
 *  @class MovieSeries
 *  @module org.schema
 *  @extends CreativeWorkSeries
 */
var MovieSeries = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CreativeWorkSeries.call(this);
    this.context = "http://schema.org/";
    this.type = "MovieSeries";
};
MovieSeries = stjs.extend(MovieSeries, CreativeWorkSeries, [], function(constructor, prototype) {
    /**
     *  Schema.org/actor
     *  An actor, e.g. in tv, radio, movie, video games etc., or in an event. Actors can be associated with individual items or with a series, episode, clip.
     * 
     *  @property actor
     *  @type Person
     */
    prototype.actor = null;
    /**
     *  Schema.org/trailer
     *  The trailer of a movie or tv/radio series, season, episode, etc.
     * 
     *  @property trailer
     *  @type VideoObject
     */
    prototype.trailer = null;
    /**
     *  Schema.org/musicBy
     *  The composer of the soundtrack.
     * 
     *  @property musicBy
     *  @type Person
     */
    prototype.musicBy = null;
    /**
     *  Schema.org/directors
     *  A director of e.g. tv, radio, movie, video games etc. content. Directors can be associated with individual items or with a series, episode, clip.
     * 
     *  @property directors
     *  @type Person
     */
    prototype.directors = null;
    /**
     *  Schema.org/director
     *  A director of e.g. tv, radio, movie, video gaming etc. content, or of an event. Directors can be associated with individual items or with a series, episode, clip.
     * 
     *  @property director
     *  @type Person
     */
    prototype.director = null;
    /**
     *  Schema.org/productionCompany
     *  The production company or studio responsible for the item e.g. series, video game, episode etc.
     * 
     *  @property productionCompany
     *  @type Organization
     */
    prototype.productionCompany = null;
    /**
     *  Schema.org/actors
     *  An actor, e.g. in tv, radio, movie, video games etc. Actors can be associated with individual items or with a series, episode, clip.
     * 
     *  @property actors
     *  @type Person
     */
    prototype.actors = null;
}, {actor: "Person", trailer: "VideoObject", musicBy: "Person", directors: "Person", director: "Person", productionCompany: "Organization", actors: "Person", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Periodical
 *  A publication in any medium issued in successive parts bearing numerical or chronological designations and intended, such as a magazine, scholarly journal, or newspaper to continue indefinitely.\n\nSee also [blog post](http://blog.schema.org/2014/09/schemaorg-support-for-bibliographic_2.html).
 * 
 *  @author schema.org
 *  @class Periodical
 *  @module org.schema
 *  @extends CreativeWorkSeries
 */
var Periodical = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CreativeWorkSeries.call(this);
    this.context = "http://schema.org/";
    this.type = "Periodical";
};
Periodical = stjs.extend(Periodical, CreativeWorkSeries, [], function(constructor, prototype) {
    /**
     *  Schema.org/issn
     *  The International Standard Serial Number (ISSN) that identifies this periodical. You can repeat this property to (for example) identify different formats of this periodical.
     * 
     *  @property issn
     *  @type Text
     */
    prototype.issn = null;
}, {about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/RadioSeries
 *  CreativeWorkSeries dedicated to radio broadcast and associated online delivery.
 * 
 *  @author schema.org
 *  @class RadioSeries
 *  @module org.schema
 *  @extends CreativeWorkSeries
 */
var RadioSeries = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CreativeWorkSeries.call(this);
    this.context = "http://schema.org/";
    this.type = "RadioSeries";
};
RadioSeries = stjs.extend(RadioSeries, CreativeWorkSeries, [], function(constructor, prototype) {
    /**
     *  Schema.org/seasons
     *  A season in a media series.
     * 
     *  @property seasons
     *  @type CreativeWorkSeason
     */
    prototype.seasons = null;
    /**
     *  Schema.org/actor
     *  An actor, e.g. in tv, radio, movie, video games etc., or in an event. Actors can be associated with individual items or with a series, episode, clip.
     * 
     *  @property actor
     *  @type Person
     */
    prototype.actor = null;
    /**
     *  Schema.org/numberOfEpisodes
     *  The number of episodes in this season or series.
     * 
     *  @property numberOfEpisodes
     *  @type Integer
     */
    prototype.numberOfEpisodes = null;
    /**
     *  Schema.org/trailer
     *  The trailer of a movie or tv/radio series, season, episode, etc.
     * 
     *  @property trailer
     *  @type VideoObject
     */
    prototype.trailer = null;
    /**
     *  Schema.org/season
     *  A season in a media series.
     * 
     *  @property season
     *  @type CreativeWorkSeason
     */
    prototype.season = null;
    /**
     *  Schema.org/episodes
     *  An episode of a TV/radio series or season.
     * 
     *  @property episodes
     *  @type Episode
     */
    prototype.episodes = null;
    /**
     *  Schema.org/musicBy
     *  The composer of the soundtrack.
     * 
     *  @property musicBy
     *  @type Person
     */
    prototype.musicBy = null;
    /**
     *  Schema.org/containsSeason
     *  A season that is part of the media series.
     * 
     *  @property containsSeason
     *  @type CreativeWorkSeason
     */
    prototype.containsSeason = null;
    /**
     *  Schema.org/directors
     *  A director of e.g. tv, radio, movie, video games etc. content. Directors can be associated with individual items or with a series, episode, clip.
     * 
     *  @property directors
     *  @type Person
     */
    prototype.directors = null;
    /**
     *  Schema.org/numberOfSeasons
     *  The number of seasons in this series.
     * 
     *  @property numberOfSeasons
     *  @type Integer
     */
    prototype.numberOfSeasons = null;
    /**
     *  Schema.org/director
     *  A director of e.g. tv, radio, movie, video gaming etc. content, or of an event. Directors can be associated with individual items or with a series, episode, clip.
     * 
     *  @property director
     *  @type Person
     */
    prototype.director = null;
    /**
     *  Schema.org/productionCompany
     *  The production company or studio responsible for the item e.g. series, video game, episode etc.
     * 
     *  @property productionCompany
     *  @type Organization
     */
    prototype.productionCompany = null;
    /**
     *  Schema.org/actors
     *  An actor, e.g. in tv, radio, movie, video games etc. Actors can be associated with individual items or with a series, episode, clip.
     * 
     *  @property actors
     *  @type Person
     */
    prototype.actors = null;
    /**
     *  Schema.org/episode
     *  An episode of a tv, radio or game media within a series or season.
     * 
     *  @property episode
     *  @type Episode
     */
    prototype.episode = null;
}, {seasons: "CreativeWorkSeason", actor: "Person", trailer: "VideoObject", season: "CreativeWorkSeason", episodes: "Episode", musicBy: "Person", containsSeason: "CreativeWorkSeason", directors: "Person", director: "Person", productionCompany: "Organization", actors: "Person", episode: "Episode", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/RadioSeason
 *  Season dedicated to radio broadcast and associated online delivery.
 * 
 *  @author schema.org
 *  @class RadioSeason
 *  @module org.schema
 *  @extends CreativeWorkSeason
 */
var RadioSeason = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CreativeWorkSeason.call(this);
    this.context = "http://schema.org/";
    this.type = "RadioSeason";
};
RadioSeason = stjs.extend(RadioSeason, CreativeWorkSeason, [], null, {actor: "Person", partOfSeries: "CreativeWorkSeries", trailer: "VideoObject", episodes: "Episode", director: "Person", productionCompany: "Organization", episode: "Episode", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/CityHall
 *  A city hall.
 * 
 *  @author schema.org
 *  @class CityHall
 *  @module org.schema
 *  @extends GovernmentBuilding
 */
var CityHall = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    GovernmentBuilding.call(this);
    this.context = "http://schema.org/";
    this.type = "CityHall";
};
CityHall = stjs.extend(CityHall, GovernmentBuilding, [], null, {photo: "ImageObject", address: "PostalAddress", openingHoursSpecification: "OpeningHoursSpecification", containedInPlace: "Place", reviews: "Review", aggregateRating: "AggregateRating", photos: "Photograph", hasMap: "SchemaMap", additionalProperty: "PropertyValue", events: "SchemaEvent", specialOpeningHoursSpecification: "OpeningHoursSpecification", amenityFeature: "LocationFeatureSpecification", logo: "ImageObject", geo: "GeoCoordinates", review: "Review", event: "SchemaEvent", containsPlace: "Place", containedIn: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/DefenceEstablishment
 *  A defence establishment, such as an army or navy base.
 * 
 *  @author schema.org
 *  @class DefenceEstablishment
 *  @module org.schema
 *  @extends GovernmentBuilding
 */
var DefenceEstablishment = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    GovernmentBuilding.call(this);
    this.context = "http://schema.org/";
    this.type = "DefenceEstablishment";
};
DefenceEstablishment = stjs.extend(DefenceEstablishment, GovernmentBuilding, [], null, {photo: "ImageObject", address: "PostalAddress", openingHoursSpecification: "OpeningHoursSpecification", containedInPlace: "Place", reviews: "Review", aggregateRating: "AggregateRating", photos: "Photograph", hasMap: "SchemaMap", additionalProperty: "PropertyValue", events: "SchemaEvent", specialOpeningHoursSpecification: "OpeningHoursSpecification", amenityFeature: "LocationFeatureSpecification", logo: "ImageObject", geo: "GeoCoordinates", review: "Review", event: "SchemaEvent", containsPlace: "Place", containedIn: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/LegislativeBuilding
 *  A legislative building&#x2014;for example, the state capitol.
 * 
 *  @author schema.org
 *  @class LegislativeBuilding
 *  @module org.schema
 *  @extends GovernmentBuilding
 */
var LegislativeBuilding = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    GovernmentBuilding.call(this);
    this.context = "http://schema.org/";
    this.type = "LegislativeBuilding";
};
LegislativeBuilding = stjs.extend(LegislativeBuilding, GovernmentBuilding, [], null, {photo: "ImageObject", address: "PostalAddress", openingHoursSpecification: "OpeningHoursSpecification", containedInPlace: "Place", reviews: "Review", aggregateRating: "AggregateRating", photos: "Photograph", hasMap: "SchemaMap", additionalProperty: "PropertyValue", events: "SchemaEvent", specialOpeningHoursSpecification: "OpeningHoursSpecification", amenityFeature: "LocationFeatureSpecification", logo: "ImageObject", geo: "GeoCoordinates", review: "Review", event: "SchemaEvent", containsPlace: "Place", containedIn: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Courthouse
 *  A courthouse.
 * 
 *  @author schema.org
 *  @class Courthouse
 *  @module org.schema
 *  @extends GovernmentBuilding
 */
var Courthouse = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    GovernmentBuilding.call(this);
    this.context = "http://schema.org/";
    this.type = "Courthouse";
};
Courthouse = stjs.extend(Courthouse, GovernmentBuilding, [], null, {photo: "ImageObject", address: "PostalAddress", openingHoursSpecification: "OpeningHoursSpecification", containedInPlace: "Place", reviews: "Review", aggregateRating: "AggregateRating", photos: "Photograph", hasMap: "SchemaMap", additionalProperty: "PropertyValue", events: "SchemaEvent", specialOpeningHoursSpecification: "OpeningHoursSpecification", amenityFeature: "LocationFeatureSpecification", logo: "ImageObject", geo: "GeoCoordinates", review: "Review", event: "SchemaEvent", containsPlace: "Place", containedIn: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Embassy
 *  An embassy.
 * 
 *  @author schema.org
 *  @class Embassy
 *  @module org.schema
 *  @extends GovernmentBuilding
 */
var Embassy = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    GovernmentBuilding.call(this);
    this.context = "http://schema.org/";
    this.type = "Embassy";
};
Embassy = stjs.extend(Embassy, GovernmentBuilding, [], null, {photo: "ImageObject", address: "PostalAddress", openingHoursSpecification: "OpeningHoursSpecification", containedInPlace: "Place", reviews: "Review", aggregateRating: "AggregateRating", photos: "Photograph", hasMap: "SchemaMap", additionalProperty: "PropertyValue", events: "SchemaEvent", specialOpeningHoursSpecification: "OpeningHoursSpecification", amenityFeature: "LocationFeatureSpecification", logo: "ImageObject", geo: "GeoCoordinates", review: "Review", event: "SchemaEvent", containsPlace: "Place", containedIn: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/HinduTemple
 *  A Hindu temple.
 * 
 *  @author schema.org
 *  @class HinduTemple
 *  @module org.schema
 *  @extends PlaceOfWorship
 */
var HinduTemple = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    PlaceOfWorship.call(this);
    this.context = "http://schema.org/";
    this.type = "HinduTemple";
};
HinduTemple = stjs.extend(HinduTemple, PlaceOfWorship, [], null, {photo: "ImageObject", address: "PostalAddress", openingHoursSpecification: "OpeningHoursSpecification", containedInPlace: "Place", reviews: "Review", aggregateRating: "AggregateRating", photos: "Photograph", hasMap: "SchemaMap", additionalProperty: "PropertyValue", events: "SchemaEvent", specialOpeningHoursSpecification: "OpeningHoursSpecification", amenityFeature: "LocationFeatureSpecification", logo: "ImageObject", geo: "GeoCoordinates", review: "Review", event: "SchemaEvent", containsPlace: "Place", containedIn: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Synagogue
 *  A synagogue.
 * 
 *  @author schema.org
 *  @class Synagogue
 *  @module org.schema
 *  @extends PlaceOfWorship
 */
var Synagogue = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    PlaceOfWorship.call(this);
    this.context = "http://schema.org/";
    this.type = "Synagogue";
};
Synagogue = stjs.extend(Synagogue, PlaceOfWorship, [], null, {photo: "ImageObject", address: "PostalAddress", openingHoursSpecification: "OpeningHoursSpecification", containedInPlace: "Place", reviews: "Review", aggregateRating: "AggregateRating", photos: "Photograph", hasMap: "SchemaMap", additionalProperty: "PropertyValue", events: "SchemaEvent", specialOpeningHoursSpecification: "OpeningHoursSpecification", amenityFeature: "LocationFeatureSpecification", logo: "ImageObject", geo: "GeoCoordinates", review: "Review", event: "SchemaEvent", containsPlace: "Place", containedIn: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Church
 *  A church.
 * 
 *  @author schema.org
 *  @class Church
 *  @module org.schema
 *  @extends PlaceOfWorship
 */
var Church = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    PlaceOfWorship.call(this);
    this.context = "http://schema.org/";
    this.type = "Church";
};
Church = stjs.extend(Church, PlaceOfWorship, [], null, {photo: "ImageObject", address: "PostalAddress", openingHoursSpecification: "OpeningHoursSpecification", containedInPlace: "Place", reviews: "Review", aggregateRating: "AggregateRating", photos: "Photograph", hasMap: "SchemaMap", additionalProperty: "PropertyValue", events: "SchemaEvent", specialOpeningHoursSpecification: "OpeningHoursSpecification", amenityFeature: "LocationFeatureSpecification", logo: "ImageObject", geo: "GeoCoordinates", review: "Review", event: "SchemaEvent", containsPlace: "Place", containedIn: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/BuddhistTemple
 *  A Buddhist temple.
 * 
 *  @author schema.org
 *  @class BuddhistTemple
 *  @module org.schema
 *  @extends PlaceOfWorship
 */
var BuddhistTemple = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    PlaceOfWorship.call(this);
    this.context = "http://schema.org/";
    this.type = "BuddhistTemple";
};
BuddhistTemple = stjs.extend(BuddhistTemple, PlaceOfWorship, [], null, {photo: "ImageObject", address: "PostalAddress", openingHoursSpecification: "OpeningHoursSpecification", containedInPlace: "Place", reviews: "Review", aggregateRating: "AggregateRating", photos: "Photograph", hasMap: "SchemaMap", additionalProperty: "PropertyValue", events: "SchemaEvent", specialOpeningHoursSpecification: "OpeningHoursSpecification", amenityFeature: "LocationFeatureSpecification", logo: "ImageObject", geo: "GeoCoordinates", review: "Review", event: "SchemaEvent", containsPlace: "Place", containedIn: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Mosque
 *  A mosque.
 * 
 *  @author schema.org
 *  @class Mosque
 *  @module org.schema
 *  @extends PlaceOfWorship
 */
var Mosque = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    PlaceOfWorship.call(this);
    this.context = "http://schema.org/";
    this.type = "Mosque";
};
Mosque = stjs.extend(Mosque, PlaceOfWorship, [], null, {photo: "ImageObject", address: "PostalAddress", openingHoursSpecification: "OpeningHoursSpecification", containedInPlace: "Place", reviews: "Review", aggregateRating: "AggregateRating", photos: "Photograph", hasMap: "SchemaMap", additionalProperty: "PropertyValue", events: "SchemaEvent", specialOpeningHoursSpecification: "OpeningHoursSpecification", amenityFeature: "LocationFeatureSpecification", logo: "ImageObject", geo: "GeoCoordinates", review: "Review", event: "SchemaEvent", containsPlace: "Place", containedIn: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/CatholicChurch
 *  A Catholic church.
 * 
 *  @author schema.org
 *  @class CatholicChurch
 *  @module org.schema
 *  @extends PlaceOfWorship
 */
var CatholicChurch = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    PlaceOfWorship.call(this);
    this.context = "http://schema.org/";
    this.type = "CatholicChurch";
};
CatholicChurch = stjs.extend(CatholicChurch, PlaceOfWorship, [], null, {photo: "ImageObject", address: "PostalAddress", openingHoursSpecification: "OpeningHoursSpecification", containedInPlace: "Place", reviews: "Review", aggregateRating: "AggregateRating", photos: "Photograph", hasMap: "SchemaMap", additionalProperty: "PropertyValue", events: "SchemaEvent", specialOpeningHoursSpecification: "OpeningHoursSpecification", amenityFeature: "LocationFeatureSpecification", logo: "ImageObject", geo: "GeoCoordinates", review: "Review", event: "SchemaEvent", containsPlace: "Place", containedIn: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/MeetingRoom
 *  A meeting room, conference room, or conference hall is a room provided for singular events such as business conferences and meetings (Source: Wikipedia, the free encyclopedia, see <a href="http://en.wikipedia.org/wiki/Conference_hall">http://en.wikipedia.org/wiki/Conference_hall</a>).
 *  <br /><br />
 *  See also the <a href="/docs/hotels.html">dedicated document on the use of schema.org for marking up hotels and other forms of accommodations</a>.
 * 
 *  @author schema.org
 *  @class MeetingRoom
 *  @module org.schema
 *  @extends Room
 */
var MeetingRoom = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Room.call(this);
    this.context = "http://schema.org/";
    this.type = "MeetingRoom";
};
MeetingRoom = stjs.extend(MeetingRoom, Room, [], null, {floorSize: "QuantitativeValue", amenityFeature: "LocationFeatureSpecification", photo: "ImageObject", address: "PostalAddress", openingHoursSpecification: "OpeningHoursSpecification", containedInPlace: "Place", reviews: "Review", aggregateRating: "AggregateRating", photos: "Photograph", hasMap: "SchemaMap", additionalProperty: "PropertyValue", events: "SchemaEvent", specialOpeningHoursSpecification: "OpeningHoursSpecification", amenityFeature: "LocationFeatureSpecification", logo: "ImageObject", geo: "GeoCoordinates", review: "Review", event: "SchemaEvent", containsPlace: "Place", containedIn: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/HotelRoom
 *  A hotel room is a single room in a hotel.
 *  <br /><br />
 *  See also the <a href="/docs/hotels.html">dedicated document on the use of schema.org for marking up hotels and other forms of accommodations</a>.
 * 
 *  @author schema.org
 *  @class HotelRoom
 *  @module org.schema
 *  @extends Room
 */
var HotelRoom = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Room.call(this);
    this.context = "http://schema.org/";
    this.type = "HotelRoom";
};
HotelRoom = stjs.extend(HotelRoom, Room, [], function(constructor, prototype) {
    /**
     *  Schema.org/occupancy
     *  The allowed total occupancy for the accommodation in persons (including infants etc). For individual accommodations, this is not necessarily the legal maximum but defines the permitted usage as per the contractual agreement (e.g. a double room used by a single person).
     *  Typical unit code(s): C62 for person
     * 
     *  @property occupancy
     *  @type QuantitativeValue
     */
    prototype.occupancy = null;
    /**
     *  Schema.org/bed
     *  The type of bed or beds included in the accommodation. For the single case of just one bed of a certain type, you use bed directly with a text.
     *  If you want to indicate the quantity of a certain kind of bed, use an instance of BedDetails. For more detailed information, use the amenityFeature property.
     * 
     *  @property bed
     *  @type BedDetails
     */
    prototype.bed = null;
}, {occupancy: "QuantitativeValue", bed: "BedDetails", floorSize: "QuantitativeValue", amenityFeature: "LocationFeatureSpecification", photo: "ImageObject", address: "PostalAddress", openingHoursSpecification: "OpeningHoursSpecification", containedInPlace: "Place", reviews: "Review", aggregateRating: "AggregateRating", photos: "Photograph", hasMap: "SchemaMap", additionalProperty: "PropertyValue", events: "SchemaEvent", specialOpeningHoursSpecification: "OpeningHoursSpecification", amenityFeature: "LocationFeatureSpecification", logo: "ImageObject", geo: "GeoCoordinates", review: "Review", event: "SchemaEvent", containsPlace: "Place", containedIn: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/SingleFamilyResidence
 *  Residence type: Single-family home.
 * 
 *  @author schema.org
 *  @class SingleFamilyResidence
 *  @module org.schema
 *  @extends House
 */
var SingleFamilyResidence = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    House.call(this);
    this.context = "http://schema.org/";
    this.type = "SingleFamilyResidence";
};
SingleFamilyResidence = stjs.extend(SingleFamilyResidence, House, [], function(constructor, prototype) {
    /**
     *  Schema.org/occupancy
     *  The allowed total occupancy for the accommodation in persons (including infants etc). For individual accommodations, this is not necessarily the legal maximum but defines the permitted usage as per the contractual agreement (e.g. a double room used by a single person).
     *  Typical unit code(s): C62 for person
     * 
     *  @property occupancy
     *  @type QuantitativeValue
     */
    prototype.occupancy = null;
    /**
     *  Schema.org/numberOfRooms
     *  The number of rooms (excluding bathrooms and closets) of the acccommodation or lodging business.
     *  Typical unit code(s): ROM for room or C62 for no unit. The type of room can be put in the unitText property of the QuantitativeValue.
     * 
     *  @property numberOfRooms
     *  @type Number
     */
    prototype.numberOfRooms = null;
}, {occupancy: "QuantitativeValue", floorSize: "QuantitativeValue", amenityFeature: "LocationFeatureSpecification", photo: "ImageObject", address: "PostalAddress", openingHoursSpecification: "OpeningHoursSpecification", containedInPlace: "Place", reviews: "Review", aggregateRating: "AggregateRating", photos: "Photograph", hasMap: "SchemaMap", additionalProperty: "PropertyValue", events: "SchemaEvent", specialOpeningHoursSpecification: "OpeningHoursSpecification", amenityFeature: "LocationFeatureSpecification", logo: "ImageObject", geo: "GeoCoordinates", review: "Review", event: "SchemaEvent", containsPlace: "Place", containedIn: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/LakeBodyOfWater
 *  A lake (for example, Lake Pontrachain).
 * 
 *  @author schema.org
 *  @class LakeBodyOfWater
 *  @module org.schema
 *  @extends BodyOfWater
 */
var LakeBodyOfWater = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    BodyOfWater.call(this);
    this.context = "http://schema.org/";
    this.type = "LakeBodyOfWater";
};
LakeBodyOfWater = stjs.extend(LakeBodyOfWater, BodyOfWater, [], null, {photo: "ImageObject", address: "PostalAddress", openingHoursSpecification: "OpeningHoursSpecification", containedInPlace: "Place", reviews: "Review", aggregateRating: "AggregateRating", photos: "Photograph", hasMap: "SchemaMap", additionalProperty: "PropertyValue", events: "SchemaEvent", specialOpeningHoursSpecification: "OpeningHoursSpecification", amenityFeature: "LocationFeatureSpecification", logo: "ImageObject", geo: "GeoCoordinates", review: "Review", event: "SchemaEvent", containsPlace: "Place", containedIn: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/RiverBodyOfWater
 *  A river (for example, the broad majestic Shannon).
 * 
 *  @author schema.org
 *  @class RiverBodyOfWater
 *  @module org.schema
 *  @extends BodyOfWater
 */
var RiverBodyOfWater = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    BodyOfWater.call(this);
    this.context = "http://schema.org/";
    this.type = "RiverBodyOfWater";
};
RiverBodyOfWater = stjs.extend(RiverBodyOfWater, BodyOfWater, [], null, {photo: "ImageObject", address: "PostalAddress", openingHoursSpecification: "OpeningHoursSpecification", containedInPlace: "Place", reviews: "Review", aggregateRating: "AggregateRating", photos: "Photograph", hasMap: "SchemaMap", additionalProperty: "PropertyValue", events: "SchemaEvent", specialOpeningHoursSpecification: "OpeningHoursSpecification", amenityFeature: "LocationFeatureSpecification", logo: "ImageObject", geo: "GeoCoordinates", review: "Review", event: "SchemaEvent", containsPlace: "Place", containedIn: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/OceanBodyOfWater
 *  An ocean (for example, the Pacific).
 * 
 *  @author schema.org
 *  @class OceanBodyOfWater
 *  @module org.schema
 *  @extends BodyOfWater
 */
var OceanBodyOfWater = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    BodyOfWater.call(this);
    this.context = "http://schema.org/";
    this.type = "OceanBodyOfWater";
};
OceanBodyOfWater = stjs.extend(OceanBodyOfWater, BodyOfWater, [], null, {photo: "ImageObject", address: "PostalAddress", openingHoursSpecification: "OpeningHoursSpecification", containedInPlace: "Place", reviews: "Review", aggregateRating: "AggregateRating", photos: "Photograph", hasMap: "SchemaMap", additionalProperty: "PropertyValue", events: "SchemaEvent", specialOpeningHoursSpecification: "OpeningHoursSpecification", amenityFeature: "LocationFeatureSpecification", logo: "ImageObject", geo: "GeoCoordinates", review: "Review", event: "SchemaEvent", containsPlace: "Place", containedIn: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Reservoir
 *  A reservoir of water, typically an artificially created lake, like the Lake Kariba reservoir.
 * 
 *  @author schema.org
 *  @class Reservoir
 *  @module org.schema
 *  @extends BodyOfWater
 */
var Reservoir = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    BodyOfWater.call(this);
    this.context = "http://schema.org/";
    this.type = "Reservoir";
};
Reservoir = stjs.extend(Reservoir, BodyOfWater, [], null, {photo: "ImageObject", address: "PostalAddress", openingHoursSpecification: "OpeningHoursSpecification", containedInPlace: "Place", reviews: "Review", aggregateRating: "AggregateRating", photos: "Photograph", hasMap: "SchemaMap", additionalProperty: "PropertyValue", events: "SchemaEvent", specialOpeningHoursSpecification: "OpeningHoursSpecification", amenityFeature: "LocationFeatureSpecification", logo: "ImageObject", geo: "GeoCoordinates", review: "Review", event: "SchemaEvent", containsPlace: "Place", containedIn: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/SeaBodyOfWater
 *  A sea (for example, the Caspian sea).
 * 
 *  @author schema.org
 *  @class SeaBodyOfWater
 *  @module org.schema
 *  @extends BodyOfWater
 */
var SeaBodyOfWater = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    BodyOfWater.call(this);
    this.context = "http://schema.org/";
    this.type = "SeaBodyOfWater";
};
SeaBodyOfWater = stjs.extend(SeaBodyOfWater, BodyOfWater, [], null, {photo: "ImageObject", address: "PostalAddress", openingHoursSpecification: "OpeningHoursSpecification", containedInPlace: "Place", reviews: "Review", aggregateRating: "AggregateRating", photos: "Photograph", hasMap: "SchemaMap", additionalProperty: "PropertyValue", events: "SchemaEvent", specialOpeningHoursSpecification: "OpeningHoursSpecification", amenityFeature: "LocationFeatureSpecification", logo: "ImageObject", geo: "GeoCoordinates", review: "Review", event: "SchemaEvent", containsPlace: "Place", containedIn: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Canal
 *  A canal, like the Panama Canal.
 * 
 *  @author schema.org
 *  @class Canal
 *  @module org.schema
 *  @extends BodyOfWater
 */
var Canal = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    BodyOfWater.call(this);
    this.context = "http://schema.org/";
    this.type = "Canal";
};
Canal = stjs.extend(Canal, BodyOfWater, [], null, {photo: "ImageObject", address: "PostalAddress", openingHoursSpecification: "OpeningHoursSpecification", containedInPlace: "Place", reviews: "Review", aggregateRating: "AggregateRating", photos: "Photograph", hasMap: "SchemaMap", additionalProperty: "PropertyValue", events: "SchemaEvent", specialOpeningHoursSpecification: "OpeningHoursSpecification", amenityFeature: "LocationFeatureSpecification", logo: "ImageObject", geo: "GeoCoordinates", review: "Review", event: "SchemaEvent", containsPlace: "Place", containedIn: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Pond
 *  A pond.
 * 
 *  @author schema.org
 *  @class Pond
 *  @module org.schema
 *  @extends BodyOfWater
 */
var Pond = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    BodyOfWater.call(this);
    this.context = "http://schema.org/";
    this.type = "Pond";
};
Pond = stjs.extend(Pond, BodyOfWater, [], null, {photo: "ImageObject", address: "PostalAddress", openingHoursSpecification: "OpeningHoursSpecification", containedInPlace: "Place", reviews: "Review", aggregateRating: "AggregateRating", photos: "Photograph", hasMap: "SchemaMap", additionalProperty: "PropertyValue", events: "SchemaEvent", specialOpeningHoursSpecification: "OpeningHoursSpecification", amenityFeature: "LocationFeatureSpecification", logo: "ImageObject", geo: "GeoCoordinates", review: "Review", event: "SchemaEvent", containsPlace: "Place", containedIn: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Waterfall
 *  A waterfall, like Niagara.
 * 
 *  @author schema.org
 *  @class Waterfall
 *  @module org.schema
 *  @extends BodyOfWater
 */
var Waterfall = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    BodyOfWater.call(this);
    this.context = "http://schema.org/";
    this.type = "Waterfall";
};
Waterfall = stjs.extend(Waterfall, BodyOfWater, [], null, {photo: "ImageObject", address: "PostalAddress", openingHoursSpecification: "OpeningHoursSpecification", containedInPlace: "Place", reviews: "Review", aggregateRating: "AggregateRating", photos: "Photograph", hasMap: "SchemaMap", additionalProperty: "PropertyValue", events: "SchemaEvent", specialOpeningHoursSpecification: "OpeningHoursSpecification", amenityFeature: "LocationFeatureSpecification", logo: "ImageObject", geo: "GeoCoordinates", review: "Review", event: "SchemaEvent", containsPlace: "Place", containedIn: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/InsertAction
 *  The act of adding at a specific location in an ordered collection.
 * 
 *  @author schema.org
 *  @class InsertAction
 *  @module org.schema
 *  @extends AddAction
 */
var InsertAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    AddAction.call(this);
    this.context = "http://schema.org/";
    this.type = "InsertAction";
};
InsertAction = stjs.extend(InsertAction, AddAction, [], function(constructor, prototype) {
    /**
     *  Schema.org/toLocation
     *  A sub property of location. The final location of the object or the agent after the action.
     * 
     *  @property toLocation
     *  @type Place
     */
    prototype.toLocation = null;
}, {toLocation: "Place", collection: "Thing", targetCollection: "Thing", result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/CommentAction
 *  The act of generating a comment about a subject.
 * 
 *  @author schema.org
 *  @class CommentAction
 *  @module org.schema
 *  @extends CommunicateAction
 */
var CommentAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CommunicateAction.call(this);
    this.context = "http://schema.org/";
    this.type = "CommentAction";
};
CommentAction = stjs.extend(CommentAction, CommunicateAction, [], function(constructor, prototype) {
    /**
     *  Schema.org/resultComment
     *  A sub property of result. The Comment created or sent as a result of this action.
     * 
     *  @property resultComment
     *  @type Comment
     */
    prototype.resultComment = null;
}, {resultComment: "Comment", about: "Thing", recipient: "Organization", inLanguage: "Language", language: "Language", result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/AskAction
 *  The act of posing a question / favor to someone.\n\nRelated actions:\n\n* [[ReplyAction]]: Appears generally as a response to AskAction.
 * 
 *  @author schema.org
 *  @class AskAction
 *  @module org.schema
 *  @extends CommunicateAction
 */
var AskAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CommunicateAction.call(this);
    this.context = "http://schema.org/";
    this.type = "AskAction";
};
AskAction = stjs.extend(AskAction, CommunicateAction, [], function(constructor, prototype) {
    /**
     *  Schema.org/question
     *  A sub property of object. A question.
     * 
     *  @property question
     *  @type Question
     */
    prototype.question = null;
}, {question: "Question", about: "Thing", recipient: "Organization", inLanguage: "Language", language: "Language", result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/CheckOutAction
 *  The act of an agent communicating (service provider, social media, etc) their departure of a previously reserved service (e.g. flight check in) or place (e.g. hotel).\n\nRelated actions:\n\n* [[CheckInAction]]: The antonym of CheckOutAction.\n* [[DepartAction]]: Unlike DepartAction, CheckOutAction implies that the agent is informing/confirming the end of a previously reserved service.\n* [[CancelAction]]: Unlike CancelAction, CheckOutAction implies that the agent is informing/confirming the end of a previously reserved service.
 * 
 *  @author schema.org
 *  @class CheckOutAction
 *  @module org.schema
 *  @extends CommunicateAction
 */
var CheckOutAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CommunicateAction.call(this);
    this.context = "http://schema.org/";
    this.type = "CheckOutAction";
};
CheckOutAction = stjs.extend(CheckOutAction, CommunicateAction, [], null, {about: "Thing", recipient: "Organization", inLanguage: "Language", language: "Language", result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/ShareAction
 *  The act of distributing content to people for their amusement or edification.
 * 
 *  @author schema.org
 *  @class ShareAction
 *  @module org.schema
 *  @extends CommunicateAction
 */
var ShareAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CommunicateAction.call(this);
    this.context = "http://schema.org/";
    this.type = "ShareAction";
};
ShareAction = stjs.extend(ShareAction, CommunicateAction, [], null, {about: "Thing", recipient: "Organization", inLanguage: "Language", language: "Language", result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/InformAction
 *  The act of notifying someone of information pertinent to them, with no expectation of a response.
 * 
 *  @author schema.org
 *  @class InformAction
 *  @module org.schema
 *  @extends CommunicateAction
 */
var InformAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CommunicateAction.call(this);
    this.context = "http://schema.org/";
    this.type = "InformAction";
};
InformAction = stjs.extend(InformAction, CommunicateAction, [], function(constructor, prototype) {
    /**
     *  Schema.org/event
     *  Upcoming or past event associated with this place, organization, or action.
     * 
     *  @property event
     *  @type SchemaEvent
     */
    prototype.event = null;
}, {event: "SchemaEvent", about: "Thing", recipient: "Organization", inLanguage: "Language", language: "Language", result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/CheckInAction
 *  The act of an agent communicating (service provider, social media, etc) their arrival by registering/confirming for a previously reserved service (e.g. flight check in) or at a place (e.g. hotel), possibly resulting in a result (boarding pass, etc).\n\nRelated actions:\n\n* [[CheckOutAction]]: The antonym of CheckInAction.\n* [[ArriveAction]]: Unlike ArriveAction, CheckInAction implies that the agent is informing/confirming the start of a previously reserved service.\n* [[ConfirmAction]]: Unlike ConfirmAction, CheckInAction implies that the agent is informing/confirming the *start* of a previously reserved service rather than its validity/existence.
 * 
 *  @author schema.org
 *  @class CheckInAction
 *  @module org.schema
 *  @extends CommunicateAction
 */
var CheckInAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CommunicateAction.call(this);
    this.context = "http://schema.org/";
    this.type = "CheckInAction";
};
CheckInAction = stjs.extend(CheckInAction, CommunicateAction, [], null, {about: "Thing", recipient: "Organization", inLanguage: "Language", language: "Language", result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/ReplyAction
 *  The act of responding to a question/message asked/sent by the object. Related to [[AskAction]]\n\nRelated actions:\n\n* [[AskAction]]: Appears generally as an origin of a ReplyAction.
 * 
 *  @author schema.org
 *  @class ReplyAction
 *  @module org.schema
 *  @extends CommunicateAction
 */
var ReplyAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CommunicateAction.call(this);
    this.context = "http://schema.org/";
    this.type = "ReplyAction";
};
ReplyAction = stjs.extend(ReplyAction, CommunicateAction, [], function(constructor, prototype) {
    /**
     *  Schema.org/resultComment
     *  A sub property of result. The Comment created or sent as a result of this action.
     * 
     *  @property resultComment
     *  @type Comment
     */
    prototype.resultComment = null;
}, {resultComment: "Comment", about: "Thing", recipient: "Organization", inLanguage: "Language", language: "Language", result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/InviteAction
 *  The act of asking someone to attend an event. Reciprocal of RsvpAction.
 * 
 *  @author schema.org
 *  @class InviteAction
 *  @module org.schema
 *  @extends CommunicateAction
 */
var InviteAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CommunicateAction.call(this);
    this.context = "http://schema.org/";
    this.type = "InviteAction";
};
InviteAction = stjs.extend(InviteAction, CommunicateAction, [], function(constructor, prototype) {
    /**
     *  Schema.org/event
     *  Upcoming or past event associated with this place, organization, or action.
     * 
     *  @property event
     *  @type SchemaEvent
     */
    prototype.event = null;
}, {event: "SchemaEvent", about: "Thing", recipient: "Organization", inLanguage: "Language", language: "Language", result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/RejectAction
 *  The act of rejecting to/adopting an object.\n\nRelated actions:\n\n* [[AcceptAction]]: The antonym of RejectAction.
 * 
 *  @author schema.org
 *  @class RejectAction
 *  @module org.schema
 *  @extends AllocateAction
 */
var RejectAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    AllocateAction.call(this);
    this.context = "http://schema.org/";
    this.type = "RejectAction";
};
RejectAction = stjs.extend(RejectAction, AllocateAction, [], null, {result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/AcceptAction
 *  The act of committing to/adopting an object.\n\nRelated actions:\n\n* [[RejectAction]]: The antonym of AcceptAction.
 * 
 *  @author schema.org
 *  @class AcceptAction
 *  @module org.schema
 *  @extends AllocateAction
 */
var AcceptAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    AllocateAction.call(this);
    this.context = "http://schema.org/";
    this.type = "AcceptAction";
};
AcceptAction = stjs.extend(AcceptAction, AllocateAction, [], null, {result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/AuthorizeAction
 *  The act of granting permission to an object.
 * 
 *  @author schema.org
 *  @class AuthorizeAction
 *  @module org.schema
 *  @extends AllocateAction
 */
var AuthorizeAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    AllocateAction.call(this);
    this.context = "http://schema.org/";
    this.type = "AuthorizeAction";
};
AuthorizeAction = stjs.extend(AuthorizeAction, AllocateAction, [], function(constructor, prototype) {
    /**
     *  Schema.org/recipient
     *  A sub property of participant. The participant who is at the receiving end of the action.
     * 
     *  @property recipient
     *  @type Organization
     */
    prototype.recipient = null;
}, {recipient: "Organization", result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/AssignAction
 *  The act of allocating an action/event/task to some destination (someone or something).
 * 
 *  @author schema.org
 *  @class AssignAction
 *  @module org.schema
 *  @extends AllocateAction
 */
var AssignAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    AllocateAction.call(this);
    this.context = "http://schema.org/";
    this.type = "AssignAction";
};
AssignAction = stjs.extend(AssignAction, AllocateAction, [], null, {result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/ScheduleAction
 *  Scheduling future actions, events, or tasks.\n\nRelated actions:\n\n* [[ReserveAction]]: Unlike ReserveAction, ScheduleAction allocates future actions (e.g. an event, a task, etc) towards a time slot / spatial allocation.
 * 
 *  @author schema.org
 *  @class ScheduleAction
 *  @module org.schema
 *  @extends PlanAction
 */
var ScheduleAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    PlanAction.call(this);
    this.context = "http://schema.org/";
    this.type = "ScheduleAction";
};
ScheduleAction = stjs.extend(ScheduleAction, PlanAction, [], null, {result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/CancelAction
 *  The act of asserting that a future event/action is no longer going to happen.\n\nRelated actions:\n\n* [[ConfirmAction]]: The antonym of CancelAction.
 * 
 *  @author schema.org
 *  @class CancelAction
 *  @module org.schema
 *  @extends PlanAction
 */
var CancelAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    PlanAction.call(this);
    this.context = "http://schema.org/";
    this.type = "CancelAction";
};
CancelAction = stjs.extend(CancelAction, PlanAction, [], null, {result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/ReserveAction
 *  Reserving a concrete object.\n\nRelated actions:\n\n* [[ScheduleAction]]</a>: Unlike ScheduleAction, ReserveAction reserves concrete objects (e.g. a table, a hotel) towards a time slot / spatial allocation.
 * 
 *  @author schema.org
 *  @class ReserveAction
 *  @module org.schema
 *  @extends PlanAction
 */
var ReserveAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    PlanAction.call(this);
    this.context = "http://schema.org/";
    this.type = "ReserveAction";
};
ReserveAction = stjs.extend(ReserveAction, PlanAction, [], null, {result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/VoteAction
 *  The act of expressing a preference from a fixed/finite/structured set of choices/options.
 * 
 *  @author schema.org
 *  @class VoteAction
 *  @module org.schema
 *  @extends ChooseAction
 */
var VoteAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    ChooseAction.call(this);
    this.context = "http://schema.org/";
    this.type = "VoteAction";
};
VoteAction = stjs.extend(VoteAction, ChooseAction, [], function(constructor, prototype) {
    /**
     *  Schema.org/candidate
     *  A sub property of object. The candidate subject of this action.
     * 
     *  @property candidate
     *  @type Person
     */
    prototype.candidate = null;
}, {candidate: "Person", result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/DisagreeAction
 *  The act of expressing a difference of opinion with the object. An agent disagrees to/about an object (a proposition, topic or theme) with participants.
 * 
 *  @author schema.org
 *  @class DisagreeAction
 *  @module org.schema
 *  @extends ReactAction
 */
var DisagreeAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    ReactAction.call(this);
    this.context = "http://schema.org/";
    this.type = "DisagreeAction";
};
DisagreeAction = stjs.extend(DisagreeAction, ReactAction, [], null, {result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/DislikeAction
 *  The act of expressing a negative sentiment about the object. An agent dislikes an object (a proposition, topic or theme) with participants.
 * 
 *  @author schema.org
 *  @class DislikeAction
 *  @module org.schema
 *  @extends ReactAction
 */
var DislikeAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    ReactAction.call(this);
    this.context = "http://schema.org/";
    this.type = "DislikeAction";
};
DislikeAction = stjs.extend(DislikeAction, ReactAction, [], null, {result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/EndorseAction
 *  An agent approves/certifies/likes/supports/sanction an object.
 * 
 *  @author schema.org
 *  @class EndorseAction
 *  @module org.schema
 *  @extends ReactAction
 */
var EndorseAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    ReactAction.call(this);
    this.context = "http://schema.org/";
    this.type = "EndorseAction";
};
EndorseAction = stjs.extend(EndorseAction, ReactAction, [], function(constructor, prototype) {
    /**
     *  Schema.org/endorsee
     *  A sub property of participant. The person/organization being supported.
     * 
     *  @property endorsee
     *  @type Organization
     */
    prototype.endorsee = null;
}, {endorsee: "Organization", result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/AgreeAction
 *  The act of expressing a consistency of opinion with the object. An agent agrees to/about an object (a proposition, topic or theme) with participants.
 * 
 *  @author schema.org
 *  @class AgreeAction
 *  @module org.schema
 *  @extends ReactAction
 */
var AgreeAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    ReactAction.call(this);
    this.context = "http://schema.org/";
    this.type = "AgreeAction";
};
AgreeAction = stjs.extend(AgreeAction, ReactAction, [], null, {result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/WantAction
 *  The act of expressing a desire about the object. An agent wants an object.
 * 
 *  @author schema.org
 *  @class WantAction
 *  @module org.schema
 *  @extends ReactAction
 */
var WantAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    ReactAction.call(this);
    this.context = "http://schema.org/";
    this.type = "WantAction";
};
WantAction = stjs.extend(WantAction, ReactAction, [], null, {result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/LikeAction
 *  The act of expressing a positive sentiment about the object. An agent likes an object (a proposition, topic or theme) with participants.
 * 
 *  @author schema.org
 *  @class LikeAction
 *  @module org.schema
 *  @extends ReactAction
 */
var LikeAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    ReactAction.call(this);
    this.context = "http://schema.org/";
    this.type = "LikeAction";
};
LikeAction = stjs.extend(LikeAction, ReactAction, [], null, {result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/WearAction
 *  The act of dressing oneself in clothing.
 * 
 *  @author schema.org
 *  @class WearAction
 *  @module org.schema
 *  @extends UseAction
 */
var WearAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    UseAction.call(this);
    this.context = "http://schema.org/";
    this.type = "WearAction";
};
WearAction = stjs.extend(WearAction, UseAction, [], null, {expectsAcceptanceOf: "Offer", result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/PostOffice
 *  A post office.
 * 
 *  @author schema.org
 *  @class PostOffice
 *  @module org.schema
 *  @extends GovernmentOffice
 */
var PostOffice = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    GovernmentOffice.call(this);
    this.context = "http://schema.org/";
    this.type = "PostOffice";
};
PostOffice = stjs.extend(PostOffice, GovernmentOffice, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/CafeOrCoffeeShop
 *  A cafe or coffee shop.
 * 
 *  @author schema.org
 *  @class CafeOrCoffeeShop
 *  @module org.schema
 *  @extends FoodEstablishment
 */
var CafeOrCoffeeShop = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    FoodEstablishment.call(this);
    this.context = "http://schema.org/";
    this.type = "CafeOrCoffeeShop";
};
CafeOrCoffeeShop = stjs.extend(CafeOrCoffeeShop, FoodEstablishment, [], null, {menu: "Menu", starRating: "Rating", branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Bakery
 *  A bakery.
 * 
 *  @author schema.org
 *  @class Bakery
 *  @module org.schema
 *  @extends FoodEstablishment
 */
var Bakery = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    FoodEstablishment.call(this);
    this.context = "http://schema.org/";
    this.type = "Bakery";
};
Bakery = stjs.extend(Bakery, FoodEstablishment, [], null, {menu: "Menu", starRating: "Rating", branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/IceCreamShop
 *  An ice cream shop.
 * 
 *  @author schema.org
 *  @class IceCreamShop
 *  @module org.schema
 *  @extends FoodEstablishment
 */
var IceCreamShop = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    FoodEstablishment.call(this);
    this.context = "http://schema.org/";
    this.type = "IceCreamShop";
};
IceCreamShop = stjs.extend(IceCreamShop, FoodEstablishment, [], null, {menu: "Menu", starRating: "Rating", branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Brewery
 *  Brewery.
 * 
 *  @author schema.org
 *  @class Brewery
 *  @module org.schema
 *  @extends FoodEstablishment
 */
var Brewery = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    FoodEstablishment.call(this);
    this.context = "http://schema.org/";
    this.type = "Brewery";
};
Brewery = stjs.extend(Brewery, FoodEstablishment, [], null, {menu: "Menu", starRating: "Rating", branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/FastFoodRestaurant
 *  A fast-food restaurant.
 * 
 *  @author schema.org
 *  @class FastFoodRestaurant
 *  @module org.schema
 *  @extends FoodEstablishment
 */
var FastFoodRestaurant = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    FoodEstablishment.call(this);
    this.context = "http://schema.org/";
    this.type = "FastFoodRestaurant";
};
FastFoodRestaurant = stjs.extend(FastFoodRestaurant, FoodEstablishment, [], null, {menu: "Menu", starRating: "Rating", branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/BarOrPub
 *  A bar or pub.
 * 
 *  @author schema.org
 *  @class BarOrPub
 *  @module org.schema
 *  @extends FoodEstablishment
 */
var BarOrPub = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    FoodEstablishment.call(this);
    this.context = "http://schema.org/";
    this.type = "BarOrPub";
};
BarOrPub = stjs.extend(BarOrPub, FoodEstablishment, [], null, {menu: "Menu", starRating: "Rating", branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Restaurant
 *  A restaurant.
 * 
 *  @author schema.org
 *  @class Restaurant
 *  @module org.schema
 *  @extends FoodEstablishment
 */
var Restaurant = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    FoodEstablishment.call(this);
    this.context = "http://schema.org/";
    this.type = "Restaurant";
};
Restaurant = stjs.extend(Restaurant, FoodEstablishment, [], null, {menu: "Menu", starRating: "Rating", branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Winery
 *  A winery.
 * 
 *  @author schema.org
 *  @class Winery
 *  @module org.schema
 *  @extends FoodEstablishment
 */
var Winery = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    FoodEstablishment.call(this);
    this.context = "http://schema.org/";
    this.type = "Winery";
};
Winery = stjs.extend(Winery, FoodEstablishment, [], null, {menu: "Menu", starRating: "Rating", branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/StadiumOrArena
 *  A stadium.
 * 
 *  @author schema.org
 *  @class StadiumOrArena
 *  @module org.schema
 *  @extends SportsActivityLocation
 */
var StadiumOrArena = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    SportsActivityLocation.call(this);
    this.context = "http://schema.org/";
    this.type = "StadiumOrArena";
};
StadiumOrArena = stjs.extend(StadiumOrArena, SportsActivityLocation, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/SportsClub
 *  A sports club.
 * 
 *  @author schema.org
 *  @class SportsClub
 *  @module org.schema
 *  @extends SportsActivityLocation
 */
var SportsClub = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    SportsActivityLocation.call(this);
    this.context = "http://schema.org/";
    this.type = "SportsClub";
};
SportsClub = stjs.extend(SportsClub, SportsActivityLocation, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/GolfCourse
 *  A golf course.
 * 
 *  @author schema.org
 *  @class GolfCourse
 *  @module org.schema
 *  @extends SportsActivityLocation
 */
var GolfCourse = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    SportsActivityLocation.call(this);
    this.context = "http://schema.org/";
    this.type = "GolfCourse";
};
GolfCourse = stjs.extend(GolfCourse, SportsActivityLocation, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/ExerciseGym
 *  A gym.
 * 
 *  @author schema.org
 *  @class ExerciseGym
 *  @module org.schema
 *  @extends SportsActivityLocation
 */
var ExerciseGym = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    SportsActivityLocation.call(this);
    this.context = "http://schema.org/";
    this.type = "ExerciseGym";
};
ExerciseGym = stjs.extend(ExerciseGym, SportsActivityLocation, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/BowlingAlley
 *  A bowling alley.
 * 
 *  @author schema.org
 *  @class BowlingAlley
 *  @module org.schema
 *  @extends SportsActivityLocation
 */
var BowlingAlley = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    SportsActivityLocation.call(this);
    this.context = "http://schema.org/";
    this.type = "BowlingAlley";
};
BowlingAlley = stjs.extend(BowlingAlley, SportsActivityLocation, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/TennisComplex
 *  A tennis complex.
 * 
 *  @author schema.org
 *  @class TennisComplex
 *  @module org.schema
 *  @extends SportsActivityLocation
 */
var TennisComplex = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    SportsActivityLocation.call(this);
    this.context = "http://schema.org/";
    this.type = "TennisComplex";
};
TennisComplex = stjs.extend(TennisComplex, SportsActivityLocation, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/SkiResort
 *  A ski resort.
 * 
 *  @author schema.org
 *  @class SkiResort
 *  @module org.schema
 *  @extends SportsActivityLocation
 */
var SkiResort = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    SportsActivityLocation.call(this);
    this.context = "http://schema.org/";
    this.type = "SkiResort";
};
SkiResort = stjs.extend(SkiResort, SportsActivityLocation, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/PublicSwimmingPool
 *  A public swimming pool.
 * 
 *  @author schema.org
 *  @class PublicSwimmingPool
 *  @module org.schema
 *  @extends SportsActivityLocation
 */
var PublicSwimmingPool = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    SportsActivityLocation.call(this);
    this.context = "http://schema.org/";
    this.type = "PublicSwimmingPool";
};
PublicSwimmingPool = stjs.extend(PublicSwimmingPool, SportsActivityLocation, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Attorney
 *  Professional service: Attorney. \n\nThis type is deprecated - [[LegalService]] is more inclusive and less ambiguous.
 * 
 *  @author schema.org
 *  @class Attorney
 *  @module org.schema
 *  @extends LegalService
 */
var Attorney = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    LegalService.call(this);
    this.context = "http://schema.org/";
    this.type = "Attorney";
};
Attorney = stjs.extend(Attorney, LegalService, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Notary
 *  A notary.
 * 
 *  @author schema.org
 *  @class Notary
 *  @module org.schema
 *  @extends LegalService
 */
var Notary = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    LegalService.call(this);
    this.context = "http://schema.org/";
    this.type = "Notary";
};
Notary = stjs.extend(Notary, LegalService, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/HairSalon
 *  A hair salon.
 * 
 *  @author schema.org
 *  @class HairSalon
 *  @module org.schema
 *  @extends HealthAndBeautyBusiness
 */
var HairSalon = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    HealthAndBeautyBusiness.call(this);
    this.context = "http://schema.org/";
    this.type = "HairSalon";
};
HairSalon = stjs.extend(HairSalon, HealthAndBeautyBusiness, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/TattooParlor
 *  A tattoo parlor.
 * 
 *  @author schema.org
 *  @class TattooParlor
 *  @module org.schema
 *  @extends HealthAndBeautyBusiness
 */
var TattooParlor = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    HealthAndBeautyBusiness.call(this);
    this.context = "http://schema.org/";
    this.type = "TattooParlor";
};
TattooParlor = stjs.extend(TattooParlor, HealthAndBeautyBusiness, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/HealthClub
 *  A health club.
 * 
 *  @author schema.org
 *  @class HealthClub
 *  @module org.schema
 *  @extends HealthAndBeautyBusiness
 */
var HealthClub = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    HealthAndBeautyBusiness.call(this);
    this.context = "http://schema.org/";
    this.type = "HealthClub";
};
HealthClub = stjs.extend(HealthClub, HealthAndBeautyBusiness, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/NailSalon
 *  A nail salon.
 * 
 *  @author schema.org
 *  @class NailSalon
 *  @module org.schema
 *  @extends HealthAndBeautyBusiness
 */
var NailSalon = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    HealthAndBeautyBusiness.call(this);
    this.context = "http://schema.org/";
    this.type = "NailSalon";
};
NailSalon = stjs.extend(NailSalon, HealthAndBeautyBusiness, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/BeautySalon
 *  Beauty salon.
 * 
 *  @author schema.org
 *  @class BeautySalon
 *  @module org.schema
 *  @extends HealthAndBeautyBusiness
 */
var BeautySalon = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    HealthAndBeautyBusiness.call(this);
    this.context = "http://schema.org/";
    this.type = "BeautySalon";
};
BeautySalon = stjs.extend(BeautySalon, HealthAndBeautyBusiness, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/DaySpa
 *  A day spa.
 * 
 *  @author schema.org
 *  @class DaySpa
 *  @module org.schema
 *  @extends HealthAndBeautyBusiness
 */
var DaySpa = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    HealthAndBeautyBusiness.call(this);
    this.context = "http://schema.org/";
    this.type = "DaySpa";
};
DaySpa = stjs.extend(DaySpa, HealthAndBeautyBusiness, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Motel
 *  A motel.
 *  <br /><br />
 *  See also the <a href="/docs/hotels.html">dedicated document on the use of schema.org for marking up hotels and other forms of accommodations</a>.
 * 
 *  @author schema.org
 *  @class Motel
 *  @module org.schema
 *  @extends LodgingBusiness
 */
var Motel = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    LodgingBusiness.call(this);
    this.context = "http://schema.org/";
    this.type = "Motel";
};
Motel = stjs.extend(Motel, LodgingBusiness, [], null, {audience: "Audience", availableLanguage: "Language", amenityFeature: "LocationFeatureSpecification", starRating: "Rating", branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Hostel
 *  A hostel - cheap accommodation, often in shared dormitories.
 *  <br /><br />
 *  See also the <a href="/docs/hotels.html">dedicated document on the use of schema.org for marking up hotels and other forms of accommodations</a>.
 * 
 *  @author schema.org
 *  @class Hostel
 *  @module org.schema
 *  @extends LodgingBusiness
 */
var Hostel = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    LodgingBusiness.call(this);
    this.context = "http://schema.org/";
    this.type = "Hostel";
};
Hostel = stjs.extend(Hostel, LodgingBusiness, [], null, {audience: "Audience", availableLanguage: "Language", amenityFeature: "LocationFeatureSpecification", starRating: "Rating", branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/BedAndBreakfast
 *  Bed and breakfast.
 *  <br /><br />
 *  See also the <a href="/docs/hotels.html">dedicated document on the use of schema.org for marking up hotels and other forms of accommodations</a>.
 * 
 *  @author schema.org
 *  @class BedAndBreakfast
 *  @module org.schema
 *  @extends LodgingBusiness
 */
var BedAndBreakfast = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    LodgingBusiness.call(this);
    this.context = "http://schema.org/";
    this.type = "BedAndBreakfast";
};
BedAndBreakfast = stjs.extend(BedAndBreakfast, LodgingBusiness, [], null, {audience: "Audience", availableLanguage: "Language", amenityFeature: "LocationFeatureSpecification", starRating: "Rating", branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Hotel
 *  A hotel is an establishment that provides lodging paid on a short-term basis (Source: Wikipedia, the free encyclopedia, see http://en.wikipedia.org/wiki/Hotel).
 *  <br /><br />
 *  See also the <a href="/docs/hotels.html">dedicated document on the use of schema.org for marking up hotels and other forms of accommodations</a>.
 * 
 *  @author schema.org
 *  @class Hotel
 *  @module org.schema
 *  @extends LodgingBusiness
 */
var Hotel = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    LodgingBusiness.call(this);
    this.context = "http://schema.org/";
    this.type = "Hotel";
};
Hotel = stjs.extend(Hotel, LodgingBusiness, [], null, {audience: "Audience", availableLanguage: "Language", amenityFeature: "LocationFeatureSpecification", starRating: "Rating", branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Resort
 *  A resort is a place used for relaxation or recreation, attracting visitors for holidays or vacations. Resorts are places, towns or sometimes commercial establishment operated by a single company (Source: Wikipedia, the free encyclopedia, see <a href="http://en.wikipedia.org/wiki/Resort">http://en.wikipedia.org/wiki/Resort</a>).
 *  <br /><br />
 *  See also the <a href="/docs/hotels.html">dedicated document on the use of schema.org for marking up hotels and other forms of accommodations</a>.
 * 
 *  @author schema.org
 *  @class Resort
 *  @module org.schema
 *  @extends LodgingBusiness
 */
var Resort = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    LodgingBusiness.call(this);
    this.context = "http://schema.org/";
    this.type = "Resort";
};
Resort = stjs.extend(Resort, LodgingBusiness, [], null, {audience: "Audience", availableLanguage: "Language", amenityFeature: "LocationFeatureSpecification", starRating: "Rating", branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/InsuranceAgency
 *  An Insurance agency.
 * 
 *  @author schema.org
 *  @class InsuranceAgency
 *  @module org.schema
 *  @extends FinancialService
 */
var InsuranceAgency = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    FinancialService.call(this);
    this.context = "http://schema.org/";
    this.type = "InsuranceAgency";
};
InsuranceAgency = stjs.extend(InsuranceAgency, FinancialService, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/AccountingService
 *  Accountancy business.\n\nAs a [[LocalBusiness]] it can be described as a [[provider]] of one or more [[Service]]\(s).
 * 
 *  @author schema.org
 *  @class AccountingService
 *  @module org.schema
 *  @extends FinancialService
 */
var AccountingService = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    FinancialService.call(this);
    this.context = "http://schema.org/";
    this.type = "AccountingService";
};
AccountingService = stjs.extend(AccountingService, FinancialService, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/BankOrCreditUnion
 *  Bank or credit union.
 * 
 *  @author schema.org
 *  @class BankOrCreditUnion
 *  @module org.schema
 *  @extends FinancialService
 */
var BankOrCreditUnion = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    FinancialService.call(this);
    this.context = "http://schema.org/";
    this.type = "BankOrCreditUnion";
};
BankOrCreditUnion = stjs.extend(BankOrCreditUnion, FinancialService, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/AutomatedTeller
 *  ATM/cash machine.
 * 
 *  @author schema.org
 *  @class AutomatedTeller
 *  @module org.schema
 *  @extends FinancialService
 */
var AutomatedTeller = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    FinancialService.call(this);
    this.context = "http://schema.org/";
    this.type = "AutomatedTeller";
};
AutomatedTeller = stjs.extend(AutomatedTeller, FinancialService, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/JewelryStore
 *  A jewelry store.
 * 
 *  @author schema.org
 *  @class JewelryStore
 *  @module org.schema
 *  @extends Store
 */
var JewelryStore = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Store.call(this);
    this.context = "http://schema.org/";
    this.type = "JewelryStore";
};
JewelryStore = stjs.extend(JewelryStore, Store, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/PawnShop
 *  A shop that will buy, or lend money against the security of, personal possessions.
 * 
 *  @author schema.org
 *  @class PawnShop
 *  @module org.schema
 *  @extends Store
 */
var PawnShop = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Store.call(this);
    this.context = "http://schema.org/";
    this.type = "PawnShop";
};
PawnShop = stjs.extend(PawnShop, Store, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/MovieRentalStore
 *  A movie rental store.
 * 
 *  @author schema.org
 *  @class MovieRentalStore
 *  @module org.schema
 *  @extends Store
 */
var MovieRentalStore = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Store.call(this);
    this.context = "http://schema.org/";
    this.type = "MovieRentalStore";
};
MovieRentalStore = stjs.extend(MovieRentalStore, Store, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/HardwareStore
 *  A hardware store.
 * 
 *  @author schema.org
 *  @class HardwareStore
 *  @module org.schema
 *  @extends Store
 */
var HardwareStore = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Store.call(this);
    this.context = "http://schema.org/";
    this.type = "HardwareStore";
};
HardwareStore = stjs.extend(HardwareStore, Store, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/WholesaleStore
 *  A wholesale store.
 * 
 *  @author schema.org
 *  @class WholesaleStore
 *  @module org.schema
 *  @extends Store
 */
var WholesaleStore = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Store.call(this);
    this.context = "http://schema.org/";
    this.type = "WholesaleStore";
};
WholesaleStore = stjs.extend(WholesaleStore, Store, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/TireShop
 *  A tire shop.
 * 
 *  @author schema.org
 *  @class TireShop
 *  @module org.schema
 *  @extends Store
 */
var TireShop = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Store.call(this);
    this.context = "http://schema.org/";
    this.type = "TireShop";
};
TireShop = stjs.extend(TireShop, Store, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/MensClothingStore
 *  A men's clothing store.
 * 
 *  @author schema.org
 *  @class MensClothingStore
 *  @module org.schema
 *  @extends Store
 */
var MensClothingStore = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Store.call(this);
    this.context = "http://schema.org/";
    this.type = "MensClothingStore";
};
MensClothingStore = stjs.extend(MensClothingStore, Store, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/HomeGoodsStore
 *  A home goods store.
 * 
 *  @author schema.org
 *  @class HomeGoodsStore
 *  @module org.schema
 *  @extends Store
 */
var HomeGoodsStore = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Store.call(this);
    this.context = "http://schema.org/";
    this.type = "HomeGoodsStore";
};
HomeGoodsStore = stjs.extend(HomeGoodsStore, Store, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/LiquorStore
 *  A shop that sells alcoholic drinks such as wine, beer, whisky and other spirits.
 * 
 *  @author schema.org
 *  @class LiquorStore
 *  @module org.schema
 *  @extends Store
 */
var LiquorStore = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Store.call(this);
    this.context = "http://schema.org/";
    this.type = "LiquorStore";
};
LiquorStore = stjs.extend(LiquorStore, Store, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/BikeStore
 *  A bike store.
 * 
 *  @author schema.org
 *  @class BikeStore
 *  @module org.schema
 *  @extends Store
 */
var BikeStore = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Store.call(this);
    this.context = "http://schema.org/";
    this.type = "BikeStore";
};
BikeStore = stjs.extend(BikeStore, Store, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/ToyStore
 *  A toy store.
 * 
 *  @author schema.org
 *  @class ToyStore
 *  @module org.schema
 *  @extends Store
 */
var ToyStore = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Store.call(this);
    this.context = "http://schema.org/";
    this.type = "ToyStore";
};
ToyStore = stjs.extend(ToyStore, Store, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/OfficeEquipmentStore
 *  An office equipment store.
 * 
 *  @author schema.org
 *  @class OfficeEquipmentStore
 *  @module org.schema
 *  @extends Store
 */
var OfficeEquipmentStore = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Store.call(this);
    this.context = "http://schema.org/";
    this.type = "OfficeEquipmentStore";
};
OfficeEquipmentStore = stjs.extend(OfficeEquipmentStore, Store, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/SportingGoodsStore
 *  A sporting goods store.
 * 
 *  @author schema.org
 *  @class SportingGoodsStore
 *  @module org.schema
 *  @extends Store
 */
var SportingGoodsStore = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Store.call(this);
    this.context = "http://schema.org/";
    this.type = "SportingGoodsStore";
};
SportingGoodsStore = stjs.extend(SportingGoodsStore, Store, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/MobilePhoneStore
 *  A store that sells mobile phones and related accessories.
 * 
 *  @author schema.org
 *  @class MobilePhoneStore
 *  @module org.schema
 *  @extends Store
 */
var MobilePhoneStore = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Store.call(this);
    this.context = "http://schema.org/";
    this.type = "MobilePhoneStore";
};
MobilePhoneStore = stjs.extend(MobilePhoneStore, Store, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/FurnitureStore
 *  A furniture store.
 * 
 *  @author schema.org
 *  @class FurnitureStore
 *  @module org.schema
 *  @extends Store
 */
var FurnitureStore = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Store.call(this);
    this.context = "http://schema.org/";
    this.type = "FurnitureStore";
};
FurnitureStore = stjs.extend(FurnitureStore, Store, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/OutletStore
 *  An outlet store.
 * 
 *  @author schema.org
 *  @class OutletStore
 *  @module org.schema
 *  @extends Store
 */
var OutletStore = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Store.call(this);
    this.context = "http://schema.org/";
    this.type = "OutletStore";
};
OutletStore = stjs.extend(OutletStore, Store, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/GardenStore
 *  A garden store.
 * 
 *  @author schema.org
 *  @class GardenStore
 *  @module org.schema
 *  @extends Store
 */
var GardenStore = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Store.call(this);
    this.context = "http://schema.org/";
    this.type = "GardenStore";
};
GardenStore = stjs.extend(GardenStore, Store, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Florist
 *  A florist.
 * 
 *  @author schema.org
 *  @class Florist
 *  @module org.schema
 *  @extends Store
 */
var Florist = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Store.call(this);
    this.context = "http://schema.org/";
    this.type = "Florist";
};
Florist = stjs.extend(Florist, Store, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/GroceryStore
 *  A grocery store.
 * 
 *  @author schema.org
 *  @class GroceryStore
 *  @module org.schema
 *  @extends Store
 */
var GroceryStore = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Store.call(this);
    this.context = "http://schema.org/";
    this.type = "GroceryStore";
};
GroceryStore = stjs.extend(GroceryStore, Store, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/HobbyShop
 *  A store that sells materials useful or necessary for various hobbies.
 * 
 *  @author schema.org
 *  @class HobbyShop
 *  @module org.schema
 *  @extends Store
 */
var HobbyShop = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Store.call(this);
    this.context = "http://schema.org/";
    this.type = "HobbyShop";
};
HobbyShop = stjs.extend(HobbyShop, Store, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/ElectronicsStore
 *  An electronics store.
 * 
 *  @author schema.org
 *  @class ElectronicsStore
 *  @module org.schema
 *  @extends Store
 */
var ElectronicsStore = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Store.call(this);
    this.context = "http://schema.org/";
    this.type = "ElectronicsStore";
};
ElectronicsStore = stjs.extend(ElectronicsStore, Store, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/ShoeStore
 *  A shoe store.
 * 
 *  @author schema.org
 *  @class ShoeStore
 *  @module org.schema
 *  @extends Store
 */
var ShoeStore = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Store.call(this);
    this.context = "http://schema.org/";
    this.type = "ShoeStore";
};
ShoeStore = stjs.extend(ShoeStore, Store, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/AutoPartsStore
 *  An auto parts store.
 * 
 *  @author schema.org
 *  @class AutoPartsStore
 *  @module org.schema
 *  @extends Store
 */
var AutoPartsStore = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Store.call(this);
    this.context = "http://schema.org/";
    this.type = "AutoPartsStore";
};
AutoPartsStore = stjs.extend(AutoPartsStore, Store, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/MusicStore
 *  A music store.
 * 
 *  @author schema.org
 *  @class MusicStore
 *  @module org.schema
 *  @extends Store
 */
var MusicStore = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Store.call(this);
    this.context = "http://schema.org/";
    this.type = "MusicStore";
};
MusicStore = stjs.extend(MusicStore, Store, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/DepartmentStore
 *  A department store.
 * 
 *  @author schema.org
 *  @class DepartmentStore
 *  @module org.schema
 *  @extends Store
 */
var DepartmentStore = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Store.call(this);
    this.context = "http://schema.org/";
    this.type = "DepartmentStore";
};
DepartmentStore = stjs.extend(DepartmentStore, Store, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/PetStore
 *  A pet store.
 * 
 *  @author schema.org
 *  @class PetStore
 *  @module org.schema
 *  @extends Store
 */
var PetStore = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Store.call(this);
    this.context = "http://schema.org/";
    this.type = "PetStore";
};
PetStore = stjs.extend(PetStore, Store, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/ConvenienceStore
 *  A convenience store.
 * 
 *  @author schema.org
 *  @class ConvenienceStore
 *  @module org.schema
 *  @extends Store
 */
var ConvenienceStore = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Store.call(this);
    this.context = "http://schema.org/";
    this.type = "ConvenienceStore";
};
ConvenienceStore = stjs.extend(ConvenienceStore, Store, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/ComputerStore
 *  A computer store.
 * 
 *  @author schema.org
 *  @class ComputerStore
 *  @module org.schema
 *  @extends Store
 */
var ComputerStore = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Store.call(this);
    this.context = "http://schema.org/";
    this.type = "ComputerStore";
};
ComputerStore = stjs.extend(ComputerStore, Store, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/BookStore
 *  A bookstore.
 * 
 *  @author schema.org
 *  @class BookStore
 *  @module org.schema
 *  @extends Store
 */
var BookStore = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Store.call(this);
    this.context = "http://schema.org/";
    this.type = "BookStore";
};
BookStore = stjs.extend(BookStore, Store, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/ClothingStore
 *  A clothing store.
 * 
 *  @author schema.org
 *  @class ClothingStore
 *  @module org.schema
 *  @extends Store
 */
var ClothingStore = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    Store.call(this);
    this.context = "http://schema.org/";
    this.type = "ClothingStore";
};
ClothingStore = stjs.extend(ClothingStore, Store, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/AutoRepair
 *  Car repair business.
 * 
 *  @author schema.org
 *  @class AutoRepair
 *  @module org.schema
 *  @extends AutomotiveBusiness
 */
var AutoRepair = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    AutomotiveBusiness.call(this);
    this.context = "http://schema.org/";
    this.type = "AutoRepair";
};
AutoRepair = stjs.extend(AutoRepair, AutomotiveBusiness, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/GasStation
 *  A gas station.
 * 
 *  @author schema.org
 *  @class GasStation
 *  @module org.schema
 *  @extends AutomotiveBusiness
 */
var GasStation = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    AutomotiveBusiness.call(this);
    this.context = "http://schema.org/";
    this.type = "GasStation";
};
GasStation = stjs.extend(GasStation, AutomotiveBusiness, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/AutoRental
 *  A car rental business.
 * 
 *  @author schema.org
 *  @class AutoRental
 *  @module org.schema
 *  @extends AutomotiveBusiness
 */
var AutoRental = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    AutomotiveBusiness.call(this);
    this.context = "http://schema.org/";
    this.type = "AutoRental";
};
AutoRental = stjs.extend(AutoRental, AutomotiveBusiness, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/MotorcycleRepair
 *  A motorcycle repair shop.
 * 
 *  @author schema.org
 *  @class MotorcycleRepair
 *  @module org.schema
 *  @extends AutomotiveBusiness
 */
var MotorcycleRepair = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    AutomotiveBusiness.call(this);
    this.context = "http://schema.org/";
    this.type = "MotorcycleRepair";
};
MotorcycleRepair = stjs.extend(MotorcycleRepair, AutomotiveBusiness, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/MotorcycleDealer
 *  A motorcycle dealer.
 * 
 *  @author schema.org
 *  @class MotorcycleDealer
 *  @module org.schema
 *  @extends AutomotiveBusiness
 */
var MotorcycleDealer = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    AutomotiveBusiness.call(this);
    this.context = "http://schema.org/";
    this.type = "MotorcycleDealer";
};
MotorcycleDealer = stjs.extend(MotorcycleDealer, AutomotiveBusiness, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/AutoWash
 *  A car wash business.
 * 
 *  @author schema.org
 *  @class AutoWash
 *  @module org.schema
 *  @extends AutomotiveBusiness
 */
var AutoWash = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    AutomotiveBusiness.call(this);
    this.context = "http://schema.org/";
    this.type = "AutoWash";
};
AutoWash = stjs.extend(AutoWash, AutomotiveBusiness, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/AutoDealer
 *  An car dealership.
 * 
 *  @author schema.org
 *  @class AutoDealer
 *  @module org.schema
 *  @extends AutomotiveBusiness
 */
var AutoDealer = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    AutomotiveBusiness.call(this);
    this.context = "http://schema.org/";
    this.type = "AutoDealer";
};
AutoDealer = stjs.extend(AutoDealer, AutomotiveBusiness, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/AutoBodyShop
 *  Auto body shop.
 * 
 *  @author schema.org
 *  @class AutoBodyShop
 *  @module org.schema
 *  @extends AutomotiveBusiness
 */
var AutoBodyShop = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    AutomotiveBusiness.call(this);
    this.context = "http://schema.org/";
    this.type = "AutoBodyShop";
};
AutoBodyShop = stjs.extend(AutoBodyShop, AutomotiveBusiness, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/NightClub
 *  A nightclub or discotheque.
 * 
 *  @author schema.org
 *  @class NightClub
 *  @module org.schema
 *  @extends EntertainmentBusiness
 */
var NightClub = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    EntertainmentBusiness.call(this);
    this.context = "http://schema.org/";
    this.type = "NightClub";
};
NightClub = stjs.extend(NightClub, EntertainmentBusiness, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/AdultEntertainment
 *  An adult entertainment establishment.
 * 
 *  @author schema.org
 *  @class AdultEntertainment
 *  @module org.schema
 *  @extends EntertainmentBusiness
 */
var AdultEntertainment = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    EntertainmentBusiness.call(this);
    this.context = "http://schema.org/";
    this.type = "AdultEntertainment";
};
AdultEntertainment = stjs.extend(AdultEntertainment, EntertainmentBusiness, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/ComedyClub
 *  A comedy club.
 * 
 *  @author schema.org
 *  @class ComedyClub
 *  @module org.schema
 *  @extends EntertainmentBusiness
 */
var ComedyClub = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    EntertainmentBusiness.call(this);
    this.context = "http://schema.org/";
    this.type = "ComedyClub";
};
ComedyClub = stjs.extend(ComedyClub, EntertainmentBusiness, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Casino
 *  A casino.
 * 
 *  @author schema.org
 *  @class Casino
 *  @module org.schema
 *  @extends EntertainmentBusiness
 */
var Casino = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    EntertainmentBusiness.call(this);
    this.context = "http://schema.org/";
    this.type = "Casino";
};
Casino = stjs.extend(Casino, EntertainmentBusiness, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/AmusementPark
 *  An amusement park.
 * 
 *  @author schema.org
 *  @class AmusementPark
 *  @module org.schema
 *  @extends EntertainmentBusiness
 */
var AmusementPark = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    EntertainmentBusiness.call(this);
    this.context = "http://schema.org/";
    this.type = "AmusementPark";
};
AmusementPark = stjs.extend(AmusementPark, EntertainmentBusiness, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/ArtGallery
 *  An art gallery.
 * 
 *  @author schema.org
 *  @class ArtGallery
 *  @module org.schema
 *  @extends EntertainmentBusiness
 */
var ArtGallery = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    EntertainmentBusiness.call(this);
    this.context = "http://schema.org/";
    this.type = "ArtGallery";
};
ArtGallery = stjs.extend(ArtGallery, EntertainmentBusiness, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/GeneralContractor
 *  A general contractor.
 * 
 *  @author schema.org
 *  @class GeneralContractor
 *  @module org.schema
 *  @extends HomeAndConstructionBusiness
 */
var GeneralContractor = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    HomeAndConstructionBusiness.call(this);
    this.context = "http://schema.org/";
    this.type = "GeneralContractor";
};
GeneralContractor = stjs.extend(GeneralContractor, HomeAndConstructionBusiness, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Plumber
 *  A plumbing service.
 * 
 *  @author schema.org
 *  @class Plumber
 *  @module org.schema
 *  @extends HomeAndConstructionBusiness
 */
var Plumber = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    HomeAndConstructionBusiness.call(this);
    this.context = "http://schema.org/";
    this.type = "Plumber";
};
Plumber = stjs.extend(Plumber, HomeAndConstructionBusiness, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/RoofingContractor
 *  A roofing contractor.
 * 
 *  @author schema.org
 *  @class RoofingContractor
 *  @module org.schema
 *  @extends HomeAndConstructionBusiness
 */
var RoofingContractor = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    HomeAndConstructionBusiness.call(this);
    this.context = "http://schema.org/";
    this.type = "RoofingContractor";
};
RoofingContractor = stjs.extend(RoofingContractor, HomeAndConstructionBusiness, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/MovingCompany
 *  A moving company.
 * 
 *  @author schema.org
 *  @class MovingCompany
 *  @module org.schema
 *  @extends HomeAndConstructionBusiness
 */
var MovingCompany = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    HomeAndConstructionBusiness.call(this);
    this.context = "http://schema.org/";
    this.type = "MovingCompany";
};
MovingCompany = stjs.extend(MovingCompany, HomeAndConstructionBusiness, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/HVACBusiness
 *  A business that provide Heating, Ventilation and Air Conditioning services.
 * 
 *  @author schema.org
 *  @class HVACBusiness
 *  @module org.schema
 *  @extends HomeAndConstructionBusiness
 */
var HVACBusiness = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    HomeAndConstructionBusiness.call(this);
    this.context = "http://schema.org/";
    this.type = "HVACBusiness";
};
HVACBusiness = stjs.extend(HVACBusiness, HomeAndConstructionBusiness, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Electrician
 *  An electrician.
 * 
 *  @author schema.org
 *  @class Electrician
 *  @module org.schema
 *  @extends HomeAndConstructionBusiness
 */
var Electrician = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    HomeAndConstructionBusiness.call(this);
    this.context = "http://schema.org/";
    this.type = "Electrician";
};
Electrician = stjs.extend(Electrician, HomeAndConstructionBusiness, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Locksmith
 *  A locksmith.
 * 
 *  @author schema.org
 *  @class Locksmith
 *  @module org.schema
 *  @extends HomeAndConstructionBusiness
 */
var Locksmith = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    HomeAndConstructionBusiness.call(this);
    this.context = "http://schema.org/";
    this.type = "Locksmith";
};
Locksmith = stjs.extend(Locksmith, HomeAndConstructionBusiness, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/HousePainter
 *  A house painting service.
 * 
 *  @author schema.org
 *  @class HousePainter
 *  @module org.schema
 *  @extends HomeAndConstructionBusiness
 */
var HousePainter = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    HomeAndConstructionBusiness.call(this);
    this.context = "http://schema.org/";
    this.type = "HousePainter";
};
HousePainter = stjs.extend(HousePainter, HomeAndConstructionBusiness, [], null, {branchOf: "Organization", serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/LocationFeatureSpecification
 *  Specifies a location feature by providing a structured value representing a feature of an accommodation as a property-value pair of varying degrees of formality.
 * 
 *  @author schema.org
 *  @class LocationFeatureSpecification
 *  @module org.schema
 *  @extends PropertyValue
 */
var LocationFeatureSpecification = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    PropertyValue.call(this);
    this.context = "http://schema.org/";
    this.type = "LocationFeatureSpecification";
};
LocationFeatureSpecification = stjs.extend(LocationFeatureSpecification, PropertyValue, [], function(constructor, prototype) {
    /**
     *  Schema.org/hoursAvailable
     *  The hours during which this service or contact is available.
     * 
     *  @property hoursAvailable
     *  @type OpeningHoursSpecification
     */
    prototype.hoursAvailable = null;
    /**
     *  Schema.org/validFrom
     *  The date when the item becomes valid.
     * 
     *  @property validFrom
     *  @type DateTime
     */
    prototype.validFrom = null;
    /**
     *  Schema.org/validThrough
     *  The date after when the item is not valid. For example the end of an offer, salary period, or a period of opening hours.
     * 
     *  @property validThrough
     *  @type DateTime
     */
    prototype.validThrough = null;
}, {hoursAvailable: "OpeningHoursSpecification", value: "StructuredValue", valueReference: "StructuredValue", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/CompoundPriceSpecification
 *  A compound price specification is one that bundles multiple prices that all apply in combination for different dimensions of consumption. Use the name property of the attached unit price specification for indicating the dimension of a price component (e.g. "electricity" or "final cleaning").
 * 
 *  @author schema.org
 *  @class CompoundPriceSpecification
 *  @module org.schema
 *  @extends PriceSpecification
 */
var CompoundPriceSpecification = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    PriceSpecification.call(this);
    this.context = "http://schema.org/";
    this.type = "CompoundPriceSpecification";
};
CompoundPriceSpecification = stjs.extend(CompoundPriceSpecification, PriceSpecification, [], function(constructor, prototype) {
    /**
     *  Schema.org/priceComponent
     *  This property links to all [[UnitPriceSpecification]] nodes that apply in parallel for the [[CompoundPriceSpecification]] node.
     * 
     *  @property priceComponent
     *  @type UnitPriceSpecification
     */
    prototype.priceComponent = null;
}, {priceComponent: "UnitPriceSpecification", eligibleTransactionVolume: "PriceSpecification", eligibleQuantity: "QuantitativeValue", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/DeliveryChargeSpecification
 *  The price for the delivery of an offer using a particular delivery method.
 * 
 *  @author schema.org
 *  @class DeliveryChargeSpecification
 *  @module org.schema
 *  @extends PriceSpecification
 */
var DeliveryChargeSpecification = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    PriceSpecification.call(this);
    this.context = "http://schema.org/";
    this.type = "DeliveryChargeSpecification";
};
DeliveryChargeSpecification = stjs.extend(DeliveryChargeSpecification, PriceSpecification, [], function(constructor, prototype) {
    /**
     *  Schema.org/ineligibleRegion
     *  The ISO 3166-1 (ISO 3166-1 alpha-2) or ISO 3166-2 code, the place, or the GeoShape for the geo-political region(s) for which the offer or delivery charge specification is not valid, e.g. a region where the transaction is not allowed.\n\nSee also [[eligibleRegion]].
     * 
     *  @property ineligibleRegion
     *  @type GeoShape
     */
    prototype.ineligibleRegion = null;
    /**
     *  Schema.org/appliesToDeliveryMethod
     *  The delivery method(s) to which the delivery charge or payment charge specification applies.
     * 
     *  @property appliesToDeliveryMethod
     *  @type DeliveryMethod
     */
    prototype.appliesToDeliveryMethod = null;
    /**
     *  Schema.org/areaServed
     *  The geographic area where a service or offered item is provided.
     * 
     *  @property areaServed
     *  @type Place
     */
    prototype.areaServed = null;
    /**
     *  Schema.org/eligibleRegion
     *  The ISO 3166-1 (ISO 3166-1 alpha-2) or ISO 3166-2 code, the place, or the GeoShape for the geo-political region(s) for which the offer or delivery charge specification is valid.\n\nSee also [[ineligibleRegion]].
     * 
     *  @property eligibleRegion
     *  @type Text
     */
    prototype.eligibleRegion = null;
}, {ineligibleRegion: "GeoShape", appliesToDeliveryMethod: "DeliveryMethod", areaServed: "Place", eligibleTransactionVolume: "PriceSpecification", eligibleQuantity: "QuantitativeValue", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/PaymentChargeSpecification
 *  The costs of settling the payment using a particular payment method.
 * 
 *  @author schema.org
 *  @class PaymentChargeSpecification
 *  @module org.schema
 *  @extends PriceSpecification
 */
var PaymentChargeSpecification = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    PriceSpecification.call(this);
    this.context = "http://schema.org/";
    this.type = "PaymentChargeSpecification";
};
PaymentChargeSpecification = stjs.extend(PaymentChargeSpecification, PriceSpecification, [], function(constructor, prototype) {
    /**
     *  Schema.org/appliesToPaymentMethod
     *  The payment method(s) to which the payment charge specification applies.
     * 
     *  @property appliesToPaymentMethod
     *  @type PaymentMethod
     */
    prototype.appliesToPaymentMethod = null;
    /**
     *  Schema.org/appliesToDeliveryMethod
     *  The delivery method(s) to which the delivery charge or payment charge specification applies.
     * 
     *  @property appliesToDeliveryMethod
     *  @type DeliveryMethod
     */
    prototype.appliesToDeliveryMethod = null;
}, {appliesToPaymentMethod: "PaymentMethod", appliesToDeliveryMethod: "DeliveryMethod", eligibleTransactionVolume: "PriceSpecification", eligibleQuantity: "QuantitativeValue", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/UnitPriceSpecification
 *  The price asked for a given offer by the respective organization or person.
 * 
 *  @author schema.org
 *  @class UnitPriceSpecification
 *  @module org.schema
 *  @extends PriceSpecification
 */
var UnitPriceSpecification = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    PriceSpecification.call(this);
    this.context = "http://schema.org/";
    this.type = "UnitPriceSpecification";
};
UnitPriceSpecification = stjs.extend(UnitPriceSpecification, PriceSpecification, [], function(constructor, prototype) {
    /**
     *  Schema.org/unitCode
     *  The unit of measurement given using the UN/CEFACT Common Code (3 characters) or a URL. Other codes than the UN/CEFACT Common Code may be used with a prefix followed by a colon.
     * 
     *  @property unitCode
     *  @type Text
     */
    prototype.unitCode = null;
    /**
     *  Schema.org/billingIncrement
     *  This property specifies the minimal quantity and rounding increment that will be the basis for the billing. The unit of measurement is specified by the unitCode property.
     * 
     *  @property billingIncrement
     *  @type Number
     */
    prototype.billingIncrement = null;
    /**
     *  Schema.org/referenceQuantity
     *  The reference quantity for which a certain price applies, e.g. 1 EUR per 4 kWh of electricity. This property is a replacement for unitOfMeasurement for the advanced cases where the price does not relate to a standard unit.
     * 
     *  @property referenceQuantity
     *  @type QuantitativeValue
     */
    prototype.referenceQuantity = null;
    /**
     *  Schema.org/unitText
     *  A string or text indicating the unit of measurement. Useful if you cannot provide a standard unit code for
     *  <a href='unitCode'>unitCode</a>.
     * 
     *  @property unitText
     *  @type Text
     */
    prototype.unitText = null;
    /**
     *  Schema.org/priceType
     *  A short text or acronym indicating multiple price specifications for the same offer, e.g. SRP for the suggested retail price or INVOICE for the invoice price, mostly used in the car industry.
     * 
     *  @property priceType
     *  @type Text
     */
    prototype.priceType = null;
}, {referenceQuantity: "QuantitativeValue", eligibleTransactionVolume: "PriceSpecification", eligibleQuantity: "QuantitativeValue", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/GeoCircle
 *  A GeoCircle is a GeoShape representing a circular geographic area. As it is a GeoShape
 *  it provides the simple textual property 'circle', but also allows the combination of postalCode alongside geoRadius.
 *  The center of the circle can be indicated via the 'geoMidpoint' property, or more approximately using 'address', 'postalCode'.
 * 
 *  @author schema.org
 *  @class GeoCircle
 *  @module org.schema
 *  @extends GeoShape
 */
var GeoCircle = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    GeoShape.call(this);
    this.context = "http://schema.org/";
    this.type = "GeoCircle";
};
GeoCircle = stjs.extend(GeoCircle, GeoShape, [], function(constructor, prototype) {
    /**
     *  Schema.org/geoRadius
     *  Indicates the approximate radius of a GeoCircle (metres unless indicated otherwise via Distance notation).
     * 
     *  @property geoRadius
     *  @type Number
     */
    prototype.geoRadius = null;
    /**
     *  Schema.org/geoMidpoint
     *  Indicates the GeoCoordinates at the centre of a GeoShape e.g. GeoCircle.
     * 
     *  @property geoMidpoint
     *  @type GeoCoordinates
     */
    prototype.geoMidpoint = null;
}, {geoMidpoint: "GeoCoordinates", address: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/PostalAddress
 *  The mailing address.
 * 
 *  @author schema.org
 *  @class PostalAddress
 *  @module org.schema
 *  @extends ContactPoint
 */
var PostalAddress = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    ContactPoint.call(this);
    this.context = "http://schema.org/";
    this.type = "PostalAddress";
};
PostalAddress = stjs.extend(PostalAddress, ContactPoint, [], function(constructor, prototype) {
    /**
     *  Schema.org/postOfficeBoxNumber
     *  The post office box number for PO box addresses.
     * 
     *  @property postOfficeBoxNumber
     *  @type Text
     */
    prototype.postOfficeBoxNumber = null;
    /**
     *  Schema.org/streetAddress
     *  The street address. For example, 1600 Amphitheatre Pkwy.
     * 
     *  @property streetAddress
     *  @type Text
     */
    prototype.streetAddress = null;
    /**
     *  Schema.org/addressCountry
     *  The country. For example, USA. You can also provide the two-letter [ISO 3166-1 alpha-2 country code](http://en.wikipedia.org/wiki/ISO_3166-1).
     * 
     *  @property addressCountry
     *  @type Text
     */
    prototype.addressCountry = null;
    /**
     *  Schema.org/addressRegion
     *  The region. For example, CA.
     * 
     *  @property addressRegion
     *  @type Text
     */
    prototype.addressRegion = null;
    /**
     *  Schema.org/postalCode
     *  The postal code. For example, 94043.
     * 
     *  @property postalCode
     *  @type Text
     */
    prototype.postalCode = null;
    /**
     *  Schema.org/addressLocality
     *  The locality. For example, Mountain View.
     * 
     *  @property addressLocality
     *  @type Text
     */
    prototype.addressLocality = null;
}, {serviceArea: "GeoShape", hoursAvailable: "OpeningHoursSpecification", contactOption: "ContactPointOption", availableLanguage: "Language", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/ParentAudience
 *  A set of characteristics describing parents, who can be interested in viewing some content.
 * 
 *  @author schema.org
 *  @class ParentAudience
 *  @module org.schema
 *  @extends PeopleAudience
 */
var ParentAudience = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    PeopleAudience.call(this);
    this.context = "http://schema.org/";
    this.type = "ParentAudience";
};
ParentAudience = stjs.extend(ParentAudience, PeopleAudience, [], function(constructor, prototype) {
    /**
     *  Schema.org/childMaxAge
     *  Maximal age of the child.
     * 
     *  @property childMaxAge
     *  @type Number
     */
    prototype.childMaxAge = null;
    /**
     *  Schema.org/childMinAge
     *  Minimal age of the child.
     * 
     *  @property childMinAge
     *  @type Number
     */
    prototype.childMinAge = null;
}, {geographicArea: "AdministrativeArea", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/EmployeeRole
 *  A subclass of OrganizationRole used to describe employee relationships.
 * 
 *  @author schema.org
 *  @class EmployeeRole
 *  @module org.schema
 *  @extends OrganizationRole
 */
var EmployeeRole = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    OrganizationRole.call(this);
    this.context = "http://schema.org/";
    this.type = "EmployeeRole";
};
EmployeeRole = stjs.extend(EmployeeRole, OrganizationRole, [], function(constructor, prototype) {
    /**
     *  Schema.org/salaryCurrency
     *  The currency (coded using [ISO 4217](http://en.wikipedia.org/wiki/ISO_4217) ) used for the main salary information in this job posting or for this employee.
     * 
     *  @property salaryCurrency
     *  @type Text
     */
    prototype.salaryCurrency = null;
    /**
     *  Schema.org/baseSalary
     *  The base salary of the job or of an employee in an EmployeeRole.
     * 
     *  @property baseSalary
     *  @type MonetaryAmount
     */
    prototype.baseSalary = null;
}, {baseSalary: "MonetaryAmount", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/LockerDelivery
 *  A DeliveryMethod in which an item is made available via locker.
 * 
 *  @author schema.org
 *  @class LockerDelivery
 *  @module org.schema
 *  @extends DeliveryMethod
 */
var LockerDelivery = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    DeliveryMethod.call(this);
    this.context = "http://schema.org/";
    this.type = "LockerDelivery";
};
LockerDelivery = stjs.extend(LockerDelivery, DeliveryMethod, [], null, {identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/ParcelService
 *  A private parcel service as the delivery mode available for a certain offer.\n\nCommonly used values:\n\n* http://purl.org/goodrelations/v1#DHL\n* http://purl.org/goodrelations/v1#FederalExpress\n* http://purl.org/goodrelations/v1#UPS
 * 
 *  @author schema.org
 *  @class ParcelService
 *  @module org.schema
 *  @extends DeliveryMethod
 */
var ParcelService = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    DeliveryMethod.call(this);
    this.context = "http://schema.org/";
    this.type = "ParcelService";
};
ParcelService = stjs.extend(ParcelService, DeliveryMethod, [], null, {identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/SteeringPositionValue
 *  A value indicating a steering position.
 * 
 *  @author schema.org
 *  @class SteeringPositionValue
 *  @module org.schema
 *  @extends QualitativeValue
 */
var SteeringPositionValue = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    QualitativeValue.call(this);
    this.context = "http://schema.org/";
    this.type = "SteeringPositionValue";
};
SteeringPositionValue = stjs.extend(SteeringPositionValue, QualitativeValue, [], null, {greater: "QualitativeValue", equal: "QualitativeValue", nonEqual: "QualitativeValue", additionalProperty: "PropertyValue", lesser: "QualitativeValue", valueReference: "StructuredValue", lesserOrEqual: "QualitativeValue", greaterOrEqual: "QualitativeValue", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/DriveWheelConfigurationValue
 *  A value indicating which roadwheels will receive torque.
 * 
 *  @author schema.org
 *  @class DriveWheelConfigurationValue
 *  @module org.schema
 *  @extends QualitativeValue
 */
var DriveWheelConfigurationValue = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    QualitativeValue.call(this);
    this.context = "http://schema.org/";
    this.type = "DriveWheelConfigurationValue";
};
DriveWheelConfigurationValue = stjs.extend(DriveWheelConfigurationValue, QualitativeValue, [], null, {greater: "QualitativeValue", equal: "QualitativeValue", nonEqual: "QualitativeValue", additionalProperty: "PropertyValue", lesser: "QualitativeValue", valueReference: "StructuredValue", lesserOrEqual: "QualitativeValue", greaterOrEqual: "QualitativeValue", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/PaymentCard
 *  A payment method using a credit, debit, store or other card to associate the payment with an account.
 * 
 *  @author schema.org
 *  @class PaymentCard
 *  @module org.schema
 *  @extends FinancialProduct
 */
var PaymentCard = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    FinancialProduct.call(this);
    this.context = "http://schema.org/";
    this.type = "PaymentCard";
};
PaymentCard = stjs.extend(PaymentCard, FinancialProduct, [], null, {serviceAudience: "Audience", serviceArea: "GeoShape", provider: "Person", audience: "Audience", hasOfferCatalog: "OfferCatalog", hoursAvailable: "OpeningHoursSpecification", aggregateRating: "AggregateRating", offers: "Offer", broker: "Person", serviceOutput: "Thing", logo: "ImageObject", isSimilarTo: "Product", isRelatedTo: "Product", availableChannel: "ServiceChannel", review: "Review", produces: "Thing", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/LoanOrCredit
 *  A financial product for the loaning of an amount of money under agreed terms and charges.
 * 
 *  @author schema.org
 *  @class LoanOrCredit
 *  @module org.schema
 *  @extends FinancialProduct
 */
var LoanOrCredit = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    FinancialProduct.call(this);
    this.context = "http://schema.org/";
    this.type = "LoanOrCredit";
};
LoanOrCredit = stjs.extend(LoanOrCredit, FinancialProduct, [], function(constructor, prototype) {
    /**
     *  Schema.org/loanTerm
     *  The duration of the loan or credit agreement.
     * 
     *  @property loanTerm
     *  @type QuantitativeValue
     */
    prototype.loanTerm = null;
    /**
     *  Schema.org/amount
     *  The amount of money.
     * 
     *  @property amount
     *  @type Number
     */
    prototype.amount = null;
    /**
     *  Schema.org/requiredCollateral
     *  Assets required to secure loan or credit repayments. It may take form of third party pledge, goods, financial instruments (cash, securities, etc.)
     * 
     *  @property requiredCollateral
     *  @type Thing
     */
    prototype.requiredCollateral = null;
}, {loanTerm: "QuantitativeValue", requiredCollateral: "Thing", serviceAudience: "Audience", serviceArea: "GeoShape", provider: "Person", audience: "Audience", hasOfferCatalog: "OfferCatalog", hoursAvailable: "OpeningHoursSpecification", aggregateRating: "AggregateRating", offers: "Offer", broker: "Person", serviceOutput: "Thing", logo: "ImageObject", isSimilarTo: "Product", isRelatedTo: "Product", availableChannel: "ServiceChannel", review: "Review", produces: "Thing", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/InvestmentOrDeposit
 *  A type of financial product that typically requires the client to transfer funds to a financial service in return for potential beneficial financial return.
 * 
 *  @author schema.org
 *  @class InvestmentOrDeposit
 *  @module org.schema
 *  @extends FinancialProduct
 */
var InvestmentOrDeposit = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    FinancialProduct.call(this);
    this.context = "http://schema.org/";
    this.type = "InvestmentOrDeposit";
};
InvestmentOrDeposit = stjs.extend(InvestmentOrDeposit, FinancialProduct, [], function(constructor, prototype) {
    /**
     *  Schema.org/amount
     *  The amount of money.
     * 
     *  @property amount
     *  @type Number
     */
    prototype.amount = null;
}, {serviceAudience: "Audience", serviceArea: "GeoShape", provider: "Person", audience: "Audience", hasOfferCatalog: "OfferCatalog", hoursAvailable: "OpeningHoursSpecification", aggregateRating: "AggregateRating", offers: "Offer", broker: "Person", serviceOutput: "Thing", logo: "ImageObject", isSimilarTo: "Product", isRelatedTo: "Product", availableChannel: "ServiceChannel", review: "Review", produces: "Thing", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/PaymentService
 *  A Service to transfer funds from a person or organization to a beneficiary person or organization.
 * 
 *  @author schema.org
 *  @class PaymentService
 *  @module org.schema
 *  @extends FinancialProduct
 */
var PaymentService = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    FinancialProduct.call(this);
    this.context = "http://schema.org/";
    this.type = "PaymentService";
};
PaymentService = stjs.extend(PaymentService, FinancialProduct, [], null, {serviceAudience: "Audience", serviceArea: "GeoShape", provider: "Person", audience: "Audience", hasOfferCatalog: "OfferCatalog", hoursAvailable: "OpeningHoursSpecification", aggregateRating: "AggregateRating", offers: "Offer", broker: "Person", serviceOutput: "Thing", logo: "ImageObject", isSimilarTo: "Product", isRelatedTo: "Product", availableChannel: "ServiceChannel", review: "Review", produces: "Thing", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/BankAccount
 *  A product or service offered by a bank whereby one may deposit, withdraw or transfer money and in some cases be paid interest.
 * 
 *  @author schema.org
 *  @class BankAccount
 *  @module org.schema
 *  @extends FinancialProduct
 */
var BankAccount = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    FinancialProduct.call(this);
    this.context = "http://schema.org/";
    this.type = "BankAccount";
};
BankAccount = stjs.extend(BankAccount, FinancialProduct, [], null, {serviceAudience: "Audience", serviceArea: "GeoShape", provider: "Person", audience: "Audience", hasOfferCatalog: "OfferCatalog", hoursAvailable: "OpeningHoursSpecification", aggregateRating: "AggregateRating", offers: "Offer", broker: "Person", serviceOutput: "Thing", logo: "ImageObject", isSimilarTo: "Product", isRelatedTo: "Product", availableChannel: "ServiceChannel", review: "Review", produces: "Thing", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/CurrencyConversionService
 *  A service to convert funds from one currency to another currency.
 * 
 *  @author schema.org
 *  @class CurrencyConversionService
 *  @module org.schema
 *  @extends FinancialProduct
 */
var CurrencyConversionService = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    FinancialProduct.call(this);
    this.context = "http://schema.org/";
    this.type = "CurrencyConversionService";
};
CurrencyConversionService = stjs.extend(CurrencyConversionService, FinancialProduct, [], null, {serviceAudience: "Audience", serviceArea: "GeoShape", provider: "Person", audience: "Audience", hasOfferCatalog: "OfferCatalog", hoursAvailable: "OpeningHoursSpecification", aggregateRating: "AggregateRating", offers: "Offer", broker: "Person", serviceOutput: "Thing", logo: "ImageObject", isSimilarTo: "Product", isRelatedTo: "Product", availableChannel: "ServiceChannel", review: "Review", produces: "Thing", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/APIReference
 *  Reference documentation for application programming interfaces (APIs).
 * 
 *  @author schema.org
 *  @class APIReference
 *  @module org.schema
 *  @extends TechArticle
 */
var APIReference = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    TechArticle.call(this);
    this.context = "http://schema.org/";
    this.type = "APIReference";
};
APIReference = stjs.extend(APIReference, TechArticle, [], function(constructor, prototype) {
    /**
     *  Schema.org/executableLibraryName
     *  Library file name e.g., mscorlib.dll, system.web.dll.
     * 
     *  @property executableLibraryName
     *  @type Text
     */
    prototype.executableLibraryName = null;
    /**
     *  Schema.org/assemblyVersion
     *  Associated product/technology version. e.g., .NET Framework 4.5.
     * 
     *  @property assemblyVersion
     *  @type Text
     */
    prototype.assemblyVersion = null;
    /**
     *  Schema.org/programmingModel
     *  Indicates whether API is managed or unmanaged.
     * 
     *  @property programmingModel
     *  @type Text
     */
    prototype.programmingModel = null;
    /**
     *  Schema.org/assembly
     *  Library file name e.g., mscorlib.dll, system.web.dll.
     * 
     *  @property assembly
     *  @type Text
     */
    prototype.assembly = null;
    /**
     *  Schema.org/targetPlatform
     *  Type of app development: phone, Metro style, desktop, XBox, etc.
     * 
     *  @property targetPlatform
     *  @type Text
     */
    prototype.targetPlatform = null;
}, {about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/BlogPosting
 *  A blog post.
 * 
 *  @author schema.org
 *  @class BlogPosting
 *  @module org.schema
 *  @extends SocialMediaPosting
 */
var BlogPosting = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    SocialMediaPosting.call(this);
    this.context = "http://schema.org/";
    this.type = "BlogPosting";
};
BlogPosting = stjs.extend(BlogPosting, SocialMediaPosting, [], null, {sharedContent: "CreativeWork", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/DiscussionForumPosting
 *  A posting to a discussion forum.
 * 
 *  @author schema.org
 *  @class DiscussionForumPosting
 *  @module org.schema
 *  @extends SocialMediaPosting
 */
var DiscussionForumPosting = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    SocialMediaPosting.call(this);
    this.context = "http://schema.org/";
    this.type = "DiscussionForumPosting";
};
DiscussionForumPosting = stjs.extend(DiscussionForumPosting, SocialMediaPosting, [], null, {sharedContent: "CreativeWork", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/Barcode
 *  An image of a visual machine-readable code such as a barcode or QR code.
 * 
 *  @author schema.org
 *  @class Barcode
 *  @module org.schema
 *  @extends ImageObject
 */
var Barcode = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    ImageObject.call(this);
    this.context = "http://schema.org/";
    this.type = "Barcode";
};
Barcode = stjs.extend(Barcode, ImageObject, [], null, {thumbnail: "ImageObject", height: "Distance", regionsAllowed: "Place", width: "Distance", associatedArticle: "NewsArticle", productionCompany: "Organization", duration: "Duration", encodesCreativeWork: "CreativeWork", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/ImageGallery
 *  Web page type: Image gallery page.
 * 
 *  @author schema.org
 *  @class ImageGallery
 *  @module org.schema
 *  @extends CollectionPage
 */
var ImageGallery = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CollectionPage.call(this);
    this.context = "http://schema.org/";
    this.type = "ImageGallery";
};
ImageGallery = stjs.extend(ImageGallery, CollectionPage, [], null, {mainContentOfPage: "WebPageElement", reviewedBy: "Organization", primaryImageOfPage: "ImageObject", specialty: "Specialty", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/VideoGallery
 *  Web page type: Video gallery page.
 * 
 *  @author schema.org
 *  @class VideoGallery
 *  @module org.schema
 *  @extends CollectionPage
 */
var VideoGallery = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    CollectionPage.call(this);
    this.context = "http://schema.org/";
    this.type = "VideoGallery";
};
VideoGallery = stjs.extend(VideoGallery, CollectionPage, [], null, {mainContentOfPage: "WebPageElement", reviewedBy: "Organization", primaryImageOfPage: "ImageObject", specialty: "Specialty", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/AppendAction
 *  The act of inserting at the end if an ordered collection.
 * 
 *  @author schema.org
 *  @class AppendAction
 *  @module org.schema
 *  @extends InsertAction
 */
var AppendAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    InsertAction.call(this);
    this.context = "http://schema.org/";
    this.type = "AppendAction";
};
AppendAction = stjs.extend(AppendAction, InsertAction, [], null, {toLocation: "Place", collection: "Thing", targetCollection: "Thing", result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/PrependAction
 *  The act of inserting at the beginning if an ordered collection.
 * 
 *  @author schema.org
 *  @class PrependAction
 *  @module org.schema
 *  @extends InsertAction
 */
var PrependAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    InsertAction.call(this);
    this.context = "http://schema.org/";
    this.type = "PrependAction";
};
PrependAction = stjs.extend(PrependAction, InsertAction, [], null, {toLocation: "Place", collection: "Thing", targetCollection: "Thing", result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/RsvpAction
 *  The act of notifying an event organizer as to whether you expect to attend the event.
 * 
 *  @author schema.org
 *  @class RsvpAction
 *  @module org.schema
 *  @extends InformAction
 */
var RsvpAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    InformAction.call(this);
    this.context = "http://schema.org/";
    this.type = "RsvpAction";
};
RsvpAction = stjs.extend(RsvpAction, InformAction, [], function(constructor, prototype) {
    /**
     *  Schema.org/additionalNumberOfGuests
     *  If responding yes, the number of guests who will attend in addition to the invitee.
     * 
     *  @property additionalNumberOfGuests
     *  @type Number
     */
    prototype.additionalNumberOfGuests = null;
    /**
     *  Schema.org/comment
     *  Comments, typically from users.
     * 
     *  @property comment
     *  @type Comment
     */
    prototype.comment = null;
    /**
     *  Schema.org/rsvpResponse
     *  The response (yes, no, maybe) to the RSVP.
     * 
     *  @property rsvpResponse
     *  @type RsvpResponseType
     */
    prototype.rsvpResponse = null;
}, {comment: "Comment", rsvpResponse: "RsvpResponseType", event: "SchemaEvent", about: "Thing", recipient: "Organization", inLanguage: "Language", language: "Language", result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/ConfirmAction
 *  The act of notifying someone that a future event/action is going to happen as expected.\n\nRelated actions:\n\n* [[CancelAction]]: The antonym of ConfirmAction.
 * 
 *  @author schema.org
 *  @class ConfirmAction
 *  @module org.schema
 *  @extends InformAction
 */
var ConfirmAction = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    InformAction.call(this);
    this.context = "http://schema.org/";
    this.type = "ConfirmAction";
};
ConfirmAction = stjs.extend(ConfirmAction, InformAction, [], null, {event: "SchemaEvent", about: "Thing", recipient: "Organization", inLanguage: "Language", language: "Language", result: "Thing", actionStatus: "ActionStatusType", target: "EntryPoint", agent: "Person", participant: "Person", instrument: "Thing", object: "Thing", error: "Thing", location: "PostalAddress", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/CreditCard
 *  A card payment method of a particular brand or name.  Used to mark up a particular payment method and/or the financial product/service that supplies the card account.\n\nCommonly used values:\n\n* http://purl.org/goodrelations/v1#AmericanExpress\n* http://purl.org/goodrelations/v1#DinersClub\n* http://purl.org/goodrelations/v1#Discover\n* http://purl.org/goodrelations/v1#JCB\n* http://purl.org/goodrelations/v1#MasterCard\n* http://purl.org/goodrelations/v1#VISA
 * 
 *  @author schema.org
 *  @class CreditCard
 *  @module org.schema
 *  @extends LoanOrCredit
 */
var CreditCard = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    LoanOrCredit.call(this);
    this.context = "http://schema.org/";
    this.type = "CreditCard";
};
CreditCard = stjs.extend(CreditCard, LoanOrCredit, [], null, {loanTerm: "QuantitativeValue", requiredCollateral: "Thing", serviceAudience: "Audience", serviceArea: "GeoShape", provider: "Person", audience: "Audience", hasOfferCatalog: "OfferCatalog", hoursAvailable: "OpeningHoursSpecification", aggregateRating: "AggregateRating", offers: "Offer", broker: "Person", serviceOutput: "Thing", logo: "ImageObject", isSimilarTo: "Product", isRelatedTo: "Product", availableChannel: "ServiceChannel", review: "Review", produces: "Thing", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/DepositAccount
 *  A type of Bank Account with a main purpose of depositing funds to gain interest or other benefits.
 * 
 *  @author schema.org
 *  @class DepositAccount
 *  @module org.schema
 *  @extends BankAccount
 */
var DepositAccount = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    BankAccount.call(this);
    this.context = "http://schema.org/";
    this.type = "DepositAccount";
};
DepositAccount = stjs.extend(DepositAccount, BankAccount, [], null, {serviceAudience: "Audience", serviceArea: "GeoShape", provider: "Person", audience: "Audience", hasOfferCatalog: "OfferCatalog", hoursAvailable: "OpeningHoursSpecification", aggregateRating: "AggregateRating", offers: "Offer", broker: "Person", serviceOutput: "Thing", logo: "ImageObject", isSimilarTo: "Product", isRelatedTo: "Product", availableChannel: "ServiceChannel", review: "Review", produces: "Thing", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Schema.org/LiveBlogPosting
 *  A blog post intended to provide a rolling textual coverage of an ongoing event through continuous updates.
 * 
 *  @author schema.org
 *  @class LiveBlogPosting
 *  @module org.schema
 *  @extends BlogPosting
 */
var LiveBlogPosting = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    BlogPosting.call(this);
    this.context = "http://schema.org/";
    this.type = "LiveBlogPosting";
};
LiveBlogPosting = stjs.extend(LiveBlogPosting, BlogPosting, [], function(constructor, prototype) {
    /**
     *  Schema.org/coverageStartTime
     *  The time when the live blog will begin covering the SchemaEvent. Note that coverage may begin before the SchemaEvent's start time. The LiveBlogPosting may also be created before coverage begins.
     * 
     *  @property coverageStartTime
     *  @type DateTime
     */
    prototype.coverageStartTime = null;
    /**
     *  Schema.org/coverageEndTime
     *  The time when the live blog will stop covering the SchemaEvent. Note that coverage may continue after the SchemaEvent concludes.
     * 
     *  @property coverageEndTime
     *  @type DateTime
     */
    prototype.coverageEndTime = null;
    /**
     *  Schema.org/liveBlogUpdate
     *  An update to the LiveBlog.
     * 
     *  @property liveBlogUpdate
     *  @type BlogPosting
     */
    prototype.liveBlogUpdate = null;
}, {liveBlogUpdate: "BlogPosting", sharedContent: "CreativeWork", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});

/**
 *  www.w3.org/2004/02/skos/core/Collection
 *  A meaningful collection of concepts.
 *  Labelled collections can be used where you would like a set of concepts to be displayed under a 'node label' in the hierarchy.
 *  @author w3.org
 *  @class Collection
 *  @module org.w3.skos
 */
var Collection = /**
 *  Constructor, automatically sets @context and @type.
 *  @constructor
 */
function() {
    EcRemoteLinkedData.call(this, "https://schema.cassproject.org/0.4/skos/", "Collection");
};
Collection = stjs.extend(Collection, EcRemoteLinkedData, [], function(constructor, prototype) {
    /**
     *  www.w3.org/2004/02/skos/core/member
     *  Relates a collection to one of its members.
     *  @property member
     *  @type N0e403dc85fe548d1b3d2f3d1ded36d20
     */
    prototype.member = null;
}, {member: {name: "Array", arguments: ["Object"]}, owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  www.w3.org/2004/02/skos/core/ConceptScheme
 *  A set of concepts, optionally including statements about semantic relationships between those concepts.
 *  A concept scheme may be defined to include concepts from different sources.
 *  @author w3.org
 *  @class ConceptScheme
 *  @module org.w3.skos
 */
var ConceptScheme = /**
 *  Constructor, automatically sets @context and @type.
 *  @constructor
 */
function() {
    EcRemoteLinkedData.call(this, "https://schema.cassproject.org/0.4/skos/", "ConceptScheme");
};
ConceptScheme = stjs.extend(ConceptScheme, EcRemoteLinkedData, [], function(constructor, prototype) {
    constructor.TYPE_0_1 = "http://schema.cassproject.org/0.3/skos/ConceptScheme";
    constructor.TYPE_0_2 = "https://schema.cassproject.org/0.3/skos/ConceptScheme";
    constructor.TYPE_0_3 = "https://schema.cassproject.org/0.4/skos/ConceptScheme";
    constructor.myType = ConceptScheme.TYPE_0_3;
    /**
     *  www.w3.org/2004/02/skos/core/hasTopConcept
     *  Relates, by convention, a concept scheme to a concept which is topmost in the broader/narrower concept hierarchies for that scheme, providing an entry point to these hierarchies.
     *  @property hasTopConcept
     *  @type Concept
     */
    prototype.hasTopConcept = null;
    prototype.upgrade = function() {
        EcRemoteLinkedData.prototype.upgrade.call(this);
        if (ConceptScheme.TYPE_0_1.equals(this.getFullType())) {
            this.setContextAndType("https://schema.cassproject.org/0.3/skos", ConceptScheme.TYPE_0_2);
        }
        if (ConceptScheme.TYPE_0_2.equals(this.getFullType())) {
            this.setContextAndType("https://schema.cassproject.org/0.4/skos", ConceptScheme.TYPE_0_3);
        }
    };
    prototype.getTypes = function() {
        var a = new Array();
        a.push(ConceptScheme.TYPE_0_3);
        a.push(ConceptScheme.TYPE_0_2);
        a.push(ConceptScheme.TYPE_0_1);
        return a;
    };
}, {hasTopConcept: "Concept", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  www.w3.org/2004/02/skos/core/Concept
 *  An idea or notion; a unit of thought.
 *  @author w3.org
 *  @class Concept
 *  @module org.w3.skos
 */
var Concept = /**
 *  Constructor, automatically sets @context and @type.
 *  @constructor
 */
function() {
    EcRemoteLinkedData.call(this, "https://schema.cassproject.org/0.4/skos/", "Concept");
};
Concept = stjs.extend(Concept, EcRemoteLinkedData, [], function(constructor, prototype) {
    constructor.TYPE_0_1 = "http://schema.cassproject.org/0.3/skos/Concept";
    constructor.TYPE_0_2 = "https://schema.cassproject.org/0.3/skos/Concept";
    constructor.TYPE_0_3 = "https://schema.cassproject.org/0.4/skos/Concept";
    constructor.myType = Concept.TYPE_0_3;
    /**
     *  www.w3.org/2004/02/skos/core/topConceptOf
     *  Relates a concept to the concept scheme that it is a top level concept of.
     *  @property topConceptOf
     *  @type ConceptScheme
     */
    prototype.topConceptOf = null;
    /**
     *  www.w3.org/2004/02/skos/core/semanticRelation
     *  Links a concept to a concept related by meaning.
     *  @property semanticRelation
     *  @type Concept
     */
    prototype.semanticRelation = null;
    prototype.upgrade = function() {
        EcRemoteLinkedData.prototype.upgrade.call(this);
        if (Concept.TYPE_0_1.equals(this.getFullType())) {
            this.setContextAndType("https://schema.cassproject.org/0.3/skos", Concept.TYPE_0_2);
        }
        if (Concept.TYPE_0_2.equals(this.getFullType())) {
            this.setContextAndType("https://schema.cassproject.org/0.4/skos", Concept.TYPE_0_3);
        }
    };
    prototype.getTypes = function() {
        var a = new Array();
        a.push(Concept.TYPE_0_3);
        a.push(Concept.TYPE_0_2);
        a.push(Concept.TYPE_0_1);
        return a;
    };
}, {topConceptOf: "ConceptScheme", semanticRelation: "Concept", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  www.w3.org/2004/02/skos/core/OrderedCollection
 *  An ordered collection of concepts, where both the grouping and the ordering are meaningful.
 *  Ordered collections can be used where you would like a set of concepts to be displayed in a specific order, and optionally under a 'node label'.
 *  @author w3.org
 *  @class OrderedCollection
 *  @module org.w3.skos
 *  @extends Collection
 */
var OrderedCollection = /**
 *  Constructor, automatically sets @context and @type.
 *  @constructor
 */
function() {
    Collection.call(this);
    this.context = "https://schema.cassproject.org/0.4/skos/";
    this.type = "OrderedCollection";
};
OrderedCollection = stjs.extend(OrderedCollection, Collection, [], function(constructor, prototype) {
    /**
     *  www.w3.org/2004/02/skos/core/memberList
     *  Relates an ordered collection to the RDF list containing its members.
     *  @property memberList
     *  @type List
     */
    prototype.memberList = null;
}, {memberList: {name: "Array", arguments: ["Object"]}, member: {name: "Array", arguments: ["Object"]}, owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});

/**
 *  Encrypted JSON-LD object or string.
 * 
 *  @author fritz.ray@eduworks.com
 *  @class EbacEncryptedValue
 *  @module org.cassproject
 */
var EbacEncryptedValue = function() {
    EcRemoteLinkedData.call(this, Ebac.context, EbacEncryptedValue.myType);
};
EbacEncryptedValue = stjs.extend(EbacEncryptedValue, EcRemoteLinkedData, [], function(constructor, prototype) {
    constructor.TYPE_0_1 = "http://schema.eduworks.com/ebac/0.1/encryptedValue";
    constructor.TYPE_0_2 = "http://schema.eduworks.com/ebac/0.2/encryptedValue";
    constructor.TYPE_0_3 = "http://schema.cassproject.org/kbac/0.2/EncryptedValue";
    constructor.TYPE_0_4 = "https://schema.cassproject.org/kbac/0.4/EncryptedValue";
    constructor.myType = EbacEncryptedValue.TYPE_0_4;
    /**
     *  Optional Hint used to aid in search.
     *  Displays the type of the encrypted object.
     * 
     *  @property encryptedType
     *  @type string
     */
    prototype.encryptedType = null;
    /**
     *  Optional Hint used to aid in search.
     *  Displays the context of the encrypted object.
     * 
     *  @property encryptedContext
     *  @type string
     */
    prototype.encryptedContext = null;
    /**
     *  Base-64 encoded, AES encrypted form of the encrypted object (or string).
     * 
     *  @property payload
     *  @type string
     */
    prototype.payload = null;
    /**
     *  Optional Hint used to aid in search and display.
     *  Name of the inner encrypted object.
     * 
     *  @property name
     *  @type string
     */
    prototype.name = null;
    /**
     *  Array of EbacEncryptedSecret objects encoded in Base-64, encrypted using
     *  RSA public keys of owners, readers, or other parties to allow them
     *  access to the payload.
     * 
     *  @property secret
     *  @type string[]
     */
    prototype.secret = null;
    prototype.copyFrom = function(that) {
        var me = (this);
        for (var key in me) 
            delete me[key];
        var you = (that);
        for (var key in you) {
            if (me[key] == null) 
                me[key.replace("@", "")] = you[key];
        }
        if (!this.isAny(this.getTypes())) 
             throw new RuntimeException("Incompatible type: " + this.getFullType());
    };
    prototype.upgrade = function() {
        EcRemoteLinkedData.prototype.upgrade.call(this);
        if (EbacEncryptedValue.TYPE_0_1 == this.type) {
            var me = (this);
            if (me["@context"] == null && me["@schema"] != null) 
                me["@context"] = me["@schema"];
            this.setContextAndType(Ebac.context_0_2, EbacEncryptedValue.TYPE_0_2);
        }
        if (EbacEncryptedValue.TYPE_0_2 == this.getFullType()) {
            this.setContextAndType(Ebac.context_0_3, EbacEncryptedValue.TYPE_0_3);
        }
        if (EbacEncryptedValue.TYPE_0_3 == this.getFullType()) {
            this.setContextAndType(Ebac.context_0_4, EbacEncryptedValue.TYPE_0_4);
        }
    };
    prototype.getTypes = function() {
        var a = new Array();
        a.push(EbacEncryptedValue.TYPE_0_4);
        a.push(EbacEncryptedValue.TYPE_0_3);
        a.push(EbacEncryptedValue.TYPE_0_2);
        a.push(EbacEncryptedValue.TYPE_0_1);
        return a;
    };
}, {secret: {name: "Array", arguments: [null]}, owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  AES encrypted public key and display name message.
 *  Used to grant access to a contact.
 *  Contains Initialization Vectors, but not secrets.
 *  Used to encrypt public identities for storage on remote systems.
 * 
 *  @author fritz.ray@eduworks.com
 *  @class EbacContactGrant
 *  @module org.cassproject
 */
var EbacContactGrant = function() {
    EcRemoteLinkedData.call(this, Ebac.context, EbacContactGrant.TYPE_0_4);
};
EbacContactGrant = stjs.extend(EbacContactGrant, EcRemoteLinkedData, [], function(constructor, prototype) {
    constructor.TYPE_0_1 = "http://schema.eduworks.com/ebac/0.1/contactGrant";
    constructor.TYPE_0_2 = "http://schema.eduworks.com/ebac/0.2/contactGrant";
    constructor.TYPE_0_3 = "http://schema.cassproject.org/kbac/0.2/ContactGrant";
    constructor.TYPE_0_4 = "https://schema.cassproject.org/kbac/0.4/ContactGrant";
    /**
     *  Public key being granted to the owner of this message.
     * 
     *  @property pk
     *  @type string(pem)
     */
    prototype.pk = null;
    /**
     *  Display name of the contact.
     * 
     *  @property displayName
     *  @type string
     */
    prototype.displayName = null;
    /**
     *  Source server of the contact.
     * 
     *  @property source
     *  @type string
     */
    prototype.source = null;
    /**
     *  Response token used to validate that this grant is in response to a contact request you sent.
     * 
     *  @property responseToken
     *  @type string
     */
    prototype.responseToken = null;
    /**
     *  Signature (Base64 encoded) of the response token to verify against your own public key
     *  to ensure that this grant is in response to a contact request you sent.
     * 
     *  @property responseSignature
     *  @type string
     */
    prototype.responseSignature = null;
    prototype.upgrade = function() {
        EcRemoteLinkedData.prototype.upgrade.call(this);
        if (EbacContactGrant.TYPE_0_1.equals(this.type)) {
            var me = (this);
            if (me["@context"] == null && me["@schema"] != null) 
                me["@context"] = me["@schema"];
            this.setContextAndType(Ebac.context_0_2, EbacContactGrant.TYPE_0_2);
        }
        if (EbacContactGrant.TYPE_0_2.equals(this.getFullType())) {
            this.setContextAndType(Ebac.context_0_3, EbacContactGrant.TYPE_0_3);
        }
        if (EbacContactGrant.TYPE_0_3.equals(this.getFullType())) {
            this.setContextAndType(Ebac.context_0_4, EbacContactGrant.TYPE_0_4);
        }
    };
    prototype.getTypes = function() {
        var a = new Array();
        a.push(EbacContactGrant.TYPE_0_4);
        a.push(EbacContactGrant.TYPE_0_3);
        a.push(EbacContactGrant.TYPE_0_2);
        a.push(EbacContactGrant.TYPE_0_1);
        return a;
    };
}, {owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  AES encrypted public key and display name. Contains Initialization Vectors,
 *  but not secrets. Used to encrypt public identities for storage on remote
 *  systems.
 * 
 *  @author fritz.ray@eduworks.com
 *  @class EbacContact
 *  @module org.cassproject
 */
var EbacContact = function() {
    EcLinkedData.call(this, Ebac.context, EbacContact.TYPE_0_4);
};
EbacContact = stjs.extend(EbacContact, EcLinkedData, [], function(constructor, prototype) {
    constructor.TYPE_0_1 = "http://schema.eduworks.com/ebac/0.2/contact";
    constructor.TYPE_0_2 = "http://schema.eduworks.com/ebac/0.2/contact";
    constructor.TYPE_0_3 = "http://schema.cassproject.org/kbac/0.2/Contact";
    constructor.TYPE_0_4 = "https://schema.cassproject.org/kbac/0.4/Contact";
    /**
     *  AES Initialization Vector used to decode PPK. Base64 encoded.
     * 
     *  @property iv
     *  @type string
     */
    prototype.iv = null;
    /**
     *  AES encrypted Private Key in PEM format.
     * 
     *  @property pk
     *  @type string
     */
    prototype.pk = null;
    /**
     *  AES Initialization Vector used to decode displayName. Base64 encoded.
     * 
     *  @property displayNameIv
     *  @type string
     */
    prototype.displayNameIv = null;
    /**
     *  AES encrypted display name for identity.
     * 
     *  @property displayName
     *  @type string
     */
    prototype.displayName = null;
    /**
     *  AES Initialization Vector of the home server of the contact. Base64 encoded.
     * 
     *  @property sourceIv
     *  @type string
     */
    prototype.sourceIv = null;
    /**
     *  URL to the home server of the contact.
     * 
     *  @property source
     *  @type string
     */
    prototype.source = null;
    prototype.upgrade = function() {
        EcLinkedData.prototype.upgrade.call(this);
        if (EbacContact.TYPE_0_1.equals(this.type)) {
            var me = (this);
            if (me["@context"] == null && me["@schema"] != null) 
                me["@context"] = me["@schema"];
            this.setContextAndType(Ebac.context_0_2, EbacContact.TYPE_0_2);
        }
        if (EbacContact.TYPE_0_2.equals(this.getFullType())) {
            this.setContextAndType(Ebac.context_0_3, EbacContact.TYPE_0_3);
        }
        if (EbacContact.TYPE_0_3.equals(this.getFullType())) {
            this.setContextAndType(Ebac.context_0_4, EbacContact.TYPE_0_4);
        }
    };
    prototype.getTypes = function() {
        var a = new Array();
        a.push(EbacContact.TYPE_0_4);
        a.push(EbacContact.TYPE_0_3);
        a.push(EbacContact.TYPE_0_2);
        a.push(EbacContact.TYPE_0_1);
        return a;
    };
}, {atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Component of EbacEncryptedValue that contains data needed to decrypt
 *  encrypted payload. Is, itself, encrypted.
 *  <p>
 *  Also contains data used to verify that encrypted-data substitution attacks
 *  were not performed on the data.
 *  <p>
 *  Must be encryptable by RSA-2048, therefore, serialized form must less than 256
 *  bytes.
 * 
 *  @author fritz.ray@eduworks.com
 *  @class EbacEncryptedSecret
 *  @module org.cassproject
 */
var EbacEncryptedSecret = function() {
    EcLinkedData.call(this, Ebac.context, EbacEncryptedSecret.TYPE_0_4);
};
EbacEncryptedSecret = stjs.extend(EbacEncryptedSecret, EcLinkedData, [], function(constructor, prototype) {
    constructor.TYPE_0_1 = "http://schema.eduworks.com/ebac/0.1/encryptedSecret";
    constructor.TYPE_0_2 = "http://schema.eduworks.com/ebac/0.2/encryptedSecret";
    constructor.TYPE_0_3 = "http://schema.cassproject.org/kbac/0.2/EncryptedSecret";
    constructor.TYPE_0_4 = "https://schema.cassproject.org/kbac/0.4/EncryptedSecret";
    /**
     *  IV used to encrypt/decrypt payload. Base64 encoded.
     * 
     *  @property iv
     *  @type string
     */
    prototype.iv = null;
    /**
     *  Hashed and Base64 encoded ID of the parent (if any) object.
     *  Used to verify the data has not been copied from elsewhere.
     * 
     *  @property id
     *  @type string
     */
    prototype.id = null;
    /**
     *  Secret used to encrypt/decrypt payload.
     * 
     *  @property secret
     *  @type string
     */
    prototype.secret = null;
    /**
     *  Dot and Bracket notated index of the field in the parent-most object (if
     *  any). Used to verify the field has not been copied from elsewhere.
     * 
     *  @property field
     *  @type string
     */
    prototype.field = null;
    /**
     *  Deserializes the field from a compact form used in RSA encryption.
     * 
     *  @param {JSONObject} obj Object to deserialize from.
     *  @return {EbacEncryptedSecret} Secret in object form.
     *  @method fromEncryptableJson
     *  @static
     */
    constructor.fromEncryptableJson = function(obj) {
        var secret = new EbacEncryptedSecret();
        var o = (obj);
        secret.iv = o["v"];
        if (o["d"] != null) 
            secret.id = o["d"];
        secret.secret = o["s"];
        if (o["f"] != null) 
            secret.field = o["f"];
        return secret;
    };
    /**
     *  Serializes the field into a compact form for RSA encryption.
     * 
     *  @return {string} string
     *  @method toEncryptableJson
     */
    prototype.toEncryptableJson = function() {
        var o = (new Object());
        o["v"] = this.iv;
        if (this.id != null) 
            o["d"] = this.id;
        o["s"] = this.secret;
        if (this.field != null) 
            o["f"] = this.field;
        return JSON.stringify(o);
    };
    prototype.upgrade = function() {
        EcLinkedData.prototype.upgrade.call(this);
        if (EbacEncryptedSecret.TYPE_0_1.equals(this.type)) {
            var me = (this);
            if (me["@context"] == null && me["@schema"] != null) 
                me["@context"] = me["@schema"];
            this.setContextAndType(Ebac.context_0_2, EbacEncryptedSecret.TYPE_0_2);
        }
        if (EbacEncryptedSecret.TYPE_0_2.equals(this.getFullType())) {
            this.setContextAndType(Ebac.context_0_3, EbacEncryptedSecret.TYPE_0_3);
        }
        if (EbacEncryptedSecret.TYPE_0_3.equals(this.getFullType())) {
            this.setContextAndType(Ebac.context_0_4, EbacEncryptedSecret.TYPE_0_4);
        }
    };
    prototype.getTypes = function() {
        var a = new Array();
        a.push(EbacEncryptedSecret.TYPE_0_4);
        a.push(EbacEncryptedSecret.TYPE_0_3);
        a.push(EbacEncryptedSecret.TYPE_0_2);
        a.push(EbacEncryptedSecret.TYPE_0_1);
        return a;
    };
}, {atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Signature used to authorize movement of data on behalf of a private-key
 *  holding owner.
 * 
 *  @author fritz.ray@eduworks.com
 *  @class EbacSignature
 *  @module org.cassproject
 */
var EbacSignature = function() {
    EcLinkedData.call(this, Ebac.context, EbacSignature.TYPE_0_4);
};
EbacSignature = stjs.extend(EbacSignature, EcLinkedData, [], function(constructor, prototype) {
    constructor.TYPE_0_1 = "http://schema.eduworks.com/ebac/0.1/timeLimitedSignature";
    constructor.TYPE_0_2 = "http://schema.eduworks.com/ebac/0.2/timeLimitedSignature";
    constructor.TYPE_0_3 = "http://schema.cassproject.org/kbac/0.2/TimeLimitedSignature";
    constructor.TYPE_0_4 = "https://schema.cassproject.org/kbac/0.4/TimeLimitedSignature";
    /**
     *  The public key of the authorizing party in PEM format.
     * 
     *  @property owner
     *  @type string
     */
    prototype.owner = null;
    /**
     *  The time in number of milliseconds since midnight of January 1, 1970
     *  00:00:00 UTC that this signature is authorized to move data.
     * 
     *  @property expiry
     *  @type long
     */
    prototype.expiry = null;
    /**
     *  The signature of this object, having signed the object, having been
     *  encoded in JSON with no space or tabs in ASCII sort order, having no
     *  value for the signature at the time of signing.
     * 
     *  @property signature
     *  @type string
     */
    prototype.signature = null;
    /**
     *  The server authorized to move data. If this is empty, the signature may
     *  be used by a server to ask for data from other servers.
     * 
     *  @property server
     *  @type string
     */
    prototype.server = null;
    prototype.upgrade = function() {
        EcLinkedData.prototype.upgrade.call(this);
    };
    prototype.getTypes = function() {
        var a = new Array();
        a.push(EbacSignature.TYPE_0_4);
        a.push(EbacSignature.TYPE_0_3);
        a.push(EbacSignature.TYPE_0_2);
        a.push(EbacSignature.TYPE_0_1);
        return a;
    };
}, {atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  AES encrypted private key and display name. Contains Initialization Vectors,
 *  but not secrets. Used to encrypt private identities for storage on remote
 *  systems.
 * 
 *  @author fritz.ray@eduworks.com
 *  @class EbacCredential
 *  @module org.cassproject
 */
var EbacCredential = function() {
    EcLinkedData.call(this, Ebac.context, EbacCredential.TYPE_0_4);
};
EbacCredential = stjs.extend(EbacCredential, EcLinkedData, [], function(constructor, prototype) {
    constructor.TYPE_0_1 = "http://schema.eduworks.com/ebac/0.1/credential";
    constructor.TYPE_0_2 = "http://schema.eduworks.com/ebac/0.2/credential";
    constructor.TYPE_0_3 = "http://schema.cassproject.org/kbac/0.2/Credential";
    constructor.TYPE_0_4 = "https://schema.cassproject.org/kbac/0.4/Credential";
    /**
     *  AES Initialization Vector used to decode PPK. Base64 encoded.
     * 
     *  @property iv
     *  @type string
     */
    prototype.iv = null;
    /**
     *  AES encrypted Private Key in PEM form.
     * 
     *  @property ppk
     *  @type string
     */
    prototype.ppk = null;
    /**
     *  AES Initialization Vector used to decode displayName. Base64 encoded.
     * 
     *  @property displayNameIv
     *  @type string
     */
    prototype.displayNameIv = null;
    /**
     *  AES encrypted display name for identity.
     * 
     *  @property displayName
     *  @type string
     */
    prototype.displayName = null;
    prototype.upgrade = function() {
        EcLinkedData.prototype.upgrade.call(this);
        if (EbacCredential.TYPE_0_1.equals(this.type)) {
            var me = (this);
            if (me["@context"] == null && me["@schema"] != null) 
                me["@context"] = me["@schema"];
            this.setContextAndType(Ebac.context_0_2, EbacCredential.TYPE_0_2);
        }
        if (EbacCredential.TYPE_0_2.equals(this.getFullType())) {
            this.setContextAndType(Ebac.context_0_3, EbacCredential.TYPE_0_3);
        }
        if (EbacCredential.TYPE_0_3.equals(this.getFullType())) {
            this.setContextAndType(Ebac.context_0_4, EbacCredential.TYPE_0_4);
        }
    };
    prototype.getTypes = function() {
        var a = new Array();
        a.push(EbacCredential.TYPE_0_4);
        a.push(EbacCredential.TYPE_0_3);
        a.push(EbacCredential.TYPE_0_2);
        a.push(EbacCredential.TYPE_0_1);
        return a;
    };
}, {atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Message used to retrieve credentials from a remote system.
 *  <p>
 *  TODO: Vulnerable to replay attacks.
 * 
 *  @author fritz.ray@eduworks.com
 *  @class EbacCredentialRequest
 *  @module org.cassproject
 */
var EbacCredentialRequest = function() {
    EcLinkedData.call(this, Ebac.context, EbacCredentialRequest.TYPE_0_4);
};
EbacCredentialRequest = stjs.extend(EbacCredentialRequest, EcLinkedData, [], function(constructor, prototype) {
    constructor.TYPE_0_1 = "http://schema.eduworks.com/ebac/0.1/credentialRequest";
    constructor.TYPE_0_2 = "http://schema.eduworks.com/ebac/0.2/credentialRequest";
    constructor.TYPE_0_3 = "http://schema.cassproject.org/kbac/0.2/CredentialRequest";
    constructor.TYPE_0_4 = "https://schema.cassproject.org/kbac/0.4/CredentialRequest";
    /**
     *  Hashed username.
     * 
     *  @property username
     *  @type string
     */
    prototype.username = null;
    /**
     *  Hashed password to authorize request.
     * 
     *  @property password
     *  @type string
     */
    prototype.password = null;
    prototype.upgrade = function() {
        EcLinkedData.prototype.upgrade.call(this);
        if (EbacCredentialRequest.TYPE_0_1 == this.type) {
            var me = (this);
            if (me["@context"] == null && me["@schema"] != null) 
                me["@context"] = me["@schema"];
            this.setContextAndType(Ebac.context_0_2, EbacCredentialRequest.TYPE_0_2);
        }
        if (EbacCredentialRequest.TYPE_0_2 == this.getFullType()) {
            this.setContextAndType(Ebac.context_0_3, EbacCredentialRequest.TYPE_0_3);
        }
        if (EbacCredentialRequest.TYPE_0_3 == this.getFullType()) {
            this.setContextAndType(Ebac.context_0_4, EbacCredentialRequest.TYPE_0_4);
        }
    };
    prototype.getTypes = function() {
        var a = new Array();
        a.push(EbacCredentialRequest.TYPE_0_4);
        a.push(EbacCredentialRequest.TYPE_0_3);
        a.push(EbacCredentialRequest.TYPE_0_2);
        a.push(EbacCredentialRequest.TYPE_0_1);
        return a;
    };
}, {atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Credential list along with one time pad and session-based token for use in
 *  commit actions.
 * 
 *  @author fritz.ray@eduworks.com
 *  @class EbacCredentials
 *  @module org.cassproject
 */
var EbacCredentials = function() {
    EcLinkedData.call(this, Ebac.context, EbacCredentials.TYPE_0_4);
};
EbacCredentials = stjs.extend(EbacCredentials, EcLinkedData, [], function(constructor, prototype) {
    constructor.TYPE_0_1 = "http://schema.eduworks.com/ebac/0.1/credentials";
    constructor.TYPE_0_2 = "http://schema.eduworks.com/ebac/0.2/credentials";
    constructor.TYPE_0_3 = "http://schema.cassproject.org/kbac/0.2/Credentials";
    constructor.TYPE_0_4 = "https://schema.cassproject.org/kbac/0.4/Credentials";
    /**
     *  One time pad that may be used in password recovery. Base64 encoded.
     * 
     *  @property pad
     *  @type string
     */
    prototype.pad = null;
    /**
     *  Token provided by server to use in commit actions.
     * 
     *  @property token
     *  @type string
     */
    prototype.token = null;
    /**
     *  Credential array.
     * 
     *  @property credentials
     *  @type EbacCredential[]
     */
    prototype.credentials = null;
    /**
     *  Contact array.
     * 
     *  @property contacts
     *  @type EbacContact[]
     */
    prototype.contacts = null;
    prototype.upgrade = function() {
        EcLinkedData.prototype.upgrade.call(this);
        if (EbacCredentials.TYPE_0_1.equals(this.type)) {
            var me = (this);
            if (me["@context"] == null && me["@schema"] != null) 
                me["@context"] = me["@schema"];
            this.setContextAndType(Ebac.context_0_2, EbacCredentials.TYPE_0_2);
        }
        if (EbacCredentials.TYPE_0_2.equals(this.getFullType())) {
            this.setContextAndType(Ebac.context_0_3, EbacCredentials.TYPE_0_3);
        }
        if (EbacCredentials.TYPE_0_3.equals(this.getFullType())) {
            this.setContextAndType(Ebac.context_0_4, EbacCredentials.TYPE_0_4);
        }
    };
    prototype.getTypes = function() {
        var a = new Array();
        a.push(EbacCredentials.TYPE_0_4);
        a.push(EbacCredentials.TYPE_0_3);
        a.push(EbacCredentials.TYPE_0_2);
        a.push(EbacCredentials.TYPE_0_1);
        return a;
    };
}, {credentials: {name: "Array", arguments: ["EbacCredential"]}, contacts: {name: "Array", arguments: ["EbacContact"]}, atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Message used to commit credentials to a remote login server.
 *  <p>
 *  TODO: Vulnerable to replay attacks. Token field prevents some replay
 *  attacks.
 * 
 *  @author fritz.ray@eduworks.com
 *  @class EbacCredentialCommit
 *  @module org.cassproject
 */
var EbacCredentialCommit = function() {
    EcLinkedData.call(this, Ebac.context, EbacCredentialCommit.TYPE_0_4);
    this.credentials = new EbacCredentials();
};
EbacCredentialCommit = stjs.extend(EbacCredentialCommit, EcLinkedData, [], function(constructor, prototype) {
    constructor.TYPE_0_1 = "http://schema.eduworks.com/ebac/0.1/credentialCommit";
    constructor.TYPE_0_2 = "http://schema.eduworks.com/ebac/0.2/credentialCommit";
    constructor.TYPE_0_3 = "http://schema.cassproject.org/kbac/0.2/CredentialCommit";
    constructor.TYPE_0_4 = "https://schema.cassproject.org/kbac/0.4/CredentialCommit";
    /**
     *  Hashed username.
     * 
     *  @property username
     *  @type string
     */
    prototype.username = null;
    /**
     *  Hashed password to authorize commit.
     * 
     *  @property password
     *  @type string
     */
    prototype.password = null;
    /**
     *  Token provided to client when previously executed Request was done. May
     *  be empty if this is used as part of Create action.
     * 
     *  @property token
     *  @type string
     */
    prototype.token = null;
    /**
     *  List of credentials to commit to the login server storage.
     * 
     *  @property credentials
     *  @type EbacCredentials
     */
    prototype.credentials = null;
    prototype.upgrade = function() {
        EcLinkedData.prototype.upgrade.call(this);
        if (EbacCredentialCommit.TYPE_0_1.equals(this.type)) {
            var me = (this);
            if (me["@context"] == null && me["@schema"] != null) 
                me["@context"] = me["@schema"];
            this.setContextAndType(Ebac.context_0_2, EbacCredentialCommit.TYPE_0_2);
        }
        if (EbacCredentialCommit.TYPE_0_2.equals(this.getFullType())) {
            this.setContextAndType(Ebac.context_0_3, EbacCredentialCommit.TYPE_0_3);
        }
        if (EbacCredentialCommit.TYPE_0_3.equals(this.getFullType())) {
            this.setContextAndType(Ebac.context_0_4, EbacCredentialCommit.TYPE_0_4);
        }
    };
    prototype.getTypes = function() {
        var a = new Array();
        a.push(EbacCredentialCommit.TYPE_0_4);
        a.push(EbacCredentialCommit.TYPE_0_3);
        a.push(EbacCredentialCommit.TYPE_0_2);
        a.push(EbacCredentialCommit.TYPE_0_1);
        return a;
    };
}, {credentials: "EbacCredentials", atProperties: {name: "Array", arguments: [null]}}, {});

/**
 *  Class used to hold namespace data.
 * 
 *  @author fray
 *  @class Cass
 *  @module org.cassproject
 */
var Cass = function() {};
Cass = stjs.extend(Cass, null, [], function(constructor, prototype) {
    constructor.context_0_1 = "http://schema.eduworks.com/cass/0.1";
    constructor.context_0_2 = "http://schema.eduworks.com/cass/0.2";
    constructor.context_0_3 = "http://schema.cassproject.org/0.2";
    constructor.context_0_4 = "http://schema.cassproject.org/0.3";
    constructor.context_0_5 = "https://schema.cassproject.org/0.3";
    constructor.context_0_6 = "https://schema.cassproject.org/0.4";
    constructor.context = Cass.context_0_6;
}, {}, {});
var AssertionCodebook = function() {};
AssertionCodebook = stjs.extend(AssertionCodebook, null, [], function(constructor, prototype) {
    prototype.agent = null;
    prototype.subject = null;
    prototype.assertionDate = null;
    prototype.expirationDate = null;
    prototype.decayFunction = null;
    prototype.negative = null;
    prototype.evidence = null;
    prototype.assertionShortId = null;
}, {agent: "EbacEncryptedSecret", subject: "EbacEncryptedSecret", assertionDate: "EbacEncryptedSecret", expirationDate: "EbacEncryptedSecret", decayFunction: "EbacEncryptedSecret", negative: "EbacEncryptedSecret", evidence: {name: "Array", arguments: ["EbacEncryptedSecret"]}}, {});
/**
 *  Competencies include skills, knowledge, abilities, traits, and combinations thereof that are needed to perform a task or job. In CASS, competencies are identified and located using a globally unique ID. Competencies can be further described using titles, descriptions, levels, indicators (coming soon), roll-up rules, and relationships to other competencies.
 * 
 *  @author fritz.ray@eduworks.com
 *  @class Competency
 *  @module org.cassproject
 *  @extends CreativeWork
 */
var Competency = function() {
    CreativeWork.call(this);
    this.setContextAndType(Cass.context, Competency.myType);
};
Competency = stjs.extend(Competency, CreativeWork, [], function(constructor, prototype) {
    constructor.TYPE_0_1 = "http://schema.eduworks.com/cass/0.1/competency";
    constructor.TYPE_0_2 = "http://schema.eduworks.com/cass/0.2/competency";
    constructor.TYPE_0_3 = "http://schema.cassproject.org/0.2/Competency";
    constructor.TYPE_0_4 = "http://schema.cassproject.org/0.3/Competency";
    constructor.TYPE_0_5 = "https://schema.cassproject.org/0.3/Competency";
    constructor.TYPE_0_6 = "https://schema.cassproject.org/0.4/Competency";
    constructor.myType = Competency.TYPE_0_6;
    /**
     *  Scope in which the competency may be applied. e.g. Underwater.
     * 
     *  @property scope
     *  @type string
     */
    prototype.scope = null;
    prototype.upgrade = function() {
        EcRemoteLinkedData.prototype.upgrade.call(this);
        if (Competency.TYPE_0_1.equals(this.type)) {
            if (this.url != null && this.sameAs == null) {
                this.sameAs = this.url;
                this.url = null;
            }
            var me = (this);
            if (me["@context"] == null && me["@schema"] != null) 
                me["@context"] = me["@schema"];
            this.setContextAndType(Cass.context_0_2, Competency.TYPE_0_2);
        }
        if (Competency.TYPE_0_2.equals(this.getFullType())) {
            this.setContextAndType(Cass.context_0_3, Competency.TYPE_0_3);
        }
        if (Competency.TYPE_0_3.equals(this.getFullType())) {
            this.setContextAndType(Cass.context_0_4, Competency.TYPE_0_4);
        }
        if (Competency.TYPE_0_4.equals(this.getFullType())) {
            this.setContextAndType(Cass.context_0_5, Competency.TYPE_0_5);
        }
        if (Competency.TYPE_0_5.equals(this.getFullType())) {
            this.setContextAndType(Cass.context_0_6, Competency.TYPE_0_6);
        }
    };
    prototype.getTypes = function() {
        var a = new Array();
        a.push(Competency.TYPE_0_6);
        a.push(Competency.TYPE_0_5);
        a.push(Competency.TYPE_0_4);
        a.push(Competency.TYPE_0_3);
        a.push(Competency.TYPE_0_2);
        a.push(Competency.TYPE_0_1);
        return a;
    };
}, {about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  A relation between two objects.
 * 
 *  @author fritz.ray@eduworks.com
 *  @class Relation
 *  @module org.cassproject
 *  @extends CreativeWork
 */
var Relation = function() {
    CreativeWork.call(this);
    this.setContextAndType(Cass.context, Relation.myType);
};
Relation = stjs.extend(Relation, CreativeWork, [], function(constructor, prototype) {
    /**
     *  Relation type when one object enables the capability to obtain another.
     *  Enabling relations do not imply a requirement, but makes the acquisition of the source much easier.
     * 
     *  @property IS_ENABLED_BY
     *  @static
     *  @type string
     */
    constructor.IS_ENABLED_BY = "isEnabledBy";
    /**
     *  Relation type when one object requires another.
     *  Requiring relations are strict.
     * 
     *  @property REQUIRES
     *  @static
     *  @type string
     */
    constructor.REQUIRES = "requires";
    /**
     *  Relation type when one object desires another.
     *  Desire relations improve the range of applicability or improve performance of the source.
     * 
     *  @property DESIRES
     *  @static
     *  @type string
     */
    constructor.DESIRES = "desires";
    /**
     *  Relation type when one object is a subset of another.
     *  Narrows relations are strict, and represent a super/sub relation.
     * 
     *  @property NARROWS
     *  @static
     *  @type string
     */
    constructor.NARROWS = "narrows";
    /**
     *  Relation type when one object is related to another.
     *  Related relations provide linkages that do not necessarily carry information.
     *  Related relations are bidirectional.
     * 
     *  @property IS_RELATED_TO
     *  @static
     *  @type string
     */
    constructor.IS_RELATED_TO = "isRelatedTo";
    /**
     *  Relation type when one object is equivalent to another.
     *  Equivalent relations define two objects that are effectively equivalent.
     *  Equivalent relations are bidirectional.
     * 
     *  @property IS_EQUIVALENT_TO
     *  @static
     *  @type string
     */
    constructor.IS_EQUIVALENT_TO = "isEquivalentTo";
    constructor.TYPE_0_1 = "http://schema.eduworks.com/cass/0.1/relation";
    constructor.TYPE_0_2 = "http://schema.eduworks.com/cass/0.2/relation";
    constructor.TYPE_0_3 = "http://schema.cassproject.org/0.2/Relation";
    constructor.TYPE_0_4 = "http://schema.cassproject.org/0.3/Relation";
    constructor.TYPE_0_5 = "https://schema.cassproject.org/0.3/Relation";
    constructor.TYPE_0_6 = "https://schema.cassproject.org/0.4/Relation";
    constructor.myType = Relation.TYPE_0_6;
    /**
     *  URL of the object at the beginning of the relation.
     *  A <relation> B, this is A.
     * 
     *  @property source
     *  @type string(url)
     */
    prototype.source = null;
    /**
     *  URL of the object at the end of the relation.
     *  A <relation> B, this is B.
     * 
     *  @property target
     *  @type string(url)
     */
    prototype.target = null;
    /**
     *  URL or controlled vocabulary of the relation.
     *  A <relation> B, this is <relation>.
     * 
     *  @property relationType
     *  @type string | URL
     */
    prototype.relationType = null;
    /**
     *  Date time in ISO 8601 format at which the relation may be observed.
     * 
     *  @property validFrom
     *  @type string
     */
    prototype.validFrom = null;
    /**
     *  Date time in ISO 8601 format at which the relation may no longer be observed.
     * 
     *  @property validThrough
     *  @type string
     */
    prototype.validThrough = null;
    prototype.upgrade = function() {
        EcRemoteLinkedData.prototype.upgrade.call(this);
        if ("isEquivalenTo" == this.relationType) 
            this.relationType = Relation.IS_EQUIVALENT_TO;
        if (Relation.TYPE_0_1 == this.type) {
            var me = (this);
            if (me["@context"] == null && me["@schema"] != null) 
                me["@context"] = me["@schema"];
            this.setContextAndType(Cass.context_0_2, Relation.TYPE_0_2);
        }
        if (Relation.TYPE_0_2 == this.getFullType()) {
            this.setContextAndType(Cass.context_0_3, Relation.TYPE_0_3);
        }
        if (Relation.TYPE_0_3 == this.getFullType()) {
            this.setContextAndType(Cass.context_0_4, Relation.TYPE_0_4);
        }
        if (Relation.TYPE_0_4.equals(this.getFullType())) {
            this.setContextAndType(Cass.context_0_5, Relation.TYPE_0_5);
        }
        if (Relation.TYPE_0_5.equals(this.getFullType())) {
            this.setContextAndType(Cass.context_0_6, Relation.TYPE_0_6);
        }
    };
    prototype.getTypes = function() {
        var a = new Array();
        a.push(Relation.TYPE_0_6);
        a.push(Relation.TYPE_0_5);
        a.push(Relation.TYPE_0_4);
        a.push(Relation.TYPE_0_3);
        a.push(Relation.TYPE_0_2);
        a.push(Relation.TYPE_0_1);
        return a;
    };
}, {about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  A Competency Framework or simply Framework is a collection of competencies and relations between competencies in the framework and potentially between competencies in the framework and competencies in other frameworks. In practice, a Framework represents competencies related to a specific job, task, organization, career, knowledge domain, etc.
 * 
 *  @author fritz.ray@eduworks.com
 *  @class Framework
 *  @module org.cassproject
 *  @extends CreativeWork
 */
var Framework = function() {
    CreativeWork.call(this);
    this.setContextAndType(Cass.context, Framework.myType);
};
Framework = stjs.extend(Framework, CreativeWork, [], function(constructor, prototype) {
    constructor.TYPE_0_1 = "http://schema.eduworks.com/cass/0.1/framework";
    constructor.TYPE_0_2 = "http://schema.eduworks.com/cass/0.2/framework";
    constructor.TYPE_0_3 = "http://schema.cassproject.org/0.2/Framework";
    constructor.TYPE_0_4 = "http://schema.cassproject.org/0.3/Framework";
    constructor.TYPE_0_5 = "https://schema.cassproject.org/0.3/Framework";
    constructor.TYPE_0_6 = "https://schema.cassproject.org/0.4/Framework";
    constructor.myType = Framework.TYPE_0_6;
    /**
     *  URLs of competencies included in this framework.
     * 
     *  @property competency
     *  @type string[]
     */
    prototype.competency = null;
    /**
     *  URLs of relations included in this framework.
     * 
     *  @property relation
     *  @type string[]
     */
    prototype.relation = null;
    /**
     *  URLs of levels included in this framework.
     * 
     *  @property level
     *  @type string[]
     */
    prototype.level = null;
    /**
     *  URLs of RollupRules included in this framework.
     * 
     *  @property rollupRule
     *  @type string[]
     */
    prototype.rollupRule = null;
    /**
     *  URL of the directory this framework is in.
     * 
     *  @property rollupRule
     *  @type string[]
     */
    prototype.directory = null;
    prototype.upgrade = function() {
        EcRemoteLinkedData.prototype.upgrade.call(this);
        if (Framework.TYPE_0_1.equals(this.type)) {
            var me = (this);
            if (me["@context"] == null && me["@schema"] != null) 
                me["@context"] = me["@schema"];
            this.setContextAndType(Cass.context_0_2, Framework.TYPE_0_2);
        }
        if (Framework.TYPE_0_2.equals(this.getFullType())) {
            this.setContextAndType(Cass.context_0_3, Framework.TYPE_0_3);
        }
        if (Framework.TYPE_0_3.equals(this.getFullType())) {
            this.setContextAndType(Cass.context_0_4, Framework.TYPE_0_4);
        }
        if (Framework.TYPE_0_4.equals(this.getFullType())) {
            this.setContextAndType(Cass.context_0_5, Framework.TYPE_0_5);
        }
        if (Framework.TYPE_0_5.equals(this.getFullType())) {
            this.setContextAndType(Cass.context_0_6, Framework.TYPE_0_6);
        }
    };
    prototype.getTypes = function() {
        var a = new Array();
        a.push(Framework.TYPE_0_6);
        a.push(Framework.TYPE_0_5);
        a.push(Framework.TYPE_0_4);
        a.push(Framework.TYPE_0_3);
        a.push(Framework.TYPE_0_2);
        a.push(Framework.TYPE_0_1);
        return a;
    };
}, {competency: {name: "Array", arguments: [null]}, relation: {name: "Array", arguments: [null]}, level: {name: "Array", arguments: [null]}, rollupRule: {name: "Array", arguments: [null]}, about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  A Directory is a collection of frameworks and resources.
 * 
 *  @author kristin.wood@eduworks.com
 *  @class Directory
 *  @module org.cassproject
 *  @extends CreativeWork
 */
var Directory = function() {
    CreativeWork.call(this);
    this.setContextAndType(Cass.context, Directory.myType);
};
Directory = stjs.extend(Directory, CreativeWork, [], function(constructor, prototype) {
    constructor.TYPE_0_6 = "https://schema.cassproject.org/0.4/Directory";
    constructor.myType = Directory.TYPE_0_6;
    prototype.parentDirectory = null;
    prototype.upgrade = function() {
        EcRemoteLinkedData.prototype.upgrade.call(this);
    };
    prototype.getTypes = function() {
        var a = new Array();
        a.push(Directory.TYPE_0_6);
        return a;
    };
}, {about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  When an individual's performance in a competency can be measured, a level specifies milestones that an individual can reach, creating fine-grained distinction between the proficient and the adept.
 * 
 *  @author fritz.ray@eduworks.com
 *  @class Level
 *  @module org.cassproject
 *  @extends CreativeWork
 */
var Level = function() {
    CreativeWork.call(this);
    this.setContextAndType(Cass.context, Level.myType);
};
Level = stjs.extend(Level, CreativeWork, [], function(constructor, prototype) {
    constructor.TYPE_0_1 = "http://schema.eduworks.com/cass/0.1/level";
    constructor.TYPE_0_2 = "http://schema.eduworks.com/cass/0.2/level";
    constructor.TYPE_0_3 = "http://schema.cassproject.org/0.2/Level";
    constructor.TYPE_0_4 = "http://schema.cassproject.org/0.3/Level";
    constructor.TYPE_0_5 = "https://schema.cassproject.org/0.3/Level";
    constructor.TYPE_0_6 = "https://schema.cassproject.org/0.4/Level";
    constructor.myType = Level.TYPE_0_6;
    /**
     *  Specifies the URL of the competency this level relates to.
     * 
     *  @property competency
     *  @type string(URL)
     */
    prototype.competency = null;
    /**
     *  The title that one who holds this performance level may assume.
     * 
     *  @property title
     *  @type string
     */
    prototype.title = null;
    /**
     *  The performance characteristics required by this level in text form.
     *  FR - Represented by description.
     * 
     *  @property performance
     *  @type string
     */
    prototype.performance = null;
    prototype.upgrade = function() {
        EcRemoteLinkedData.prototype.upgrade.call(this);
        if (Level.TYPE_0_1.equals(this.type)) {
            var me = (this);
            if (me["@context"] == null && me["@schema"] != null) 
                me["@context"] = me["@schema"];
            this.setContextAndType(Cass.context_0_2, Level.TYPE_0_2);
        }
        if (Level.TYPE_0_2.equals(this.getFullType())) {
            this.setContextAndType(Cass.context_0_3, Level.TYPE_0_3);
        }
        if (Level.TYPE_0_3.equals(this.getFullType())) {
            this.setContextAndType(Cass.context_0_4, Level.TYPE_0_4);
        }
        if (Level.TYPE_0_4.equals(this.getFullType())) {
            this.setContextAndType(Cass.context_0_5, Level.TYPE_0_5);
        }
        if (Level.TYPE_0_5.equals(this.getFullType())) {
            this.setContextAndType(Cass.context_0_6, Level.TYPE_0_6);
        }
    };
    prototype.getTypes = function() {
        var a = new Array();
        a.push(Level.TYPE_0_6);
        a.push(Level.TYPE_0_5);
        a.push(Level.TYPE_0_4);
        a.push(Level.TYPE_0_3);
        a.push(Level.TYPE_0_2);
        a.push(Level.TYPE_0_1);
        return a;
    };
}, {about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  A segment of script that defines in a domain specific language how competence is transferred from one competency to another.
 * 
 *  @author fritz.ray@eduworks.com
 *  @class RollupRule
 *  @module org.cassproject
 *  @extends CreativeWork
 */
var RollupRule = function() {
    CreativeWork.call(this);
    this.setContextAndType(Cass.context, RollupRule.myType);
};
RollupRule = stjs.extend(RollupRule, CreativeWork, [], function(constructor, prototype) {
    constructor.TYPE_0_2 = "http://schema.eduworks.com/cass/0.2/rollupRule";
    constructor.TYPE_0_3 = "http://schema.cassproject.org/0.2/RollupRule";
    constructor.TYPE_0_4 = "http://schema.cassproject.org/0.3/RollupRule";
    constructor.TYPE_0_5 = "https://schema.cassproject.org/0.3/RollupRule";
    constructor.TYPE_0_6 = "https://schema.cassproject.org/0.4/RollupRule";
    constructor.myType = RollupRule.TYPE_0_6;
    /**
     *  The rollup rule encoded as source code that is understandable to the assertion processor.
     * 
     *  @property rule
     *  @type string
     */
    prototype.rule = null;
    /**
     *  Specifies the URL of the competency that the rollup rule pertains to.
     * 
     *  @property competency
     *  @type string
     */
    prototype.competency = null;
    prototype.upgrade = function() {
        EcRemoteLinkedData.prototype.upgrade.call(this);
        if (RollupRule.TYPE_0_2.equals(this.getFullType())) {
            this.setContextAndType(Cass.context_0_3, RollupRule.TYPE_0_3);
        }
        if (RollupRule.TYPE_0_3.equals(this.getFullType())) {
            this.setContextAndType(Cass.context_0_4, RollupRule.TYPE_0_4);
        }
        if (RollupRule.TYPE_0_4.equals(this.getFullType())) {
            this.setContextAndType(Cass.context_0_5, RollupRule.TYPE_0_5);
        }
        if (RollupRule.TYPE_0_5.equals(this.getFullType())) {
            this.setContextAndType(Cass.context_0_6, RollupRule.TYPE_0_6);
        }
    };
    prototype.getTypes = function() {
        var a = new Array();
        a.push(RollupRule.TYPE_0_6);
        a.push(RollupRule.TYPE_0_5);
        a.push(RollupRule.TYPE_0_4);
        a.push(RollupRule.TYPE_0_3);
        a.push(RollupRule.TYPE_0_2);
        return a;
    };
}, {about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  A claim of competence in CASS is called an Assertion. It states with some confidence that an individual has mastered a competency at a given level, provides evidence of such mastery, and records data such as the time of assertion and the party making the assertion.
 * 
 *  @author fritz.ray@eduworks.com
 *  @class Assertion
 *  @module org.cassproject
 *  @extends CreativeWork
 */
var Assertion = function() {
    CreativeWork.call(this);
    this.setContextAndType(Cass.context, Assertion.myType);
};
Assertion = stjs.extend(Assertion, CreativeWork, [], function(constructor, prototype) {
    constructor.TYPE_0_1 = "http://schema.eduworks.com/cass/0.1/assertion";
    constructor.TYPE_0_2 = "http://schema.eduworks.com/cass/0.2/assertion";
    constructor.TYPE_0_3 = "http://schema.cassproject.org/0.2/Assertion";
    constructor.TYPE_0_4 = "http://schema.cassproject.org/0.3/Assertion";
    constructor.TYPE_0_5 = "https://schema.cassproject.org/0.3/Assertion";
    constructor.TYPE_0_6 = "https://schema.cassproject.org/0.4/Assertion";
    constructor.myType = Assertion.TYPE_0_6;
    constructor.codebooks = null;
    /**
     *  URL of the competency.
     * 
     *  @property competency
     *  @type string(URL)
     */
    prototype.competency = null;
    /**
     *  URL of the framework within which the assertion is restricted.
     * 
     *  @property framework
     *  @type string(URL)
     */
    prototype.framework = null;
    /**
     *  URL of the level, or null if 'held with no performance expectations'.
     * 
     *  @property level
     *  @type string
     */
    prototype.level = null;
    /**
     *  Confidence with which the assertion was made.
     *  Confidence has many interpretations, one possibility is the probability that the individual could demonstrate the competency again.
     * 
     *  @property confidence
     *  @type float [0,1]
     */
    prototype.confidence = null;
    /**
     *  Public Key in PEM format of the recipient of the assertion.
     * 
     *  @property subject
     *  @type EcEncryptedValue<Public Key PEM>
     */
    prototype.subject = null;
    /**
     *  Public Key in PEM format of the identity making the assertion.
     * 
     *  @property agent
     *  @type EcEncryptedValue<Public Key PEM>
     */
    prototype.agent = null;
    /**
     *  Encrypted evidence. May be a string, URL or schema.org/Thing.
     * 
     *  @property evidence
     *  @type EcEncryptedValue<string | URL | Thing>[]
     */
    prototype.evidence = null;
    /**
     *  Time that the assertion was made in milliseconds since the Unix Epoch.
     * 
     *  @property assertionDate
     *  @type EcEncryptedValue<long>
     */
    prototype.assertionDate = null;
    /**
     *  Time that the assertion expires, specified in milliseconds since the Unix Epoch.
     * 
     *  @property expirationDate
     *  @type EcEncryptedValue<long>
     */
    prototype.expirationDate = null;
    /**
     *  Describes the slope of the line from the initial confidence at the assertion date and the expiration date. t is a number between [0,1] representing the percentage of time that has elapsed. Examples include t^2 and ln(t).
     * 
     *  @property decayFunction
     *  @type EcEncryptedValue<string>
     */
    prototype.decayFunction = null;
    /**
     *  True if the assertion is a claim that the subject cannot demonstrate the competency.
     * 
     *  @property negative
     *  @type EcEncryptedValue<boolean>
     */
    prototype.negative = null;
    prototype.getSubject = function() {
        return EcPk.fromPem(this.subject);
    };
    /**
     *  Sets the subject of an assertion. Makes a few assumptions: Owners of the
     *  object should be able to see and change the encrypted value. Owners and
     *  readers of the object should be persisted.
     * 
     *  @param pk
     */
    prototype.setSubject = function(pk) {
        var owners = new Array();
        var readers = this.reader;
        if (readers == null) 
            readers = new Array();
        if (this.subject != null) {
            if (this.subject.owner != null) 
                owners.concat(this.subject.owner);
            if (this.subject.reader != null) 
                readers.concat(this.subject.reader);
        }
        if (this.owner != null) 
            owners = owners.concat(this.owner);
        readers.push(pk.toPem());
        this.subject = pk.toPem();
    };
    prototype.getSubjectAsync = function(success, failure) {
        success(EcPk.fromPem(this.subject));
    };
    prototype.getAgent = function() {
        return EcPk.fromPem(this.agent);
    };
    prototype.setAgent = function(pk) {
        this.agent = pk.toPem();
    };
    prototype.getAgentAsync = function(success, failure) {
        success(EcPk.fromPem(this.agent));
    };
    prototype.getSubjectName = function() {
        if (this.subject == null) 
            return "Nobody";
        var subjectPk = this.getSubject();
        var identity = EcIdentityManager.getIdentity(subjectPk);
        if (identity != null && identity.displayName != null) 
            return identity.displayName + " (You)";
        var contact = EcIdentityManager.getContact(subjectPk);
        if (contact == null || contact.displayName == null) 
            return "Unknown Subject";
        return contact.displayName;
    };
    prototype.getSubjectNameAsync = function(success, failure) {
        if (this.subject == null) {
            success("Nobody");
            return;
        }
        this.getSubjectAsync(function(subjectPk) {
            var identity = EcIdentityManager.getIdentity(subjectPk);
            if (identity != null && identity.displayName != null) {
                success(identity.displayName + " (You)");
                return;
            }
            var contact = EcIdentityManager.getContact(subjectPk);
            if (contact == null || contact.displayName == null) {
                success("Unknown Subject");
                return;
            }
            success(contact.displayName);
        }, failure);
    };
    prototype.getAgentName = function() {
        if (this.agent == null) 
            return "Nobody";
        var agentPk = this.getAgent();
        var identity = EcIdentityManager.getIdentity(agentPk);
        if (identity != null && identity.displayName != null) 
            return identity.displayName + " (You)";
        var contact = EcIdentityManager.getContact(agentPk);
        if (contact == null || contact.displayName == null) 
            return "Unknown Agent";
        return contact.displayName;
    };
    prototype.getAgentNameAsync = function(success, failure) {
        if (this.subject == null) {
            success("Nobody");
            return;
        }
        this.getAgentAsync(function(subjectPk) {
            var identity = EcIdentityManager.getIdentity(subjectPk);
            if (identity != null && identity.displayName != null) {
                success(identity.displayName + " (You)");
                return;
            }
            var contact = EcIdentityManager.getContact(subjectPk);
            if (contact == null || contact.displayName == null) {
                success("Unknown Agent");
                return;
            }
            success(contact.displayName);
        }, failure);
    };
    prototype.getAssertionDate = function() {
        return this.assertionDate;
    };
    prototype.setAssertionDate = function(assertionDateMs) {
        this.assertionDate = assertionDateMs;
    };
    prototype.getAssertionDateAsync = function(success, failure) {
        success(this.assertionDate);
    };
    prototype.getExpirationDate = function() {
        return this.expirationDate;
    };
    prototype.setExpirationDate = function(expirationDateMs) {
        this.expirationDate = expirationDateMs;
    };
    prototype.getExpirationDateAsync = function(success, failure) {
        success(this.expirationDate);
    };
    prototype.getEvidenceCount = function() {
        if (this.evidence == null) 
            return 0;
        return this.evidence.length;
    };
    prototype.getEvidence = function(index) {
        return this.evidence[index];
    };
    prototype.getEvidenceAsync = function(index, success, failure) {
        success(this.evidence[index]);
    };
    prototype.getDecayFunction = function() {
        return this.decayFunction;
    };
    prototype.setDecayFunction = function(decayFunctionText) {
        this.decayFunction = decayFunctionText;
    };
    prototype.getDecayFunctionAsync = function(success, failure) {
        success(this.decayFunction);
    };
    prototype.getNegative = function() {
        return "true".equals(this.negative);
    };
    prototype.setNegative = function(negativeB) {
        this.negative = negativeB;
    };
    prototype.getNegativeAsync = function(success, failure) {
        success("true".equals(this.negative));
    };
    prototype.setCompetency = function(competencyUrl) {
        this.competency = competencyUrl;
    };
    prototype.setLevel = function(levelUrl) {
        this.level = levelUrl;
    };
    prototype.setConfidence = function(confidenceZeroToOne) {
        this.confidence = confidenceZeroToOne;
    };
    prototype.setEvidence = function(evidences) {
        this.evidence = evidences;
    };
    prototype.upgrade = function() {
        EcRemoteLinkedData.prototype.upgrade.call(this);
        if (Assertion.TYPE_0_1.equals(this.type)) {
            var me = (this);
            if (me["@context"] == null && me["@schema"] != null) 
                me["@context"] = me["@schema"];
            this.setContextAndType(Cass.context_0_2, Assertion.TYPE_0_2);
        }
        if (Assertion.TYPE_0_2.equals(this.getFullType())) {
            this.setContextAndType(Cass.context_0_3, Assertion.TYPE_0_3);
        }
        if (Assertion.TYPE_0_3.equals(this.getFullType())) {
            this.setContextAndType(Cass.context_0_4, Assertion.TYPE_0_4);
        }
        if (Assertion.TYPE_0_4.equals(this.getFullType())) {
            this.setContextAndType(Cass.context_0_5, Assertion.TYPE_0_5);
        }
        if (Assertion.TYPE_0_5.equals(this.getFullType())) {
            this.setContextAndType(Cass.context_0_6, Assertion.TYPE_0_6);
        }
        this.agent = EcEncryptedValue.revive(this.agent);
        this.subject = EcEncryptedValue.revive(this.subject);
        this.assertionDate = EcEncryptedValue.revive(this.assertionDate);
        this.expirationDate = EcEncryptedValue.revive(this.expirationDate);
        this.decayFunction = EcEncryptedValue.revive(this.decayFunction);
        this.negative = EcEncryptedValue.revive(this.negative);
        if (this.evidence != null) 
            for (var i = 0; i < this.evidence.length; i++) {
                this.evidence[i] = EcEncryptedValue.revive(this.evidence[i]);
            }
    };
    prototype.getTypes = function() {
        var a = new Array();
        a.push(Assertion.TYPE_0_6);
        a.push(Assertion.TYPE_0_5);
        a.push(Assertion.TYPE_0_4);
        a.push(Assertion.TYPE_0_3);
        a.push(Assertion.TYPE_0_2);
        a.push(Assertion.TYPE_0_1);
        return a;
    };
    constructor.getCodebook = function(assertion) {
        if (Assertion.codebooks == null) 
            Assertion.codebooks = new Object();
        return (Assertion.codebooks)[assertion.id];
    };
}, {codebooks: "Object", subject: "EcEncryptedValue", agent: "EcEncryptedValue", evidence: {name: "Array", arguments: ["EcEncryptedValue"]}, assertionDate: "EcEncryptedValue", expirationDate: "EcEncryptedValue", decayFunction: "EcEncryptedValue", negative: "EcEncryptedValue", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Container for storing assertions and the secrets used to decrypt those assertions.
 * 
 *  @author fritz.ray@eduworks.com
 *  @class AssertionEnvelope
 *  @extends CreativeWork
 *  @module org.cassproject
 */
var AssertionEnvelope = function() {
    CreativeWork.call(this);
    this.setContextAndType(Cass.context, AssertionEnvelope.myType);
};
AssertionEnvelope = stjs.extend(AssertionEnvelope, CreativeWork, [], function(constructor, prototype) {
    constructor.TYPE_0_5 = "http://schema.cassproject.org/0.4/AssertionEnvelope";
    constructor.TYPE_0_6 = "https://schema.cassproject.org/0.4/AssertionEnvelope";
    constructor.myType = AssertionEnvelope.TYPE_0_6;
    /**
     *  List of assertions to pack in the envelope.
     * 
     *  @property assertion
     *  @type Assertion[]
     */
    prototype.assertion = null;
    /**
     *  List of secrets found in assertions to the objects necessary to decrypt the assertion data.
     * 
     *  @property codebook
     *  @type AssertionCodebook[]
     */
    prototype.codebook = null;
    prototype.length = function() {
        if (this.assertion != null) 
            return this.assertion.length;
        return 0;
    };
    /**
     *  Removes an assertion from the envelope
     *  @param assertionShortIdToRemove
     *  @method removeAssertionByShortId
     */
    prototype.removeAssertionByShortId = function(assertionShortIdToRemove) {
        if (this.assertion != null) {
            for (var i = 0; i < this.assertion.length; i++) {
                if (this.getAssertion(i).shortId().equals(assertionShortIdToRemove)) {
                    this.assertion.splice(i, 1);
                    break;
                }
            }
        }
        if (this.codebook != null) {
            for (var i = 0; i < this.codebook.length; i++) {
                if (this.codebook[i].assertionShortId.equals(assertionShortIdToRemove)) {
                    this.codebook.splice(i, 1);
                    break;
                }
            }
        }
    };
    /**
     *  Returns the assertion indexed at position @index.
     *  @param index
     *  @method getAssertion
     *  @return
     */
    prototype.getAssertion = function(index) {
        if (this.assertion != null) 
            if (index < this.assertion.length) {
                if (Assertion.codebooks == null) 
                    Assertion.codebooks = new Object();
                var a = new Assertion();
                a.copyFrom(this.assertion[index]);
                (Assertion.codebooks)[a.id] = this.codebook[index];
                return a;
            }
        return null;
    };
    /**
     *  Adds the assertion to the envelope and adds the keys necessary to decode the assertion to the envelope.
     *  @param a Assertion to add.
     *  @method addAssertion
     */
    prototype.addAssertion = function(a) {
        var me = this;
        var ac = new AssertionCodebook();
        if (this.assertion == null) 
            this.assertion = new Array();
        this.assertion.push(a);
        if (this.codebook == null) 
            this.codebook = new Array();
        this.codebook.push(ac);
        if (a.shortId() != null) 
            ac.assertionShortId = a.shortId();
        if (a.agent != null) 
            ac.agent = a.agent.decryptSecret();
        if (a.subject != null) 
            ac.subject = a.subject.decryptSecret();
        if (a.assertionDate != null) 
            ac.assertionDate = a.assertionDate.decryptSecret();
        if (a.expirationDate != null) 
            ac.expirationDate = a.expirationDate.decryptSecret();
        if (a.decayFunction != null) 
            ac.decayFunction = a.decayFunction.decryptSecret();
        if (a.negative != null) 
            ac.negative = a.negative.decryptSecret();
        if (a.evidence != null) 
            for (var i = 0; i < a.evidence.length; i++) {
                if (ac.evidence == null) 
                    ac.evidence = new Array();
                var ecEncryptedValue = a.evidence[i];
                ac.evidence.push(ecEncryptedValue.decryptSecret());
            }
    };
    /**
     *  Adds the assertion to the envelope and adds the keys necessary to decode the assertion to the envelope.
     *  @param a Assertion to add.
     *  @param success Event to call when success occurs.
     *  @param failure Event to call when failure occurs.
     *  @method addAssertionAsync
     */
    prototype.addAssertionAsync = function(a, success, failure) {
        var me = this;
        var ac = new AssertionCodebook();
        if (this.assertion == null) 
            this.assertion = new Array();
        this.assertion.push(a);
        if (this.codebook == null) 
            this.codebook = new Array();
        this.codebook.push(ac);
        var thingsToRun = new Array();
        var eah = new EcAsyncHelper();
        if (a.agent != null) 
            thingsToRun.push(function(finished) {
                a.agent.decryptSecretAsync(function(secret) {
                    ac.agent = secret;
                    finished();
                }, failure);
            });
        if (a.subject != null) 
            thingsToRun.push(function(finished) {
                a.subject.decryptSecretAsync(function(secret) {
                    ac.subject = secret;
                    finished();
                }, failure);
            });
        if (a.assertionDate != null) 
            thingsToRun.push(function(finished) {
                a.assertionDate.decryptSecretAsync(function(secret) {
                    ac.assertionDate = secret;
                    finished();
                }, failure);
            });
        if (a.expirationDate != null) 
            thingsToRun.push(function(finished) {
                a.expirationDate.decryptSecretAsync(function(secret) {
                    ac.expirationDate = secret;
                    finished();
                }, failure);
            });
        if (a.decayFunction != null) 
            thingsToRun.push(function(finished) {
                a.decayFunction.decryptSecretAsync(function(secret) {
                    ac.decayFunction = secret;
                    finished();
                }, failure);
            });
        if (a.negative != null) 
            thingsToRun.push(function(finished) {
                a.negative.decryptSecretAsync(function(secret) {
                    ac.negative = secret;
                    finished();
                }, failure);
            });
        if (a.evidence != null) 
            thingsToRun.push(function(finished) {
                var eah = new EcAsyncHelper();
                eah.each(a.evidence, function(ecEncryptedValue, callback0) {
                    ecEncryptedValue.decryptSecretAsync(function(ebacEncryptedSecret) {
                        if (ebacEncryptedSecret != null) {
                            if (ac.evidence == null) 
                                ac.evidence = new Array();
                            ac.evidence.push(ebacEncryptedSecret);
                        }
                        callback0();
                    }, failure);
                }, function(strings) {
                    finished();
                });
            });
        eah.each(thingsToRun, function(theThingToDo, callback0) {
            theThingToDo(callback0);
        }, function(strings) {
            success();
        });
    };
    /**
     *  Validates that all assertions have not been tampered with (are authentic).
     *  Does not validate the sources of assertions.
     *  @return True IFF assertions are authentic.
     *  @method validate
     */
    prototype.validate = function() {
        if (this.assertion != null) 
            for (var i = 0; i < this.assertion.length; i++) 
                if (this.assertion[i].invalid()) 
                    return false;
        return true;
    };
}, {assertion: {name: "Array", arguments: ["Assertion"]}, codebook: {name: "Array", arguments: ["AssertionCodebook"]}, about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});

var EcAnswer = function() {
    Answer.call(this);
};
EcAnswer = stjs.extend(EcAnswer, Answer, [], null, {parentItem: "Question", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
var EcPerson = function() {
    Person.call(this);
};
EcPerson = stjs.extend(EcPerson, Person, [], function(constructor, prototype) {
    constructor.getByPk = function(repo, pk, success, failure) {
        EcPerson.get(repo.selectedServer + (repo.selectedServer.endsWith("/") ? "" : "/") + "data/" + pk.fingerprint(), success, failure);
    };
    constructor.getByPkBlocking = function(repo, pk) {
        return EcPerson.getBlocking(repo.selectedServer + (repo.selectedServer.endsWith("/") ? "" : "/") + "data/" + pk.fingerprint());
    };
    prototype.equals = function(obj) {
        return this.isId((obj).id);
    };
    /**
     *  Retrieves a person from it's server asynchronously
     * 
     *  @param {String}            id
     *                             ID of the competency to retrieve from the server
     *  @param {Callback1<String>} success
     *                             Callback triggered after retrieving the person,
     *                             returns the person retrieved
     *  @param {Callback1<String>} failure
     *                             Callback triggered if error retrieving person
     *  @memberOf EcPerson
     *  @method get
     *  @static
     */
    constructor.get = function(id, success, failure) {
        EcRepository.getAs(id, new EcPerson(), success, failure);
    };
    /**
     *  Retrieves a person from it's server synchronously, the call
     *  blocks until it is successful or an error occurs
     * 
     *  @param {String} id
     *                  ID of the person to retrieve
     *  @return EcPerson
     *  The person retrieved
     *  @memberOf EcPerson
     *  @method getBlocking
     *  @static
     */
    constructor.getBlocking = function(id) {
        return EcRepository.getBlockingAs(id, new EcPerson());
    };
    /**
     *  Searches a repository for persons that match the search query
     * 
     *  @param {EcRepository}          repo Repository to search using the query
     *  @param {String}                query Query string to pass to the search web service
     *  @param {Callback1<Array<Quiz>> success Callback triggered after
     *                                 completing the search, returns the results
     *  @param {Callback1<String>}     failure Callback triggered if error searching
     *  @param {Object}                paramObj Parameter object for search
     *  @memberOf EcPerson
     *  @method search
     *  @static
     */
    constructor.search = function(repo, query, success, failure, paramObj) {
        EcRepository.searchAs(repo, query, function() {
            return new EcPerson();
        }, success, failure, paramObj);
    };
    /**
     *  Attempts to find and return the person's fingerprint from the id.
     * 
     *  @return {String}
     *  @method getFingerprintFromId
     */
    prototype.getFingerprintFromId = function() {
        return this.getGuid();
    };
    /**
     *  Attempts to find and return the person's fingerprint from the id.
     * 
     *  @return {String}
     *  @method getFingerprintFromId
     */
    prototype.getFingerprint = function() {
        return this.getGuid();
    };
}, {address: "PostalAddress", spouse: "Person", funder: "Person", colleagues: "Person", memberOf: "Organization", height: "Distance", workLocation: "ContactPoint", netWorth: "PriceSpecification", children: "Person", hasOfferCatalog: "OfferCatalog", deathPlace: "Place", birthPlace: "Place", parents: "Person", alumniOf: "EducationalOrganization", homeLocation: "ContactPoint", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", sibling: "Person", performerIn: "SchemaEvent", siblings: "Person", weight: "QuantitativeValue", contactPoint: "ContactPoint", hasPOS: "Place", parent: "Person", owns: "OwnershipInfo", affiliation: "Organization", sponsor: "Organization", brand: "Organization", nationality: "Country", relatedTo: "Person", follows: "Person", knows: "Person", worksFor: "Organization", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
var EcCreativeWork = function() {
    CreativeWork.call(this);
};
EcCreativeWork = stjs.extend(EcCreativeWork, CreativeWork, [], function(constructor, prototype) {
    /**
     *  Retrieves a creative work from it's server asynchronously
     * 
     *  @param {String}            id
     *                             ID of the creative work to retrieve from the server
     *  @param {Callback1<String>} success
     *                             Callback triggered after retrieving the creative work,
     *                             returns the creative work retrieved
     *  @param {Callback1<String>} failure
     *                             Callback triggered if error retrieving creative work
     *  @memberOf EcCreativeWork
     *  @method get
     *  @static
     */
    constructor.get = function(id, success, failure) {
        EcRepository.getAs(id, new EcCreativeWork(), success, failure);
    };
    /**
     *  Retrieves a creative work from it's server synchronously, the call
     *  blocks until it is successful or an error occurs
     * 
     *  @param {String} id
     *                  ID of the creative work to retrieve
     *  @return EcCreativeWork
     *  The creative work retrieved
     *  @memberOf EcCreativeWork
     *  @method getBlocking
     *  @static
     */
    constructor.getBlocking = function(id) {
        return EcRepository.getBlockingAs(id, new EcCreativeWork());
    };
    /**
     *  Searches a repository for creative works that match the search query
     * 
     *  @param {EcRepository}                    repo
     *                                           Repository to search using the query
     *  @param {String}                          query
     *                                           Query string to pass to the search web service
     *  @param {Callback1<Array<EcCreativeWork>> success
     *                                           Callback triggered after completing the search, returns the results
     *  @param {Callback1<String>}               failure
     *                                           Callback triggered if error searching
     *  @param {Object}                          paramObj
     *                                           Parameter object for search
     *  @memberOf EcCreativeWork
     *  @method search
     *  @static
     */
    constructor.search = function(repo, query, success, failure, paramObj) {
        EcRepository.searchAs(repo, query, function() {
            return new EcCreativeWork();
        }, success, failure, paramObj);
    };
}, {about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
var EcComment = function() {
    Comment.call(this);
};
EcComment = stjs.extend(EcComment, Comment, [], function(constructor, prototype) {
    /**
     *  Retrieves a comment from it's server asynchronously
     * 
     *  @param {String}            id
     *                             ID of the comment to retrieve from the server
     *  @param {Callback1<String>} success
     *                             Callback triggered after retrieving the comment,
     *                             returns the comment retrieved
     *  @param {Callback1<String>} failure
     *                             Callback triggered if error retrieving comment
     *  @memberOf EcComment
     *  @method get
     *  @static
     */
    constructor.get = function(id, success, failure) {
        EcRepository.getAs(id, new EcComment(), success, failure);
    };
    /**
     *  Retrieves an comment from it's server synchronously, the call
     *  blocks until it is successful or an error occurs
     * 
     *  @param {String} id
     *                  ID of the comment to retrieve
     *  @return EcComment
     *  The concept retrieved
     *  @memberOf EcComment
     *  @method getBlocking
     *  @static
     */
    constructor.getBlocking = function(id) {
        return EcRepository.getBlockingAs(id, new EcComment());
    };
    /**
     *  Searches a repository for comments that match the search query
     * 
     *  @param {EcRepository}                repo Repository to search using the query
     *  @param {String}                      query Query string to pass to the search web service
     *  @param {Callback1<Array<EcComment>>  success Callback triggered after
     *                                       completing the search, returns the results
     *  @param {Callback1<String>}           failure Callback triggered if error searching
     *  @param {Object}                      paramObj Parameter object for search
     *  @memberOf EcComment
     *  @method search
     *  @static
     */
    constructor.search = function(repo, query, success, failure, paramObj) {
        EcRepository.searchAs(repo, query, function() {
            return new EcComment();
        }, success, failure, paramObj);
    };
    /**
     *  Sets the comment's subject as follows:
     *   Comment.isBasedOn: framework.shortId to provide a framework context to the comment
     *   Comment.about: aboutObj.shortId to provide an about/subject to the comment
     * 
     *  @param {EcFramework}         framework Framework which contains the id to set to the comment's isBasedOn
     *  @param {EcRemoteLinkedData}  aboutObj Object which contains the id to set to the comment's about
     *  @method setSubject
     */
    prototype.setSubject = function(framework, aboutObj) {
        if (framework != null) {
            (this)["isBasedOn"] = framework.shortId();
        }
        if (aboutObj != null) {
            (this)["about"] = aboutObj.shortId();
        }
    };
    /**
     *  Sets the comment's subject as follows:
     *   Comment.isBasedOn: frameworkId to provide a framework context to the comment
     *   Comment.about: aboutId to provide an about/subject to the comment
     * 
     *  @param {String}  frameworkId Framework ID to set to the comment's isBasedOn
     *  @param {String}  aboutId Object ID to set to the comment's about
     *  @method setSubjectIds
     */
    prototype.setSubjectIds = function(frameworkId, aboutId) {
        if (frameworkId != null) {
            (this)["isBasedOn"] = frameworkId;
        }
        if (aboutId != null) {
            (this)["about"] = aboutId;
        }
    };
    /**
     *  Sets the comment's creator to the ID of the given person object
     *  @param {EcPerson}  person Person which contains the id to set to the comment's creator
     *  @method setCreator
     */
    prototype.setCreator = function(creatorObj) {
        if (creatorObj != null) {
            (this)["creator"] = creatorObj.shortId();
        }
    };
    /**
     *  Sets the comment's creator to the given person ID
     *  @param {String}  creatorId ID of the person to set to the comment's creator
     *  @method setCreatorId
     */
    prototype.setCreatorId = function(creatorId) {
        if (creatorId != null) {
            (this)["creator"] = creatorId;
        }
    };
    /**
     *  Sets the comment's dateCreated to the given time in milliseconds
     *  @param {String}  longDateString The time in milliseconds to set to the comment's dateCreated
     *  @method setDateCreated
     */
    prototype.setDateCreated = function(longDateString) {
        if (longDateString != null) {
            (this)["dateCreated"] = longDateString;
        }
    };
}, {parentItem: "Question", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
var EcQuiz = function() {
    CreativeWork.call(this);
    this.type = "Quiz";
    this.context = "http://schema.eduworks.com/0.1/";
};
EcQuiz = stjs.extend(EcQuiz, CreativeWork, [], function(constructor, prototype) {
    constructor.myType = "http://schema.eduworks.com/0.1/Quiz";
    prototype.duration = null;
    prototype.question = null;
    /**
     *  Searches a repository for quizzes that match the search query
     * 
     *  @param {EcRepository}          repo Repository to search using the query
     *  @param {String}                query Query string to pass to the search web service
     *  @param {Callback1<Array<Quiz>> success Callback triggered after
     *                                 completing the search, returns the results
     *  @param {Callback1<String>}     failure Callback triggered if error searching
     *  @param {Object}                paramObj Parameter object for search
     *  @param start
     *  @param size
     *  @memberOf Quiz
     *  @method search
     *  @static
     */
    constructor.search = function(repo, query, success, failure, paramObj) {
        EcRepository.searchAs(repo, query, function() {
            return new EcQuiz();
        }, success, failure, paramObj);
    };
}, {question: {name: "Array", arguments: [null]}, about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
var EcQuestion = function() {
    Question.call(this);
};
EcQuestion = stjs.extend(EcQuestion, Question, [], function(constructor, prototype) {
    constructor.MULTIPLE_CHOICE = "Multiple Choice";
    constructor.MULTIPLE_SELECT = "Multiple Select";
    constructor.SHORT_ANSWER = "Short Answer";
    constructor.FILL_IN_THE_BLANK = "Fill in the Blank";
    constructor.ESSAY_OR_SHORT_ANSWER = "Essay or Short Answer";
    constructor.HAND_GRADED_ESSAY = "Hand-graded Essay";
    /**
     *  Searches a repository for questions that match the search query
     * 
     *  @param {EcRepository}          repo Repository to search using the query
     *  @param {String}                query Query string to pass to the search web service
     *  @param {Callback1<Array<Quiz>> success Callback triggered after
     *                                 completing the search, returns the results
     *  @param {Callback1<String>}     failure Callback triggered if error searching
     *  @param {Object}                paramObj Parameter object for search
     *  @memberOf EcQuestion
     *  @method search
     *  @static
     */
    constructor.search = function(repo, query, success, failure, paramObj) {
        EcRepository.searchAs(repo, query, function() {
            return new EcQuestion();
        }, success, failure, paramObj);
    };
    /**
     *  Heuristic method of determining how this question should be asked.
     * 
     *  @return
     */
    prototype.getQuestionType = function() {
        var acceptedAnswers = this.acceptedAnswers();
        if (acceptedAnswers == null) {
            if (this.canEdit(EcIdentityManager.ids[0].ppk.toPk())) {
                return EcQuestion.HAND_GRADED_ESSAY;
            } else {
                return EcQuestion.ESSAY_OR_SHORT_ANSWER;
            }
        }
        var m = acceptedAnswers.length;
        if (m == 0) {
            return EcQuestion.HAND_GRADED_ESSAY;
        }
        if (this.suggestedAnswer == null) {
            if (this.text != null && this.text.indexOf("__") != -1) {
                return EcQuestion.FILL_IN_THE_BLANK;
            }
            return EcQuestion.SHORT_ANSWER;
        }
        var l = (this.suggestedAnswer).length;
        if (l == 0) {
            if (this.text != null && this.text.indexOf("__") != -1) {
                return EcQuestion.FILL_IN_THE_BLANK;
            }
            return EcQuestion.SHORT_ANSWER;
        }
        if (m > 1) {
            return EcQuestion.MULTIPLE_SELECT;
        }
        if (l > 0) {
            return EcQuestion.MULTIPLE_CHOICE;
        }
        return "Not sure.";
    };
    prototype.cementAnswerId = function(id) {
        if (this.acceptedAnswer != null) {
            if (!EcArray.isArray(this.acceptedAnswer)) {
                 throw new RuntimeException("Accepted Answer is not Array");
            }
            var ary = this.acceptedAnswer;
            for (var i = 0; i < ary.length; i++) {
                if (EcRemoteLinkedData.trimVersionFromUrl(ary[i]) == EcRemoteLinkedData.trimVersionFromUrl(id)) {
                    ary[i] = id;
                }
            }
        }
        if (this.suggestedAnswer != null) {
            if (!EcArray.isArray(this.suggestedAnswer)) {
                 throw new RuntimeException("Suggested Answer is not Array");
            }
            var ary = this.suggestedAnswer;
            for (var i = 0; i < ary.length; i++) {
                if (EcRemoteLinkedData.trimVersionFromUrl(ary[i]) == EcRemoteLinkedData.trimVersionFromUrl(id)) {
                    ary[i] = id;
                }
            }
        }
    };
    prototype.acceptedAnswers = function() {
        if (this.acceptedAnswer == null) {
            return new Array();
        }
        return this.acceptedAnswer;
    };
    prototype.suggestedAnswers = function() {
        if (this.suggestedAnswer == null) {
            return new Array();
        }
        return this.suggestedAnswer;
    };
    prototype.addAcceptedAnswer = function(answer) {
        if (this.acceptedAnswer == null) {
            (this)["acceptedAnswer"] = new Array();
        }
        if (!EcArray.isArray(this.acceptedAnswer)) {
             throw new RuntimeException("Accepted Answer is not Array");
        }
        var ary = this.acceptedAnswer;
        ary.push(answer.id);
    };
    prototype.addSuggestedAnswer = function(answer) {
        if (this.suggestedAnswer == null) {
            (this)["suggestedAnswer"] = new Array();
        }
        if (!EcArray.isArray(this.suggestedAnswer)) {
             throw new RuntimeException("Suggested Answer is not Array");
        }
        var ary = this.suggestedAnswer;
        ary.push(answer.id);
    };
    prototype.removeSuggestedAnswerById = function(id) {
        if (this.suggestedAnswer == null) {
            return;
        }
        if (!EcArray.isArray(this.suggestedAnswer)) {
             throw new RuntimeException("Suggested Answer is not Array");
        }
        var ary = this.suggestedAnswer;
        for (var i = 0; i < ary.length; i++) {
            if (EcRemoteLinkedData.trimVersionFromUrl(ary[i]) == EcRemoteLinkedData.trimVersionFromUrl(id)) {
                ary.splice(i, 1);
            }
        }
    };
    prototype.removeAcceptedAnswerById = function(id) {
        if (this.acceptedAnswer == null) {
            return;
        }
        if (!EcArray.isArray(this.acceptedAnswer)) {
             throw new RuntimeException("Accepted Answer is not Array");
        }
        var ary = this.acceptedAnswer;
        for (var i = 0; i < ary.length; i++) {
            if (EcRemoteLinkedData.trimVersionFromUrl(ary[i]) == EcRemoteLinkedData.trimVersionFromUrl(id)) {
                ary.splice(i, 1);
            }
        }
    };
}, {acceptedAnswer: "Answer", suggestedAnswer: "Answer", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
var EcOrganization = function() {
    Organization.call(this);
};
EcOrganization = stjs.extend(EcOrganization, Organization, [], function(constructor, prototype) {
    constructor.ORG_PPK_SET_KEY = "https://schema.cassproject.org/0.3/ppkSet";
    /**
     *  Retrieves an organization from it's server asynchronously
     * 
     *  @param {String}            id
     *                             ID of the concept to retrieve from the server
     *  @param {Callback1<String>} success
     *                             Callback triggered after retrieving the organization,
     *                             returns the organization retrieved
     *  @param {Callback1<String>} failure
     *                             Callback triggered if error retrieving organization
     *  @memberOf EcOrganization
     *  @method get
     *  @static
     */
    constructor.get = function(id, success, failure) {
        EcRepository.getAs(id, new EcOrganization(), success, failure);
    };
    /**
     *  Retrieves an organization from it's server synchronously, the call
     *  blocks until it is successful or an error occurs
     * 
     *  @param {String} id
     *                  ID of the organization to retrieve
     *  @return EcOrganization
     *  The concept retrieved
     *  @memberOf EcOrganization
     *  @method getBlocking
     *  @static
     */
    constructor.getBlocking = function(id) {
        return EcRepository.getBlockingAs(id, new EcOrganization());
    };
    /**
     *  Searches a repository for organizations that match the search query
     * 
     *  @param {EcRepository}                    repo Repository to search using the query
     *  @param {String}                          query Query string to pass to the search web service
     *  @param {Callback1<Array<EcOrganization>> success Callback triggered after
     *                                           completing the search, returns the results
     *  @param {Callback1<String>}               failure Callback triggered if error searching
     *  @param {Object}                          paramObj Parameter object for search
     *  @memberOf EcOrganization
     *  @method search
     *  @static
     */
    constructor.search = function(repo, query, success, failure, paramObj) {
        EcRepository.searchAs(repo, query, function() {
            return new EcOrganization();
        }, success, failure, paramObj);
    };
    /**
     *  Adds the given person's id to the employee list
     * 
     *  @param {EcPerson}          person Person to add to the Organization's employee list
     *  @method addEmployee
     */
    prototype.addEmployee = function(person) {
        if (this.employee == null) 
            (this)["employee"] = new Array();
        if (!EcArray.isArray(this.employee)) 
             throw new RuntimeException("Employee is not Array");
        var ary = this.employee;
        var psid = person.shortId();
        for (var i = 0; i < ary.length; i++) {
            if (ary[i] == psid) 
                return;
        }
        ary.push(psid);
    };
    /**
     *  Removes the person id from the employee list
     * 
     *  @param {String}          id Person id to be removed from Organization's employee list
     *  @method removeEmployeeById
     */
    prototype.removeEmployeeById = function(id) {
        if (this.employee == null) 
            return;
        if (!EcArray.isArray(this.employee)) 
             throw new RuntimeException("Employee is not Array");
        var ary = this.employee;
        for (var i = 0; i < ary.length; i++) {
            if (EcRemoteLinkedData.trimVersionFromUrl(ary[i]) == EcRemoteLinkedData.trimVersionFromUrl(id)) {
                ary.splice(i, 1);
            }
        }
    };
    /**
     *  Moves all Person type Member to Employee
     * 
     *  @method movePersonMembersToEmployee
     */
    prototype.movePersonMembersToEmployee = function() {
        if (this.member == null) 
            return;
        if (this.employee == null) 
            (this)["employee"] = new Array();
        if (!EcArray.isArray(this.employee) || !EcArray.isArray(this.member)) 
            return;
        var membAry = this.member;
        var empAry = this.employee;
        var me = (this);
        for (var i = 0; i < membAry.length; i++) {
            var id = membAry[i];
            if (id.toLowerCase().indexOf("person") > -1) {
                if (empAry.indexOf(id) <= -1) {
                    empAry.push(id);
                }
                membAry.splice(i, 1);
            }
        }
    };
    /**
     *  Adds the given person's id to the employee list
     * 
     *  @param {Array<EcPpk>} ppkList Person to add to the Organization's employee list
     * 
     *  @return String
     *  A JSON array string containing the PEMs of the given PPKs
     * 
     *  @method ppkListToPemArrayString
     */
    prototype.ppkListToPemArrayString = function(ppkList) {
        if (ppkList == null) 
            return JSON.stringify(new Array());
         else {
            var pemArray = new Array();
            for (var i = 0; i < ppkList.length; i++) {
                pemArray.push(ppkList[i].toPem());
            }
            return JSON.stringify(pemArray);
        }
    };
    /**
     *  Add's a key to the organization
     * 
     *  @param {EcPpk}   newOrgPpk The key to add to the organization
     *  @memberOf EcOrganization
     *  @method addOrgKey
     */
    prototype.addOrgKey = function(newOrgPpk) {
        var orgKeys = this.getOrgKeys();
        orgKeys.push(newOrgPpk);
        var newKeys = EcEncryptedValue.encryptValue(this.ppkListToPemArrayString(orgKeys), EcOrganization.ORG_PPK_SET_KEY, this.owner, this.reader);
        (this)[EcOrganization.ORG_PPK_SET_KEY] = newKeys;
    };
    /**
     *  Performs a rekey operation and saves the organization details to the server
     * 
     *  @param {Callback1<String>} success
     *                             Callback triggered on successfully saving the competency
     *  @param {Callback1<String>} failure
     *                             Callback triggered if error saving competency
     *  @memberOf EcOrganization
     *  @method rekeyAndSave
     */
    prototype.rekeyAndSave = function(success, failure, repo) {
        if (repo == null) {
            var msg = "Repository cannot be null for a rekey operation";
            if (failure != null) 
                failure(msg);
             else 
                console.error(msg);
            return;
        } else {
            var oldKey = this.getCurrentOrgKey();
            var newKey = EcPpk.generateKey();
            var identity = new EcIdentity();
            identity.ppk = newKey;
            identity.displayName = "Organization Rekey New Key";
            EcIdentityManager.addIdentity(identity);
            var rekeyRequest = EcRekeyRequest.generateRekeyRequest(repo.selectedServer, oldKey, newKey);
            this.addOrgKey(newKey);
            var newKeys = EcEncryptedValue.encryptValue(this.ppkListToPemArrayString(this.getOrgKeys()), EcOrganization.ORG_PPK_SET_KEY, this.owner, this.reader);
            (this)[EcOrganization.ORG_PPK_SET_KEY] = newKeys;
            repo.saveTo(this, function(res) {
                repo.saveTo(rekeyRequest, success, failure);
            }, failure);
        }
    };
    /**
     *  Encrypts the org keys and saves the organization details to the server
     * 
     *  @param {Callback1<String>} success
     *                             Callback triggered on successfully saving the competency
     *  @param {Callback1<String>} failure
     *                             Callback triggered if error saving competency
     *  @memberOf EcOrganization
     *  @method save
     */
    prototype.save = function(success, failure, repo) {
        var newKeys = EcEncryptedValue.encryptValue(this.ppkListToPemArrayString(this.getOrgKeys()), EcOrganization.ORG_PPK_SET_KEY, this.owner, this.reader);
        (this)[EcOrganization.ORG_PPK_SET_KEY] = newKeys;
        if (repo == null) 
            EcRepository.save(this, success, failure);
         else 
            repo.saveTo(this, success, failure);
    };
    /**
     *  Returns the current organization key
     * 
     *  @return EcPpk
     *  The current organization key
     *  @memberOf EcOrganization
     *  @method getCurrentOrgKey
     */
    prototype.getCurrentOrgKey = function() {
        var orgKeys = this.getOrgKeys();
        if (orgKeys.length >= 1) {
            return orgKeys[orgKeys.length - 1];
        } else 
            return null;
    };
    /**
     *  Returns the list of organization keys
     * 
     *  @return Array<EcPpk>
     *  The Array of organization keys
     *  @memberOf EcOrganization
     *  @method getOrgKeys
     */
    prototype.getOrgKeys = function() {
        var orgKeys = new Array();
        var o = (this)[EcOrganization.ORG_PPK_SET_KEY];
        if (o != null) {
            var ev = new EcEncryptedValue();
            ev.copyFrom(o);
            var orgKeysPPKPems = JSON.parse(ev.decryptIntoString());
            for (var i = 0; i < orgKeysPPKPems.length; i++) {
                orgKeys.push(EcPpk.fromPem(orgKeysPPKPems[i]));
            }
        }
        return orgKeys;
    };
    /**
     *  Moves old key field to new key field array
     * 
     *  @method moveKeyField
     */
    prototype.moveKeyField = function() {
        var o = (this)["https://schema.cassproject.org/0.3/ppk"];
        if (o != null) {
            var ev = new EcEncryptedValue();
            ev.copyFrom(o);
            var currentGroupPpkPem = ev.decryptIntoString();
            var keyArray = new Array();
            keyArray.push(currentGroupPpkPem);
            var newKey = EcEncryptedValue.encryptValue(JSON.stringify(keyArray), EcOrganization.ORG_PPK_SET_KEY, this.owner, this.reader);
            (this)[EcOrganization.ORG_PPK_SET_KEY] = newKey;
            delete (this)["https://schema.cassproject.org/0.3/ppk"];
        }
    };
    prototype.upgrade = function() {
        EcRemoteLinkedData.prototype.upgrade.call(this);
        this.movePersonMembersToEmployee();
        this.moveKeyField();
    };
    /**
     *  Attempts to find and return the organization's fingerprint from the id.
     * 
     *  @return {String}
     *  @method getFingerprintFromId
     */
    prototype.getFingerprintFromId = function() {
        return this.getGuid();
    };
    /**
     *  Attempts to find and return the organization's fingerprint from the id.
     * 
     *  @return {String}
     *  @method getFingerprintFromId
     */
    prototype.getFingerprint = function() {
        return this.getGuid();
    };
}, {serviceArea: "GeoShape", address: "PostalAddress", funder: "Person", memberOf: "Organization", subOrganization: "Organization", hasOfferCatalog: "OfferCatalog", reviews: "Review", members: "Organization", aggregateRating: "AggregateRating", makesOffer: "Offer", contactPoints: "ContactPoint", seeks: "Demand", member: "Organization", founders: "Person", alumni: "Person", events: "SchemaEvent", logo: "ImageObject", employees: "Person", department: "Organization", contactPoint: "ContactPoint", parentOrganization: "Organization", employee: "Person", numberOfEmployees: "QuantitativeValue", hasPOS: "Place", review: "Review", foundingLocation: "Place", owns: "OwnershipInfo", event: "SchemaEvent", founder: "Person", sponsor: "Organization", location: "PostalAddress", brand: "Organization", areaServed: "Place", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});

var RemoteIdentityManagerInterface = function() {};
RemoteIdentityManagerInterface = stjs.extend(RemoteIdentityManagerInterface, null, [], function(constructor, prototype) {
    prototype.configure = function(usernameSalt, usernameIterations, usernameWidth, passwordSalt, passwordIterations, passwordWidth, secretSalt, secretIterations) {};
    prototype.configureFromServer = function(success, failure) {};
    prototype.isGlobal = function() {};
    prototype.clear = function() {};
    prototype.setDefaultIdentityManagementServer = function(server) {};
    prototype.startLogin = function(username, password) {};
    prototype.changePassword = function(username, oldPassword, newPassword) {};
    prototype.fetch = function(success, failure) {};
    prototype.commit = function(success, failure) {};
    prototype.create = function(success, failure) {};
}, {}, {});
/**
 *  The record used to request a rekey of a given public key
 */
var EcRekeyRequest = /**
 *  Constructor, automatically sets @context and @type.
 * 
 *  @constructor
 */
function() {
    EcRemoteLinkedData.call(this, "https://schema.cassproject.org/0.4/kbac", "RekeyRequest");
};
EcRekeyRequest = stjs.extend(EcRekeyRequest, EcRemoteLinkedData, [], function(constructor, prototype) {
    constructor.REKEY_ID_PREFIX = "rekey_";
    /**
     *  PEM encoded public key of the replacement (new) key
     *  @property rekeyPk
     *  @type string (PEM)
     */
    prototype.rekeyPk = null;
    /**
     *  SHA256 signature of the rekey request
     *  @property rekeySignature
     *  @type string (SHA256 signature)
     */
    prototype.rekeySignature = null;
    /**
     *  Generates the ID of the rekey request in the appropriate format
     * 
     *  {string} server      Base URL of the server's repository functionality.
     *  {EcPk}   oldKeyPk    The public key to replace
     *  @method generateRekeyRequestId
     */
    prototype.generateRekeyRequestId = function(server, oldKeyPk) {
        this.assignId(server, EcRekeyRequest.REKEY_ID_PREFIX + oldKeyPk.fingerprint());
    };
    /**
     *  Adds a signature to the rekey request and finalizes before save
     * 
     *  {EcPpk}  oldKeyPpk   The old PPK
     *  @method generateRekeyRequestId
     */
    prototype.finalizeRequest = function(oldKeyPpk) {
        this.rekeySignature = EcRsaOaep.signSha256(oldKeyPpk, this.toSignableJson());
    };
    /**
     *  Generates and populates a rekey request with the given information
     * 
     *  {String} server  Base URL of the server's repository functionality.
     *  {EcPpk}  oldKey  The old PPK
     *  {EcPpk}  newKey  The new PPK
     *  @method generateRekeyRequest
     */
    constructor.generateRekeyRequest = function(server, oldKey, newKey) {
        var err = new EcRekeyRequest();
        err.addOwner(newKey.toPk());
        err.rekeyPk = oldKey.toPk().toPem();
        err.generateRekeyRequestId(server, oldKey.toPk());
        err.finalizeRequest(oldKey);
        return err;
    };
    /**
     *  Encodes the object in a form where it is ready to be signed.
     *  This method is under long term review, and may change from version to version.
     * 
     *  @return ASCII-sort order encoded space-free and tab-free JSON-LD.
     *  @method toSignableJson
     */
    prototype.toSignableRekeyJson = function() {
        var d = JSON.parse(EcRemoteLinkedData.prototype.toSignableJson.call(this));
        delete (d)["rekeySignature"];
        var e = new EcLinkedData(d.context, d.type);
        e.copyFrom(d);
        return e.toJson();
    };
    /**
     *  Verifies both the integrity of the rekey request and the signed nonce of the old key. Returns false if either of these fail.
     *  @return True if the rekey request is valid and maintains its cryptographically integrity.
     */
    prototype.verify = function() {
        if (!EcRemoteLinkedData.prototype.verify.call(this)) 
            return false;
        return EcRsaOaep.verifySha256(EcPk.fromPem(this.rekeyPk), this.toSignableRekeyJson(), this.rekeySignature);
    };
    prototype.addRekeyRequestToForwardingTable = function() {
        if (!this.verify()) 
            return;
        if (this.owner != null) 
            EcRemoteLinkedData.forwardKey(this.rekeyPk, this.owner[0]);
    };
}, {owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  A contact is an identity that we do not own. Using the public key we may: 1.
 *  Send them information (by encrypting data with their public key) 2. Verify a
 *  signed message that was sent (by using the verify function of the public key)
 *  3. Distinguish between this identity and other identities through the
 *  displayName.
 * 
 *  @author fritz.ray@eduworks.com
 *  @module com.eduworks.ec
 *  @class EcContact
 *  @constructor
 */
var EcContact = function() {};
EcContact = stjs.extend(EcContact, null, [], function(constructor, prototype) {
    /**
     *  Public Key of the contact
     * 
     *  @property pk
     *  @type EcPk
     */
    prototype.pk = null;
    /**
     *  Display Name of the contact
     * 
     *  @property displayName
     *  @type String
     */
    prototype.displayName = null;
    /**
     *  URL to the home server of the contact
     * 
     *  @property source
     *  @type String
     */
    prototype.source = null;
    /**
     *  Helper function to decrypt an encrypted contact (storable version of an contact)
     *  into an contact
     * 
     *  @param {EbacContact} contact
     *                       Contact to decrypt.
     *  @param {String}      secret
     *                       AES secret used to decrypt the credential.
     *  @param {String}      source
     *                       Source of the credential, used to track where a contact
     *                       came from.
     *  @return {EcContact}
     *  Decrypted identity object, ready for use.
     *  @memberOf EcContact
     *  @method fromEncryptedContact
     *  @static
     */
    constructor.fromEncryptedContact = function(contact, secret, source) {
        var i = new EcContact();
        i.pk = EcPk.fromPem(EcAesCtr.decrypt(contact.pk, secret, contact.iv));
        i.source = source;
        if (contact.displayName != null && contact.displayNameIv != null) 
            i.displayName = EcAesCtr.decrypt(contact.displayName, secret, contact.iv);
        return i;
    };
    /**
     *  Comparison method that checks if the key is the same as another EcContact
     * 
     *  @param {Object} obj
     *                  Contact to compare if same key
     *  @return {boolean}
     *  true if the key is the same, false if not
     *  @memberOf EcContact
     *  @method equals
     */
    prototype.equals = function(obj) {
        if (stjs.isInstanceOf(obj.constructor, EcContact)) {
            if (this.pk == null) 
                return false;
            if ((obj).pk == null) 
                return false;
            return this.pk.toPem().equals((obj).pk.toPem());
        }
        return Object.prototype.equals.call(this, obj);
    };
    /**
     *  Returns the URL to generic image that should be displayed for the contact
     * 
     *  @return {String}
     *  URL of generic image file
     *  @memberOf EcContact
     *  @method getImageUrl
     */
    prototype.getImageUrl = function() {
        return "https://upload.wikimedia.org/wikipedia/commons/thumb/1/12/User_icon_2.svg/48px-User_icon_2.svg.png";
    };
    /**
     *  Helper function to encrypt a contact into an encrypted contact (storable
     *  version of a contact)
     * 
     *  @param {String} secret
     *                  AES secret used to encrypt the contact.
     *  @return {EbacContact}
     *  Encrypted contact object.
     *  @memberOf EcContact
     *  @method toEncryptedContact
     */
    prototype.toEncryptedContact = function(secret) {
        var c = new EbacContact();
        c.iv = EcAes.newIv(16);
        c.pk = EcAesCtr.encrypt(this.pk.toPem(), secret, c.iv);
        c.displayNameIv = EcAes.newIv(16);
        c.displayName = EcAesCtr.encrypt(this.displayName, secret, c.iv);
        c.sourceIv = EcAes.newIv(16);
        c.source = EcAesCtr.encrypt(this.source, secret, c.iv);
        return c;
    };
}, {pk: "EcPk"}, {});
/**
 *  An identity is an alias that a person or system may own. It consists of a
 *  private key and a display name. Using the private key we may: 1. Perform all
 *  operations of a EcContact. 2. Decrypt messages using our private key. 3. Sign
 *  messages, ensuring the recipient knows that we sent the message and it was
 *  not altered.
 * 
 *  @author fritz.ray@eduworks.com
 *  @module com.eduworks.ec
 *  @class EcIdentity
 *  @constructor
 */
var EcIdentity = function() {
    this.displayName = "Alias " + EcIdentity.identityCounter++;
};
EcIdentity = stjs.extend(EcIdentity, null, [], function(constructor, prototype) {
    constructor.identityCounter = 1;
    /**
     *  Private Key of this identity
     * 
     *  @property ppk
     *  @type EcPpk
     */
    prototype.ppk = null;
    /**
     *  Display name of this identity
     * 
     *  @property displayName
     *  @type String
     */
    prototype.displayName = null;
    /**
     *  String identifying where this identity came from
     * 
     *  @property displayName
     *  @type String
     */
    prototype.source = null;
    /**
     *  Helper function to decrypt a credential (storable version of an identity)
     *  into an identity)
     * 
     *  @param {EbacCredential} credential
     *                          Credential to decrypt.
     *  @param {String}         secret
     *                          AES secret used to decrypt the credential.
     *  @param {String}         source
     *                          Source of the credential, used to track where a credential
     *                          came from.
     *  @return {EcIdentity}
     *  Decrypted identity object, ready for use.
     *  @memberOf EcIdentity
     *  @method fromCredential
     *  @static
     */
    constructor.fromCredential = function(credential, secret, source) {
        var i = new EcIdentity();
        i.ppk = EcPpk.fromPem(EcAesCtr.decrypt(credential.ppk, secret, credential.iv));
        i.source = source;
        if (credential.displayName != null && credential.displayNameIv != null) 
            i.displayName = EcAesCtr.decrypt(credential.displayName, secret, credential.iv);
        return i;
    };
    prototype.equals = function(obj) {
        if (stjs.isInstanceOf(obj.constructor, EcIdentity)) {
            if (this.ppk == null) 
                return false;
            if ((obj).ppk == null) 
                return false;
            return this.ppk.toPem().equals((obj).ppk.toPem());
        }
        return Object.prototype.equals.call(this, obj);
    };
    /**
     *  Helper function to encrypt an identity into a credential (storable
     *  version of an identity)
     * 
     *  @param {String} secret
     *                  AES secret used to encrypt the credential.
     *  @return {EbacCredential}
     *  Encrypted credential object.
     *  @memberOf EcIdentity
     *  @method toCredential
     */
    prototype.toCredential = function(secret) {
        var c = new EbacCredential();
        c.iv = EcAes.newIv(16);
        c.ppk = EcAesCtr.encrypt(this.ppk.toPem(), secret, c.iv);
        c.displayNameIv = EcAes.newIv(16);
        c.displayName = EcAesCtr.encrypt(this.displayName, secret, c.iv);
        return c;
    };
    /**
     *  Converts an identity to a contact.
     * 
     *  @return {EcContact}
     *  Contact object.
     *  @memberOf EcIdentity
     *  @method toContact
     */
    prototype.toContact = function() {
        var c = new EcContact();
        c.displayName = this.displayName;
        c.pk = this.ppk.toPk();
        c.source = this.source;
        return c;
    };
}, {ppk: "EcPpk"}, {});
/**
 *  Manages identities and contacts, provides hooks to respond to identity and
 *  contact events, and builds signatures and signature sheets for authorizing
 *  movement of data. Also provides helper functions for identity management and
 *  reads the users contacts on application start with a static constructor that
 *  pulls them out of any temporary storage
 * 
 *  @author fritz.ray@eduworks.com
 *  @module com.eduworks.ec
 *  @class EcIdentityManager
 *  @static
 */
var EcIdentityManager = function() {};
EcIdentityManager = stjs.extend(EcIdentityManager, null, [], function(constructor, prototype) {
    /**
     *  The current user's owned identities (keys+displayName)
     * 
     *  @property ids
     *  @type EcIdentity[]
     *  @static
     */
    constructor.ids = new Array();
    /**
     *  Contacts (Keys that we do not own)
     * 
     *  @property contacts
     *  @type EcContact[]
     *  @static
     */
    constructor.contacts = new Array();
    /**
     *  Identity change hook.
     * 
     *  @property onIdentityChanged
     *  @type Callback1<EcIdentity>
     *  @static
     */
    constructor.onIdentityChanged = null;
    /**
     *  Contacts change hook.
     * 
     *  @property onContactChanged
     *  @type Callback1<EcIdentity>
     *  @static
     */
    constructor.onContactChanged = null;
    constructor.signatureSheetCaching = false;
    constructor.signatureSheetCache = new Object();
    constructor.async = true;
    constructor.main = function(args) {
        EcIdentityManager.readContacts();
    };
    /**
     *  Trigger for the onIdentityChanged hook
     * 
     *  @param {EcIdentity} identity Identity that has changed
     *  @memberOf EcIdentityManager
     *  @method identityChanged
     *  @static
     */
    constructor.identityChanged = function(identity) {
        if (EcIdentityManager.onIdentityChanged != null) {
            EcIdentityManager.onIdentityChanged(identity);
        }
    };
    /**
     *  Trigger for the onContactChanged hook
     * 
     *  @param {EcContact} contact Contact that has changed
     *  @memberOf EcIdentityManager
     *  @method contactChanged
     *  @static
     */
    constructor.contactChanged = function(contact) {
        if (EcIdentityManager.onContactChanged != null) {
            EcIdentityManager.onContactChanged(contact);
        }
        EcIdentityManager.saveContacts();
    };
    /**
     *  Reads contact data from localstorage.
     * 
     *  @memberOf EcIdentityManager
     *  @method readContacts
     *  @static
     */
    constructor.readContacts = function() {
        var localStore = localStorage["contacts"];
        if (localStore == null) {
            return;
        }
        var c = JSON.parse(localStore);
        for (var i = 0; i < c.length; i++) {
            var contact = new EcContact();
            var o = c[i];
            var props = (o);
            contact.displayName = props["displayName"];
            contact.pk = EcPk.fromPem(props["pk"]);
            contact.source = props["source"];
            var cont = false;
            for (var j = 0; j < EcIdentityManager.contacts.length; j++) {
                if (EcIdentityManager.contacts[j].pk.toPem() == contact.pk.toPem()) {
                    cont = true;
                }
            }
            if (cont) {
                continue;
            }
            EcIdentityManager.contacts.push(contact);
        }
    };
    /**
     *  Writes contact data to localstorage.
     * 
     *  @memberOf EcIdentityManager
     *  @method saveContacts
     *  @static
     */
    constructor.saveContacts = function() {
        var c = new Array();
        for (var i = 0; i < EcIdentityManager.contacts.length; i++) {
            var o = new Object();
            var props = (o);
            var contact = EcIdentityManager.contacts[i];
            props["displayName"] = contact.displayName;
            props["pk"] = contact.pk.toPem();
            props["source"] = contact.source;
            c.push(o);
        }
        localStorage["contacts"] = JSON.stringify(c);
    };
    /**
     *  Reads contact data from localstorage.
     * 
     *  @memberOf EcIdentityManager
     *  @method readIdentities
     *  @static
     */
    constructor.readIdentities = function() {
        var localStore = localStorage["identities"];
        if (localStore == null) {
            return;
        }
        var c = JSON.parse(localStore);
        for (var i = 0; i < c.length; i++) {
            var identity = new EcIdentity();
            var o = c[i];
            var props = (o);
            identity.displayName = props["displayName"];
            identity.ppk = EcPpk.fromPem(props["ppk"]);
            identity.source = props["source"];
            var cont = false;
            for (var j = 0; j < EcIdentityManager.ids.length; j++) {
                if (EcIdentityManager.ids[j].ppk.toPem() == identity.ppk.toPem()) {
                    cont = true;
                }
            }
            if (cont) {
                continue;
            }
            EcIdentityManager.ids.push(identity);
        }
    };
    /**
     *  Writes contact data to localstorage.
     * 
     *  @memberOf EcIdentityManager
     *  @method saveIdentities
     *  @static
     */
    constructor.saveIdentities = function() {
        var c = new Array();
        for (var i = 0; i < EcIdentityManager.ids.length; i++) {
            var o = new Object();
            var props = (o);
            var identity = EcIdentityManager.ids[i];
            props["displayName"] = identity.displayName;
            props["ppk"] = identity.ppk.toPem();
            props["source"] = identity.source;
            c.push(o);
        }
        localStorage["identities"] = JSON.stringify(c);
    };
    /**
     *  Clears contacts from the local storage
     * 
     *  @memberOf EcIdentityManager
     *  @method clearContacts
     *  @static
     */
    constructor.clearContacts = function() {
        delete localStorage["contacts"];
        EcIdentityManager.contacts = new Array();
    };
    /**
     *  Clears identities from the local storage
     * 
     *  @memberOf EcIdentityManager
     *  @method clearIdentities
     *  @static
     */
    constructor.clearIdentities = function() {
        delete localStorage["identities"];
        EcIdentityManager.ids = new Array();
    };
    /**
     *  Adds an identity to the identity manager. Checks for duplicates. Triggers
     *  events.
     * 
     *  @param {EcIdentity} identity Identity to add.
     *  @memberOf EcIdentityManager
     *  @method addIdentity
     *  @static
     */
    constructor.addIdentity = function(identity) {
        for (var i = 0; i < EcIdentityManager.ids.length; i++) {
            if (EcIdentityManager.ids[i].equals(identity)) {
                return;
            }
        }
        EcIdentityManager.ids.push(identity);
        EcIdentityManager.identityChanged(identity);
    };
    /**
     *  Adds an identity to the identity manager. Checks for duplicates. Does not trigger
     *  events.
     * 
     *  @param {EcIdentity} identity Identity to add.
     *  @memberOf EcIdentityManager
     *  @method addIdentityQuietly
     *  @static
     */
    constructor.addIdentityQuietly = function(identity) {
        for (var i = 0; i < EcIdentityManager.ids.length; i++) {
            if (EcIdentityManager.ids[i].equals(identity)) {
                return;
            }
        }
        EcIdentityManager.ids.push(identity);
    };
    /**
     *  Adds a contact to the identity manager. Checks for duplicates. Triggers
     *  events.
     * 
     *  @param {EcContact} contact Contact to add.
     *  @memberOf EcIdentityManager
     *  @method addContact
     *  @static
     */
    constructor.addContact = function(contact) {
        for (var i = 0; i < EcIdentityManager.ids.length; i++) {
            if (EcIdentityManager.ids[i].ppk.toPk().toPem().equals(contact.pk.toPem())) {
                EcIdentityManager.ids[i].displayName = contact.displayName;
                EcIdentityManager.identityChanged(EcIdentityManager.ids[i]);
            }
        }
        for (var i = 0; i < EcIdentityManager.contacts.length; i++) {
            if (EcIdentityManager.contacts[i].pk.toPem().equals(contact.pk.toPem())) {
                EcIdentityManager.contacts[i].displayName = contact.displayName;
                EcIdentityManager.contactChanged(EcIdentityManager.contacts[i]);
            }
        }
        for (var i = 0; i < EcIdentityManager.contacts.length; i++) {
            if (EcIdentityManager.contacts[i].equals(contact)) {
                return;
            }
        }
        EcIdentityManager.contacts.push(contact);
        EcIdentityManager.contactChanged(contact);
    };
    /**
     *  Adds a contact to the identity manager. Checks for duplicates. Does not trigger
     *  events.
     * 
     *  @param {EcContact} contact Contact to add.
     *  @memberOf EcIdentityManager
     *  @method addContactQuietly
     *  @static
     */
    constructor.addContactQuietly = function(contact) {
        for (var i = 0; i < EcIdentityManager.ids.length; i++) {
            if (EcIdentityManager.ids[i].ppk.toPk().toPem().equals(contact.pk.toPem())) {
                EcIdentityManager.ids[i].displayName = contact.displayName;
            }
        }
        for (var i = 0; i < EcIdentityManager.contacts.length; i++) {
            if (EcIdentityManager.contacts[i].pk.toPem().equals(contact.pk.toPem())) {
                EcIdentityManager.contacts[i].displayName = contact.displayName;
            }
        }
        for (var i = 0; i < EcIdentityManager.contacts.length; i++) {
            if (EcIdentityManager.contacts[i].equals(contact)) {
                return;
            }
        }
        EcIdentityManager.contacts.push(contact);
    };
    /**
     *  Create a signature sheet, authorizing movement of data outside of our
     *  control.
     * 
     *  @param {String[]} identityPksinPem Which identities to create signatures
     *                    for.
     *  @param {long}     duration Length of time in milliseconds to authorize
     *                    control.
     *  @param {String}   server Server that we are authorizing.
     *  @return {String} JSON Array containing signatures.
     *  @memberOf EcIdentityManager
     *  @method signatureSheetFor
     *  @static
     */
    constructor.signatureSheetFor = function(identityPksinPem, duration, server) {
        var signatures = new Array();
        for (var j = 0; j < EcIdentityManager.ids.length; j++) {
            var ppk = EcIdentityManager.ids[j].ppk;
            var pk = ppk.toPk();
            if (identityPksinPem != null) {
                for (var i = 0; i < identityPksinPem.length; i++) {
                    var ownerPpk = EcPk.fromPem(identityPksinPem[i].trim());
                    if (pk.equals(ownerPpk)) {
                        signatures.push(EcIdentityManager.createSignature(duration, server, ppk).atIfy());
                    }
                }
            }
        }
        return JSON.stringify(signatures);
    };
    /**
     *  Asynchronous version of creating a signature sheet for a list of
     *  identities
     * 
     *  @param {String[]}          identityPksinPem Which identities to create signatures
     *                             for.
     *  @param {long}              duration Length of time in milliseconds to authorize
     *                             control.
     *  @param {String}            server Server that we are authorizing.
     *  @param {Callback1<String>} success Callback triggered once the signature
     *                             sheet has been created, returns the signature sheet
     *  @memberOf EcIdentityManager
     *  @method signatureSheetForAsync
     *  @static
     */
    constructor.signatureSheetForAsync = function(identityPksinPem, duration, server, success, failure) {
        var signatures = new Array();
        new EcAsyncHelper().each(EcIdentityManager.ids, function(p1, incrementalSuccess) {
            var ppk = p1.ppk;
            var pk = ppk.toPk();
            var found = false;
            if (identityPksinPem != null) {
                for (var j = 0; j < identityPksinPem.length; j++) {
                    var ownerPpk = EcPk.fromPem(identityPksinPem[j].trim());
                    if (pk.equals(ownerPpk)) {
                        found = true;
                        EcIdentityManager.createSignatureAsync(duration, server, ppk, function(p1) {
                            signatures.push(p1.atIfy());
                            incrementalSuccess();
                        }, failure);
                    }
                }
            }
            if (!found) {
                incrementalSuccess();
            }
        }, function(pks) {
            success(JSON.stringify(signatures));
        });
    };
    /**
     *  Create a signature sheet for all identities, authorizing movement of data
     *  outside of our control.
     * 
     *  @param {long}   duration Length of time in milliseconds to authorize
     *                  control.
     *  @param {String} server Server that we are authorizing.
     *  @return {String} JSON Array containing signatures.
     *  @memberOf EcIdentityManager
     *  @method signatureSheet
     *  @static
     */
    constructor.signatureSheet = function(duration, server) {
        var cache = null;
        if (EcIdentityManager.signatureSheetCaching) {
            cache = (EcIdentityManager.signatureSheetCache)[server];
            if (cache != null) {
                if (cache[0] > new Date().getTime() + duration) {
                    return cache[1];
                }
            }
            duration += 20000;
        }
        var signatures = new Array();
        for (var j = 0; j < EcIdentityManager.ids.length; j++) {
            var ppk = EcIdentityManager.ids[j].ppk;
            signatures.push(EcIdentityManager.createSignature(duration, server, ppk).atIfy());
        }
        var stringified = JSON.stringify(signatures);
        if (EcIdentityManager.signatureSheetCaching) {
            cache = new Array();
            cache[0] = new Date().getTime() + duration;
            cache[1] = stringified;
            (EcIdentityManager.signatureSheetCache)[server] = cache;
        }
        return stringified;
    };
    /**
     *  Asynchronous version of creating a signature sheet for all identities
     * 
     *  @param {long}             duration Length of time in milliseconds to authorize
     *                            control.
     *  @param {String}           server Server that we are authorizing.
     *  @param {Callback<String>} success Callback triggered once the signature
     *                            sheet has been created, returns the signature sheet
     *  @memberOf EcIdentityManager
     *  @method signatureSheetAsync
     *  @static
     */
    constructor.signatureSheetAsync = function(duration, server, success, failure) {
        if (!EcIdentityManager.async) {
            var sheet = EcIdentityManager.signatureSheet(duration, server);
            if (success != null) 
                success(sheet);
            return;
        }
        var signatures = new Array();
        var cache = null;
        if (EcIdentityManager.signatureSheetCaching) {
            cache = (EcIdentityManager.signatureSheetCache)[server];
            if (cache != null) {
                if (cache[0] > new Date().getTime() + duration) {
                    success(cache[1]);
                    return;
                }
            }
            duration += 20000;
        }
        var finalDuration = duration;
        new EcAsyncHelper().each(EcIdentityManager.ids, function(p1, incrementalSuccess) {
            var ppk = p1.ppk;
            EcIdentityManager.createSignatureAsync(finalDuration, server, ppk, function(p1) {
                signatures.push(p1.atIfy());
                incrementalSuccess();
            }, function(s) {
                failure(s);
                incrementalSuccess();
            });
        }, function(pks) {
            var cache = null;
            var stringified = JSON.stringify(signatures);
            if (EcIdentityManager.signatureSheetCaching) {
                cache = new Array();
                cache[0] = new Date().getTime() + finalDuration;
                cache[1] = stringified;
                (EcIdentityManager.signatureSheetCache)[server] = cache;
            }
            success(stringified);
        });
    };
    /**
     *  Create a signature for a specific identity, authorizing movement of data
     *  outside of our control.
     * 
     *  @param {long}   duration Length of time in milliseconds to authorize
     *                  control.
     *  @param {String} server Server that we are authorizing.
     *  @param {EcPpk}  ppk Key of the identity to create a signature for
     *  @return {Ebac Signature} Signature created
     *  @memberOf EcIdentityManager
     *  @method createSignature
     *  @static
     */
    constructor.createSignature = function(duration, server, ppk) {
        var s = new EbacSignature();
        s.expiry = new Date().getTime() + duration;
        s.server = server;
        (s)["@owner"] = ppk.toPk().toPem();
        (s)["@signature"] = EcRsaOaep.sign(ppk, s.toJson());
        return s;
    };
    /**
     *  Asynchronously create a signature for a specific identity
     * 
     *  @param {long}   duration Length of time in milliseconds to authorize
     *                  control.
     *  @param {String} server Server that we are authorizing.
     *  @param {EcPpk}  ppk Key of the identity to create a signature for
     *  @param success  Callback triggered once the signature sheet has been
     *                  created, returns the signature
     *  @memberOf EcIdentityManager
     *  @method createSignatureAsync
     *  @static
     */
    constructor.createSignatureAsync = function(duration, server, ppk, success, failure) {
        var s = new EbacSignature();
        (s)["@owner"] = ppk.toPk().toPem();
        s.expiry = new Date().getTime() + duration;
        s.server = server;
        EcRsaOaepAsync.sign(ppk, s.toJson(), function(p1) {
            (s)["@signature"] = p1;
            success(s);
        }, failure);
    };
    /**
     *  Get PPK from PK (if we have it)
     * 
     *  @param {EcPk} fromPem PK to use to look up PPK
     *  @return {EcPpk} PPK or null.
     *  @memberOf EcIdentityManager
     *  @method getPpk
     *  @static
     */
    constructor.getPpk = function(fromPem) {
        var pem = fromPem.toPem();
        for (var i = 0; i < EcIdentityManager.ids.length; i++) {
            if (pem.equals(EcIdentityManager.ids[i].ppk.toPk().toPem())) {
                return EcIdentityManager.ids[i].ppk;
            }
        }
        return null;
    };
    /**
     *  Get Contact from PK (if we have it)
     * 
     *  @param {EcPk} pk PK to use to look up PPK
     *  @return {EcPpk} PPK or null.
     *  @memberOf EcIdentityManager
     *  @method getContact
     *  @static
     */
    constructor.getContact = function(pk) {
        for (var i = 0; i < EcIdentityManager.contacts.length; i++) {
            if (pk.equals(EcIdentityManager.contacts[i].pk)) {
                return EcIdentityManager.contacts[i];
            }
        }
        return null;
    };
    /**
     *  Get Identity from PK (if we have it)
     * 
     *  @param {EcPk} pk PK to use to look up PPK
     *  @return {EcIdentity} identity or null.
     *  @memberOf EcIdentityManager
     *  @method getIdentity
     *  @static
     */
    constructor.getIdentity = function(pk) {
        for (var i = 0; i < EcIdentityManager.ids.length; i++) {
            if (pk.equals(EcIdentityManager.ids[i].ppk.toPk())) {
                return EcIdentityManager.ids[i];
            }
        }
        return null;
    };
    /**
     *  Sign a piece of data with all available keys that own that data.
     * 
     *  @param {EcRemoteLinkedData} d Data to sign.
     *  @memberOf EcIdentityManager
     *  @method sign
     *  @static
     */
    constructor.sign = function(d) {
        if (d.signature != null) {
            for (var i = 0; i < d.signature.length; ) {
                var works = false;
                var signature = d.signature[i];
                if (d.owner != null) {
                    for (var j = 0; j < d.owner.length; j++) {
                        var owner = d.owner[j];
                        var pk = EcPk.fromPem(owner);
                        try {
                            if (EcRsaOaep.verify(pk, d.toSignableJson(), signature)) {
                                works = true;
                                break;
                            }
                        }catch (ex) {}
                    }
                }
                if (!works) {
                    d.signature.splice(i, 1);
                } else {
                    i++;
                }
            }
        }
        if (d.owner != null) {
            for (var i = 0; i < d.owner.length; i++) {
                var attempt = EcIdentityManager.getPpk(EcPk.fromPem(d.owner[i]));
                if (attempt != null) {
                    d.signWith(attempt);
                }
            }
        }
        if (d.signature != null && d.signature.length == 0) {
            delete (d)["signature"];
        }
    };
    constructor.myIdentitiesSearchString = function() {
        var searchString = "";
        for (var i = 0; i < EcIdentityManager.ids.length; i++) {
            if (i > 0) {
                searchString += " OR ";
            }
            searchString += "\\*reader:\"" + EcIdentityManager.ids[i].ppk.toPk().toPem() + "\"";
            searchString += " OR ";
            searchString += "\\*owner:\"" + EcIdentityManager.ids[i].ppk.toPk().toPem() + "\"";
        }
        return searchString;
    };
    constructor.getMyPks = function() {
        var pks = new Array();
        if (EcIdentityManager.ids == null) 
            return pks;
        for (var i = 0; i < EcIdentityManager.ids.length; i++) 
            pks.push(EcIdentityManager.ids[i].ppk.toPk());
        return pks;
    };
}, {ids: {name: "Array", arguments: ["EcIdentity"]}, contacts: {name: "Array", arguments: ["EcContact"]}, onIdentityChanged: {name: "Callback1", arguments: ["EcIdentity"]}, onContactChanged: {name: "Callback1", arguments: ["EcContact"]}, signatureSheetCache: "Object"}, {});
if (!stjs.mainCallDisabled) 
    EcIdentityManager.main();
/**
 *  Created by fray on 5/9/17.
 */
var OAuth2FileBasedRemoteIdentityManager = /**
 *  Reads the remote OAuth2 endpoint file.
 * 
 *  @param {Callback0} Method to call when initialization is complete.
 *  @memberOf OAuth2FileBasedRemoteIdentityManager
 *  @constructor
 */
function(initialized) {
    var me = this;
    EcRemote.getExpectingObject("", "hello.json", function(o) {
        try {
            me.configuration = JSON.parse(JSON.stringify(o));
            hello.init(o);
            me.constructor.oauthEnabled = true;
            initialized();
        }catch (ex) {
            me.constructor.oauthEnabled = false;
        }
    }, function(s) {
        me.constructor.oauthEnabled = false;
    });
};
OAuth2FileBasedRemoteIdentityManager = stjs.extend(OAuth2FileBasedRemoteIdentityManager, null, [RemoteIdentityManagerInterface], function(constructor, prototype) {
    constructor.oauthEnabled = false;
    prototype.server = null;
    prototype.configuration = null;
    prototype.oauthLoginResponse = null;
    prototype.network = null;
    prototype.global = null;
    /**
     *  Returns true if the identity manager is global. Returns false if the identity manager is local to the server.
     * 
     *  @return {Boolean} true if the identity manager is global.
     *  @memberOf OAuth2FileBasedRemoteIdentityManager
     *  @method isGlobal
     */
    prototype.isGlobal = function() {
        if (this.global == null) 
            return true;
        return this.global;
    };
    prototype.configure = function(usernameSalt, usernameIterations, usernameWidth, passwordSalt, passwordIterations, passwordWidth, secretSalt, secretIterations) {};
    prototype.configureFromServer = function(success, failure) {
        success(null);
    };
    /**
     *  Wipes login data and logs you out.
     * 
     *  @memberOf OAuth2FileBasedRemoteIdentityManager
     *  @method clear
     */
    prototype.clear = function() {
        OAuth2FileBasedRemoteIdentityManager.oauthEnabled = false;
        if (this.server != null) 
            hello.logout(this.server, null);
    };
    /**
     *  Configure compatible remote identity management server.
     * 
     *  @param {String} server
     *                  Name of the remote identity management server.
     *  @memberOf OAuth2FileBasedRemoteIdentityManager
     *  @method setDefaultIdentityManagementServer
     */
    prototype.setDefaultIdentityManagementServer = function(server) {
        this.server = server;
    };
    prototype.startLogin = function(username, password) {};
    prototype.changePassword = function(username, oldPassword, newPassword) {
        return false;
    };
    /**
     *  Fetch credentials from server, invoking events based on login success or
     *  failure.
     *  <p>
     *  Automatically populates EcIdentityManager.
     *  <p>
     *  Does not require startLogin().
     * 
     *  @param {Callback1<Object>} success
     *  @param {Callback1<String>} failure
     *  @memberOf OAuth2FileBasedRemoteIdentityManager
     *  @method fetch
     */
    prototype.fetch = function(success, failure) {
        var o = new Object();
        (o)["scope"] = (this.configuration)[this.server + "Scope"];
        (o)["display"] = "page";
        var me = this;
        hello.on("auth.login", function(o) {
            me.oauthLoginResponse = o;
            me.network = (me.oauthLoginResponse)["network"];
            hello.api(me.network + "/me/folders", "get", new Object()).then(function(folderResponse) {
                var folders = (folderResponse)["data"];
                var foundIdentities = false;
                var foundContacts = false;
                for (var i = 0; i < folders.length; i++) {
                    var d = folders[i];
                    var name = (d)["name"];
                    var id = (d)["id"];
                    if (name == "CASS Identities") {
                        foundIdentities = true;
                        me.hookIdentityManagerIdentities(id);
                        me.readIdentityFiles(id, success, failure);
                    }
                    if (name == "CASS Contacts") {
                        foundContacts = true;
                        me.hookIdentityManagerContacts(id);
                        me.readContactFiles(id, success, failure);
                    }
                }
                if (!foundIdentities) {
                    me.createIdentityFolder(success);
                }
                if (!foundContacts) {
                    me.createContactFolder();
                }
            }).fail(failure);
        });
        hello.login(this.server, o).fail(failure);
    };
    prototype.createContactFolder = function() {
        var me = this;
        var o = new Object();
        (o)["name"] = "CASS Contacts";
        hello.api(me.network + "/me/folders", "post", o).then(function(r) {
            me.hookIdentityManagerContacts((r)["id"]);
        });
    };
    prototype.createIdentityFolder = function(success) {
        var me = this;
        var o = new Object();
        (o)["name"] = "CASS Identities";
        hello.api(me.network + "/me/folders", "post", o).then(function(r) {
            me.hookIdentityManagerIdentities((r)["id"]);
            success(r);
        });
    };
    prototype.writeIdentityFiles = function(folderId, success) {
        var me = this;
        var helper = new EcAsyncHelper();
        helper.each(EcIdentityManager.ids, function(identity, callback0) {
            me.writeIdentityFile(folderId, identity, callback0);
        }, function(strings) {
            success(strings);
        });
    };
    prototype.writeIdentityFile = function(folderId, identity, finished) {
        var file = stringToFile(identity.ppk.toPem(), identity.displayName + ".pem", "text/plain");
        var o = new Object();
        (o)["id"] = (identity)["id"];
        if ((o)["id"] == undefined) 
            (o)["parent"] = folderId;
        (o)["name"] = file.name;
        var files = new Array();
        files.push(file);
        (o)["file"] = files;
        hello.api(this.network + "/me/files", (identity)["id"] == undefined ? "post" : "put", o).then(function(r) {
            (identity)["id"] = (r)["id"];
            if (finished != null) 
                finished();
        });
    };
    prototype.writeContactFiles = function(folderId) {
        for (var i = 0; i < EcIdentityManager.contacts.length; i++) {
            this.writeContactFile(folderId, EcIdentityManager.contacts[i]);
        }
    };
    prototype.writeContactFile = function(folderId, contact) {
        var file = stringToFile(contact.pk.toPem(), contact.displayName + ".pem", "text/plain");
        var o = new Object();
        (o)["id"] = (contact)["id"];
        if ((o)["id"] == undefined) 
            (o)["parent"] = folderId;
        (o)["name"] = file.name;
        var files = new Array();
        files.push(file);
        (o)["file"] = files;
        hello.api(this.network + "/me/files", (contact)["id"] == undefined ? "post" : "put", o).then(function(r) {
            (contact)["id"] = (r)["id"];
        });
    };
    prototype.readIdentityFiles = function(folderId, success, failure) {
        var me = this;
        var o = new Object();
        (o)["parent"] = folderId;
        hello.api(this.network + "/me/files", "get", o).then(function(folderResponse) {
            var files = (folderResponse)["data"];
            var h = new EcAsyncHelper();
            h.each(files, function(d, callback0) {
                var name = ((d)["name"]).replace("\\.pem", "");
                var id = (d)["id"];
                var directLink = (d)["downloadUrl"];
                EcRemote.getExpectingString("", directLink + "&access_token=" + (hello.getAuthResponse(me.network))["access_token"], function(s) {
                    var identity = new EcIdentity();
                    identity.displayName = name.replace(".pem", "");
                    identity.ppk = EcPpk.fromPem(s);
                    identity.source = "google";
                    (identity)["id"] = id;
                    EcIdentityManager.addIdentityQuietly(identity);
                    callback0();
                }, failure);
            }, function(strings) {
                success(null);
            });
        });
    };
    prototype.readContactFiles = function(folderId, success, failure) {
        var me = this;
        var o = new Object();
        (o)["parent"] = folderId;
        hello.api(this.network + "/me/files", "get", o).then(function(folderResponse) {
            var files = (folderResponse)["data"];
            var h = new EcAsyncHelper();
            h.each(files, function(d, callback0) {
                var name = ((d)["name"]).replace("\\.pem", "");
                var id = (d)["id"];
                var directLink = (d)["downloadUrl"];
                EcRemote.getExpectingString("", directLink + "&access_token=" + (hello.getAuthResponse(me.network))["access_token"], function(s) {
                    var contact = new EcContact();
                    contact.displayName = name.replace(".pem", "");
                    contact.pk = EcPk.fromPem(s);
                    contact.source = "google";
                    (contact)["id"] = id;
                    EcIdentityManager.addContactQuietly(contact);
                    callback0();
                }, failure);
            }, function(strings) {
                success(null);
            });
        });
    };
    prototype.hookIdentityManagerIdentities = function(folderId) {
        var me = this;
        EcIdentityManager.onIdentityChanged = function(identity) {
            me.writeIdentityFile(folderId, identity, null);
        };
    };
    prototype.hookIdentityManagerContacts = function(folderId) {
        var me = this;
        EcIdentityManager.onContactChanged = function(contact) {
            me.writeContactFile(folderId, contact);
        };
    };
    /**
     *  Commits credentials in EcIdentityManager to remote server.
     * 
     *  @param {Callback1<String>}   success
     *  @param {Callback1<String>}   failure
     *  @memberOf OAuth2FileBasedRemoteIdentityManager
     *  @method commit
     */
    prototype.commit = function(success, failure) {
        var me = this;
        var apio = new Object();
        (apio)["network"] = this.network;
        if (hello.getAuthResponse(this.server)) 
            hello.api(me.network + "/me/folders", "get", apio).then(function(folderResponse) {
                var folders = (folderResponse)["data"];
                for (var i = 0; i < folders.length; i++) {
                    var d = folders[i];
                    var name = (d)["name"];
                    var id = (d)["id"];
                    if (name == "CASS Identities") {
                        me.writeIdentityFiles(id, success);
                    }
                    if (name == "CASS Contacts") {
                        me.writeContactFiles(id);
                    }
                }
            }).fail(failure);
         else 
            failure("Please login again.");
    };
    prototype.create = function(success, failure) {
        var o = new Object();
        (o)["scope"] = (this.configuration)[this.server + "Scope"];
        var me = this;
        hello.on("auth.login", function(o) {
            me.oauthLoginResponse = o;
            me.network = (me.oauthLoginResponse)["network"];
            hello.api(me.network + "/me/folders", "get", new Object()).then(function(folderResponse) {
                var folders = (folderResponse)["data"];
                var foundIdentities = false;
                var foundContacts = false;
                for (var i = 0; i < folders.length; i++) {
                    var d = folders[i];
                    var name = (d)["name"];
                    var id = (d)["id"];
                    if (name == "CASS Identities") {
                        foundIdentities = true;
                        me.hookIdentityManagerIdentities(id);
                        me.readIdentityFiles(id, success, failure);
                    }
                    if (name == "CASS Contacts") {
                        foundContacts = true;
                        me.hookIdentityManagerContacts(id);
                        me.readContactFiles(id, success, failure);
                    }
                }
                if (!foundIdentities) {
                    me.createIdentityFolder(success);
                }
                if (!foundContacts) {
                    me.createContactFolder();
                }
            }).fail(failure);
        });
        hello.login(this.server, o).fail(failure);
    };
}, {configuration: "Object", oauthLoginResponse: "Object"}, {});
/**
 *  Logs into and stores/retrieves credentials from a compatible remote server.
 *  Performs anonymization of the user.
 *  <p>
 *  Requires initialization with server specific salts. Server specific salts
 *  prevent co-occurrence attacks, should credentials on one server be
 *  compromised (intercepted in transit).
 *  <p>
 *  Transmits hashed username, hashed password, and encrypts credentials using
 *  the hashed combination of the username and password. This prevents the system
 *  storing the credentials from having any knowledge of the user.
 *  <p>
 *  Password recovery is done by, when the password changes, creating a
 *  cryptographic pad (or perfect cipher) where one half is stored on the server,
 *  and the other half is stored with the user. Should the user lose this pad and
 *  forget their password, they are not able to recover or reset their password,
 *  and their data should be considered lost.
 * 
 *  @author fritz.ray@eduworks.com
 *  @module com.eduworks.ec
 *  @class EcRemoteIdentityManager
 */
var EcRemoteIdentityManager = function() {};
EcRemoteIdentityManager = stjs.extend(EcRemoteIdentityManager, null, [RemoteIdentityManagerInterface], function(constructor, prototype) {
    prototype.server = null;
    prototype.global = null;
    prototype.usernameWithSalt = null;
    prototype.passwordWithSalt = null;
    prototype.secretWithSalt = null;
    prototype.pad = null;
    prototype.token = null;
    prototype.usernameSalt = null;
    prototype.usernameIterations = 0;
    prototype.usernameWidth = 0;
    prototype.passwordSalt = null;
    prototype.passwordIterations = 0;
    prototype.passwordWidth = 0;
    prototype.secretSalt = null;
    prototype.secretIterations = 0;
    prototype.configured = false;
    /**
     *  Returns true if the identity manager is global. Returns false if the identity manager is local to the server.
     * 
     *  @return {Boolean} true if the identity manager is global.
     *  @memberOf EcRemoteIdentityManager
     */
    prototype.isGlobal = function() {
        if (this.global == null) 
            return false;
        return this.global;
    };
    /**
     *  Configure parameters of the remote login storage.
     * 
     *  @param {String} usernameSalt
     *                  Salt used in hashing the username.
     *  @param {int}    usernameIterations
     *                  Number of times to hash the username.
     *  @param {int}    usernameWidth
     *                  Resultant width of username in bytes.
     *  @param {String} passwordSalt
     *                  Salt used to hash password.
     *  @param {int}    passwordIterations
     *                  Number of times to hash password.
     *  @param {int}    passwordWidth
     *                  Resultant width of password in bytes.
     *  @param {String} secretSalt
     *                  Salt used to hash secret (composed of username + password)
     *  @param {int}    secretIterations
     *                  Number of times to hash secret.
     *  @memberOf EcRemoteIdentityManager
     *  @method configure
     */
    prototype.configure = function(usernameSalt, usernameIterations, usernameWidth, passwordSalt, passwordIterations, passwordWidth, secretSalt, secretIterations) {
        this.usernameSalt = usernameSalt;
        this.usernameIterations = usernameIterations;
        this.usernameWidth = usernameWidth;
        this.passwordSalt = passwordSalt;
        this.passwordIterations = passwordIterations;
        this.passwordWidth = passwordWidth;
        this.secretSalt = secretSalt;
        this.secretIterations = secretIterations;
        this.configured = true;
    };
    /**
     *  Configures parameters of the remote server by accessing configuration details via webservice
     * 
     *  @param {Callback1<Object>} success
     *                             Callback triggered after successfully configured
     *  @param {Callback1<String>} failure
     *                             Callback triggered if an error during failure
     *  @memberOf EcRemoteIdentityManager
     *  @method configureFromServer
     */
    prototype.configureFromServer = function(success, failure) {
        var me = this;
        EcRemote.getExpectingObject(this.server, "sky/id/salts", function(p1) {
            me.usernameSalt = (p1)["usernameSalt"];
            if (me.usernameSalt.length < 16) {
                failure("Insufficient length on Username Salt");
                return;
            }
            me.usernameIterations = stjs.trunc((p1)["usernameIterations"]);
            if (me.usernameIterations < 1000) {
                failure("Insufficient iterations on Username Hash");
                return;
            }
            me.usernameWidth = stjs.trunc((p1)["usernameLength"]);
            if (me.usernameWidth != 64) {
                failure("Username Hash required to be length 64.");
                return;
            }
            me.passwordSalt = (p1)["passwordSalt"];
            if (me.passwordSalt.length < 16) {
                failure("Insufficient length on Password Salt");
                return;
            }
            me.passwordIterations = stjs.trunc((p1)["passwordIterations"]);
            if (me.passwordIterations < 1000) {
                failure("Insufficient iterations on Password Hash");
                return;
            }
            me.passwordWidth = stjs.trunc((p1)["passwordLength"]);
            if (me.passwordWidth != 64) {
                failure("Password Hash required to be length 64.");
                return;
            }
            me.secretSalt = (p1)["secretSalt"];
            if (me.secretSalt.length < 16) {
                failure("Insufficient length on Secret Salt");
                return;
            }
            me.secretIterations = stjs.trunc((p1)["secretIterations"]);
            if (me.secretIterations < 1000) {
                failure("Insufficient iterations on Secret Hash");
                return;
            }
            me.configured = true;
            if (success != null) 
                success(p1);
        }, function(p1) {
            me.configured = false;
            if (failure != null) 
                failure(p1);
             else 
                console.error(p1);
        });
    };
    /**
     *  Wipes login data.
     * 
     *  @memberOf EcRemoteIdentityManager
     *  @method clear
     */
    prototype.clear = function() {
        this.usernameWithSalt = null;
        this.passwordWithSalt = null;
        this.secretWithSalt = null;
        this.pad = null;
        this.token = null;
    };
    /**
     *  Configure compatible remote identity management server.
     * 
     *  @param {String} server
     *                  URL to remote identity management server.
     *  @memberOf EcRemoteIdentityManager
     *  @method setDefaultIdentityManagementServer
     */
    prototype.setDefaultIdentityManagementServer = function(server) {
        this.server = server;
    };
    /**
     *  "Log Into" system, generating credentials. Does not actually remotely
     *  access any machine.
     *  <p>
     *  Please clear username and password fields after this function is called.
     * 
     *  @param {String} username
     *                  Username to login with
     *  @param {String} password
     *                  Password to authenticate username with
     *  @memberOf EcRemoteIdentityManager
     *  @method startLogin
     */
    prototype.startLogin = function(username, password) {
        if (!this.configured) {
             throw new RuntimeException("Remote Identity not configured.");
        }
        this.usernameWithSalt = forge.util.encode64(forge.pkcs5.pbkdf2(username, this.usernameSalt, this.usernameIterations, this.usernameWidth));
        this.passwordWithSalt = forge.util.encode64(forge.pkcs5.pbkdf2(password, this.passwordSalt, this.passwordIterations, this.passwordWidth));
        var arys = new Array();
        arys.push(username, password);
        var secret = this.splicePasswords(arys);
        this.secretWithSalt = forge.util.encode64(forge.pkcs5.pbkdf2(secret, this.secretSalt, this.secretIterations, 32));
    };
    /**
     *  Change password of user in memory. Does not automatically commit new credentials.
     *  <p>
     *  Please clear username and password fields after this function is called.
     * 
     *  @param {String} username
     *                  Username
     *  @param {String} oldPassword
     *                  Current password
     *  @param {String} newPassword
     *                  Desired password
     *  @return {boolean}
     *  Valid password change request.
     *  @memberOf EcRemoteIdentityManager
     *  @method changePassword
     */
    prototype.changePassword = function(username, oldPassword, newPassword) {
        var usernameHash = forge.util.encode64(forge.pkcs5.pbkdf2(username, this.usernameSalt, this.usernameIterations, this.usernameWidth));
        if (this.usernameWithSalt != usernameHash) {
             throw new RuntimeException("Username does not match. Aborting password change.");
        }
        var oldPasswordHash = forge.util.encode64(forge.pkcs5.pbkdf2(oldPassword, this.passwordSalt, this.passwordIterations, this.passwordWidth));
        if (this.passwordWithSalt != oldPasswordHash) {
             throw new RuntimeException("Old password does not match. Aborting password change.");
        }
        this.passwordWithSalt = forge.util.encode64(forge.pkcs5.pbkdf2(newPassword, this.passwordSalt, this.passwordIterations, this.passwordWidth));
        var arys = new Array();
        arys.push(username, newPassword);
        var secret = this.splicePasswords(arys);
        this.secretWithSalt = forge.util.encode64(forge.pkcs5.pbkdf2(secret, this.secretSalt, this.secretIterations, 32));
        return true;
    };
    /**
     *  Fetch credentials from server, invoking events based on login success or
     *  failure.
     *  <p>
     *  Automatically populates EcIdentityManager.
     *  <p>
     *  Requires login().
     * 
     *  @param {Callback1<Object>} success
     *  @param {Callback1<String>} failure
     *  @memberOf EcRemoteIdentityManager
     *  @method fetch
     */
    prototype.fetch = function(success, failure) {
        if (!this.configured) {
            failure("Remote Identity not configured.");
            return;
        }
        if (this.usernameWithSalt == null || this.passwordWithSalt == null || this.secretWithSalt == null) {
            failure("Please log in before performing this operation.");
            return;
        }
        var r = new EbacCredentialRequest();
        r.username = this.usernameWithSalt;
        r.password = this.passwordWithSalt;
        var fd = new FormData();
        fd.append("credentialRequest", r.toJson());
        var me = this;
        EcRemote.postExpectingObject(this.server, "sky/id/login", fd, function(arg0) {
            var cs = arg0;
            me.pad = cs.pad;
            me.token = cs.token;
            if (cs.credentials != null) 
                for (var i = 0; i < cs.credentials.length; i++) {
                    var c = cs.credentials[i];
                    var identity = EcIdentity.fromCredential(c, me.secretWithSalt, me.server);
                    EcIdentityManager.addIdentity(identity);
                }
            if (cs.contacts != null) 
                for (var i = 0; i < cs.contacts.length; i++) {
                    var c = cs.contacts[i];
                    var identity = EcContact.fromEncryptedContact(c, me.secretWithSalt, me.server);
                    EcIdentityManager.addContact(identity);
                }
            success(arg0);
        }, function(arg0) {
            failure(arg0);
        });
    };
    /**
     *  Commits credentials in EcIdentityManager to remote server.
     *  <p>
     *  Will trigger pad generation and fail if the pad has not been specified.
     * 
     *  @param {Callback1<String>}   success
     *  @param {Callback1<String>}   failure
     *  @memberOf EcRemoteIdentityManager
     *  @method commit
     */
    prototype.commit = function(success, failure) {
        var service = "sky/id/commit";
        this.sendCredentials(success, failure, service);
    };
    /**
     *  Creates an account.
     *  <p>
     *  Please note that the remote login server does not throw error messages if
     *  an account creation is blocked due to being a duplicate. This prevents
     *  login probing. This will always succeed (if the request is properly
     *  formed and makes it to the server).
     *  <p>
     *  Will trigger pad generation and fail if the pad has not been specified.
     * 
     *  @param {Callback1<String>}   success
     *                               Callback triggered after successfully creating an account
     *  @param {Callback1<String>}   failure
     *                               Callback triggered if error creating an account
     *  @memberOf EcRemoteIdentityManager
     *  @method create
     */
    prototype.create = function(success, failure) {
        var service = "sky/id/create";
        this.sendCredentials(success, failure, service);
    };
    /**
     *  Sends the identity managers credentials to the service specified
     * 
     *  @param {Callback1<String>}   success
     *                               Callback triggered if credentials sent successfully
     *  @param {Callback1<String>}   failure
     *                               Callback triggered if error sending credentials
     *  @param service               Service to send credentials to on server
     *  @memberOf EcRemoteIdentityManager
     *  @method sendCredentials
     */
    prototype.sendCredentials = function(success, failure, service) {
        if (!this.configured) 
             throw new RuntimeException("Remote Identity not configured.");
        if (this.usernameWithSalt == null || this.passwordWithSalt == null || this.secretWithSalt == null) {
             throw new RuntimeException("Please log in before performing this operation.");
        }
        var credentials = new Array();
        var contacts = new Array();
        for (var i = 0; i < EcIdentityManager.ids.length; i++) {
            var id = EcIdentityManager.ids[i];
            if (id.source != null && id.source != this.server) 
                continue;
            id.source = this.server;
            credentials.push(id.toCredential(this.secretWithSalt));
        }
        for (var i = 0; i < EcIdentityManager.contacts.length; i++) {
            var id = EcIdentityManager.contacts[i];
            if (id.source != null && id.source != this.server) 
                continue;
            id.source = this.server;
            contacts.push(id.toEncryptedContact(this.secretWithSalt));
        }
        var commit = new EbacCredentialCommit();
        commit.username = this.usernameWithSalt;
        commit.password = this.passwordWithSalt;
        commit.token = this.token;
        commit.credentials.pad = this.pad;
        commit.credentials.credentials = credentials;
        commit.credentials.contacts = contacts;
        var fd = new FormData();
        fd.append("credentialCommit", commit.toJson());
        var me = this;
        EcIdentityManager.signatureSheetAsync(60000, this.server, function(p1) {
            fd.append("signatureSheet", p1);
            EcRemote.postExpectingString(me.server, service, fd, function(arg0) {
                success(arg0);
            }, function(arg0) {
                failure(arg0);
            });
        }, failure);
    };
    /**
     *  Splices together passwords (in a fashion more like shuffling a deck of
     *  cards, not appending).
     * 
     *  @param {String[]} passwords
     *                    Passwords to splice.
     *  @return {String}
     *  Spliced password.
     *  @memberOf EcRemoteIdentityManager
     *  @method splicePasswords
     */
    prototype.splicePasswords = function(passwords) {
        var passwordSplice = "";
        for (var charIndex = 0; charIndex > 0; charIndex++) {
            var foundAny = false;
            for (var passwordIndex = 0; passwordIndex < passwords.length; passwordIndex++) {
                if (charIndex >= passwords[passwordIndex].length) 
                    continue;
                passwordSplice += passwords[passwordIndex].charAt(charIndex);
                foundAny = true;
            }
            if (!foundAny) 
                break;
        }
        return passwordSplice;
    };
}, {}, {});
/**
 *  Contact Grant that is used to share your public key with another user
 * 
 *  @author fritz.ray@eduworks.com
 *  @author devlin.junker@eduworks.com
 *  @module com.eduworks.ec
 *  @class EcContact
 *  @extends EbacContactGrant
 *  @constructor
 */
var EcContactGrant = function() {
    EbacContactGrant.call(this);
};
EcContactGrant = stjs.extend(EcContactGrant, EbacContactGrant, [], function(constructor, prototype) {
    /**
     *  Verifies that the contact grant is valid
     * 
     *  @return {boolean}
     *  true if valid, false if not
     */
    prototype.valid = function() {
        if (!this.verify()) 
            return false;
        if (this.invalid()) 
            return false;
        var found = false;
        for (var i = 0; i < EcIdentityManager.ids.length; i++) {
            if (EcRsaOaep.verify(EcIdentityManager.ids[i].ppk.toPk(), this.responseToken, this.responseSignature)) 
                found = true;
        }
        return found;
    };
}, {owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});

/**
 *  Represents an encrypted piece of data. Provides helper functions for
 *  encryption/decryption of JSON-LD objects, and provides some searchability of
 *  the data within.
 * 
 *  @author fritz.ray@eduworks.com
 *  @module com.eduworks.ec
 *  @class EcEncryptedValue
 *  @extends EbacEncryptedValue
 */
var EcEncryptedValue = function() {
    EbacEncryptedValue.call(this);
};
EcEncryptedValue = stjs.extend(EcEncryptedValue, EbacEncryptedValue, [], function(constructor, prototype) {
    constructor.encryptOnSaveMap = null;
    constructor.revive = function(partiallyRehydratedObject) {
        if (partiallyRehydratedObject == null) 
            return null;
        var v = new EcEncryptedValue();
        v.copyFrom(partiallyRehydratedObject);
        return v;
    };
    /**
     *  Converts a piece of (likely) encrypted remote linked data to an unencrypted object.
     *  @param d Data to decrypt
     *  @return Decrypted data
     *  @memberOf EcEncryptedValue
     *  @static
     *  @method fromEncryptedValue
     */
    constructor.fromEncryptedValue = function(d) {
        if (!d.isAny(new EcEncryptedValue().getTypes())) 
            return d;
        var eev = new EcEncryptedValue();
        eev.copyFrom(d);
        EcEncryptedValue.encryptOnSave(d.id, true);
        EcEncryptedValue.encryptOnSave(d.shortId(), true);
        return eev.decryptIntoObject();
    };
    /**
     *  Converts a piece of (likely) encrypted remote linked data to an unencrypted object.
     *  @param {EcRemoteLinkedData} d Data to decrypt
     *  @param {Callback1<EcRemoteLinkedData>} success
     *  @param {Callback1<String>} failure
     *  @param d Data to decrypt
     *  @return Decrypted data
     *  @memberOf EcEncryptedValue
     *  @static
     *  @method fromEncryptedValue
     */
    constructor.fromEncryptedValueAsync = function(d, success, failure) {
        if (!d.isAny(new EcEncryptedValue().getTypes())) 
            success(d);
         else {
            var eev = new EcEncryptedValue();
            eev.copyFrom(d);
            EcEncryptedValue.encryptOnSave(d.id, true);
            EcEncryptedValue.encryptOnSave(d.shortId(), true);
            eev.decryptIntoObjectAsync(success, failure);
        }
    };
    /**
     *  Gets the fully qualified type name, as JSON-LD allows the "namespace" of
     *  the type to be defined in @context.
     * 
     *  @return {string} Fully qualified type name.
     *  @method getEncryptedFullType
     */
    prototype.getEncryptedFullType = function() {
        if (this.encryptedContext == null) 
            return this.encryptedType;
        if (this.encryptedType.indexOf("http") != -1) 
            return this.encryptedType;
        var computedType = this.encryptedContext;
        if (EcObject.isObject(this.encryptedContext)) {
            var typeParts = this.encryptedType.split(":");
            if (typeParts.length == 2) {
                computedType = (this.encryptedContext)[typeParts[0]];
                if (!computedType.endsWith("/")) 
                    computedType += "/";
                computedType += typeParts[1];
                return computedType;
            } else if ((this.encryptedContext)["@vocab"] != null) 
                computedType = (this.encryptedContext)["@vocab"];
        }
        if (!computedType.endsWith("/")) 
            computedType += "/";
        computedType += this.encryptedType;
        return computedType;
    };
    prototype.getEncryptedDottedType = function() {
        return this.getEncryptedFullType().replace("http://", "").replace("https://", "").replaceAll("/", ".");
    };
    /**
     *  Converts a piece of remote linked data to an encrypted value
     * 
     *  @param {EcRemoteLinkedData} d Data to encrypt
     *  @param {Boolean}            hideType Flag to hide the type of the encrypted value
     *                              when encrypting
     *  @return {EcEncryptedValue} Encrypted value
     *  @memberOf EcEncryptedValue
     *  @method toEncryptedValue
     *  @static
     */
    constructor.toEncryptedValue = function(d, hideType) {
        d.updateTimestamp();
        var v = new EcEncryptedValue();
        if (hideType == null || !hideType) {
            v.encryptedType = d.type;
            v.encryptedContext = d.context;
        }
        var newIv = EcAes.newIv(16);
        var newSecret = EcAes.newIv(16);
        var conceptName = (d)["skos:prefLabel"];
        var conceptSchemeName = (d)["dcterms:title"];
        v.payload = EcAesCtr.encrypt(d.toJson(), newSecret, newIv);
        v.owner = d.owner;
        v.reader = d.reader;
        v.id = d.id;
        if ((d)["name"] != null) {
            v.name = (d)["name"];
        }
        if (d.owner != null) {
            for (var i = 0; i < d.owner.length; i++) {
                var eSecret = new EbacEncryptedSecret();
                eSecret.iv = newIv;
                eSecret.secret = newSecret;
                if (v.secret == null) {
                    v.secret = new Array();
                }
                v.secret.push(EcRsaOaep.encrypt(EcPk.fromPem(d.owner[i]), eSecret.toEncryptableJson()));
            }
        }
        if (d.reader != null) {
            for (var i = 0; i < d.reader.length; i++) {
                var eSecret = new EbacEncryptedSecret();
                eSecret.iv = newIv;
                eSecret.secret = newSecret;
                if (v.secret == null) {
                    v.secret = new Array();
                }
                v.secret.push(EcRsaOaep.encrypt(EcPk.fromPem(d.reader[i]), eSecret.toEncryptableJson()));
            }
        }
        if (conceptName != null) {
            (v)["skos:prefLabel"] = conceptName;
        }
        if (conceptSchemeName != null) {
            (v)["dcterms:title"] = conceptSchemeName;
        }
        return v;
    };
    /**
     *  Converts a piece of remote linked data to an encrypted value,
     *  asynchronously
     * 
     *  @param {EcRemoteLinkedData}          d Data to encrypt
     *  @param {boolean}                     hideType Flag to hide the type of the encrypted value
     *                                       when encrypting
     *  @param {Callback1<EcEncryptedValue>} success Callback triggered with
     *                                       successfully encrypted, returns the encrypted value
     *  @param {Callback1<String>}           failure Callback triggered on error during
     *                                       encryption
     *  @memberOf EcEncryptedValue
     *  @method toEncryptedValueAsync
     *  @static
     */
    constructor.toEncryptedValueAsync = function(d, hideType, success, failure) {
        d.updateTimestamp();
        var v = new EcEncryptedValue();
        if (hideType == null || !hideType) {
            v.encryptedType = d.type;
        }
        var newIv = EcAes.newIv(16);
        var newSecret = EcAes.newIv(16);
        EcAesCtrAsync.encrypt(d.toJson(), newSecret, newIv, function(encryptedText) {
            v.payload = encryptedText;
            v.owner = d.owner;
            v.reader = d.reader;
            v.id = d.id;
            if ((d)["name"] != null) {
                v.name = (d)["name"];
            }
            if (d.owner != null) {
                new EcAsyncHelper().each(d.owner, function(pk, arg1) {
                    EcEncryptedValue.insertSecret(pk, arg1, newIv, newSecret, v, failure);
                }, function(arg0) {
                    if (d.reader != null) {
                        new EcAsyncHelper().each(d.reader, function(pk, arg1) {
                            EcEncryptedValue.insertSecret(pk, arg1, newIv, newSecret, v, failure);
                        }, function(arg0) {
                            success(v);
                        });
                    } else 
                        success(v);
                });
            }
        }, failure);
    };
    constructor.insertSecret = function(pk, success, newIv, newSecret, v, failure) {
        var eSecret = new EbacEncryptedSecret();
        eSecret.iv = newIv;
        eSecret.secret = newSecret;
        if (v.secret == null) {
            v.secret = new Array();
        }
        EcRsaOaepAsync.encrypt(EcPk.fromPem(pk), eSecret.toEncryptableJson(), function(encryptedSecret) {
            v.secret.push(encryptedSecret);
            success();
        }, failure);
    };
    /**
     *  Encrypts a text value with the key provided
     * 
     *  @param {String} text Text to encrypt
     *  @param {String} id ID of the encrypted value
     *  @param {EcPk}   owner Key to Encrypt
     *  @return {EcEncryptedValue} Encrypted value
     *  @memberOf EcEncryptedValue
     *  @method encryptValueOld
     *  @static
     *  @deprecated
     */
    constructor.encryptValueOld = function(text, id, owner) {
        var v = new EcEncryptedValue();
        var newIv = EcAes.newIv(16);
        var newSecret = EcAes.newIv(16);
        v.payload = EcAesCtr.encrypt(text, newSecret, newIv);
        v.addOwner(owner);
        for (var i = 0; i < v.owner.length; i++) {
            var eSecret = new EbacEncryptedSecret();
            eSecret.id = forge.util.encode64(forge.pkcs5.pbkdf2(id, "", 1, 8));
            eSecret.iv = newIv;
            eSecret.secret = newSecret;
            if (v.secret == null) {
                v.secret = new Array();
            }
            v.secret.push(EcRsaOaep.encrypt(EcPk.fromPem(v.owner[i]), eSecret.toEncryptableJson()));
        }
        return v;
    };
    /**
     *  Encrypts a text value with the owners and readers provided
     * 
     *  @param {String}   text Text to encrypt
     *  @param {String}   id ID of the value to encrypt
     *  @param {String[]} owners Owner keys to encrypt value with
     *  @param {String[]} readers Reader keys to encrypt value with
     *  @return {EcEncryptedValue} Encrypted value
     *  @memberOf EcEncryptedValue
     *  @method encryptValue
     *  @static
     */
    constructor.encryptValue = function(text, id, owners, readers) {
        var v = new EcEncryptedValue();
        var newIv = EcAes.newIv(16);
        var newSecret = EcAes.newIv(16);
        v.payload = EcAesCtr.encrypt(text, newSecret, newIv);
        if (owners != null) {
            for (var i = 0; i < owners.length; i++) {
                v.addOwner(EcPk.fromPem(owners[i]));
            }
        }
        if (owners != null) 
            if (v.owner != null) {
                for (var i = 0; i < v.owner.length; i++) {
                    var eSecret = new EbacEncryptedSecret();
                    eSecret.id = forge.util.encode64(forge.pkcs5.pbkdf2(id, "", 1, 8));
                    eSecret.iv = newIv;
                    eSecret.secret = newSecret;
                    if (v.secret == null) {
                        v.secret = new Array();
                    }
                    v.secret.push(EcRsaOaep.encrypt(EcPk.fromPem(v.owner[i]), eSecret.toEncryptableJson()));
                }
            }
        if (readers != null) 
            if (v.reader != null) {
                for (var i = 0; i < v.reader.length; i++) {
                    var eSecret = new EbacEncryptedSecret();
                    eSecret.id = forge.util.encode64(forge.pkcs5.pbkdf2(id, "", 1, 8));
                    eSecret.iv = newIv;
                    eSecret.secret = newSecret;
                    if (v.secret == null) {
                        v.secret = new Array();
                    }
                    v.secret.push(EcRsaOaep.encrypt(EcPk.fromPem(v.reader[i]), eSecret.toEncryptableJson()));
                }
            }
        if (readers != null) {
            for (var i = 0; i < readers.length; i++) {
                v.addReader(EcPk.fromPem(readers[i]));
            }
        }
        return v;
    };
    /**
     *  Encrypts a text value with the owners and readers provided
     * 
     *  @param {String}   text Text to encrypt
     *  @param {String}   id ID of the value to encrypt
     *  @param {String[]} owners Owner keys to encrypt value with
     *  @param {String[]} readers Reader keys to encrypt value with
     *  @return {EcEncryptedValue} Encrypted value
     *  @memberOf EcEncryptedValue
     *  @method encryptValue
     *  @static
     */
    constructor.encryptValueAsync = function(text, id, owners, readers, success, failure) {
        var v = new EcEncryptedValue();
        var newIv = EcAes.newIv(16);
        var newSecret = EcAes.newIv(16);
        v.payload = EcAesCtr.encrypt(text, newSecret, newIv);
        if (owners != null) {
            for (var i = 0; i < owners.length; i++) {
                v.addOwner(EcPk.fromPem(owners[i]));
            }
        }
        if (readers != null) {
            for (var i = 0; i < readers.length; i++) {
                v.addReaderBasic(EcPk.fromPem(readers[i]));
            }
        }
        var pks = new Array();
        if (owners != null) 
            if (v.owner != null) 
                pks = pks.concat(v.owner);
        if (readers != null) 
            if (v.reader != null) 
                pks = pks.concat(v.reader);
        new EcAsyncHelper().each(pks, function(pk, callback0) {
            var eSecret = new EbacEncryptedSecret();
            eSecret.id = forge.util.encode64(forge.pkcs5.pbkdf2(id, "", 1, 8));
            eSecret.iv = newIv;
            eSecret.secret = newSecret;
            if (v.secret == null) {
                v.secret = new Array();
            }
            EcRsaOaepAsync.encrypt(EcPk.fromPem(pk), eSecret.toEncryptableJson(), function(s) {
                v.secret.push(s);
                callback0();
            }, callback0);
        }, function(pks) {
            success(v);
        });
    };
    /**
     *  Encrypt a value with a specific IV and secret
     * 
     *  @param {String}   iv Initialization Vector for encryption
     *  @param {String}   secret Encryption secret
     *  @param {String}   text Text to encrypt
     *  @param {String}   id ID of value to encrypt
     *  @param {String[]} owners Owners keys to encrypt with
     *  @param {String[]} readers Reader Keys to encrypt with
     *  @return {EcEncryptedValue}
     *  @memberOf EcEncryptedValue
     *  @method encryptValueUsingIvAndSecret
     *  @static
     */
    constructor.encryptValueUsingIvAndSecret = function(iv, secret, text, id, owners, readers) {
        var v = new EcEncryptedValue();
        v.payload = EcAesCtr.encrypt(text, secret, iv);
        if (owners != null) {
            for (var i = 0; i < owners.length; i++) {
                v.addOwner(EcPk.fromPem(owners[i]));
            }
        }
        if (owners != null) {
            for (var i = 0; i < v.owner.length; i++) {
                var eSecret = new EbacEncryptedSecret();
                eSecret.id = forge.util.encode64(forge.pkcs5.pbkdf2(id, "", 1, 8));
                eSecret.iv = iv;
                eSecret.secret = secret;
                if (v.secret == null) {
                    v.secret = new Array();
                }
                v.secret.push(EcRsaOaep.encrypt(EcPk.fromPem(v.owner[i]), eSecret.toEncryptableJson()));
            }
        }
        if (readers != null) {
            for (var i = 0; i < readers.length; i++) {
                v.addReader(EcPk.fromPem(readers[i]));
            }
        }
        return v;
    };
    /**
     *  Setter and getter function for encryptOnSave of an identifier,
     *  encryptOnSave is used by the static save functions of a class to
     *  determine whether or not to encrypt something when it is saved. This
     *  value is usually set when an object is decrypted using one of the decrypt
     *  functions above.
     * 
     *  @param {String}  id ID of the data to get/set encryptOnSave for
     *  @param {boolean} [val] If passed in, sets the value, if null this
     *                   function gets the encryptOnSave value
     *  @return {boolean} if val is null/ignored returns value in the map, if val
     *  is passed in returns val
     *  @memberOf EcEncryptedValue
     *  @method encryptOnSave
     *  @static
     */
    constructor.encryptOnSave = function(id, val) {
        if (EcEncryptedValue.encryptOnSaveMap == null) {
            EcEncryptedValue.encryptOnSaveMap = {};
        }
        if (val == null) {
            if (EcEncryptedValue.encryptOnSaveMap[id] != null) {
                return EcEncryptedValue.encryptOnSaveMap[id];
            } else {
                return false;
            }
        } else {
            EcEncryptedValue.encryptOnSaveMap[id] = val;
            return val;
        }
    };
    /**
     *  Decrypts this encrypted value into an object
     * 
     *  @return The Decrypted Object
     *  @memberOf EcEncryptedValue
     *  @method decryptIntoObject
     */
    prototype.decryptIntoObject = function() {
        var decryptRaw = this.decryptIntoString();
        if (decryptRaw == null) {
            return null;
        }
        if (!EcLinkedData.isProbablyJson(decryptRaw)) {
            return null;
        }
        var decrypted = new EcRemoteLinkedData("", "");
        decrypted.copyFrom(JSON.parse(decryptRaw));
        EcEncryptedValue.encryptOnSave(decrypted.id, true);
        decrypted.id = this.id;
        return decrypted.deAtify();
    };
    /**
     *  Asynchronously decrypts this encrypted value into an object
     * 
     *  @param {Callback1<EcRemoteLinkedDat>} success Callback triggered on
     *                                        successful encryption, returns the decrypted object
     *  @param {Callback1<String>}            failure Callback triggered if error during
     *                                        encryption
     *  @memberOf EcEncryptedValue
     *  @method decryptIntoObjectAsync
     */
    prototype.decryptIntoObjectAsync = function(success, failure) {
        var id = this.id;
        this.decryptIntoStringAsync(function(decryptRaw) {
            if (decryptRaw == null) {
                failure("Could not decrypt data.");
            }
            if (!EcLinkedData.isProbablyJson(decryptRaw)) {
                failure("Could not decrypt data.");
            }
            var decrypted = new EcRemoteLinkedData("", "");
            decrypted.copyFrom(JSON.parse(decryptRaw));
            EcEncryptedValue.encryptOnSave(decrypted.id, true);
            decrypted.id = id;
            success(decrypted.deAtify());
        }, failure);
    };
    /**
     *  Asynchronously decrypts this encrypted value into an object with a IV and
     *  secret provided
     * 
     *  @param {String}                        iv Initialization Vector for decryption
     *  @param {String}                        secret Secret for decryption
     *  @param {Callback1<EcRemoteLinkedData>} success Callback triggered after
     *                                         successful decryption
     *  @param {Callback1<String>}             failure Callback triggered if error during
     *                                         decryption
     *  @memberOf EcEncryptedValue
     *  @method decryptIntoObjectUsingIvAndSecretAsync
     */
    prototype.decryptIntoObjectUsingIvAndSecretAsync = function(iv, secret, success, failure) {
        this.decryptIntoStringUsingIvAndSecretAsync(iv, secret, function(decryptRaw) {
            if (decryptRaw == null) {
                failure("Could not decrypt data.");
            }
            if (!EcLinkedData.isProbablyJson(decryptRaw)) {
                failure("Could not decrypt data.");
            }
            var decrypted = new EcRemoteLinkedData("", "");
            decrypted.copyFrom(JSON.parse(decryptRaw));
            EcEncryptedValue.encryptOnSave(decrypted.id, true);
            success(decrypted.deAtify());
        }, failure);
    };
    /**
     *  Decrypts an encrypted value into a string
     * 
     *  @return {String} Decrypted string value
     *  @memberOf EcEncryptedValue
     *  @method decryptIntoString
     */
    prototype.decryptIntoString = function() {
        var decryptSecret = this.decryptSecret();
        if (decryptSecret != null) {
            return EcAesCtr.decrypt(this.payload, decryptSecret.secret, decryptSecret.iv);
        }
        return null;
    };
    /**
     *  Decrypts an encrypted value into a string using an alternative secret.
     * 
     *  @return {String} Decrypted string value
     *  @memberOf EcEncryptedValue
     *  @method decryptIntoString
     */
    prototype.decryptIntoStringUsingSecret = function(decryptSecret) {
        if (decryptSecret != null) {
            return EcAesCtr.decrypt(this.payload, decryptSecret.secret, decryptSecret.iv);
        }
        return null;
    };
    /**
     *  Asynchronously decrypts an encrypted value into a string
     * 
     *  @param {Callback1<String>} success Callback triggered after successfully
     *                             decrypted, returns decrypted string
     *  @param {Callback1<String>} failure Callback triggered if error during
     *                             decryption
     *  @memberOf EcEncryptedValue
     *  @method decryptIntoStringAsync
     */
    prototype.decryptIntoStringAsync = function(success, failure) {
        var me = this;
        this.decryptSecretAsync(function(decryptSecret) {
            if (decryptSecret != null) {
                if (me.context == Ebac.context_0_2 || me.context == Ebac.context_0_3) {
                    if (base64.decode(decryptSecret.iv).byteLength == 32) 
                        decryptSecret.iv = base64.encode(base64.decode(decryptSecret.iv).slice(0, 16));
                }
                EcAesCtrAsync.decrypt(me.payload, decryptSecret.secret, decryptSecret.iv, success, failure);
            }
        }, failure);
    };
    /**
     *  Asynchronously decrypts an encrypted value into a string
     * 
     *  @param {Callback1<String>} success Callback triggered after successfully
     *                             decrypted, returns decrypted string
     *  @param {Callback1<String>} failure Callback triggered if error during
     *                             decryption
     *  @memberOf EcEncryptedValue
     *  @method decryptIntoStringAsync
     */
    prototype.decryptIntoStringUsingSecretAsync = function(decryptSecret, success, failure) {
        var me = this;
        if (decryptSecret != null) {
            if (me.context == Ebac.context_0_2 || me.context == Ebac.context_0_3) {
                if (base64.decode(decryptSecret.iv).byteLength == 32) 
                    decryptSecret.iv = base64.encode(base64.decode(decryptSecret.iv).slice(0, 16));
            }
            EcAesCtrAsync.decrypt(me.payload, decryptSecret.secret, decryptSecret.iv, success, failure);
        }
    };
    /**
     *  Asynchronously decrypts an encrypted value into a string with an IV and
     *  secrete provided
     * 
     *  @param {String}            iv Initialization Vector for decryption
     *  @param {String}            secret Secret for decryption
     *  @param {Callback1<String>} success Callback triggered on successful
     *                             decryption
     *  @param {Callback1<String>} failure Callback triggered if error during
     *                             decryption
     *  @memberOf EcEncryptedValue
     *  @method decryptIntoStringUsingIvAndSecretAsync
     */
    prototype.decryptIntoStringUsingIvAndSecretAsync = function(iv, secret, success, failure) {
        if (this.context == Ebac.context_0_2 || this.context == Ebac.context_0_3) {
            if (base64.decode(iv).byteLength == 32) 
                iv = base64.encode(base64.decode(iv).slice(0, 16));
        }
        EcAesCtrAsync.decrypt(this.payload, secret, iv, success, failure);
    };
    /**
     *  Attempts to decrypt the secret by using all Identities in the Identity
     *  Manager
     * 
     *  @return {EbacEncryptedSecret} Secret after decrypted
     *  @memberOf EcEncryptedValue
     *  @method decryptSecret
     */
    prototype.decryptSecret = function() {
        var candidateIndex = 0;
        if (this.owner != null) {
            for (var i = 0; i < this.owner.length; i++) {
                var decryptionKey = EcIdentityManager.getPpk(EcPk.fromPem(this.owner[i]));
                if (decryptionKey == null) {
                    candidateIndex++;
                    continue;
                }
                var decrypted = this.decryptSecretByKey(decryptionKey, candidateIndex);
                if (decrypted != null) {
                    return decrypted;
                }
            }
        }
        if (this.reader != null) {
            for (var i = 0; i < this.reader.length; i++) {
                var decryptionKey = EcIdentityManager.getPpk(EcPk.fromPem(this.reader[i]));
                if (decryptionKey == null) {
                    candidateIndex++;
                    continue;
                }
                var decrypted = this.decryptSecretByKey(decryptionKey, candidateIndex);
                if (decrypted != null) {
                    return decrypted;
                }
            }
        }
        for (var i = 0; i < EcIdentityManager.ids.length; i++) {
            var decryptionKey = EcIdentityManager.ids[i].ppk;
            var decrypted = this.decryptSecretByKey(decryptionKey, -1);
            if (decrypted != null) {
                return decrypted;
            }
        }
        return null;
    };
    /**
     *  Attempts to decrypt secret with a specific key
     * 
     *  @param {EcPpk} decryptionKey Key to attempt secret decryption
     *  @return {EbacEncryptedSecret} Decrypted Secret
     *  @memberOf EcEncryptedValue
     *  @method decryptSecretByKey
     */
    prototype.decryptSecretByKey = function(decryptionKey, tryThisIndexFirst) {
        var encryptedSecret = null;
        if (this.secret != null) {
            if (tryThisIndexFirst >= 0) 
                try {
                    encryptedSecret = this.tryDecryptSecretByKeyAndIndex(decryptionKey, tryThisIndexFirst);
                    if (encryptedSecret != null) 
                        return encryptedSecret;
                }catch (ex) {}
            for (var j = 0; j < this.secret.length; j++) {
                if (tryThisIndexFirst < 0 || j != tryThisIndexFirst) 
                    try {
                        encryptedSecret = this.tryDecryptSecretByKeyAndIndex(decryptionKey, j);
                    }catch (ex) {}
                if (encryptedSecret != null) 
                    return encryptedSecret;
            }
        }
        return null;
    };
    /**
     *  Asynchronously attempts to decrypt secret using all identities in
     *  Identity Manager
     * 
     *  @param {Callback1<EbacEncryptedSecret>} success Callback triggered after
     *                                          successfully decrypting secret, returns the decrypted secret
     *  @param {Callback1<String>}              failure Callback triggered if error decrypting
     *                                          secret
     *  @memberOf EcEncryptedValue
     *  @method decryptSecretAsync
     */
    prototype.decryptSecretAsync = function(success, failure) {
        var ppks = new Array();
        var estimatedIndices = new Array();
        if (this.owner != null) {
            for (var i = 0; i < this.owner.length; i++) {
                var decryptionKey = EcIdentityManager.getPpk(EcPk.fromPem(this.owner[i]));
                if (decryptionKey != null) {
                    if (!decryptionKey.inArray(ppks)) {
                        ppks.push(decryptionKey);
                        estimatedIndices.push(i);
                    }
                }
            }
        }
        if (this.reader != null) {
            for (var i = 0; i < this.reader.length; i++) {
                var decryptionKey = EcIdentityManager.getPpk(EcPk.fromPem(this.reader[i]));
                if (decryptionKey != null) {
                    if (!decryptionKey.inArray(ppks)) {
                        ppks.push(decryptionKey);
                        estimatedIndices.push(i + this.owner.length);
                    }
                }
            }
        }
        var me = this;
        var helper = new EcAsyncHelper();
        helper.each(ppks, function(decryptionKey, countdown) {
            var estimatedIndex = -1;
            for (var i = 0; i < ppks.length; i++) 
                if (ppks[i].equals(decryptionKey)) 
                    estimatedIndex = estimatedIndices[i];
            me.decryptSecretByKeyAsync(decryptionKey, estimatedIndex, function(p1) {
                if (helper.counter == -1) {
                    countdown();
                    return;
                }
                helper.stop();
                success(p1);
                countdown();
            }, function(arg0) {
                countdown();
            });
        }, function(arg0) {
            failure("Could not decrypt secret.");
        });
    };
    prototype.tryDecryptSecretByKeyAndIndex = function(decryptionKey, j) {
        var decryptedSecret = null;
        decryptedSecret = EcRsaOaep.decrypt(decryptionKey, this.secret[j]);
        if (EcLinkedData.isProbablyJson(decryptedSecret)) {
            var encryptedSecret = EbacEncryptedSecret.fromEncryptableJson(JSON.parse(decryptedSecret));
            return encryptedSecret;
        }
        return null;
    };
    /**
     *  Asynchronously attempts to decrypt secret with a specific key
     * 
     *  @param {EcPpk}                          decryptionKey Key to attempt secret decryption
     *  @param {Callback1<EbacEncryptedSecret>} success Callback triggered after
     *                                          successful decryption of secret, returns decrypted secret
     *  @param {Callback1<String>}              failure Callback triggered if error during
     *                                          secret decryption
     *  @memberOf EcEncryptedValue
     *  @method decryptSecretByKeyAsync
     */
    prototype.decryptSecretByKeyAsync = function(decryptionKey, estimatedIndex, success, failure) {
        var encryptedSecret = null;
        var me = this;
        if (this.secret != null) {
            if (estimatedIndex < 0 || estimatedIndex >= this.secret.length) {
                this.decryptSecretsByKeyAsync(decryptionKey, success, failure);
            } else {
                EcRsaOaepAsync.decrypt(decryptionKey, this.secret[estimatedIndex], function(decryptedSecret) {
                    if (!EcLinkedData.isProbablyJson(decryptedSecret)) {
                        me.decryptSecretsByKeyAsync(decryptionKey, success, failure);
                    } else {
                        success(EbacEncryptedSecret.fromEncryptableJson(JSON.parse(decryptedSecret)));
                    }
                }, function(arg0) {
                    me.decryptSecretsByKeyAsync(decryptionKey, success, failure);
                });
            }
        } else 
            failure("Secret field is empty.");
    };
    prototype.decryptSecretsByKeyAsync = function(decryptionKey, success, failure) {
        var helper = new EcAsyncHelper();
        helper.each(this.secret, function(decryptionSecret, decrement) {
            EcRsaOaepAsync.decrypt(decryptionKey, decryptionSecret, function(decryptedSecret) {
                if (helper.counter == -1) {
                    return;
                }
                if (!EcLinkedData.isProbablyJson(decryptedSecret)) {
                    decrement();
                } else {
                    helper.stop();
                    success(EbacEncryptedSecret.fromEncryptableJson(JSON.parse(decryptedSecret)));
                }
            }, function(arg0) {
                decrement();
            });
        }, function(arg0) {
            failure("Could not find decryption key.");
        });
    };
    /**
     *  Checks if this encrypted value is an encrypted version of a specific
     *  type, only works if the type wasn't hidden during encryption
     * 
     *  @param {String} type Type to compare if an encrypted type
     *  @return {boolean} True if encrypted version of type, false if not or
     *  can't tell
     *  @memberOf EcEncryptedValue
     *  @method isAnEncrypted
     */
    prototype.isAnEncrypted = function(type) {
        if (this.encryptedType == null) {
            return false;
        }
        var typeSplit = (type.split("/"));
        return this.encryptedType == type || this.encryptedType == typeSplit[typeSplit.length - 1];
    };
    /**
     *  Adds a reader to the object, if the reader does not exist.
     * 
     *  @param {EcPk} newReader PK of the new reader.
     *  @memberOf EcEncryptedValue
     *  @method addReader
     */
    prototype.addReader = function(newReader) {
        this.addReaderBasic(newReader);
        var payloadSecret = this.decryptSecret();
        if (payloadSecret == null) {
            console.error("Cannot add a Reader if you don't know the secret");
            return;
        }
        EcArray.setAdd(this.secret, EcRsaOaep.encrypt(newReader, payloadSecret.toEncryptableJson()));
    };
    /**
     *  Adds a reader to the object, if the reader does not exist.
     * 
     *  @param {EcPk} newReader PK of the new reader.
     *  @memberOf EcEncryptedValue
     *  @method addReader
     */
    prototype.addReaderBasic = function(newReader) {
        var pem = newReader.toPem();
        if (this.reader == null) {
            this.reader = new Array();
        }
        if (EcArray.has(this.reader, pem)) 
            return;
        if (this.owner != null) 
            if (EcArray.has(this.owner, pem)) 
                return;
        EcArray.setAdd(this.reader, pem);
    };
    /**
     *  Removes a reader from the object, if the reader does exist.
     * 
     *  @param {EcPk} oldReader PK of the old reader.
     *  @memberOf EcEncryptedValue
     *  @method removeReader
     */
    prototype.removeReader = function(oldReader) {
        var payloadSecret = this.decryptSecret();
        var pem = oldReader.toPem();
        if (this.reader != null) {
            EcArray.setRemove(this.reader, pem);
        }
        if (payloadSecret == null) {
            console.error("Cannot remove a Reader if you don't know the secret");
            return;
        }
        this.secret = new Array();
        if (this.owner != null) 
            for (var i = 0; i < this.owner.length; i++) 
                EcArray.setAdd(this.secret, EcRsaOaep.encrypt(EcPk.fromPem(this.owner[i]), payloadSecret.toEncryptableJson()));
        if (this.reader != null) 
            for (var i = 0; i < this.reader.length; i++) 
                EcArray.setAdd(this.secret, EcRsaOaep.encrypt(EcPk.fromPem(this.reader[i]), payloadSecret.toEncryptableJson()));
    };
    /**
     *  Adds a reader to the object, if the reader does not exist.
     * 
     *  @param {EcPk}              newReader PK of the new reader.
     *  @param {Callback0}         success   Callback triggered after successful encryption
     *  @param {Callback1<String>} failure Callback triggered if error during secret decryption
     *  @memberOf EcEncryptedValue
     *  @method addReaderAsync
     */
    prototype.addReaderAsync = function(newReader, success, failure) {
        var me = this;
        this.decryptSecretAsync(function(payloadSecret) {
            EcRsaOaepAsync.encrypt(newReader, payloadSecret.toEncryptableJson(), function(s) {
                var pem = newReader.toPem();
                if (me.reader == null) {
                    me.reader = new Array();
                }
                for (var i = 0; i < me.reader.length; i++) {
                    if (me.reader[i] == pem) {
                        success();
                        return;
                    }
                }
                EcArray.setAdd(me.reader, pem);
                EcArray.setAdd(me.secret, s);
                success();
            }, failure);
        }, failure);
    };
    /**
     *  Removes a reader from the object, if the reader does exist.
     * 
     *  @param {EcPk}              oldReader PK of the old reader.
     *  @param {Callback0}         success   Callback triggered after successful encryption
     *  @param {Callback1<String>} failure Callback triggered if error during secret decryption
     *  @memberOf EcEncryptedValue
     *  @method removeReaderAsync
     */
    prototype.removeReaderAsync = function(oldReader, success, failure) {
        var me = this;
        this.decryptSecretAsync(function(payloadSecret) {
            var pem = oldReader.toPem();
            if (me.reader != null) {
                EcArray.setRemove(me.reader, pem);
            }
            var ary = new Array();
            if (me.owner != null) 
                for (var i = 0; i < me.owner.length; i++) 
                    EcArray.setAdd(ary, EcPk.fromPem(me.owner[i]));
            if (me.reader != null) 
                for (var i = 0; i < me.reader.length; i++) 
                    EcArray.setAdd(ary, EcPk.fromPem(me.reader[i]));
            me.secret = new Array();
            var eah = new EcAsyncHelper();
            eah.each(ary, function(ecPk, callback0) {
                EcRsaOaepAsync.encrypt(oldReader, payloadSecret.toEncryptableJson(), function(secret) {
                    EcArray.setRemove(me.secret, secret);
                    callback0();
                }, failure);
            }, function(strings) {
                success();
            });
        }, failure);
    };
}, {encryptOnSaveMap: {name: "Map", arguments: [null, null]}, secret: {name: "Array", arguments: [null]}, owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  A representation of a file.
 * 
 *  @author fritz.ray@eduworks.com
 *  @module com.eduworks.ec
 *  @class GeneralFile
 *  @extends EcRemoteLinkedData
 *  @constructor
 */
var GeneralFile = function() {
    EcRemoteLinkedData.call(this, General.context, GeneralFile.myType);
};
GeneralFile = stjs.extend(GeneralFile, EcRemoteLinkedData, [], function(constructor, prototype) {
    constructor.TYPE_0_1 = "http://schema.eduworks.com/general/0.1/file";
    constructor.TYPE_0_2 = "http://schema.eduworks.com/general/0.2/file";
    constructor.myType = GeneralFile.TYPE_0_2;
    /**
     *  Optional checksum of the file, used to verify if the file has been
     *  transmitted correctly.
     * 
     *  @property checksum
     *  @type String
     */
    prototype.checksum = null;
    /**
     *  Mime type of the file.
     * 
     *  @property mimeType
     *  @type String
     */
    prototype.mimeType = null;
    /**
     *  Base-64 encoded version of the bytestream of a file.
     * 
     *  @property data
     *  @type String
     */
    prototype.data = null;
    /**
     *  Name of the file, used to distinguish it
     * 
     *  @property name
     *  @type String
     */
    prototype.name = null;
    /**
     *  Helper method to force the browser to download the file.
     * 
     *  @memberOf GeneralFile
     *  @method download
     */
    prototype.download = function() {
        var blob = base64ToBlob(this.data, this.mimeType);
        saveAs(blob, this.name);
    };
    prototype.upgrade = function() {
        EcRemoteLinkedData.prototype.upgrade.call(this);
        if (GeneralFile.TYPE_0_1.equals(this.type)) {
            var me = (this);
            if (me["@context"] == null && me["@schema"] != null) 
                me["@context"] = me["@schema"];
            this.setContextAndType(General.context_0_2, GeneralFile.TYPE_0_2);
        }
    };
    prototype.getTypes = function() {
        var a = new Array();
        a.push(GeneralFile.TYPE_0_2);
        a.push(GeneralFile.TYPE_0_1);
        return a;
    };
}, {owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Repository object used to interact with the CASS Repository web services.
 *  Should be used for all CRUD and search operations
 * 
 *  @author fritz.ray@eduworks.com
 *  @module com.eduworks.ec
 *  @class EcRepository
 */
var EcRepository = function() {
    EcRepository.repos.push(this);
};
EcRepository = stjs.extend(EcRepository, null, [], function(constructor, prototype) {
    constructor.caching = false;
    constructor.cachingSearch = false;
    constructor.unsigned = false;
    constructor.alwaysTryUrl = false;
    constructor.cache = new Object();
    constructor.fetching = new Object();
    constructor.repos = new Array();
    prototype.adminKeys = null;
    prototype.selectedServer = null;
    prototype.autoDetectFound = false;
    prototype.timeOffset = 0;
    prototype.init = function(selectedServer, success, failure) {
        this.selectedServer = selectedServer;
        this.negotiateTimeOffset(success, failure);
    };
    prototype.negotiateTimeOffset = function(success, failure) {
        var oldTimeout = EcRemote.timeout;
        EcRemote.timeout = 500;
        var me = this;
        var successCheck = function(p1) {
            if (p1 != null) {
                if ((p1)["ping"] == "pong") {
                    if ((p1)["time"] != null) 
                        me.timeOffset = (((p1)["time"] - new Date().getTime()));
                    me.buildKeyForwardingTable(success, failure);
                }
            }
        };
        var failureCheck = function(p1) {
            if (p1 != null) {
                if (p1 != "") {
                    try {
                        if (p1.indexOf("pong") != -1) 
                            if ((p1)["time"] != null) 
                                me.timeOffset = (new Date().getTime()) - ((p1)["time"]);
                        me.buildKeyForwardingTable(success, failure);
                    }catch (ex) {
                        if (failure != null) 
                            failure(ex);
                    }
                }
            }
        };
        try {
            EcRemote.getExpectingObject(this.selectedServer, "ping", successCheck, failureCheck);
        }catch (ex) {
            if (failure != null) 
                failure(ex.toString());
        }
        EcRemote.timeout = oldTimeout;
    };
    prototype.buildKeyForwardingTable = function(success, failure) {
        var params = new Object();
        (params)["size"] = 10000;
        EcRepository.searchAs(this, "*", function() {
            return new EcRekeyRequest();
        }, function(array) {
            var rekeyRequests = array;
            for (var i = 0; i < rekeyRequests.length; i++) {
                rekeyRequests[i].addRekeyRequestToForwardingTable();
            }
            if (success != null) 
                success();
        }, failure, params);
    };
    /**
     *  Gets a JSON-LD object from the place designated by the URI.
     *  <p>
     *  Uses a signature sheet gathered from {@link EcIdentityManager}.
     * 
     *  @param {String}                               url URL of the remote object.
     *  @param {Callback1<EcRemoteLinkedData>}success Event to call upon
     *                                                successful retrieval.
     *  @param {Callback1<String>}                    failure Event to call upon spectacular
     *                                                failure.
     *  @memberOf EcRepository
     *  @method get
     *  @static
     */
    constructor.get = function(url, success, failure) {
        if (url == null) {
            failure("URL is null. Cannot EcRepository.get");
            return;
        }
        if (url.toLowerCase().indexOf("http") != 0) {
            failure("URL does not begin with http. Cannot EcRepository.get");
            return;
        }
        var originalUrl = url;
        if (EcRemote.async == false) {
            var result = EcRepository.getBlocking(url);
            if (result == null) {
                if (failure != null) 
                    failure("Could not locate object. May be due to EcRepository.alwaysTryUrl flag.");
            } else if (success != null) 
                success(result);
            return;
        }
        if (EcRepository.caching) {
            if ((EcRepository.cache)[url] != null) {
                if (EcRemote.async) {
                    Task.immediate(function() {
                        success((EcRepository.cache)[originalUrl]);
                    });
                } else {
                    success((EcRepository.cache)[url]);
                }
                return;
            }
            if (EcRemote.async) {
                if ((EcRepository.fetching)[url] != null) {
                    if ((EcRepository.fetching)[url] > new Date().getTime()) {
                        setTimeout(function() {
                            EcRepository.get(originalUrl, success, failure);
                        }, 100);
                        return;
                    }
                }
                (EcRepository.fetching)[url] = new Date().getTime() + 60000;
            }
        }
        if (!EcRepository.shouldTryUrl(url)) {
            if (EcRepository.repos.length == 1) {
                if (!url.startsWith(EcRepository.repos[0].selectedServer)) 
                    url = EcRemoteLinkedData.veryShortId(EcRepository.repos[0].selectedServer, EcCrypto.md5(url));
            } else {
                EcRepository.find(url, "Could not locate object. May be due to EcRepository.alwaysTryUrl flag.", new Object(), 0, success, failure);
                return;
            }
        }
        var fd = new FormData();
        var finalUrl = url;
        if (EcRepository.unsigned) {
            EcRemote.getExpectingObject(finalUrl, null, function(p1) {
                EcRepository.getHandleData(p1, originalUrl, success, failure, finalUrl);
            }, function(p1) {
                EcRepository.find(originalUrl, p1, new Object(), 0, success, failure);
            });
        } else {
            var offset = EcRepository.setOffset(url);
            EcIdentityManager.signatureSheetAsync(60000 + offset, url, function(p1) {
                if ((EcRepository.cache)[originalUrl] != null) {
                    delete (EcRepository.fetching)[originalUrl];
                    success((EcRepository.cache)[originalUrl]);
                    return;
                }
                fd.append("signatureSheet", p1);
                EcRemote.postExpectingObject(finalUrl, null, fd, function(p1) {
                    EcRepository.getHandleData(p1, originalUrl, success, failure, finalUrl);
                }, function(p1) {
                    EcRepository.find(originalUrl, p1, new Object(), 0, success, failure);
                });
            }, failure);
        }
    };
    constructor.setOffset = function(url) {
        var offset = 0;
        for (var i = 0; i < EcRepository.repos.length; i++) {
            if (url.indexOf(EcRepository.repos[i].selectedServer) != -1) {
                offset = EcRepository.repos[i].timeOffset;
            }
        }
        return offset;
    };
    constructor.getHandleData = function(p1, originalUrl, success, failure, finalUrl) {
        delete (EcRepository.fetching)[originalUrl];
        var d = new EcRemoteLinkedData("", "");
        d.copyFrom(p1);
        if (d.getFullType() == null) {
            EcRepository.find(originalUrl, JSON.stringify(p1), new Object(), 0, success, failure);
            return;
        }
        if (EcRepository.caching) {
            (EcRepository.cache)[finalUrl] = d;
            if (d.id != null) 
                (EcRepository.cache)[d.id] = d;
        }
        success(d);
    };
    constructor.shouldTryUrl = function(url) {
        if (url == null) 
            return false;
        if (EcRepository.alwaysTryUrl) 
            return true;
        if (EcRepository.repos.length == 0) 
            return true;
        var validUrlFound = false;
        for (var i = 0; i < EcRepository.repos.length; i++) {
            if (EcRepository.repos[i].selectedServer == null) 
                continue;
            validUrlFound = true;
        }
        if (!validUrlFound) 
            return true;
        return false;
    };
    constructor.find = function(url, error, history, i, success, failure) {
        if (isNaN(i) || i == undefined || i > EcRepository.repos.length || EcRepository.repos[i] == null) {
            delete (EcRepository.fetching)[url];
            if (failure != null) 
                failure(error);
            return;
        }
        var repo = EcRepository.repos[i];
        if (repo.selectedServer == null) {
            EcRepository.find(url, error, history, i + 1, success, failure);
            return;
        }
        if (((history)[repo.selectedServer]) == true) {
            EcRepository.find(url, error, history, i + 1, success, failure);
            return;
        }
        (history)[repo.selectedServer] = true;
        repo.search("@id:\"" + url + "\"", null, function(strings) {
            if (strings == null || strings.length == 0) 
                EcRepository.find(url, error, history, i + 1, success, failure);
             else {
                var done = false;
                for (var i = 0; i < strings.length; i++) {
                    if (strings[i].id == url || strings[i].shortId() == url) {
                        if (done) 
                            log("Searching for exact ID:" + url + ", found more than one@:" + repo.selectedServer);
                        done = true;
                        delete (EcRepository.fetching)[url];
                        if (EcRepository.caching) {
                            (EcRepository.cache)[url] = strings[i];
                        }
                        success(strings[i]);
                    }
                }
                if (done) 
                    return;
                EcRepository.find(url, error, history, i + 1, success, failure);
            }
        }, function(s) {
            EcRepository.find(url, s, history, i + 1, success, failure);
        });
    };
    constructor.findBlocking = function(url, error, history, i) {
        if (i > EcRepository.repos.length || EcRepository.repos[i] == null) {
            delete (EcRepository.fetching)[url];
            return null;
        }
        var repo = EcRepository.repos[i];
        if (repo.selectedServer == null) {
            return EcRepository.findBlocking(url, error, history, i + 1);
        }
        if (((history)[repo.selectedServer]) == true) 
            EcRepository.findBlocking(url, error, history, i + 1);
        (history)[repo.selectedServer] = true;
        var strings = repo.searchBlocking("@id:\"" + url + "\"");
        if (strings == null || strings.length == 0) 
            return EcRepository.findBlocking(url, error, history, i + 1);
         else {
            for (var j = 0; j < strings.length; j++) {
                if (strings[j].id == url || strings[j].shortId() == url) {
                    delete (EcRepository.fetching)[url];
                    if (EcRepository.caching) {
                        (EcRepository.cache)[url] = strings[j];
                    }
                    return strings[j];
                }
            }
        }
        return EcRepository.findBlocking(url, error, history, i + 1);
    };
    /**
     *  Retrieves a piece of data synchronously from the server, blocking until
     *  it is returned
     * 
     *  @param {String} url URL ID of the data to be retrieved
     *  @return {EcRemoteLinkedData} Data retrieved, corresponding to the ID
     *  @memberOf EcRepository
     *  @method getBlocking
     *  @static
     */
    constructor.getBlocking = function(url) {
        if (url.toLowerCase().indexOf("http") != 0) {
            return null;
        }
        var originalUrl = url;
        if (originalUrl == null) 
            return null;
        if (EcRepository.caching) {
            if ((EcRepository.cache)[originalUrl] != null) {
                return (EcRepository.cache)[originalUrl];
            }
        }
        if (!EcRepository.shouldTryUrl(originalUrl)) {
            if (EcRepository.repos.length == 1) {
                if (!url.startsWith(EcRepository.repos[0].selectedServer)) {
                    url = EcRemoteLinkedData.veryShortId(EcRepository.repos[0].selectedServer, EcCrypto.md5(url));
                }
            } else {
                return EcRepository.findBlocking(originalUrl, "Could not locate object. May be due to EcRepository.alwaysTryUrl flag.", new Object(), 0);
            }
        }
        var fd = new FormData();
        var p1 = null;
        if (EcRepository.unsigned == false) {
            var offset = EcRepository.setOffset(url);
            p1 = EcIdentityManager.signatureSheet(60000 + offset, originalUrl);
            fd.append("signatureSheet", p1);
        }
        var oldAsync = EcRemote.async;
        EcRemote.async = false;
        var finalUrl = url;
        EcRemote.postExpectingObject(finalUrl, null, fd, function(p1) {
            var d = new EcRemoteLinkedData("", "");
            d.copyFrom(p1);
            if (d.getFullType() == null) {
                EcRepository.findBlocking(originalUrl, JSON.stringify(p1), new Object(), 0);
                return;
            }
            (EcRepository.cache)[originalUrl] = d;
            if (d != null) {
                if (d.id != null) 
                    (EcRepository.cache)[d.id] = d;
            }
        }, function(s) {
            var d = EcRepository.findBlocking(originalUrl, s, new Object(), 0);
            (EcRepository.cache)[originalUrl] = d;
            if (d != null) {
                if (d.id != null) 
                    (EcRepository.cache)[d.id] = d;
            }
        });
        EcRemote.async = oldAsync;
        var result = (EcRepository.cache)[originalUrl];
        if (!EcRepository.caching) {
            delete (EcRepository.cache)[originalUrl];
        }
        return result;
    };
    /**
     *  Escapes a search query
     * 
     *  @param {String} query Query string to escape
     *  @return {String} Escaped query string
     *  @memberOf EcRepository
     *  @method escapeSearch
     *  @static
     */
    constructor.escapeSearch = function(query) {
        var s = null;
        s = (query.split("\\")).join("\\\\");
        s = (s.split("-")).join("\\-");
        s = (s.split("=")).join("\\=");
        s = (s.split("&&")).join("\\&&");
        s = (s.split("||")).join("\\||");
        s = (s.split("<")).join("\\<");
        s = (s.split(">")).join("\\>");
        s = (s.split("|")).join("\\|");
        s = (s.split("(")).join("\\(");
        s = (s.split(")")).join("\\)");
        s = (s.split("{")).join("\\{");
        s = (s.split("}")).join("\\}");
        s = (s.split("[")).join("\\[");
        s = (s.split("]")).join("\\]");
        s = (s.split("^")).join("\\^");
        s = (s.split("\"")).join("\\\"");
        s = (s.split("~")).join("\\~");
        s = (s.split("*")).join("\\*");
        s = (s.split("?")).join("\\?");
        s = (s.split(":")).join("\\:");
        s = (s.split("/")).join("\\/");
        s = (s.split("+")).join("\\+");
        return s;
    };
    /**
     *  Attempts to save a piece of data.
     *  <p>
     *  Uses a signature sheet informed by the owner field of the data.
     * 
     *  @param {EcRemoteLinkedData} data Data to save to the location designated
     *                              by its id.
     *  @param {Callback1<String>}  success Callback triggered on successful save
     *  @param {Callback1<String>}  failure Callback triggered if error during
     *                              save
     *  @memberOf EcRepository
     *  @method save
     *  @static
     */
    constructor.save = function(data, success, failure) {
        EcRepository._save(data, success, failure, null);
    };
    /**
     *  Attempts to save a piece of data. If the @id of the data is not of this server, will register the data to the server.
     *  <p>
     *  Uses a signature sheet informed by the owner field of the data.
     * 
     *  @param {EcRemoteLinkedData} data Data to save to the location designated
     *                              by its id.
     *  @param {Callback1<String>}  success Callback triggered on successful save
     *  @param {Callback1<String>}  failure Callback triggered if error during
     *                              save
     *  @memberOf EcRepository
     *  @method save
     *  @static
     */
    prototype.saveTo = function(data, success, failure) {
        EcRepository._save(data, success, failure, this);
    };
    /**
     *  Attempts to save a piece of data. Does some checks before saving to
     *  ensure the data is valid. This version does not send a console warning,
     *  <p>
     *  Uses a signature sheet informed by the owner field of the data.
     * 
     *  @param {EcRemoteLinkedData} data Data to save to the location designated
     *                              by its id.
     *  @param {Callback1<String>}  success Callback triggered on successful save
     *  @param {Callback1<String>}  failure Callback triggered if error during
     *                              save
     *  @memberOf EcRepository
     *  @method _save
     *  @static
     */
    constructor._save = function(data, success, failure, repo) {
        if (data.invalid()) {
            var msg = "Cannot save data. It is missing a vital component.";
            if (failure != null) {
                failure(msg);
            } else {
                console.error(msg);
            }
            return;
        }
        if (data.reader != null && data.reader.length == 0) {
            delete (data)["reader"];
        }
        if (data.owner != null && data.owner.length == 0) {
            delete (data)["owner"];
        }
        if (EcEncryptedValue.encryptOnSave(data.id, null) && !data.isAny(new EcEncryptedValue().getTypes())) {
            var encrypted = EcEncryptedValue.toEncryptedValue(data, false);
            EcIdentityManager.sign(encrypted);
            EcRepository._saveWithoutSigning(encrypted, success, failure, repo);
        } else {
            EcIdentityManager.sign(data);
            EcRepository._saveWithoutSigning(data, success, failure, repo);
        }
    };
    /**
     *  Attempts to save many pieces of data. Does some checks before saving to
     *  ensure the data is valid. This version does not send a console warning,
     *  <p>
     *  Uses a signature sheet informed by the owner field of the data.
     * 
     *  @param {Array<EcRemoteLinkedData>} data Data to save to the location designated
     *                                     by its id.
     *  @param {Callback1<String>}         success Callback triggered on successful save
     *  @param {Callback1<String>}         failure Callback triggered if error during
     *                                     save
     *  @memberOf EcRepository
     *  @method multiput
     *  @static
     */
    prototype.multiput = function(data, success, failure) {
        var me = this;
        for (var i = 0; i < data.length; i++) {
            var d = data[i];
            if (d.invalid()) {
                var msg = "Cannot save data. It is missing a vital component.";
                if (failure != null) {
                    failure(msg);
                } else {
                    console.error(msg);
                }
                return;
            }
            if (d.reader != null && d.reader.length == 0) {
                delete (d)["reader"];
            }
            if (d.owner != null && d.owner.length == 0) {
                delete (d)["owner"];
            }
        }
        var allOwners = new Array();
        var serialized = new Array();
        for (var i = 0; i < data.length; i++) {
            var d = data[i];
            if (EcEncryptedValue.encryptOnSave(d.id, null) && !d.isAny(new EcEncryptedValue().getTypes())) {
                var encrypted = EcEncryptedValue.toEncryptedValue(d, false);
                EcIdentityManager.sign(encrypted);
                data[i] = encrypted;
                d = encrypted;
            } else {
                EcIdentityManager.sign(d);
            }
            if (EcRepository.caching) {
                delete (EcRepository.cache)[d.id];
                delete (EcRepository.cache)[d.shortId()];
            }
            if (d.invalid()) {
                failure("Data is malformed.");
                return;
            }
            if (EcRepository.alwaysTryUrl || this.constructor.shouldTryUrl(d.id) || d.id.indexOf(this.selectedServer) != -1) 
                d.updateTimestamp();
            if (d.owner != null) 
                for (var j = 0; j < d.owner.length; j++) 
                    EcArray.setAdd(allOwners, d.owner[j]);
            serialized.push(JSON.parse(d.toJson()));
        }
        var fd = new FormData();
        fd.append("data", JSON.stringify(serialized));
        var afterSignatureSheet = function(signatureSheet) {
            fd.append("signatureSheet", signatureSheet);
            EcRemote.postExpectingString(me.selectedServer, "sky/repo/multiPut", fd, success, failure);
        };
        if (EcRemote.async == false) {
            var signatureSheet;
            if (allOwners != null && allOwners.length > 0) {
                signatureSheet = EcIdentityManager.signatureSheetFor(allOwners, 60000 + this.timeOffset, this.selectedServer);
            } else {
                signatureSheet = EcIdentityManager.signatureSheet(60000 + this.timeOffset, this.selectedServer);
            }
            afterSignatureSheet(signatureSheet);
        } else if (allOwners != null && allOwners.length > 0) {
            EcIdentityManager.signatureSheetForAsync(allOwners, 60000 + this.timeOffset, this.selectedServer, afterSignatureSheet, failure);
        } else {
            EcIdentityManager.signatureSheetAsync(60000 + this.timeOffset, this.selectedServer, afterSignatureSheet, failure);
        }
    };
    /**
     *  Attempts to save a piece of data without signing it.
     *  <p>
     *  Uses a signature sheet informed by the owner field of the data.
     * 
     *  @param {EcRemoteLinkedData} data Data to save to the location designated
     *                              by its id.
     *  @param {Callback1<String>}  success Callback triggered on successful save
     *  @param {Callback1<String>}  failure Callback triggered if error during
     *                              save
     *  @memberOf EcRepository
     *  @method _saveWithoutSigning
     *  @static
     */
    constructor._saveWithoutSigning = function(data, success, failure, repo) {
        if (EcRepository.caching) {
            delete (EcRepository.cache)[data.id];
            delete (EcRepository.cache)[data.shortId()];
            if (repo != null) 
                delete (EcRepository.cache)[EcRemoteLinkedData.veryShortId(repo.selectedServer, data.getGuid())];
        }
        if (data.invalid()) {
            failure("Data is malformed.");
            return;
        }
        if (EcRepository.alwaysTryUrl || repo == null || repo.constructor.shouldTryUrl(data.id) || (repo != null && data.id.indexOf(repo.selectedServer) != -1)) 
            data.updateTimestamp();
        var fd = new FormData();
        fd.append("data", data.toJson());
        var afterSignatureSheet = function(signatureSheet) {
            fd.append("signatureSheet", signatureSheet);
            if (!EcRepository.alwaysTryUrl) {
                if (repo != null) {
                    if (data.id.indexOf(repo.selectedServer) != -1) {
                        EcRemote.postExpectingString(data.id, "", fd, success, failure);
                        return;
                    }
                    if (!repo.constructor.shouldTryUrl(data.id) || data.id.indexOf(repo.selectedServer) == -1) {
                        EcRemote.postExpectingString(EcRemote.urlAppend(repo.selectedServer, "data/" + data.getDottedType() + "/" + EcCrypto.md5(data.shortId())), "", fd, success, failure);
                        return;
                    }
                }
            }
            EcRemote.postExpectingString(data.id, "", fd, success, failure);
        };
        var offset = 0;
        if (repo == null) {
            offset = EcRepository.setOffset(data.id);
        } else {
            offset = repo.timeOffset;
        }
        if (EcRemote.async == false) {
            var signatureSheet;
            if (data.owner != null && data.owner.length > 0) {
                signatureSheet = EcIdentityManager.signatureSheetFor(data.owner, 60000 + offset, data.id);
            } else {
                signatureSheet = EcIdentityManager.signatureSheet(60000 + offset, data.id);
            }
            afterSignatureSheet(signatureSheet);
        } else if (data.owner != null && data.owner.length > 0) {
            EcIdentityManager.signatureSheetForAsync(data.owner, 60000 + offset, data.id, afterSignatureSheet, failure);
        } else {
            EcIdentityManager.signatureSheetAsync(60000 + offset, data.id, afterSignatureSheet, failure);
        }
    };
    /**
     *  Attempts to delete a piece of data.
     *  <p>
     *  Uses a signature sheet informed by the owner field of the data.
     * 
     *  @param {EcRemoteLinkedData} data Data to save to the location designated
     *                              by its id.
     *  @param {Callback1<String>}  success Callback triggered on successful
     *                              delete
     *  @param {Callback1<String>}  failure Callback triggered if error during
     *                              delete
     *  @memberOf EcRepository
     *  @method _delete
     *  @static
     */
    constructor._delete = function(data, success, failure) {
        EcRepository.DELETE(data, success, failure);
    };
    /**
     *  Attempts to delete a piece of data.
     *  <p>
     *  Uses a signature sheet informed by the owner field of the data.
     * 
     *  @param {EcRemoteLinkedData} data Data to save to the location designated
     *                              by its id.
     *  @param {Callback1<String>}  success Callback triggered on successful
     *                              delete
     *  @param {Callback1<String>}  failure Callback triggered if error during
     *                              delete
     *  @memberOf EcRepository
     *  @method DELETE
     *  @static
     */
    constructor.DELETE = function(data, success, failure) {
        if (EcRepository.caching) {
            delete (EcRepository.cache)[data.id];
            delete (EcRepository.cache)[data.shortId()];
        }
        var targetUrl;
        targetUrl = data.shortId();
        var offset = EcRepository.setOffset(data.id);
        if (data.owner != null && data.owner.length > 0) {
            if (EcRemote.async) {
                EcIdentityManager.signatureSheetForAsync(data.owner, 60000 + offset, data.id, function(signatureSheet) {
                    if (signatureSheet.length == 2) {
                        for (var i = 0; i < EcRepository.repos.length; i++) {
                            if (data.id.indexOf(EcRepository.repos[i].selectedServer) != -1) {
                                EcRepository.repos[i].deleteRegistered(data, success, failure);
                                return;
                            }
                        }
                        if (failure != null) 
                            failure("Cannot delete object without a signature. If deleting from a server, use the non-static _delete");
                    } else 
                        EcRemote._delete(targetUrl, signatureSheet, success, failure);
                }, failure);
            } else {
                var signatureSheet = EcIdentityManager.signatureSheetFor(data.owner, 60000 + offset, data.id);
                if (signatureSheet.length == 2) {
                    for (var i = 0; i < EcRepository.repos.length; i++) {
                        if (data.id.indexOf(EcRepository.repos[i].selectedServer) != -1) {
                            EcRepository.repos[i].deleteRegistered(data, success, failure);
                            return;
                        }
                    }
                    if (failure != null) 
                        failure("Cannot delete object without a signature. If deleting from a server, use the non-static _delete");
                } else 
                    EcRemote._delete(targetUrl, signatureSheet, success, failure);
            }
        } else {
            EcRemote._delete(targetUrl, "[]", success, failure);
        }
    };
    /**
     *  Attempts to delete a piece of data.
     *  <p>
     *  Uses a signature sheet informed by the owner field of the data.
     * 
     *  @param {EcRemoteLinkedData} data Data to save to the location designated
     *                              by its id.
     *  @param {Callback1<String>}  success Callback triggered on successful
     *                              delete
     *  @param {Callback1<String>}  failure Callback triggered if error during
     *                              delete
     *  @memberOf EcRepository
     *  @method DELETE
     *  @static
     */
    prototype.deleteRegistered = function(data, success, failure) {
        if (EcRepository.caching) {
            delete (EcRepository.cache)[data.id];
            delete (EcRepository.cache)[data.shortId()];
            delete (EcRepository.cache)[EcRemoteLinkedData.veryShortId(this.selectedServer, data.getGuid())];
        }
        var targetUrl;
        if (EcRepository.shouldTryUrl(data.id) || data.id.indexOf(this.selectedServer) != -1) 
            targetUrl = EcRemote.urlAppend(this.selectedServer, "data/" + data.getDottedType() + "/" + data.getGuid());
         else 
            targetUrl = EcRemote.urlAppend(this.selectedServer, "data/" + data.getDottedType() + "/" + EcCrypto.md5(data.shortId()));
        var me = this;
        if (data.owner != null && data.owner.length > 0) {
            if (EcRemote.async) {
                EcIdentityManager.signatureSheetForAsync(data.owner, 60000 + this.timeOffset, data.id, function(signatureSheet) {
                    if (signatureSheet.length == 2 && me.adminKeys != null) {
                        EcIdentityManager.signatureSheetForAsync(me.adminKeys, 60000 + me.timeOffset, data.id, function(signatureSheet) {
                            EcRemote._delete(targetUrl, signatureSheet, success, failure);
                        }, failure);
                    } else 
                        EcRemote._delete(targetUrl, signatureSheet, success, failure);
                }, failure);
            } else {
                var signatureSheet = EcIdentityManager.signatureSheetFor(data.owner, 60000 + me.timeOffset, data.id);
                if (signatureSheet.length == 2 && me.adminKeys != null) {
                    signatureSheet = EcIdentityManager.signatureSheetFor(me.adminKeys, 60000 + me.timeOffset, data.id);
                    EcRemote._delete(targetUrl, signatureSheet, success, failure);
                } else 
                    EcRemote._delete(targetUrl, signatureSheet, success, failure);
            }
        } else {
            EcRemote._delete(targetUrl, "[]", success, failure);
        }
    };
    /**
     *  Retrieves data from the server and caches it for use later during the
     *  application. This should be called before the data is needed if possible,
     *  so loading displays can be faster.
     * 
     *  @param {String[]}  urls List of Data ID Urls that should be precached
     *  @param {Callback0} success Callback triggered once all of the data has
     *                     been retrieved
     *  @memberOf EcRepository
     *  @method precache
     */
    prototype.precache = function(urls, success) {
        if (urls == null || urls.length == 0) {
            if (success != null) {
                success();
            }
            return;
        }
        var cacheUrls = new Array();
        for (var i = 0; i < urls.length; i++) {
            var url = urls[i];
            if ((EcRepository.cache)[url] != null) {} else if (url.startsWith(this.selectedServer)) {
                cacheUrls.push(url.replace(this.selectedServer, "").replace("custom/", ""));
            } else {
                cacheUrls.push("data/" + EcCrypto.md5(url));
            }
        }
        if (cacheUrls.length == 0) {
            if (success != null) {
                success();
            }
            return;
        }
        var fd = new FormData();
        fd.append("data", JSON.stringify(cacheUrls));
        var me = this;
        if (EcRepository.unsigned) {
            this.precachePost(success, cacheUrls, fd, me);
        } else {
            EcIdentityManager.signatureSheetAsync(60000 + this.timeOffset, this.selectedServer, function(p1) {
                fd.append("signatureSheet", p1);
                me.precachePost(success, cacheUrls, fd, me);
            }, null);
        }
    };
    /**
     *  Retrieves data from the server and caches it for use later during the
     *  application. This should be called before the data is needed if possible,
     *  so loading displays can be faster.
     * 
     *  @param {String[]}  urls List of Data ID Urls that should be precached
     *  @param {Callback0} success Callback triggered once all of the data has
     *                     been retrieved
     *  @memberOf EcRepository
     *  @method precachePost
     */
    prototype.precachePost = function(success, cacheUrls, fd, me) {
        EcRemote.postExpectingObject(me.selectedServer, "sky/repo/multiGet", fd, function(p1) {
            var results = p1;
            for (var i = 0; i < results.length; i++) {
                var d = new EcRemoteLinkedData(null, null);
                d.copyFrom(results[i]);
                results[i] = d;
                if (EcRepository.caching) {
                    if (!EcRepository.shouldTryUrl(d.id)) {
                        var md5 = EcCrypto.md5(d.shortId());
                        for (var j = 0; j < cacheUrls.length; j++) {
                            var url = cacheUrls[j];
                            if (url.indexOf(md5) != -1) {
                                (EcRepository.cache)[url] = d;
                                break;
                            }
                        }
                    }
                    (EcRepository.cache)[d.shortId()] = d;
                    (EcRepository.cache)[d.id] = d;
                    (EcRepository.cache)[EcRemoteLinkedData.veryShortId(me.selectedServer, d.getGuid())] = d;
                }
            }
            if (success != null) {
                success();
            }
        }, null);
    };
    /**
     *  Returns an array of JSON-LD objects from the places designated by the given URIs.
     *  <p>
     *  Uses a signature sheet gathered from {@link EcIdentityManager}.
     * 
     *  @param {Array<String>}                        urls URLs of the remote objects.
     *  @param {Callback1<Array<EcRemoteLinkedData>>} success Event to call upon
     *                                                successful retrieval.
     *  @param {Callback1<String>}                    failure Event to call upon spectacular
     *                                                failure.
     *  @param {Callback1<Array<EcRemoteLinkedData>>} cachedValues Event to call upon
     *                                                successful retrieval from cache.
     *  @memberOf EcRepository
     *  @method multiget
     */
    prototype.multiget = function(urls, success, failure) {
        if (urls == null) {
            if (failure != null) {
                failure("");
            }
            return;
        }
        var results = new Array();
        var me = this;
        if (EcRepository.caching) 
            this.precache(urls, function() {
                var eah = new EcAsyncHelper();
                me.multigetInner(urls, success, results, eah);
            });
         else {
            var eah = new EcAsyncHelper();
            this.multigetInner(urls, success, results, eah);
        }
    };
    prototype.multigetInner = function(urls, success, results, eah) {
        eah.each(urls, function(url, done) {
            EcRepository.get(url, function(result) {
                results.push(result);
                done();
            }, function(s) {
                done();
            });
        }, function(urls) {
            success(results);
        });
    };
    /**
     *  Search a repository for JSON-LD compatible data.
     *  <p>
     *  Uses a signature sheet gathered from {@link EcIdentityManager}.
     * 
     *  @param {String}                          query ElasticSearch compatible query string, similar to
     *                                           Google query strings.
     *  @param {Callback1<EcRemoteLinkedData>}   eachSuccess Success event for each
     *                                           found object.
     *  @param {Callback1<EcRemoteLinkedData[]>} success Success event, called
     *                                           after eachSuccess.
     *  @param {Callback1<String>}               failure Failure event.
     *  @memberOf EcRepository
     *  @method search
     */
    prototype.search = function(query, eachSuccess, success, failure) {
        this.searchWithParams(query, null, eachSuccess, success, failure);
    };
    /**
     *  Search a repository for JSON-LD compatible data synchronously.
     *  <p>
     *  Uses a signature sheet gathered from {@link EcIdentityManager}.
     * 
     *  @param {String} query ElasticSearch compatible query string, similar to
     *                  Google query strings.
     *  @returns EcRemoteLinkedData[]
     *  @memberOf EcRepository
     *  @method search
     */
    prototype.searchBlocking = function(query) {
        return this.searchWithParamsBlocking(query, null);
    };
    /**
     *  Search a repository for JSON-LD compatible data.
     *  <p>
     *  Uses a signature sheet gathered from {@link EcIdentityManager}.
     * 
     *  @param {String}                          query ElasticSearch compatible query string, similar to
     *                                           Google query strings.
     *  @param {Object}                          paramObj Additional parameters that can be used to tailor
     *                                           the search.
     *  @param {Callback1<EcRemoteLinkedData>}   eachSuccess Success event for each
     *                                           found object.
     *  @param {Callback1<EcRemoteLinkedData[]>} success Success event, called
     *                                           after eachSuccess.
     *  @param {Callback1<String>}               failure Failure event.
     *  @memberOf EcRepository
     *  @method searchWithParams
     */
    prototype.searchWithParams = function(originalQuery, originalParamObj, eachSuccess, success, failure) {
        if (EcRemote.async == false) {
            var result = this.searchWithParamsBlocking(originalQuery, originalParamObj);
            if (result == null) {
                if (failure != null) 
                    failure("Search failed.");
            } else {
                for (var i = 0; i < result.length; i++) 
                    if (eachSuccess != null) 
                        eachSuccess(result[i]);
                if (success != null) 
                    success(result);
            }
            return;
        }
        var query = originalQuery;
        var paramObj = originalParamObj;
        if (paramObj == null) {
            paramObj = new Object();
        }
        var params = new Object();
        var paramProps = (params);
        query = this.searchParamProps(query, paramObj, paramProps);
        if ((paramObj)["fields"] != null) {
            paramProps["fields"] = (paramObj)["fields"];
        }
        var cacheKey;
        if (EcRepository.cachingSearch) {
            cacheKey = JSON.stringify(paramProps) + query;
            if ((EcRepository.cache)[cacheKey] != null) {
                this.handleSearchResults((EcRepository.cache)[cacheKey], eachSuccess, success, failure);
                return;
            }
            var me = this;
            if (EcRemote.async) {
                if ((EcRepository.fetching)[cacheKey] != null) {
                    if ((EcRepository.fetching)[cacheKey] > new Date().getTime()) {
                        setTimeout(function() {
                            me.searchWithParams(originalQuery, originalParamObj, eachSuccess, success, failure);
                        }, 100);
                        return;
                    }
                }
                (EcRepository.fetching)[cacheKey] = new Date().getTime() + 60000;
            }
        } else {
            cacheKey = null;
        }
        var fd = new FormData();
        fd.append("data", query);
        if (params != null) {
            fd.append("searchParams", JSON.stringify(params));
        }
        var me = this;
        if (EcRepository.unsigned == true || (paramObj)["unsigned"] == true) {
            fd.append("signatureSheet", "[]");
            EcRemote.postExpectingObject(me.selectedServer, "sky/repo/search", fd, function(p1) {
                if (EcRepository.cachingSearch) {
                    (EcRepository.cache)[cacheKey] = p1;
                }
                if (cacheKey != null) {
                    delete (EcRepository.fetching)[cacheKey];
                }
                me.handleSearchResults(p1, eachSuccess, success, failure);
            }, function(p1) {
                if (cacheKey != null) {
                    delete (EcRepository.fetching)[cacheKey];
                }
                if (failure != null) {
                    failure(p1);
                }
            });
        } else 
            EcIdentityManager.signatureSheetAsync(60000 + this.timeOffset, this.selectedServer, function(signatureSheet) {
                fd.append("signatureSheet", signatureSheet);
                EcRemote.postExpectingObject(me.selectedServer, "sky/repo/search", fd, function(p1) {
                    if (EcRepository.cachingSearch) {
                        (EcRepository.cache)[cacheKey] = p1;
                    }
                    if (cacheKey != null) {
                        delete (EcRepository.fetching)[cacheKey];
                    }
                    me.handleSearchResults(p1, eachSuccess, success, failure);
                }, function(p1) {
                    if (cacheKey != null) {
                        delete (EcRepository.fetching)[cacheKey];
                    }
                    if (failure != null) {
                        failure(p1);
                    }
                });
            }, failure);
    };
    /**
     *  Search a repository for JSON-LD compatible data synchronously.
     *  <p>
     *  Uses a signature sheet gathered from {@link EcIdentityManager}.
     * 
     *  @param {String} query ElasticSearch compatible query string, similar to
     *                  Google query strings.
     *  @param {Object} paramObj Additional parameters that can be used to tailor
     *                  the search.
     *  @returns EcRemoteLinkedData[]
     *  @memberOf EcRepository
     *  @method searchWithParams
     */
    prototype.searchWithParamsBlocking = function(originalQuery, originalParamObj) {
        var query = originalQuery;
        var paramObj = originalParamObj;
        if (paramObj == null) {
            paramObj = new Object();
        }
        var params = new Object();
        var paramProps = (params);
        query = this.searchParamProps(query, paramObj, paramProps);
        if ((paramObj)["fields"] != null) {
            paramProps["fields"] = (paramObj)["fields"];
        }
        var oldAsync = EcRemote.async;
        EcRemote.async = false;
        var cacheKey;
        cacheKey = JSON.stringify(paramProps) + query;
        if (EcRepository.cachingSearch) {
            if ((EcRepository.cache)[cacheKey] != null) {
                return this.handleSearchResults((EcRepository.cache)[cacheKey], null, null, null);
            }
        }
        var fd = new FormData();
        fd.append("data", query);
        if (params != null) {
            fd.append("searchParams", JSON.stringify(params));
        }
        var me = this;
        if (EcRepository.unsigned == true || (paramObj)["unsigned"] == true) {
            fd.append("signatureSheet", "[]");
            EcRemote.postExpectingObject(me.selectedServer, "sky/repo/search", fd, function(p1) {
                (EcRepository.cache)[cacheKey] = p1;
                if (cacheKey != null) {
                    delete (EcRepository.fetching)[cacheKey];
                }
            }, function(p1) {
                if (cacheKey != null) {
                    delete (EcRepository.fetching)[cacheKey];
                }
                (EcRepository.cache)[cacheKey] = null;
            });
        } else {
            var signatureSheet;
            signatureSheet = EcIdentityManager.signatureSheet(60000 + this.timeOffset, this.selectedServer);
            fd.append("signatureSheet", signatureSheet);
            EcRemote.postExpectingObject(me.selectedServer, "sky/repo/search", fd, function(p1) {
                (EcRepository.cache)[cacheKey] = p1;
                if (cacheKey != null) {
                    delete (EcRepository.fetching)[cacheKey];
                }
            }, function(p1) {
                if (cacheKey != null) {
                    delete (EcRepository.fetching)[cacheKey];
                }
                (EcRepository.cache)[cacheKey] = null;
            });
        }
        var result = this.handleSearchResults((EcRepository.cache)[cacheKey], null, null, null);
        if (!EcRepository.cachingSearch) {
            delete (EcRepository.cache)[cacheKey];
        }
        EcRemote.async = oldAsync;
        return result;
    };
    prototype.searchParamProps = function(query, paramObj, paramProps) {
        if ((paramObj)["start"] != null) {
            paramProps["start"] = (paramObj)["start"];
        }
        if ((paramObj)["size"] != null) {
            paramProps["size"] = (paramObj)["size"];
        }
        if ((paramObj)["types"] != null) {
            paramProps["types"] = (paramObj)["types"];
        }
        if ((paramObj)["sort"] != null) {
            paramProps["sort"] = (paramObj)["sort"];
        }
        if ((paramObj)["track_scores"] != null) {
            paramProps["track_scores"] = (paramObj)["track_scores"];
        }
        if ((paramObj)["index_hint"] != null) {
            paramProps["index_hint"] = (paramObj)["index_hint"];
        }
        if ((paramObj)["ownership"] != null) {
            var ownership = (paramObj)["ownership"];
            if (!query.startsWith("(") || !query.endsWith(")")) {
                query = "(" + query + ")";
            }
            if (ownership == "public") {
                query += " AND (_missing_:owner) AND (_missing_:@owner)";
            } else if (ownership == "owned") {
                query += " AND (_exists_:owner OR _exists_:@owner)";
            } else if (ownership == "me") {
                query += " AND (";
                for (var i = 0; i < EcIdentityManager.ids.length; i++) {
                    if (i != 0) {
                        query += " OR ";
                    }
                    var id = EcIdentityManager.ids[i];
                    query += "\\*owner:\"" + id.ppk.toPk().toPem() + "\"";
                }
                query += ")";
            }
        }
        return query;
    };
    /**
     *  Searches known repository endpoints to set the server configuration for
     *  this repositories instance
     * 
     *  @memberOf EcRepository
     *  @method autoDetectRepository
     */
    prototype.autoDetectRepositoryAsync = function(success, failure) {
        var protocols = new Array();
        if (window != null) {
            if (window.location != null) {
                if (window.location.protocol == "https:") {
                    protocols.push("https:");
                }
            }
        }
        if (window != null) {
            if (window.location != null) {
                if (window.location.protocol == "http:") {
                    protocols.push("http:");
                    protocols.push("https:");
                }
            }
        }
        if (protocols.length == 0) {
            protocols.push("https:");
            protocols.push("http:");
        }
        var hostnames = new Array();
        var servicePrefixes = new Array();
        if (this.selectedServer != null) {
            var e = window.document.createElement("a");
            (e)["href"] = this.selectedServer;
            hostnames.push((e)["host"]);
            servicePrefixes.push((e)["pathname"]);
        } else {
            if (window.location.host != null) {
                hostnames.push(window.location.host, window.location.host.replace(".", ".service."), window.location.host + ":8080", window.location.host.replace(".", ".service.") + ":8080");
            }
            if (window.location.hostname != null) {
                hostnames.push(window.location.hostname, window.location.hostname.replace(".", ".service."), window.location.hostname + ":8080", window.location.hostname.replace(".", ".service.") + ":8080");
            }
        }
        EcArray.removeDuplicates(hostnames);
        servicePrefixes.push("/" + window.location.pathname.split("/")[1] + "/api/", "/", "/service/", "/api/");
        EcArray.removeDuplicates(servicePrefixes);
        var me = this;
        me.autoDetectFound = false;
        for (var j = 0; j < hostnames.length; j++) {
            for (var k = 0; k < servicePrefixes.length; k++) {
                for (var i = 0; i < protocols.length; i++) {
                    this.autoDetectRepositoryActualAsync(protocols[i] + "//" + hostnames[j] + servicePrefixes[k].replaceAll("//", "/"), success, failure);
                    setTimeout(function() {
                        if (me.autoDetectFound == false) {
                            var servicePrefixes = new Array();
                            servicePrefixes.push("/" + window.location.pathname.split("/")[1] + "/api/custom/", "/api/custom/");
                            EcArray.removeDuplicates(servicePrefixes);
                            for (var j = 0; j < hostnames.length; j++) {
                                for (var k = 0; k < servicePrefixes.length; k++) {
                                    for (var i = 0; i < protocols.length; i++) {
                                        me.autoDetectRepositoryActualAsync(protocols[i] + "//" + hostnames[j] + servicePrefixes[k].replaceAll("//", "/"), success, failure);
                                        setTimeout(function() {
                                            if (me.autoDetectFound == false) 
                                                failure("Could not find service.");
                                        }, 5000);
                                    }
                                }
                            }
                        }
                    }, 5000);
                }
            }
        }
    };
    /**
     *  Searches known repository endpoints to set the server configuration for
     *  this repositories instance
     * 
     *  @memberOf EcRepository
     *  @method autoDetectRepository
     */
    prototype.autoDetectRepository = function() {
        EcRemote.async = false;
        var protocols = new Array();
        if (window != null) {
            if (window.location != null) {
                if (window.location.protocol == "https:") {
                    protocols.push("https:");
                }
            }
        }
        if (window != null) {
            if (window.location != null) {
                if (window.location.protocol == "http:") {
                    protocols.push("http:");
                    protocols.push("https:");
                }
            }
        }
        if (protocols.length == 0) {
            protocols.push("https:");
            protocols.push("http:");
        }
        var hostnames = new Array();
        var servicePrefixes = new Array();
        if (this.selectedServer != null && window != null && window.document != null) {
            var e = window.document.createElement("a");
            if (e != null) {
                (e)["href"] = this.selectedServer;
                hostnames.push((e)["host"]);
                servicePrefixes.push((e)["pathname"]);
            }
        } else if (window != null && window.location != null) {
            if (window.location.host != null) {
                hostnames.push(window.location.host, window.location.host.replace(".", ".service."), window.location.host + ":8080", window.location.host.replace(".", ".service.") + ":8080");
            }
            if (window.location.hostname != null) {
                hostnames.push(window.location.hostname, window.location.hostname.replace(".", ".service."), window.location.hostname + ":8080", window.location.hostname.replace(".", ".service.") + ":8080");
            }
        }
        if (window != null) {
            if (window.location != null) {
                servicePrefixes.push("/" + window.location.pathname.split("/")[1] + "/api/");
                servicePrefixes.push("/" + window.location.pathname.split("/")[1] + "/api/custom/");
            }
        }
        if (hostnames.length == 0) {
            hostnames.push("localhost", "localhost:8080");
        }
        servicePrefixes.push("/");
        servicePrefixes.push("/service/");
        servicePrefixes.push("/api/");
        servicePrefixes.push("/api/custom/");
        for (var j = 0; j < hostnames.length; j++) {
            for (var k = 0; k < servicePrefixes.length; k++) {
                for (var i = 0; i < protocols.length; i++) {
                    if (this.autoDetectRepositoryActual(protocols[i] + "//" + hostnames[j] + servicePrefixes[k].replaceAll("//", "/"))) {
                        EcRemote.async = true;
                        return;
                    }
                }
            }
        }
        EcRemote.async = true;
    };
    /**
     *  Handles the actual detection of repository endpoint /ping service
     * 
     *  @param {String} guess The server prefix
     *  @return {boolean} Whether the detection successfully found the endpoint
     *  @memberOf EcRepository
     *  @method autoDetectRepositoryAsync
     *  @private
     */
    prototype.autoDetectRepositoryActualAsync = function(guess, success, failure) {
        var me = this;
        var successCheck = function(p1) {
            if (p1 != null) {
                if ((p1)["ping"] == "pong") {
                    if ((p1)["time"] != null) 
                        me.timeOffset = (((p1)["time"] - new Date().getTime()));
                    if (me.autoDetectFound == false) {
                        me.selectedServer = guess;
                        me.autoDetectFound = true;
                        success();
                    }
                }
            }
        };
        var failureCheck = function(p1) {
            if (p1 != null) {
                if (!(p1 == "")) {
                    try {
                        if (p1.indexOf("pong") != -1) {
                            if (me.autoDetectFound == false) {
                                me.selectedServer = guess;
                                me.autoDetectFound = true;
                                success();
                            }
                        }
                    }catch (ex) {}
                }
            }
        };
        if (guess != null && guess != "") {
            try {
                EcRemote.getExpectingObject(guess, "ping", successCheck, failureCheck);
            }catch (ex) {}
        }
        return this.autoDetectFound;
    };
    /**
     *  Handles the actual detection of repository endpoint /ping service
     * 
     *  @param {String} guess The server prefix
     *  @return {boolean} Whether the detection successfully found the endpoint
     *  @memberOf EcRepository
     *  @method autoDetectRepositoryActual
     *  @private
     */
    prototype.autoDetectRepositoryActual = function(guess) {
        var oldTimeout = EcRemote.timeout;
        EcRemote.timeout = 500;
        var me = this;
        var successCheck = function(p1) {
            if (p1 != null) {
                if ((p1)["ping"] == "pong") {
                    if ((p1)["time"] != null) 
                        me.timeOffset = (((p1)["time"] - new Date().getTime()));
                    me.selectedServer = guess;
                    me.autoDetectFound = true;
                }
            }
        };
        var failureCheck = function(p1) {
            if (p1 != null) {
                if (p1 != "") {
                    try {
                        if (p1.indexOf("pong") != -1) {
                            me.selectedServer = guess;
                            me.autoDetectFound = true;
                        }
                    }catch (ex) {}
                }
            }
        };
        if (guess != null && guess != "") {
            try {
                EcRemote.getExpectingObject(guess, "ping", successCheck, failureCheck);
            }catch (ex) {}
        }
        EcRemote.timeout = oldTimeout;
        return this.autoDetectFound;
    };
    /**
     *  Lists all types visible to the current user in the repository
     *  <p>
     *  Uses a signature sheet gathered from {@link EcIdentityManager}.
     * 
     *  @param {Callback1<Object[]>} success Success event
     *  @param {Callback1<String>}   failure Failure event.
     *  @memberOf EcRepository
     *  @method listTypes
     */
    prototype.listTypes = function(success, failure) {
        var fd = new FormData();
        fd.append("signatureSheet", EcIdentityManager.signatureSheet(60000 + this.timeOffset, this.selectedServer));
        EcRemote.postExpectingObject(this.selectedServer, "sky/repo/types", fd, function(p1) {
            var results = p1;
            if (success != null) {
                success(results);
            }
        }, failure);
    };
    /**
     *  Backs up the skyrepo elasticsearch database to the server backup directory
     * 
     *  @param {String}            serverSecret Secret string stored on the server to authenticate administrative rights
     *  @param {Callback1<Object>} success Success event
     *  @param {Callback1<String>} failure Failure event.
     *  @memberOf EcRepository
     *  @method backup
     */
    prototype.backup = function(serverSecret, success, failure) {
        EcRemote.getExpectingObject(this.selectedServer, "util/backup?secret=" + serverSecret, success, failure);
    };
    /**
     *  Restores the skyrepo elasticsearch backup from the server backup directory
     * 
     *  @param {String}            serverSecret Secret string stored on the server to authenticate administrative rights
     *  @param {Callback1<Object>} success Success event
     *  @param {Callback1<String>} failure Failure event.
     *  @memberOf EcRepository
     *  @method restoreBackup
     */
    prototype.restoreBackup = function(serverSecret, success, failure) {
        EcRemote.getExpectingObject(this.selectedServer, "util/restore?secret=" + serverSecret, success, failure);
    };
    /**
     *  Wipes all data from the the skyrepo elasticsearch, can only be restored by using backup restore
     * 
     *  @param {String}            serverSecret Secret string stored on the server to authenticate administrative rights
     *  @param {Callback1<Object>} success Success event
     *  @param {Callback1<String>} failure Failure event.
     *  @memberOf EcRepository
     *  @method wipe
     */
    prototype.wipe = function(serverSecret, success, failure) {
        EcRemote.getExpectingObject(this.selectedServer, "util/purge?secret=" + serverSecret, success, failure);
    };
    /**
     *  Handles the search results in search by params, before returning them
     *  with the callback passed into search method
     * 
     *  @param {EcRemoteLinkedData[]}            results Results to handle before returning
     *  @param {Callback1<EcRemoteLinkedData>}   eachSuccess Callback function to
     *                                           trigger for each search result
     *  @param {Callback1<EcRemoteLinkedData[]>} success Callback function to
     *                                           trigger with all search results
     *  @param failure
     *  @memberOf EcRepository
     *  @method handleSearchResults
     *  @private
     */
    prototype.handleSearchResults = function(results, eachSuccess, success, failure) {
        if (results == null) {
            if (failure != null) 
                failure("Error in search. See HTTP request for more details.");
            return null;
        }
        for (var i = 0; i < results.length; i++) {
            var d = new EcRemoteLinkedData(null, null);
            d.copyFrom(results[i]);
            results[i] = d;
            if (EcRepository.caching) {
                (EcRepository.cache)[d.shortId()] = d;
                (EcRepository.cache)[d.id] = d;
                (EcRepository.cache)[EcRemoteLinkedData.veryShortId(this.selectedServer, d.getGuid())] = d;
            }
            if (eachSuccess != null) {
                eachSuccess(results[i]);
            }
        }
        if (success != null) {
            success(results);
        }
        return results;
    };
    /**
     *  Fetches the admin keys from the server to compare for check if current
     *  user is an admin user
     * 
     *  @param {Callback1<String[]>} success
     *                               Callback triggered when the admin keys are successfully returned,
     *                               returns an array of the admin public keys
     *  @param {Callback1<String>}   failure
     *                               Callback triggered if error occurs fetching admin keys
     *  @memberOf EcRemoteIdentityManager
     *  @method fetchServerAdminKeys
     */
    prototype.fetchServerAdminKeys = function(success, failure) {
        var service;
        if (this.selectedServer.endsWith("/")) {
            service = "sky/admin";
        } else {
            service = "/sky/admin";
        }
        var me = this;
        EcRemote.getExpectingObject(this.selectedServer, service, function(p1) {
            var ary = p1;
            me.adminKeys = new Array();
            for (var i = 0; i < ary.length; i++) {
                me.adminKeys.push(ary[i]);
            }
            success(ary);
        }, function(p1) {
            failure("");
        });
    };
    constructor.getAs = function(id, result, success, failure) {
        EcRepository.get(id, function(p1) {
            if (p1.getClass() == result.getClass()) 
                if (success != null) {
                    success(p1);
                    return;
                }
            EcEncryptedValue.fromEncryptedValueAsync(p1, function(p1) {
                if (p1.isAny(result.getTypes())) {
                    result.copyFrom(p1);
                    if (EcRepository.caching) {
                        (EcRepository.cache)[result.shortId()] = result;
                        (EcRepository.cache)[result.id] = result;
                    }
                    if (success != null) 
                        success(result);
                } else {
                    var msg = "Retrieved object was not a " + result.getFullType();
                    if (failure != null) 
                        failure(msg);
                     else 
                        console.error(msg);
                }
            }, failure);
        }, failure);
    };
    constructor.getBlockingAs = function(id, result) {
        var p1 = EcRepository.getBlocking(id);
        if (p1 == null) 
            return null;
        if (p1.getClass() == result.getClass()) 
            return p1;
        p1 = EcEncryptedValue.fromEncryptedValue(p1);
        if (p1.isAny(result.getTypes())) {
            result.copyFrom(p1);
            if (EcRepository.caching) {
                (EcRepository.cache)[result.shortId()] = result;
                (EcRepository.cache)[result.id] = result;
            }
            return result;
        } else {
            var msg = "Retrieved object was not a " + result.getFullType();
            console.error(msg);
            return null;
        }
    };
    constructor.searchAs = function(repo, query, factory, success, failure, paramObj) {
        if (paramObj == null) 
            paramObj = new Object();
        var template = (factory());
        var queryAdd = template.getSearchStringByType();
        (paramObj)["index_hint"] = "*" + template.type.toLowerCase() + ",*encryptedvalue";
        if (query == null || query == "") 
            query = queryAdd;
         else 
            query = "(" + query + ") AND " + queryAdd;
        repo.searchWithParams(query, paramObj, null, function(p1s) {
            var eah = new EcAsyncHelper();
            if (success != null) {
                eah.eachSet(p1s, function(p1, set) {
                    EcEncryptedValue.fromEncryptedValueAsync(p1, function(p1) {
                        var result = factory();
                        if (p1.isAny(result.getTypes())) {
                            result.copyFrom(p1);
                            set(result);
                        } else {
                            set(null);
                        }
                    }, EcAsyncHelper.setNull(set));
                }, function(results) {
                    success(results);
                });
            }
        }, failure);
    };
}, {cache: "Object", fetching: "Object", repos: {name: "Array", arguments: ["EcRepository"]}, adminKeys: {name: "Array", arguments: [null]}}, {});
/**
 *  Implementation of a file with methods for communicating with repository services
 * 
 *  @author devlin.junker@eduworks.com
 *  @module com.eduworks.ec
 *  @class EcFile
 *  @extends GeneralFile
 *  @constructor
 */
var EcFile = function() {
    GeneralFile.call(this);
};
EcFile = stjs.extend(EcFile, GeneralFile, [], function(constructor, prototype) {
    /**
     *  Factory method for creating a file with certain values
     * 
     *  @param {String} name
     *                  Name of the file to be created
     *  @param {String} base64Data
     *                  Base 64 encoded file data
     *  @param {String} mimeType
     *                  MIME Type of the file
     *  @return {EcFile}
     *  The file created
     *  @memberOf EcFile
     *  @method create
     *  @static
     */
    constructor.create = function(name, base64Data, mimeType) {
        var f = new EcFile();
        f.data = base64Data;
        f.name = name;
        f.mimeType = mimeType;
        return f;
    };
    /**
     *  Retrieves a file from the server specified by it's ID
     * 
     *  @param {String}            id
     *                             ID of the file data to be retrieved
     *  @param {Callback1<EcFile>} success
     *                             Callback triggered if successfully retrieved from the server,
     *                             returns the retrieved file
     *  @param {Callback1<String>} failure
     *                             Callback triggered if error occurs while retrieving file from server
     *  @memberOf EcFile
     *  @method get
     *  @static
     */
    constructor.get = function(id, success, failure) {
        EcRepository.getAs(id, new EcFile(), success, failure);
    };
    constructor.getBlocking = function(id) {
        return EcRepository.getBlockingAs(id, new EcFile());
    };
    /**
     *  Searches the repository given for files that match the query passed in
     * 
     *  @param {EcRepository}       repo
     *                              Repository to search for files
     *  @param {String}             query
     *                              Query to user for search
     *  @param {Callback1<EcFile[]> success
     *                              Callback triggered after search completes,
     *                              returns results
     *  @param {Callback1<String>}  failure
     *                              Callback triggered if error occurs while searching
     *  @param {Object}             paramObj
     *                              Parameters to pass to search
     *  @memberOf EcFile
     *  @method search
     *  @static
     */
    constructor.search = function(repo, query, success, failure, paramObj) {
        EcRepository.searchAs(repo, query, function() {
            return new EcFile();
        }, success, failure, paramObj);
    };
    /**
     *  Saves this file in the repository using the repository web services
     * 
     *  @param {Callback1<String>} success
     *                             Callback triggered if successfully saved
     *  @param {Callback1<String>} failure
     *                             Callback triggered if error occurs while saving
     *  @memberOf EcFile
     *  @method save
     */
    prototype.save = function(success, failure) {
        if (this.name == null || this.name == "") {
            var msg = "File Name can not be empty";
            if (failure != null) 
                failure(msg);
             else 
                console.error(msg);
            return;
        }
        EcRepository.save(this, success, failure);
    };
    /**
     *  Deletes the file from the repository using repository web services
     * 
     *  @param {Callback1<String>} success
     *                             Callback triggered if successfully deleted
     *  @param {Callback1<String>} failure
     *                             Callback triggered if error occurs while deleting
     *  @memberOf EcFile
     *  @method _delete
     */
    prototype._delete = function(repo, success, failure) {
        repo.constructor.DELETE(this, success, failure);
    };
}, {owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});

/**
 *  Implementation of a Directory object with methods for interacting with CASS
 *  services on a server.
 * 
 *  @author kristin.wood@eduworks.com
 *  @module org.cassproject
 *  @class EcDirectory
 *  @constructor
 *  @extends Directory
 */
var EcDirectory = function() {
    Directory.call(this);
    var me = (this);
    if (EcDirectory.template != null) {
        var you = (EcDirectory.template);
        for (var key in you) {
            if ((typeof you[key]) != "function") 
                me[key.replace("@", "")] = you[key];
        }
    }
};
EcDirectory = stjs.extend(EcDirectory, Directory, [], function(constructor, prototype) {
    constructor.template = null;
    prototype.equals = function(obj) {
        return this.isId((obj).id);
    };
    /**
     *  Retrieves a directory from the server, specified by the ID
     * 
     *  @param {String}                 id
     *                                  ID of the directory to retrieve
     *  @param {Callback1<EcDirectory>} success
     *                                  Callback triggered after successfully retrieving the directory,
     *                                  returns the retrieved directory
     *  @param {Callback1<String>}      failure
     *                                  Callback triggered if an error occurs while retrieving the directory
     *  @memberOf EcDirectory
     *  @method get
     *  @static
     */
    constructor.get = function(id, success, failure) {
        EcRepository.getAs(id, new EcDirectory(), success, failure);
    };
    /**
     *  Retrieves a directory from the server in a blocking fashion, specified by the ID
     * 
     *  @param {String}                 id
     *                                  ID of the directory to retrieve
     *  @param {Callback1<EcDirectory>} success
     *                                  Callback triggered after successfully retrieving the directory,
     *                                  returns the retrieved directory
     *  @param {Callback1<String>}      failure
     *                                  Callback triggered if an error occurs while retrieving the directory
     *  @memberOf EcDirectory
     *  @method getBlocking
     *  @static
     */
    constructor.getBlocking = function(id) {
        return EcRepository.getBlockingAs(id, new EcDirectory());
    };
    /**
     *  Searches the repository given for directories using the query passed in
     * 
     *  @param {EcRepository}                 repo
     *                                        Repository to search for directories
     *  @param {String}                       query
     *                                        Query string used to search for a directory
     *  @param {Callback1<Array<EcDirectory>} success
     *                                        Callback triggered when the search successfully returns,
     *                                        returns search results
     *  @param {Callback1<String>}            failure
     *                                        Callback triggered if an error occurs while searching
     *  @param {Object}                       paramObj
     *                                        Parameter object for search
     *  @memberOf EcDirectory
     *  @method search
     *  @static
     */
    constructor.search = function(repo, query, success, failure, paramObj) {
        EcRepository.searchAs(repo, query, function() {
            return new EcDirectory();
        }, success, failure, paramObj);
    };
    /**
     *  Saves this directory's details on the server specified by its ID or repo
     * 
     *  @param {Callback1<String>} success
     *                             Callback triggered after successfully saving the directory
     *  @param {Callback1<String>} failure
     *                             Callback triggered if error occurs while saving the directory
     *  @param {EcRepository}      repo
     *                             Repository to save the item to
     *  @memberOf EcDirectory
     *  @method save
     */
    prototype.save = function(success, failure, repo) {
        if (this.name == null || this.name == "") {
            var msg = "Directory Name Cannot be Empty";
            if (failure != null) 
                failure(msg);
             else 
                console.error(msg);
            return;
        }
        if (repo == null) 
            EcRepository.save(this, success, failure);
         else 
            repo.saveTo(this, success, failure);
    };
    /**
     *  Deletes this directory from the server specified by its ID
     * 
     *  @param {Callback1<String>} success
     *                             Callback triggered if successfully deleted directory
     *  @param {Callback1<String>} failure
     *                             Callback triggered if error occurs when deleting the directory
     *  @memberOf EcDirectory
     *  @method _delete
     */
    prototype._delete = function(success, failure) {
        EcRepository.DELETE(this, success, failure);
    };
}, {template: "Object", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Implementation of a Rollup Rule object with methods for interacting with CASS
 *  services on a server.
 * 
 *  @author fritz.ray@eduworks.com
 *  @author devlin.junker@eduworks.com
 *  @module org.cassproject
 *  @class EcRollupRule
 *  @constructor
 *  @extends RollupRule
 */
var EcRollupRule = function() {
    RollupRule.call(this);
};
EcRollupRule = stjs.extend(EcRollupRule, RollupRule, [], function(constructor, prototype) {
    /**
     *  Retrieves a rollup rule from the server
     * 
     *  @param {String}                  id
     *                                   ID of the rollup rule to retrieve
     *  @param {Callback1<EcRollupRule>} success
     *                                   Callback triggered on successful retrieving rollup rule,
     *                                   returns the rollup rule
     *  @param {Callback1<String>}       failure
     *                                   Callback triggered if error retrieving rollup rule
     *  @memberOf EcRollupRule
     *  @method get
     *  @static
     */
    constructor.get = function(id, success, failure) {
        EcRepository.getAs(id, new EcRollupRule(), success, failure);
    };
    constructor.getBlocking = function(id) {
        return EcRepository.getBlockingAs(id, new EcRollupRule());
    };
    /**
     *  Searches for levels with a string query
     * 
     *  @param {EcRepository}                   repo
     *                                          Repository to search for levels
     *  @param {String}                         query
     *                                          query string to use in search
     *  @param {Callback1<Array<EcRollupRule>>} success
     *                                          Callback triggered when searches successfully
     *  @param {Callback1<String>}              failure
     *                                          Callback triggered if an error occurs while searching
     *  @param {Object}                         paramObj
     *                                          Search parameters object to pass in
     *  @memberOf EcRollupRule
     *  @method search
     *  @static
     */
    constructor.search = function(repo, query, success, failure, paramObj) {
        EcRepository.searchAs(repo, query, function() {
            return new EcRollupRule();
        }, success, failure, paramObj);
    };
    /**
     *  Method for setting a rollup rule name
     * 
     *  @param name
     *  @memberOf EcRollupRule
     *  @method setName
     */
    prototype.setName = function(name) {
        this.name = name;
    };
    /**
     *  Method for setting a rollup rule description
     * 
     *  @param {String} description
     *  @memberOf EcRollupRule
     *  @method setDescription
     */
    prototype.setDescription = function(description) {
        this.description = description;
    };
    /**
     *  Saves this rollup rules details on the server specified by its ID
     * 
     *  @param {Callback1<String>} success
     *                             Callback triggered on successful save of rollup rule
     *  @param {Callback1<String>} failure
     *                             Callback triggered if error saving rollup rule
     *  @memberOf EcRollupRule
     *  @method save
     */
    prototype.save = function(success, failure, repo) {
        if (this.rule == null || this.rule == "") {
            var msg = "RollupRule Rule cannot be empty";
            if (failure != null) 
                failure(msg);
             else 
                console.error(msg);
            return;
        }
        if (this.competency == null || this.competency == "") {
            var msg = "RollupRule's Competency cannot be empty";
            if (failure != null) 
                failure(msg);
             else 
                console.error(msg);
            return;
        }
        if (repo == null) 
            EcRepository.save(this, success, failure);
         else 
            repo.saveTo(this, success, failure);
    };
    /**
     *  Deletes this rollup rule from the server specified by it's ID
     * 
     *  @param {Callback1<String>} success
     *                             Callback triggered on successful deleting the rollup rle
     *  @param {Callback1<String>} failure
     *                             Callback triggered if error deleting the rollup rule
     *  @memberOf EcRollupRule
     *  @method _delete
     */
    prototype._delete = function(success, failure) {
        EcRepository.DELETE(this, success, failure);
    };
}, {about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Implementation of an alignment object with methods for interacting with CASS
 *  services on a server.
 * 
 *  @author fritz.ray@eduworks.com
 *  @author devlin.junker@eduworks.com
 *  <p>
 *  TODO: Test case where an absent relation is in the framework.
 *  @module org.cassproject
 *  @class EcAlignment
 *  @constructor
 *  @extends Relation
 */
var EcAlignment = function() {
    Relation.call(this);
};
EcAlignment = stjs.extend(EcAlignment, Relation, [], function(constructor, prototype) {
    prototype.equals = function(obj) {
        if ((obj).id == null) 
            return ((obj).source == this.source && (obj).target == this.target && (obj).relationType == this.relationType);
        return this.isId((obj).id);
    };
    /**
     *  Retrieves the alignment specified with the ID from the server
     * 
     *  @param {String}                 id
     *                                  ID of the alignment to retrieve
     *  @param {Callback1<EcAlignment>} success
     *                                  Callback triggered on successfully retrieving the alignment,
     *                                  returns the alignment
     *  @param {Callback1<String>}      [failure]
     *                                  Callback triggered if error while retrieving alignment
     *  @memberOf EcAlignment
     *  @method get
     *  @static
     */
    constructor.get = function(id, success, failure) {
        EcRepository.getAs(id, new EcAlignment(), success, failure);
    };
    /**
     *  Retrieves an alignment from it's server synchronously, the call
     *  blocks until it is successful or an error occurs
     * 
     *  @param {String} id
     *                  ID of the alignment to retrieve
     *  @return EcAlignment
     *  The alignment retrieved
     *  @memberOf EcAlignment
     *  @method getBlocking
     *  @static
     */
    constructor.getBlocking = function(id) {
        return EcRepository.getBlockingAs(id, new EcAlignment());
    };
    /**
     *  Searches the repository using the query and optional parameters provided
     * 
     *  @param {EcRepository}                  repo
     *                                         Repository to search using the query provided
     *  @param {String}                        query
     *                                         The query to send to the search
     *  @param {Callback1<Array<EcAlignment>>} success
     *                                         Callback triggered on successful search return
     *  @param {Callback1<String>}             [failure]
     *                                         Callback triggered if error searching
     *  @param {Object}                        [paramObj]
     *                                         Parameters to include in the search
     *  @memberOf EcAlignment
     *  @method search
     *  @static
     */
    constructor.search = function(repo, query, success, failure, paramObj) {
        EcRepository.searchAs(repo, query, function() {
            return new EcAlignment();
        }, success, failure, paramObj);
    };
    /**
     *  Searches the repository for alignments with a specific ID in the source field
     * 
     *  @param {EcRepository}                  repo
     *                                         Repository to search for alignments with the source specified
     *  @param {String}                        sourceId
     *                                         ID in the source field of the alignments to find
     *  @param {Callback1<Array<EcAlignment>>} success
     *                                         Callback triggered on successful search return
     *  @param {Callback1<String>}             [failure]
     *                                         Callback triggered if error searching
     *  @param {Object}                        [paramObj]
     *                                         Parameters to include in the search
     *  @memberOf EcAlignment
     *  @method searchBySource
     *  @static
     */
    constructor.searchBySource = function(repo, sourceId, success, failure, paramObj) {
        var query = "";
        var noVersion = EcRemoteLinkedData.trimVersionFromUrl(sourceId);
        if (noVersion == sourceId) {
            query += "source:\"" + sourceId + "\"";
        } else {
            query += "source:\"" + sourceId + "\" OR source:\"" + noVersion + "\"";
        }
        EcAlignment.search(repo, query, success, failure, paramObj);
    };
    /**
     *  Searches the repository for alignments with one of an array of IDs in the source field
     * 
     *  @param {EcRepository}                  repo
     *                                         Repository to search for alignments with the source specified
     *  @param {String}                        sourceId
     *                                         ID in the source field of the alignments to find
     *  @param {Callback1<Array<EcAlignment>>} success
     *                                         Callback triggered on successful search return
     *  @param {Callback1<String>}             [failure]
     *                                         Callback triggered if error searching
     *  @param {Object}                        [paramObj]
     *                                         Parameters to include in the search
     *  @memberOf EcAlignment
     *  @method searchBySource
     *  @static
     */
    constructor.searchBySources = function(repo, sourceIds, success, failure, paramObj) {
        var query = "";
        query = "(source:";
        var noVersions = [];
        for (var i = 0; i < sourceIds.length; i++) {
            var sourceId = sourceIds[i];
            if (i != 0) 
                query += " OR ";
            var noVersion = EcRemoteLinkedData.trimVersionFromUrl(sourceId);
            if (noVersion == sourceId) {
                query += "\"" + sourceId + "\"";
            } else {
                query += "\"" + sourceId + "\" OR source:\"" + noVersion + "\"";
            }
            noVersions.push(noVersion);
        }
        query += ")";
        EcAlignment.search(repo, query, success, failure, paramObj);
    };
    /**
     *  Searches the repository for alignments with a specific ID in the target field
     * 
     *  @param {EcRepository}                  repo
     *                                         Repository to search for alignments with the source specified
     *  @param {String}                        competencyId
     *                                         ID in the target field of the alignments to find
     *  @param {Callback1<Array<EcAlignment>>} success
     *                                         Callback triggered on successful search return
     *  @param {Callback1<String>}             [failure]
     *                                         Callback triggered if error searching
     *  @param {Object}                        [paramObj]
     *                                         Parameters to include in the search
     *  @memberOf EcAlignment
     *  @method searchByCompetency
     *  @static
     */
    constructor.searchByCompetency = function(repo, competencyId, success, failure, paramObj) {
        var query = "";
        var noVersion = EcRemoteLinkedData.trimVersionFromUrl(competencyId);
        if (noVersion == competencyId) {
            query += " AND (source:\"" + competencyId + "\" OR target:\"" + competencyId + "\")";
        } else {
            query += " AND (source:\"" + competencyId + "\" OR source:\"" + noVersion + "\" OR target:\"" + competencyId + "\" OR target:\"" + noVersion + "\")";
        }
        EcAlignment.search(repo, query, success, failure, paramObj);
    };
    /**
     *  Setter for alignment name
     * 
     *  @param {String} name
     *                  name to give this alignment
     *  @memberOf EcAlignment
     *  @method setName
     */
    prototype.setName = function(name) {
        this.name = name;
    };
    /**
     *  Setter for alignment description
     * 
     *  @param {String} description
     *                  description to give this alignment
     *  @memberOf EcAlignment
     *  @method setDescription
     */
    prototype.setDescription = function(description) {
        this.description = description;
    };
    /**
     *  Saves this alignment details on the server corresponding to its ID
     * 
     *  @param {Callback1<String>} success
     *                             Callback triggered on successfully saving the alignment
     *  @param {Callback1<String>} [failure]
     *                             Callback triggered if error while saving alignment
     *  @memberOf EcAlignment
     *  @method save
     */
    prototype.save = function(success, failure, repo) {
        if (this.source == null || this.source == "") {
            var msg = "Source Competency cannot be missing";
            if (failure != null) 
                failure(msg);
             else 
                console.error(msg);
            return;
        }
        if (this.target == null || this.target == "") {
            var msg = "Target Competency cannot be missing";
            if (failure != null) 
                failure(msg);
             else 
                console.error(msg);
            return;
        }
        if (this.relationType == null || this.relationType == "") {
            var msg = "Relation Type cannot be missing";
            if (failure != null) 
                failure(msg);
             else 
                console.error(msg);
            return;
        }
        if (repo == null) 
            EcRepository.save(this, success, failure);
         else 
            repo.saveTo(this, success, failure);
    };
    /**
     *  Deletes the alignment from the server corresponding to its ID
     * 
     *  @param {Callback1<String>} success
     *                             Callback triggered on successfully deleting the alignment
     *  @param {Callback1<String>} [failure]
     *                             Callback triggered if error while deleting alignment
     *  @memberOf EcAlignment
     *  @method _delete
     */
    prototype._delete = function(success, failure) {
        EcRepository.DELETE(this, success, failure);
    };
}, {about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Created by fray on 11/29/17.
 */
var EcConceptScheme = function() {
    ConceptScheme.call(this);
    var me = (this);
    if (EcConceptScheme.template != null) {
        var you = (EcConceptScheme.template);
        for (var key in you) {
            if ((typeof you[key]) != "function") 
                me[key.replace("@", "")] = you[key];
        }
    }
};
EcConceptScheme = stjs.extend(EcConceptScheme, ConceptScheme, [], function(constructor, prototype) {
    constructor.template = null;
    /**
     *  Retrieves a concept scheme from the server, specified by the ID
     * 
     *  @param {String}                 id
     *                                  ID of the concept scheme to retrieve
     *  @param {Callback1<EcConceptScheme>} success
     *                                  Callback triggered after successfully retrieving the concept scheme,
     *                                  returns the retrieved concept scheme
     *  @param {Callback1<String>}      failure
     *                                  Callback triggered if an error occurs while retrieving the concept scheme
     *  @memberOf EcConceptScheme
     *  @method get
     *  @static
     */
    constructor.get = function(id, success, failure) {
        EcRepository.getAs(id, new EcConceptScheme(), success, failure);
    };
    /**
     *  Retrieves a concept scheme from the server in a blocking fashion, specified by the ID
     * 
     *  @param {String}                 id
     *                                  ID of the concept scheme to retrieve
     *  @param {Callback1<EcConceptScheme>} success
     *                                  Callback triggered after successfully retrieving the concept scheme,
     *                                  returns the retrieved concept scheme
     *  @param {Callback1<String>}      failure
     *                                  Callback triggered if an error occurs while retrieving the concept scheme
     *  @memberOf EcConceptScheme
     *  @method getBlocking
     *  @static
     */
    constructor.getBlocking = function(id) {
        return EcRepository.getBlockingAs(id, new EcConceptScheme());
    };
    /**
     *  Searches the repository given for concept schemes using the query passed in
     * 
     *  @param {EcRepository}                 repo
     *                                        Repository to search for concept schemes
     *  @param {String}                       query
     *                                        Query string used to search for a concept scheme
     *  @param {Callback1<Array<EcConceptScheme>} success
     *                                        Callback triggered when the search successfully returns,
     *                                        returns search results
     *  @param {Callback1<String>}            failure
     *                                        Callback triggered if an error occurs while searching
     *  @param {Object}                       paramObj
     *                                        Parameter object for search
     *  @memberOf EcConceptScheme
     *  @method search
     *  @static
     */
    constructor.search = function(repo, query, success, failure, paramObj) {
        EcRepository.searchAs(repo, query, function() {
            return new EcConceptScheme();
        }, success, failure, paramObj);
    };
}, {template: "Object", hasTopConcept: "Concept", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Created by fray on 11/29/17.
 */
var EcConcept = function() {
    Concept.call(this);
    var me = (this);
    if (EcConcept.template != null) {
        var you = (EcConcept.template);
        for (var key in you) {
            if ((typeof you[key]) != "function") 
                me[key.replace("@", "")] = you[key];
        }
    }
};
EcConcept = stjs.extend(EcConcept, Concept, [], function(constructor, prototype) {
    constructor.template = null;
    /**
     *  Retrieves a concept from it's server asynchronously
     * 
     *  @param {String}            id
     *                             ID of the concept to retrieve from the server
     *  @param {Callback1<String>} success
     *                             Callback triggered after retrieving the concept,
     *                             returns the concept retrieved
     *  @param {Callback1<String>} failure
     *                             Callback triggered if error retrieving concept
     *  @memberOf EcConcept
     *  @method get
     *  @static
     */
    constructor.get = function(id, success, failure) {
        EcRepository.getAs(id, new EcConcept(), success, failure);
    };
    /**
     *  Retrieves a concept from it's server synchronously, the call
     *  blocks until it is successful or an error occurs
     * 
     *  @param {String} id
     *                  ID of the concept to retrieve
     *  @return EcConcept
     *  The concept retrieved
     *  @memberOf EcConcept
     *  @method getBlocking
     *  @static
     */
    constructor.getBlocking = function(id) {
        return EcRepository.getBlockingAs(id, new EcConcept());
    };
    /**
     *  Searches a repository for competencies that match the search query
     * 
     *  @param {EcRepository}                  repo
     *                                         Repository to search using the query
     *  @param {String}                        query
     *                                         Query string to pass to the search web service
     *  @param {Callback1<Array<EcConcept>> success
     *                                         Callback triggered after completing the search, returns the results
     *  @param {Callback1<String>}             failure
     *                                         Callback triggered if error searching
     *  @param {Object}                        paramObj
     *                                         Parameter object for search
     *  @memberOf EcConcept
     *  @method search
     *  @static
     */
    constructor.search = function(repo, query, success, failure, paramObj) {
        EcRepository.searchAs(repo, query, function() {
            return new EcConcept();
        }, success, failure, paramObj);
    };
}, {template: "Object", topConceptOf: "ConceptScheme", semanticRelation: "Concept", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  The sequence that assertions should be built as such: 1. Generate the ID. 2.
 *  Add the owner. 3. Set the subject. 4. Set the agent. Further functions may be
 *  called afterwards in any order. WARNING: The modifications of ownership and
 *  readership do not "just work".
 * 
 *  @author fritz.ray@eduworks.com
 */
var EcAssertion = function() {
    Assertion.call(this);
};
EcAssertion = stjs.extend(EcAssertion, Assertion, [], function(constructor, prototype) {
    prototype.equals = function(obj) {
        return this.isId((obj).id);
    };
    constructor.get = function(id, success, failure) {
        EcRepository.getAs(id, new EcAssertion(), success, failure);
    };
    constructor.getBlocking = function(id) {
        return EcRepository.getBlockingAs(id, new EcAssertion());
    };
    constructor.search = function(repo, query, success, failure, paramObj) {
        EcRepository.searchAs(repo, query, function() {
            return new EcAssertion();
        }, success, failure, paramObj);
    };
    prototype.getSubject = function() {
        if (this.subject == null) 
            return null;
        var v = new EcEncryptedValue();
        v.copyFrom(this.subject);
        var codebook = Assertion.getCodebook(this);
        var decryptedString;
        if (codebook != null) 
            decryptedString = v.decryptIntoStringUsingSecret(codebook.subject);
         else {
            decryptedString = v.decryptIntoString();
        }
        if (decryptedString == null) 
            return null;
        return EcPk.fromPem(decryptedString);
    };
    /**
     *  Sets the subject of an assertion. Makes a few assumptions: Owners of the
     *  object should be able to see and change the encrypted value. Owners and
     *  readers of the object should be persisted.
     * 
     *  @param pk
     */
    prototype.setSubject = function(pk) {
        var owners = new Array();
        var readers = null;
        if (this.reader == null) 
            readers = new Array();
         else 
            readers = JSON.parse(JSON.stringify(this.reader));
        if (this.subject != null) {
            if (this.subject.owner != null) 
                owners.concat(this.subject.owner);
            if (this.subject.reader != null) 
                readers.concat(this.subject.reader);
        }
        if (this.owner != null) 
            owners = owners.concat(this.owner);
        readers.push(pk.toPem());
        this.subject = EcEncryptedValue.encryptValue(pk.toPem(), this.id, owners, readers);
    };
    prototype.setSubjectAsync = function(pk, success, failure) {
        var me = this;
        var owners = new Array();
        var readers = null;
        if (this.reader == null) 
            readers = new Array();
         else 
            readers = JSON.parse(JSON.stringify(this.reader));
        if (this.subject != null) {
            if (this.subject.owner != null) 
                owners.concat(this.subject.owner);
            if (this.subject.reader != null) 
                readers.concat(this.subject.reader);
        }
        if (this.owner != null) 
            owners = owners.concat(this.owner);
        readers.push(pk.toPem());
        EcEncryptedValue.encryptValueAsync(pk.toPem(), this.id, owners, readers, function(subject) {
            me.subject = subject;
            success();
        }, failure);
    };
    prototype.getSubjectAsync = function(success, failure) {
        if (this.subject == null) {
            success(null);
            return;
        }
        var v = new EcEncryptedValue();
        v.copyFrom(this.subject);
        var decrypted = function(decryptedString) {
            if (decryptedString == null) 
                failure("Could not decrypt subject.");
             else 
                success(EcPk.fromPem(decryptedString));
        };
        var codebook = Assertion.getCodebook(this);
        if (codebook != null) 
            v.decryptIntoStringUsingSecretAsync(codebook.subject, decrypted, failure);
         else 
            v.decryptIntoStringAsync(decrypted, failure);
    };
    prototype.getAgent = function() {
        if (this.agent == null) 
            return null;
        var v = new EcEncryptedValue();
        v.copyFrom(this.agent);
        var codebook = Assertion.getCodebook(this);
        var decryptedString;
        if (codebook != null) 
            decryptedString = v.decryptIntoStringUsingSecret(codebook.agent);
         else {
            decryptedString = v.decryptIntoString();
        }
        if (decryptedString == null) 
            return null;
        return EcPk.fromPem(decryptedString);
    };
    prototype.setAgent = function(pk) {
        this.agent = EcEncryptedValue.encryptValue(pk.toPem(), this.id, this.subject.owner, this.subject.reader);
    };
    prototype.setAgentAsync = function(pk, success, failure) {
        var me = this;
        EcEncryptedValue.encryptValueAsync(pk.toPem(), this.id, this.subject.owner, this.subject.reader, function(agent) {
            me.agent = agent;
            success();
        }, failure);
    };
    prototype.getAgentAsync = function(success, failure) {
        if (this.agent == null) {
            success(null);
            return;
        }
        var v = new EcEncryptedValue();
        v.copyFrom(this.agent);
        var decrypted = function(decryptedString) {
            if (decryptedString == null) 
                failure("Could not decrypt agent.");
             else 
                success(EcPk.fromPem(decryptedString));
        };
        var codebook = Assertion.getCodebook(this);
        if (codebook != null) 
            v.decryptIntoStringUsingSecretAsync(codebook.agent, decrypted, failure);
         else 
            v.decryptIntoStringAsync(decrypted, failure);
    };
    prototype.getSubjectName = function() {
        if (this.subject == null) 
            return "Nobody";
        var subjectPk = this.getSubject();
        var name = EcAssertion.getNameByPkBlocking(subjectPk);
        if (name != null) 
            return name;
        return "Unknown Subject";
    };
    prototype.getSubjectNameAsync = function(success, failure) {
        if (this.subject == null) {
            success("Nobody");
            return;
        }
        this.getSubjectAsync(EcAssertion.getNameByPk(success, failure, "Unknown Subject"), failure);
    };
    prototype.getAgentName = function() {
        if (this.agent == null) 
            return "Nobody";
        var agentPk = this.getAgent();
        var name = EcAssertion.getNameByPkBlocking(agentPk);
        if (name != null) 
            return name;
        return "Unknown Agent";
    };
    prototype.getAgentNameAsync = function(success, failure) {
        if (this.subject == null) {
            success("Nobody");
            return;
        }
        this.getAgentAsync(EcAssertion.getNameByPk(success, failure, "Unknown Agent"), failure);
    };
    constructor.getNameByPk = function(success, failure, dflt) {
        return function(pk) {
            var repoHelper = new EcAsyncHelper();
            repoHelper.each(EcRepository.repos, function(ecRepository, callback0) {
                var url = ecRepository.selectedServer;
                if (url == null) {
                    callback0();
                    return;
                }
                if (url.endsWith("/") == false) 
                    url += "/";
                url += "data/" + pk.fingerprint();
                EcRepository.get(url, function(personOrOrganization) {
                    var e = new EcEncryptedValue();
                    if (personOrOrganization.isAny(e.getTypes())) {
                        e.copyFrom(personOrOrganization);
                        e.decryptIntoObjectAsync(function(decryptedPersonOrOrganization) {
                            var name = Thing.getDisplayStringFrom((decryptedPersonOrOrganization)["name"]);
                            if (name != null && repoHelper.counter != -1) {
                                success(name);
                                repoHelper.stop();
                            } else {
                                callback0();
                                return;
                            }
                        }, function(s) {
                            callback0();
                        });
                    } else {
                        var name = Thing.getDisplayStringFrom((personOrOrganization)["name"]);
                        if (name != null && repoHelper.counter != -1) {
                            success(name);
                            repoHelper.stop();
                        } else {
                            callback0();
                            return;
                        }
                    }
                }, function(s) {
                    callback0();
                });
            }, function(strings) {
                var identity = EcIdentityManager.getIdentity(pk);
                if (identity != null && identity.displayName != null) {
                    success(identity.displayName + " (You)");
                    return;
                }
                var contact = EcIdentityManager.getContact(pk);
                if (contact != null && contact.displayName != null) {
                    success(contact.displayName);
                    return;
                }
                success(dflt);
            });
        };
    };
    constructor.getNameByPkBlocking = function(agentPk) {
        for (var i = 0; i < EcRepository.repos.length; i++) {
            var url = EcRepository.repos[i].selectedServer;
            if (url == null) 
                continue;
            if (url.endsWith("/") == false) 
                url += "/";
            url += "data/" + agentPk.fingerprint();
            var personOrOrganization = EcRepository.getBlocking(url);
            if (personOrOrganization == null) 
                continue;
            var e = new EcEncryptedValue();
            if (personOrOrganization.isAny(e.getTypes())) {
                e.copyFrom(personOrOrganization);
                var decryptedPersonOrOrganization = e.decryptIntoObject();
                if (decryptedPersonOrOrganization != null) 
                    personOrOrganization = decryptedPersonOrOrganization;
            }
            var name = Thing.getDisplayStringFrom((personOrOrganization)["name"]);
            if (name != null) 
                return name;
        }
        var identity = EcIdentityManager.getIdentity(agentPk);
        if (identity != null && identity.displayName != null) 
            return identity.displayName + " (You)";
        var contact = EcIdentityManager.getContact(agentPk);
        if (contact != null && contact.displayName != null) 
            return contact.displayName;
        return null;
    };
    prototype.getAssertionDate = function() {
        if (this.assertionDate == null) 
            return null;
        var v = new EcEncryptedValue();
        v.copyFrom(this.assertionDate);
        var codebook = Assertion.getCodebook(this);
        var decryptedString;
        if (codebook != null) 
            decryptedString = v.decryptIntoStringUsingSecret(codebook.assertionDate);
         else {
            decryptedString = v.decryptIntoString();
        }
        if (decryptedString == null) 
            return null;
        return Long.parseLong(decryptedString);
    };
    prototype.setAssertionDate = function(assertionDateMs) {
        this.assertionDate = EcEncryptedValue.encryptValue(assertionDateMs.toString(), this.id, this.subject.owner, this.subject.reader);
    };
    prototype.setAssertionDateAsync = function(assertionDateMs, success, failure) {
        var me = this;
        EcEncryptedValue.encryptValueAsync(assertionDateMs.toString(), this.id, this.subject.owner, this.subject.reader, function(assertionDate) {
            me.assertionDate = assertionDate;
            success();
        }, failure);
    };
    prototype.getAssertionDateAsync = function(success, failure) {
        if (this.assertionDate == null) {
            success(null);
            return;
        }
        var v = new EcEncryptedValue();
        v.copyFrom(this.assertionDate);
        var decrypted = function(decryptedString) {
            if (decryptedString == null) 
                failure("Could not decrypt assertion date.");
             else 
                success(Long.parseLong(decryptedString));
        };
        var codebook = Assertion.getCodebook(this);
        if (codebook != null) 
            v.decryptIntoStringUsingSecretAsync(codebook.assertionDate, decrypted, failure);
         else 
            v.decryptIntoStringAsync(decrypted, failure);
    };
    prototype.getExpirationDate = function() {
        if (this.expirationDate == null) 
            return null;
        var v = new EcEncryptedValue();
        var codebook = Assertion.getCodebook(this);
        var decryptedString;
        v.copyFrom(this.expirationDate);
        if (codebook != null) 
            decryptedString = v.decryptIntoStringUsingSecret(codebook.expirationDate);
         else {
            decryptedString = v.decryptIntoString();
        }
        if (decryptedString == null) 
            return null;
        return Long.parseLong(decryptedString);
    };
    prototype.setExpirationDate = function(expirationDateMs) {
        this.expirationDate = EcEncryptedValue.encryptValue(expirationDateMs.toString(), this.id, this.subject.owner, this.subject.reader);
    };
    prototype.setExpirationDateAsync = function(expirationDateMs, success, failure) {
        var me = this;
        EcEncryptedValue.encryptValueAsync(expirationDateMs.toString(), this.id, this.subject.owner, this.subject.reader, function(expirationDate) {
            me.expirationDate = expirationDate;
            success();
        }, failure);
    };
    prototype.getExpirationDateAsync = function(success, failure) {
        if (this.expirationDate == null) {
            success(null);
            return;
        }
        var v = new EcEncryptedValue();
        v.copyFrom(this.expirationDate);
        var decrypted = function(decryptedString) {
            if (decryptedString == null) 
                failure("Could not decrypt expiration date.");
             else 
                success(Long.parseLong(decryptedString));
        };
        var codebook = Assertion.getCodebook(this);
        if (codebook != null) 
            v.decryptIntoStringUsingSecretAsync(codebook.expirationDate, decrypted, failure);
         else 
            v.decryptIntoStringAsync(decrypted, failure);
    };
    prototype.getEvidenceCount = function() {
        if (this.evidence == null) 
            return 0;
        return this.evidence.length;
    };
    prototype.getEvidence = function(index) {
        if (this.evidence == null) 
            return null;
        var v = new EcEncryptedValue();
        v.copyFrom(this.evidence[index]);
        var codebook = Assertion.getCodebook(this);
        var decryptedString;
        if (codebook != null) 
            decryptedString = v.decryptIntoStringUsingSecret(codebook.evidence[index]);
         else {
            decryptedString = v.decryptIntoString();
        }
        return decryptedString;
    };
    prototype.getEvidencesAsync = function(success, failure) {
        var results = new Array();
        if (this.evidence != null) 
            new EcAsyncHelper().each(this.evidence, function(e, callback0) {
                e.decryptIntoStringAsync(function(str) {
                    results.push(str);
                    callback0();
                }, callback0);
            }, function(strings) {
                success(results);
            });
         else 
            success(results);
    };
    prototype.getEvidenceAsync = function(index, success, failure) {
        if (this.evidence[index] == null) {
            success(null);
            return;
        }
        var v = new EcEncryptedValue();
        v.copyFrom(this.evidence[index]);
        var decrypted = function(decryptedString) {
            if (decryptedString == null) 
                failure("Could not decrypt evidence.");
             else 
                success(decryptedString);
        };
        var codebook = Assertion.getCodebook(this);
        if (codebook != null) 
            v.decryptIntoStringUsingSecretAsync(codebook.evidence[index], decrypted, failure);
         else 
            v.decryptIntoStringAsync(decrypted, failure);
    };
    prototype.getDecayFunction = function() {
        if (this.decayFunction == null) 
            return null;
        var v = new EcEncryptedValue();
        v.copyFrom(this.decayFunction);
        var codebook = Assertion.getCodebook(this);
        var decryptedString;
        if (codebook != null) 
            decryptedString = v.decryptIntoStringUsingSecret(codebook.decayFunction);
         else {
            decryptedString = v.decryptIntoString();
        }
        if (decryptedString == null) 
            return null;
        return decryptedString;
    };
    prototype.setDecayFunction = function(decayFunctionText) {
        this.decayFunction = EcEncryptedValue.encryptValue(decayFunctionText.toString(), this.id, this.subject.owner, this.subject.reader);
    };
    prototype.setDecayFunctionAsync = function(decayFunctionText, success, failure) {
        var me = this;
        EcEncryptedValue.encryptValueAsync(decayFunctionText, this.id, this.subject.owner, this.subject.reader, function(decayFunction) {
            me.decayFunction = decayFunction;
            success();
        }, failure);
    };
    prototype.getDecayFunctionAsync = function(success, failure) {
        if (this.decayFunction == null) {
            success(null);
            return;
        }
        var v = new EcEncryptedValue();
        v.copyFrom(this.decayFunction);
        var decrypted = function(decryptedString) {
            if (decryptedString == null) 
                failure("Could not decrypt decay function.");
             else 
                success(decryptedString);
        };
        var codebook = Assertion.getCodebook(this);
        if (codebook != null) 
            v.decryptIntoStringUsingSecretAsync(codebook.decayFunction, decrypted, failure);
         else 
            v.decryptIntoStringAsync(decrypted, failure);
    };
    prototype.getNegative = function() {
        if (this.negative == null) 
            return false;
        var v = new EcEncryptedValue();
        v.copyFrom(this.negative);
        var codebook = Assertion.getCodebook(this);
        var decryptedString;
        if (codebook != null) 
            decryptedString = v.decryptIntoStringUsingSecret(codebook.negative);
         else {
            decryptedString = v.decryptIntoString();
        }
        if (decryptedString != null) 
            decryptedString.toLowerCase();
        return "true".equals(decryptedString);
    };
    prototype.setNegative = function(negativeB) {
        this.negative = EcEncryptedValue.encryptValue(negativeB.toString(), this.id, this.subject.owner, this.subject.reader);
    };
    prototype.setNegativeAsync = function(negativeB, success, failure) {
        var me = this;
        EcEncryptedValue.encryptValueAsync(negativeB.toString(), this.id, this.subject.owner, this.subject.reader, function(negative) {
            me.negative = negative;
            success();
        }, failure);
    };
    prototype.getNegativeAsync = function(success, failure) {
        if (this.negative == null) {
            success(null);
            return;
        }
        var v = new EcEncryptedValue();
        v.copyFrom(this.negative);
        var decrypted = function(decryptedString) {
            if (decryptedString == null) 
                if (decryptedString == null) {
                    failure("Could not decrypt negative.");
                    return;
                }
            if (decryptedString != null) 
                decryptedString.toLowerCase();
            success("true".equals(decryptedString));
        };
        var codebook = Assertion.getCodebook(this);
        if (codebook != null) 
            v.decryptIntoStringUsingSecretAsync(codebook.negative, decrypted, failure);
         else 
            v.decryptIntoStringAsync(decrypted, failure);
    };
    prototype.setCompetency = function(competencyUrl) {
        this.competency = competencyUrl;
    };
    prototype.setLevel = function(levelUrl) {
        this.level = levelUrl;
    };
    prototype.setConfidence = function(confidenceZeroToOne) {
        this.confidence = confidenceZeroToOne;
    };
    prototype.setEvidence = function(evidences) {
        var encryptedValues = new Array();
        for (var i = 0; i < evidences.length; i++) 
            encryptedValues.push(EcEncryptedValue.encryptValue(evidences[i], this.id, this.subject.owner, this.subject.reader));
        this.evidence = encryptedValues;
    };
    prototype.setEvidenceAsync = function(evidences, success, failure) {
        var me = this;
        var encryptedValues = new Array();
        new EcAsyncHelper().each(evidences, function(s, callback0) {
            EcEncryptedValue.encryptValueAsync(s, me.id, me.subject.owner, me.subject.reader, function(ecEncryptedValue) {
                encryptedValues.push(ecEncryptedValue);
                callback0();
            }, callback0);
        }, function(strings) {
            me.evidence = encryptedValues;
            success();
        });
    };
    prototype.save = function(success, failure, repo) {
        if (this.competency == null || this.competency == "") {
            var msg = "Failing to save: Competency cannot be missing";
            if (failure != null) 
                failure(msg);
             else 
                console.error(msg);
            return;
        }
        if (this.subject == null) {
            var msg = "Failing to save: Subject cannot be missing";
            if (failure != null) 
                failure(msg);
             else 
                console.error(msg);
            return;
        }
        if (this.agent == null) {
            var msg = "Failing to save: Agent cannot be missing";
            if (failure != null) 
                failure(msg);
             else 
                console.error(msg);
            return;
        }
        if (this.confidence == null) {
            var msg = "Failing to save: Confidence cannot be missing";
            if (failure != null) 
                failure(msg);
             else 
                console.error(msg);
            return;
        }
        if (this.assertionDate == null) {
            var msg = "Failing to save: Assertion Date cannot be missing";
            if (failure != null) 
                failure(msg);
             else 
                console.error(msg);
            return;
        }
        if (this.decayFunction == null) {
            var msg = "Failing to save: Decay Function cannot be missing";
            if (failure != null) 
                failure(msg);
             else 
                console.error(msg);
            return;
        }
        if (repo == null) 
            EcRepository.save(this, success, failure);
         else 
            repo.saveTo(this, success, failure);
    };
    prototype.addReader = function(newReader) {
        if (this.agent != null) {
            this.agent.addReader(newReader);
        }
        if (this.assertionDate != null) {
            this.assertionDate.addReader(newReader);
        }
        if (this.decayFunction != null) {
            this.decayFunction.addReader(newReader);
        }
        if (this.evidence != null) 
            for (var i = 0; i < this.evidence.length; i++) {
                this.evidence[i].addReader(newReader);
            }
        if (this.expirationDate != null) {
            this.expirationDate.addReader(newReader);
        }
        if (this.negative != null) {
            this.negative.addReader(newReader);
        }
        if (this.subject != null) {
            this.subject.addReader(newReader);
        }
        EcRemoteLinkedData.prototype.addReader.call(this, newReader);
    };
    prototype.removeReader = function(newReader) {
        if (this.agent != null) {
            this.agent.removeReader(newReader);
        }
        if (this.assertionDate != null) {
            this.assertionDate.removeReader(newReader);
        }
        if (this.decayFunction != null) {
            this.decayFunction.removeReader(newReader);
        }
        if (this.evidence != null) 
            for (var i = 0; i < this.evidence.length; i++) {
                this.evidence[i].removeReader(newReader);
            }
        if (this.expirationDate != null) {
            this.expirationDate.removeReader(newReader);
        }
        if (this.negative != null) {
            this.negative.removeReader(newReader);
        }
        if (this.subject != null) {
            this.subject.removeReader(newReader);
        }
        EcRemoteLinkedData.prototype.removeReader.call(this, newReader);
    };
    prototype.addReaderAsync = function(newReader, success, failure) {
        var ary = new Array();
        if (this.agent != null) {
            ary.push(this.agent);
        }
        if (this.assertionDate != null) {
            ary.push(this.assertionDate);
        }
        if (this.decayFunction != null) {
            ary.push(this.decayFunction);
        }
        if (this.evidence != null) 
            for (var i = 0; i < this.evidence.length; i++) {
                ary.push(this.evidence[i]);
            }
        if (this.expirationDate != null) {
            ary.push(this.expirationDate);
        }
        if (this.negative != null) {
            ary.push(this.negative);
        }
        if (this.subject != null) {
            ary.push(this.subject);
        }
        EcRemoteLinkedData.prototype.addReader.call(this, newReader);
        var eah = new EcAsyncHelper();
        eah.each(ary, function(ecEncryptedValue, callback0) {
            ecEncryptedValue.addReaderAsync(newReader, callback0, function(s) {
                if (!eah.isStopped()) {
                    eah.stop();
                    failure("Failed to add reader to an assertion.");
                }
            });
        }, function(strings) {
            success();
        });
    };
    prototype.removeReaderAsync = function(oldReader, success, failure) {
        var ary = new Array();
        if (this.agent != null) {
            ary.push(this.agent);
        }
        if (this.assertionDate != null) {
            ary.push(this.assertionDate);
        }
        if (this.decayFunction != null) {
            ary.push(this.decayFunction);
        }
        if (this.evidence != null) 
            for (var i = 0; i < this.evidence.length; i++) {
                ary.push(this.evidence[i]);
            }
        if (this.expirationDate != null) {
            ary.push(this.expirationDate);
        }
        if (this.negative != null) {
            ary.push(this.negative);
        }
        if (this.subject != null) {
            ary.push(this.subject);
        }
        EcRemoteLinkedData.prototype.removeReader.call(this, oldReader);
        var eah = new EcAsyncHelper();
        eah.each(ary, function(ecEncryptedValue, callback0) {
            ecEncryptedValue.removeReaderAsync(oldReader, callback0, function(s) {
                if (!eah.isStopped()) {
                    eah.stop();
                    failure("Failed to remove reader to an assertion.");
                }
            });
        }, function(strings) {
            success();
        });
    };
    prototype.getSearchStringByTypeAndCompetency = function(competency) {
        return "(" + this.getSearchStringByType() + " AND competency:\"" + competency.shortId() + "\")";
    };
}, {codebooks: "Object", subject: "EcEncryptedValue", agent: "EcEncryptedValue", evidence: {name: "Array", arguments: ["EcEncryptedValue"]}, assertionDate: "EcEncryptedValue", expirationDate: "EcEncryptedValue", decayFunction: "EcEncryptedValue", negative: "EcEncryptedValue", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Implementation of a Level object with methods for interacting with CASS
 *  services on a server.
 * 
 *  @author fritz.ray@eduworks.com
 *  @author devlin.junker@eduworks.com
 *  @module org.cassproject
 *  @class EcLevel
 *  @constructor
 *  @extends Level
 */
var EcLevel = function() {
    Level.call(this);
};
EcLevel = stjs.extend(EcLevel, Level, [], function(constructor, prototype) {
    /**
     *  Retrieves a level from the server specified by its ID
     * 
     *  @param {String}             id
     *                              ID of the level to retrieve
     *  @param {Callback1<EcLevel>} success
     *                              Callback triggered when successfully retrieving the level,
     *                              returns the level
     *  @param {Callback1<String>}  failure
     *                              Callback triggered if error occurs when retrieving the level
     *  @memberOf EcLevel
     *  @method get
     *  @static
     */
    constructor.get = function(id, success, failure) {
        EcRepository.getAs(id, new EcLevel(), success, failure);
    };
    /**
     *  Retrieves a level from it's server synchronously, the call
     *  blocks until it is successful or an error occurs
     * 
     *  @param {String} id
     *                  ID of the level to retrieve
     *  @return EcLevel
     *  The level retrieved
     *  @memberOf EcLevel
     *  @method getBlocking
     *  @static
     */
    constructor.getBlocking = function(id) {
        return EcRepository.getBlockingAs(id, new EcLevel());
    };
    /**
     *  Searches for levels with a string query
     * 
     *  @param {EcRepository}              repo
     *                                     Repository to search for levels
     *  @param {String}                    query
     *                                     query string to use in search
     *  @param {Callback1<Array<EcLevel>>} success
     *                                     Callback triggered when searches successfully
     *  @param {Callback1<String>}         failure
     *                                     Callback triggered if an error occurs while searching
     *  @param {Object}                    paramObj
     *                                     Search parameters object to pass in
     *  @memberOf EcLevel
     *  @method search
     *  @static
     */
    constructor.search = function(repo, query, success, failure, paramObj) {
        EcRepository.searchAs(repo, query, function() {
            return new EcLevel();
        }, success, failure, paramObj);
    };
    /**
     *  Searches for levels using a competency that the results must be related to
     * 
     *  @param {EcRepository}              repo
     *                                     Repository to search for levels
     *  @param {String}                    competencyId
     *                                     competency ID that the levels are rleated to
     *  @param {Callback1<Array<EcLevel>>} success
     *                                     Callback triggered when searches successfully
     *  @param {Callback1<String>}         failure
     *                                     Callback triggered if an error occurs while searching
     *  @param {Object}                    paramObj
     *                                     Search parameters object to pass in
     *  @memberOf EcLevel
     *  @method searchByCompetency
     *  @static
     */
    constructor.searchByCompetency = function(repo, competencyId, success, failure, paramObj) {
        if (competencyId == null || competencyId == "") {
            failure("No Competency Specified");
            return;
        }
        var query = "competency:\"" + competencyId + "\" OR competency:\"" + EcRemoteLinkedData.trimVersionFromUrl(competencyId) + "\"";
        EcLevel.search(repo, competencyId, success, failure, paramObj);
    };
    /**
     *  Adds a relationship between this level and a target level to define
     *  how they correspond to one another
     * 
     *  @param {EcLevel} targetLevel
     *                   Target level of the relationship
     *  @param {String}  alignmentType
     *                   Type of relationship
     *  @param {EcPpk}   identity
     *                   Private key that will own the new relationship
     *  @param {String}  server
     *                   URL Prefix of the new relationship ID (Server it will be saved on)
     *  @memberOf EcLevel
     *  @method addRelationship
     */
    prototype.addRelationship = function(targetLevel, alignmentType, identity, serverUrl, success, failure, repo) {
        var a = new EcAlignment();
        a.source = this.id;
        a.target = targetLevel.id;
        a.relationType = alignmentType;
        a.addOwner(identity.toPk());
        if (repo == null || repo.selectedServer.indexOf(serverUrl) != -1) 
            a.generateId(serverUrl);
         else 
            a.generateShortId(serverUrl);
        a.signWith(identity);
        a.save(success, failure, repo);
    };
    /**
     *  Method to set the name of this level
     * 
     *  @param {String} name
     *                  Name to set on the level
     *  @memberOf EcLevel
     *  @method setName
     */
    prototype.setName = function(name) {
        this.name = name;
    };
    /**
     *  Method to set the description of the level
     * 
     *  @param {String} description
     *                  Description to set on the level
     *  @memberOf EcLevel
     *  @method setDescription
     */
    prototype.setDescription = function(description) {
        this.description = description;
    };
    /**
     *  Saves this levels details to the server
     * 
     *  @param {Callback1<String>} success
     *                             Callback triggered on successfully saving the level to the server
     *  @param {Callback1<String>} failure
     *                             Callback triggered if error occurs while saving the level to the server
     *  @memberOf EcLevel
     *  @method save
     */
    prototype.save = function(success, failure, repo) {
        if (this.name == null || this.name == "") {
            var msg = "Level name cannot be empty";
            if (failure != null) 
                failure(msg);
             else 
                console.error(msg);
            return;
        }
        if (this.competency == null || this.competency == "") {
            var msg = "Level's Competency cannot be empty";
            if (failure != null) 
                failure(msg);
             else 
                console.error(msg);
            return;
        }
        if (repo == null) 
            EcRepository.save(this, success, failure);
         else 
            repo.saveTo(this, success, failure);
    };
    /**
     *  Deletes the level from it's repository
     * 
     *  @param {Callback1<String>} success
     *                             Callback triggered when the level is successfully deleted from the server
     *  @param {Callback1<String>} failure
     *                             Callback triggered if an error occurs while deleting the level
     *  @memberOf EcLevel
     *  @method _delete
     */
    prototype._delete = function(success, failure) {
        EcRepository.DELETE(this, success, failure);
    };
}, {about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Implementation of a Competency object with methods for interacting with CASS
 *  services on a server.
 * 
 *  @author fritz.ray@eduworks.com
 *  @author devlin.junker@eduworks.com
 *  @module org.cassproject
 *  @class EcCompetency
 *  @constructor
 *  @extends Competency
 */
var EcCompetency = function() {
    Competency.call(this);
    var me = (this);
    if (EcCompetency.template != null) {
        var you = (EcCompetency.template);
        for (var key in you) {
            if ((typeof you[key]) != "function") 
                me[key.replace("@", "")] = you[key];
        }
    }
};
EcCompetency = stjs.extend(EcCompetency, Competency, [], function(constructor, prototype) {
    constructor.relDone = {};
    constructor.levelDone = {};
    constructor.template = null;
    prototype.equals = function(obj) {
        return this.isId((obj).id);
    };
    /**
     *  Retrieves a competency from it's server asynchronously
     * 
     *  @param {String}            id
     *                             ID of the competency to retrieve from the server
     *  @param {Callback1<String>} success
     *                             Callback triggered after retrieving the competency,
     *                             returns the competency retrieved
     *  @param {Callback1<String>} failure
     *                             Callback triggered if error retrieving competency
     *  @memberOf EcCompetency
     *  @method get
     *  @static
     */
    constructor.get = function(id, success, failure) {
        EcRepository.getAs(id, new EcCompetency(), success, failure);
    };
    /**
     *  Retrieves a competency from it's server synchronously, the call
     *  blocks until it is successful or an error occurs
     * 
     *  @param {String} id
     *                  ID of the competency to retrieve
     *  @return EcCompetency
     *  The competency retrieved
     *  @memberOf EcCompetency
     *  @method getBlocking
     *  @static
     */
    constructor.getBlocking = function(id) {
        return EcRepository.getBlockingAs(id, new EcCompetency());
    };
    /**
     *  Searches a repository for competencies that match the search query
     * 
     *  @param {EcRepository}                  repo
     *                                         Repository to search using the query
     *  @param {String}                        query
     *                                         Query string to pass to the search web service
     *  @param {Callback1<Array<EcCompetency>> success
     *                                         Callback triggered after completing the search, returns the results
     *  @param {Callback1<String>}             failure
     *                                         Callback triggered if error searching
     *  @param {Object}                        paramObj
     *                                         Parameter object for search
     *  @memberOf EcCompetency
     *  @method search
     *  @static
     */
    constructor.search = function(repo, query, success, failure, paramObj) {
        EcRepository.searchAs(repo, query, function() {
            return new EcCompetency();
        }, success, failure, paramObj);
    };
    /**
     *  Adds a new alignment on the server specified with this competency as its
     *  source and the specified target competency
     * 
     *  @param {EcCompetency}      target
     *                             Competency to be related with
     *  @param {String}            alignmentType
     *                             String defining the relationship type
     *  @param {EcPpk}             owner
     *                             Private Key that will own the relationship created
     *  @param {String}            server
     *                             URL Prefix of the new relationship (Server it will be saved on)
     *  @param {Callback1<String>} success
     *                             Callback triggered after successfully creating and saving the relationship
     *  @param {Callback1<String>} [failure]
     *                             Callback triggered if error creating and saving relationship
     *  @return EcAlignment
     *  Created relationship
     *  @memberOf EcCompetency
     *  @method addAlignment
     */
    prototype.addAlignment = function(target, alignmentType, owner, serverUrl, success, failure, repo) {
        var a = new EcAlignment();
        if (repo == null || repo.selectedServer.indexOf(serverUrl) != -1) 
            a.generateId(serverUrl);
         else 
            a.generateShortId(serverUrl);
        a.source = this.shortId();
        a.target = target.shortId();
        a.relationType = alignmentType;
        a.addOwner(owner.toPk());
        a.save(success, failure, repo);
        return a;
    };
    /**
     *  Searches the repository given for any relationships that contain this competency
     * 
     *  @param {EcRepository}                  repo
     *                                         Repository to search for relationships
     *  @param {Callback1<EcAlignment>}        eachSuccess
     *                                         Callback triggered for each relationship found
     *  @param {Callback1<String>}             failure
     *                                         Callback triggered if an error finding relationships
     *  @param {Callback1<Array<EcAlignment>>} successAll
     *                                         Callback triggered once all of the relationships have been found
     *  @memberOf EcCompetency
     *  @method relations
     */
    prototype.relations = function(repo, eachSuccess, failure, successAll) {
        this.relationships(repo, eachSuccess, failure, successAll);
    };
    /**
     *  Searches the repository given for any relationships that contain this competency
     * 
     *  @param {EcRepository}                  repo
     *                                         Repository to search for relationships
     *  @param {Callback1<EcAlignment>}        eachSuccess
     *                                         Callback triggered for each relationship found
     *  @param {Callback1<String>}             failure
     *                                         Callback triggered if an error finding relationships
     *  @param {Callback1<Array<EcAlignment>>} successAll
     *                                         Callback triggered once all of the relationships have been found
     *  @memberOf EcCompetency
     *  @method relations
     *  @deprecated
     */
    prototype.relationships = function(repo, eachSuccess, failure, successAll) {
        EcAlignment.search(repo, "source:\"" + this.id + "\" OR target:\"" + this.id + "\" OR source:\"" + this.shortId() + "\" OR target:\"" + this.shortId() + "\"", function(results) {
            for (var i = 0; i < results.length; i++) 
                eachSuccess(results[i]);
            successAll(results);
        }, failure, new Object());
    };
    /**
     *  Adds a new level on the server specified for this competency.
     * 
     *  @param {String}            name
     *                             Name of the new level to create
     *  @param {String}            description
     *                             Description of the new level to create
     *  @param {String}            owner
     *                             Private key of the owner of the new level
     *  @param {String}            server
     *                             URL Prefix for the new level's ID (Server saved on)
     *  @param {Callback1<String>} success
     *                             Callback triggered after successfully creating and saving the level
     *  @param {Callback1<String>} failure
     *                             Callback triggered if an error creating and saving the level
     *  @return EcLevel
     *  Level created
     *  @memberOf EcCompetency
     *  @method addLevel
     */
    prototype.addLevel = function(name, description, owner, serverUrl, success, failure, repo) {
        var l = new EcLevel();
        if (repo == null || repo.selectedServer.indexOf(serverUrl) != -1) 
            l.generateId(serverUrl);
         else 
            l.generateShortId(serverUrl);
        l.competency = this.shortId();
        l.description = description;
        l.name = name;
        l.addOwner(owner.toPk());
        l.save(success, failure, repo);
        return l;
    };
    /**
     *  Searches the repository given for any levels of this competency
     * 
     *  @param {EcRepository}              repo
     *                                     Repository to search for levels
     *  @param {Callback1<EcLevel>}        success
     *                                     Callback triggered for each level found
     *  @param {Callback1<String>}         failure
     *                                     Callback triggered if an error finding levels
     *  @param {Callback1<Array<EcLevel>>} successAll
     *                                     Callback triggered once all of the levels have been found
     *  @memberOf EcCompetency
     *  @method levels
     */
    prototype.levels = function(repo, eachSuccess, failure, successAll) {
        var query = "competency:\"" + this.id + "\" OR competency:\"" + this.shortId() + "\"";
        EcLevel.search(repo, query, function(results) {
            for (var i = 0; i < results.length; i++) 
                eachSuccess(results[i]);
            successAll(results);
        }, failure, new Object());
    };
    /**
     *  Adds a new rollup rule on the server specified for this competency
     * 
     *  @param {String}            name
     *                             Name of the rollup rule to create
     *  @param {String}            description
     *                             Description of the rollup rule to create
     *  @param {EcPpk}             owner
     *                             Private key that will own the new rollup rule
     *  @param {String}            server
     *                             URL Prefix for the new rollup rule's ID (Server that it will be saved on)
     *  @param {Callback1<String>} success
     *                             Callback triggered if successfully save the rollup rule
     *  @param {Callback1<String>} failure
     *                             Callback triggered fi error during save of rollup rule
     *  @return EcRollupRule
     *  Created rollup rule
     *  @memberOf EcCompetency
     *  @method addRollupRule
     */
    prototype.addRollupRule = function(name, description, owner, serverUrl, success, failure, repo) {
        var r = new EcRollupRule();
        if (repo == null) 
            if (repo == null || repo.selectedServer.indexOf(serverUrl) != -1) 
                r.generateId(serverUrl);
             else 
                r.generateShortId(serverUrl);
        r.competency = this.shortId();
        r.description = description;
        r.name = name;
        r.addOwner(owner.toPk());
        r.save(success, failure, repo);
        return r;
    };
    /**
     *  Searches the repository given for any rollup rules of this competency
     * 
     *  @param {EcRepository}                  repo
     *                                         Repository to search for levels
     *  @param {Callback1<EcRollupRule>}       success
     *                                         Callback triggered for each rollup rule found
     *  @param {Callback1<String>}             failure
     *                                         Callback triggered if an error finding rollup rule
     *  @param {Callback1<Array<EcRollupRule>} successAll
     *                                         Callback triggered once all of the rollup rules have been found
     *  @memberOf EcCompetency
     *  @method rollupRules
     */
    prototype.rollupRules = function(repo, eachSuccess, failure, successAll) {
        var query = "competency:\"" + this.id + "\" OR competency:\"" + this.shortId() + "\"";
        EcRollupRule.search(repo, query, function(results) {
            for (var i = 0; i < results.length; i++) 
                eachSuccess(results[i]);
            successAll(results);
        }, failure, new Object());
    };
    /**
     *  Method to set competency scope
     * 
     *  @param {String} scope
     *                  Scope to set for its competency
     *  @memberOf EcCompetency
     *  @method setScope
     */
    prototype.setScope = function(scope) {
        this.scope = scope;
    };
    /**
     *  Saves the competency details to the server
     * 
     *  @param {Callback1<String>} success
     *                             Callback triggered on successfully saving the competency
     *  @param {Callback1<String>} failure
     *                             Callback triggered if error saving competency
     *  @memberOf EcCompetency
     *  @method save
     */
    prototype.save = function(success, failure, repo) {
        if (this.name == null || this.name == "") {
            var msg = "Competency Name can not be empty";
            if (failure != null) 
                failure(msg);
             else 
                console.error(msg);
            return;
        }
        if (repo == null) 
            EcRepository.save(this, success, failure);
         else 
            repo.saveTo(this, success, failure);
    };
    /**
     *  Deletes the competency from the server
     *  <p>
     *  TODO: Delete rollup rules?
     * 
     *  @param {Callback1<String>} success
     *                             Callback triggered on successful deleting the competency
     *  @param {Callback1<String>} failure
     *                             Callback triggered if error deleting the competency
     *  @param {EcRepository}      repo
     *                             Repository to delete from and to check for levels or relationships to delete
     *  @memberOf EcCompetency
     *  @method _delete
     */
    prototype._delete = function(success, failure, repo) {
        var me = this;
        EcRepository.DELETE(this, function(p1) {
            if (repo != null) {
                me.relationships(repo, function(p1) {
                    for (var i = 0; i < EcIdentityManager.ids.length; i++) {
                        if (p1.canEdit(EcIdentityManager.ids[i].ppk.toPk())) {
                            p1._delete(null, function(p1) {
                                if (failure != null) 
                                    failure("Unable to Delete Competency Relation");
                                 else 
                                    console.error("Unable to Delete Competency Relation");
                            });
                            return;
                        }
                    }
                }, failure, function(p1) {
                    if (EcCompetency.levelDone[this.id]) {
                        if (success != null) 
                            success("");
                    } else {
                        EcCompetency.relDone[this.id] = true;
                    }
                });
                me.levels(repo, function(p1) {
                    for (var i = 0; i < EcIdentityManager.ids.length; i++) {
                        if (p1.canEdit(EcIdentityManager.ids[i].ppk.toPk())) {
                            p1._delete(null, function(p1) {
                                if (failure != null) 
                                    failure("Unable to Delete Competency Relation");
                                 else 
                                    console.error("Unable to Delete Competency Relation");
                            });
                            return;
                        }
                    }
                }, failure, function(p1) {
                    if (EcCompetency.relDone[this.id]) {
                        if (success != null) 
                            success("");
                    } else {
                        EcCompetency.levelDone[this.id] = true;
                    }
                });
            } else {
                if (success != null) 
                    success(p1);
            }
        }, failure);
    };
}, {relDone: {name: "Map", arguments: [null, null]}, levelDone: {name: "Map", arguments: [null, null]}, template: "Object", about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});
/**
 *  Implementation of a Framework object with methods for interacting with CASS
 *  services on a server.
 * 
 *  @author fritz.ray@eduworks.com
 *  @author devlin.junker@eduworks.com
 *  @module org.cassproject
 *  @class EcFramework
 *  @constructor
 *  @extends Framework
 */
var EcFramework = function() {
    Framework.call(this);
    var me = (this);
    if (EcFramework.template != null) {
        var you = (EcFramework.template);
        for (var key in you) {
            if ((typeof you[key]) != "function") 
                me[key.replace("@", "")] = you[key];
        }
    }
};
EcFramework = stjs.extend(EcFramework, Framework, [], function(constructor, prototype) {
    constructor.relDone = {};
    constructor.levelDone = {};
    constructor.template = null;
    prototype.equals = function(obj) {
        return this.isId((obj).id);
    };
    /**
     *  Retrieves a framework from the server, specified by the ID
     * 
     *  @param {String}                 id
     *                                  ID of the framework to retrieve
     *  @param {Callback1<EcFramework>} success
     *                                  Callback triggered after successfully retrieving the framework,
     *                                  returns the retrieved framework
     *  @param {Callback1<String>}      failure
     *                                  Callback triggered if an error occurs while retrieving the framework
     *  @memberOf EcFramework
     *  @method get
     *  @static
     */
    constructor.get = function(id, success, failure) {
        EcRepository.getAs(id, new EcFramework(), success, failure);
    };
    /**
     *  Retrieves a framework from the server in a blocking fashion, specified by the ID
     * 
     *  @param {String}                 id
     *                                  ID of the framework to retrieve
     *  @param {Callback1<EcFramework>} success
     *                                  Callback triggered after successfully retrieving the framework,
     *                                  returns the retrieved framework
     *  @param {Callback1<String>}      failure
     *                                  Callback triggered if an error occurs while retrieving the framework
     *  @memberOf EcFramework
     *  @method getBlocking
     *  @static
     */
    constructor.getBlocking = function(id) {
        return EcRepository.getBlockingAs(id, new EcFramework());
    };
    /**
     *  Searches the repository given for frameworks using the query passed in
     * 
     *  @param {EcRepository}                 repo
     *                                        Repository to search for frameworks
     *  @param {String}                       query
     *                                        Query string used to search for a framework
     *  @param {Callback1<Array<EcFramework>} success
     *                                        Callback triggered when the search successfully returns,
     *                                        returns search results
     *  @param {Callback1<String>}            failure
     *                                        Callback triggered if an error occurs while searching
     *  @param {Object}                       paramObj
     *                                        Parameter object for search
     *  @memberOf EcFramework
     *  @method search
     *  @static
     */
    constructor.search = function(repo, query, success, failure, paramObj) {
        EcRepository.searchAs(repo, query, function() {
            return new EcFramework();
        }, success, failure, paramObj);
    };
    /**
     *  Adds the competency ID specified to the frameworks list of competency IDs
     * 
     *  @param {String} id
     *                  ID of the competency to add
     *  @memberOf EcFramework
     *  @method addCompetency
     */
    prototype.addCompetency = function(id) {
        id = EcRemoteLinkedData.trimVersionFromUrl(id);
        if (this.competency == null) 
            this.competency = new Array();
        for (var i = 0; i < this.competency.length; i++) 
            if (EcRemoteLinkedData.trimVersionFromUrl(this.competency[i]).equals(id)) 
                return;
        this.competency.push(id);
    };
    /**
     *  Removes a competency ID from the framework's list, also removes any
     *  levels and relations associated with that competency
     *  <p>
     *  TODO: remove rollup rules? should we add flag to remove these extras
     * 
     *  @param {String}            id
     *                             ID of the competency to remove
     *  @param {Callback1<String>} success
     *                             Callback triggered after succesfully removing the competency and levels and relationships
     *  @param {Callback1<String>} failure
     *                             Callback triggered if error occurs when removing competency and levels and relationships
     *  @memberOf EcFramework
     *  @method removeCompetency
     */
    prototype.removeCompetency = function(id, success, failure) {
        var shortId = EcRemoteLinkedData.trimVersionFromUrl(id);
        if (this.competency == null) 
            this.competency = new Array();
        for (var i = 0; i < this.competency.length; i++) 
            if (this.competency[i].equals(shortId) || this.competency[i].equals(id)) 
                this.competency.splice(i, 1);
        if ((this.relation == null || this.relation.length == 0) && (this.level == null || this.level.length == 0)) 
            if (success != null) {
                success("");
                return;
            }
        EcFramework.relDone[id] = false;
        EcFramework.levelDone[id] = false;
        if (this.relation != null) {
            this.removeRelationshipsThatInclude(id, 0, function(p1) {
                if (EcFramework.levelDone[id]) {
                    if (success != null) 
                        success(p1);
                } else {
                    EcFramework.relDone[id] = true;
                }
            }, failure);
        } else {
            EcFramework.relDone[id] = true;
        }
        if (this.level != null) {
            this.removeLevelsThatInclude(id, 0, function(p1) {
                if (EcFramework.relDone[id]) {
                    if (success != null) 
                        success(p1);
                } else {
                    EcFramework.levelDone[id] = true;
                }
            }, failure);
        } else {
            EcFramework.levelDone[id] = true;
        }
    };
    /**
     *  Helper method to remove relationships associated with a competency from this framework
     * 
     *  @param {String}            id
     *                             ID of the competency being removed, to find relationships on
     *  @param {int}               i
     *                             recursive index parameter
     *  @param {Callback1<String>} success
     *                             Callback triggered after all relationships in the framework have been checked
     *  @param {Callback1<String>} failure
     *                             Callback triggered if error occurs looking through relationships
     *  @memberOf EcFramework
     *  @method removeRelationshipsThatInclude
     *  @private
     */
    prototype.removeRelationshipsThatInclude = function(id, i, success, failure) {
        var shortId = EcRemoteLinkedData.trimVersionFromUrl(id);
        var me = this;
        if (i >= this.relation.length && success != null) 
            success("");
         else 
            EcAlignment.get(this.relation[i], function(a) {
                if (a != null && a.source == shortId || a.target == shortId || a.source == id || a.target == id) {
                    me.relation.splice(i, 1);
                    me.removeRelationshipsThatInclude(id, i, success, failure);
                } else 
                    me.removeRelationshipsThatInclude(id, i + 1, success, failure);
            }, function(s) {
                me.removeRelationshipsThatInclude(id, i + 1, success, failure);
            });
    };
    /**
     *  Helper method to remove levels associated with a competency from this framework
     * 
     *  @param {String}            id
     *                             ID of the competency being removed, to find levels on
     *  @param {int}               i
     *                             recursive index parameter
     *  @param {Callback1<String>} success
     *                             Callback triggered after all levels in the framework have been checked
     *  @param {Callback1<String>} failure
     *                             Callback triggered if error occurs looking through levels
     *  @memberOf EcFramework
     *  @method removeLevelsThatInclude
     *  @private
     */
    prototype.removeLevelsThatInclude = function(id, i, success, failure) {
        var shortId = EcRemoteLinkedData.trimVersionFromUrl(id);
        var me = this;
        if (i >= this.level.length && success != null) 
            success("");
         else 
            EcLevel.get(this.level[i], function(a) {
                if (a.competency == shortId || a.competency == id) {
                    me.level.splice(i, 1);
                    me.removeLevelsThatInclude(id, i, success, failure);
                } else 
                    me.removeLevelsThatInclude(id, i + 1, success, failure);
            }, function(s) {
                me.removeLevelsThatInclude(id, i + 1, success, failure);
            });
    };
    /**
     *  Adds a relation ID to the framework's list of relations
     * 
     *  @param {String} id
     *                  ID to add to the framework's relation list
     *  @memberOf EcFramework
     *  @method addRelation
     */
    prototype.addRelation = function(id) {
        id = EcRemoteLinkedData.trimVersionFromUrl(id);
        if (this.relation == null) 
            this.relation = new Array();
        for (var i = 0; i < this.relation.length; i++) 
            if (EcRemoteLinkedData.trimVersionFromUrl(this.relation[i]).equals(id)) 
                return;
        this.relation.push(id);
    };
    /**
     *  Removes a relation ID from the framework's list of relations
     * 
     *  @param {String} id
     *                  ID to remove from the framework's relation list
     *  @memberOf EcFramework
     *  @method removeCompetency
     */
    prototype.removeRelation = function(id) {
        id = EcRemoteLinkedData.trimVersionFromUrl(id);
        if (this.relation == null) 
            this.relation = new Array();
        for (var i = 0; i < this.relation.length; i++) 
            if (EcRemoteLinkedData.trimVersionFromUrl(this.relation[i]).equals(id)) 
                this.relation.splice(i, 1);
    };
    /**
     *  Adds a level ID to the framework's list of levels
     * 
     *  @param {String} id
     *                  ID of the level to add to framework's list
     *  @memberOf EcFramework
     *  @method addLevel
     */
    prototype.addLevel = function(id) {
        id = EcRemoteLinkedData.trimVersionFromUrl(id);
        if (this.level == null) 
            this.level = new Array();
        for (var i = 0; i < this.level.length; i++) 
            if (EcRemoteLinkedData.trimVersionFromUrl(this.level[i]).equals(id)) 
                return;
        this.level.push(id);
    };
    /**
     *  Removes a level ID from the framework's list of levels
     * 
     *  @param {String} id
     *                  ID to remove from framework's level list
     *  @memberOf EcFramework
     *  @method removeLevel
     */
    prototype.removeLevel = function(id) {
        id = EcRemoteLinkedData.trimVersionFromUrl(id);
        if (this.level == null) 
            this.level = new Array();
        for (var i = 0; i < this.level.length; i++) 
            if (EcRemoteLinkedData.trimVersionFromUrl(this.level[i]).equals(id)) 
                this.level.splice(i, 1);
    };
    /**
     *  Adds a rollup rule ID to the framework's list of rollup rules
     * 
     *  @param {String} id
     *                  ID of the rollup rule to add
     *  @memberOf EcFramework
     *  @method addRollupRule
     */
    prototype.addRollupRule = function(id) {
        id = EcRemoteLinkedData.trimVersionFromUrl(id);
        if (this.rollupRule == null) 
            this.rollupRule = new Array();
        for (var i = 0; i < this.rollupRule.length; i++) 
            if (EcRemoteLinkedData.trimVersionFromUrl(this.rollupRule[i]).equals(id)) 
                return;
        this.rollupRule.push(id);
    };
    /**
     *  Removes a rollup rule ID from the framework's list of rollup rules
     * 
     *  @param {String} id
     *                  ID to remove from rollup rule list
     *  @memberOf EcFramework
     *  @method removeRollupRule
     */
    prototype.removeRollupRule = function(id) {
        id = EcRemoteLinkedData.trimVersionFromUrl(id);
        if (this.rollupRule == null) 
            this.rollupRule = new Array();
        for (var i = 0; i < this.rollupRule.length; i++) 
            if (EcRemoteLinkedData.trimVersionFromUrl(this.rollupRule[i]).equals(id)) 
                this.rollupRule.splice(i, 1);
    };
    /**
     *  Saves this frameworks details on the server specified by it's ID
     * 
     *  @param {Callback1<String>} success
     *                             Callback triggered after successfully saving the framework
     *  @param {Callback1<String>} failure
     *                             Callback triggered if error occurs while saving the framework
     *  @memberOf EcFramework
     *  @method save
     */
    prototype.save = function(success, failure, repo) {
        if (this.name == null || this.name == "") {
            var msg = "Framework Name Cannot be Empty";
            if (failure != null) 
                failure(msg);
             else 
                console.error(msg);
            return;
        }
        if (repo == null) 
            EcRepository.save(this, success, failure);
         else 
            repo.saveTo(this, success, failure);
    };
    /**
     *  Deletes this framework from the server specified by it's ID
     * 
     *  @param {Callback1<String>} success
     *                             Callback triggered if successfully deleted framework
     *  @param {Callback1<String>} failure
     *                             Callback triggered if error occurs when deleting the framework
     *  @memberOf EcFramework
     *  @method _delete
     */
    prototype._delete = function(success, failure) {
        EcRepository.DELETE(this, success, failure);
    };
    prototype.asAsnJson = function(success, failure, fallbackServerUrl) {
        var id = this.id;
        var server = this.getServerBaseUrl();
        if (server != null && server != undefined && !server.endsWith("/")) {
            server = server + "/";
        }
        EcRemote.getExpectingString(server, "asn?id=" + this.getGuid(), success, function(p1) {
            if (fallbackServerUrl != null && fallbackServerUrl != undefined) {
                var server = fallbackServerUrl;
                if (!server.endsWith("/")) {
                    server = server + "/";
                }
                EcRemote.getExpectingString(server, "asn?id=" + id, success, failure);
            } else {
                failure(p1);
            }
        });
    };
}, {relDone: {name: "Map", arguments: [null, null]}, levelDone: {name: "Map", arguments: [null, null]}, template: "Object", competency: {name: "Array", arguments: [null]}, relation: {name: "Array", arguments: [null]}, level: {name: "Array", arguments: [null]}, rollupRule: {name: "Array", arguments: [null]}, about: "Thing", educationalAlignment: "AlignmentObject", associatedMedia: "MediaObject", funder: "Person", audio: "AudioObject", workExample: "CreativeWork", provider: "Person", encoding: "MediaObject", character: "Person", audience: "Audience", sourceOrganization: "Organization", isPartOf: "CreativeWork", video: "VideoObject", publication: "PublicationEvent", contributor: "Organization", reviews: "Review", hasPart: "CreativeWork", releasedEvent: "PublicationEvent", contentLocation: "Place", aggregateRating: "AggregateRating", locationCreated: "Place", accountablePerson: "Person", spatialCoverage: "Place", offers: "Offer", editor: "Person", copyrightHolder: "Person", recordedAt: "SchemaEvent", publisher: "Person", interactionStatistic: "InteractionCounter", exampleOfWork: "CreativeWork", mainEntity: "Thing", author: "Person", timeRequired: "Duration", translator: "Person", comment: "Comment", inLanguage: "Language", review: "Review", license: "CreativeWork", encodings: "MediaObject", isBasedOn: "Product", creator: "Person", sponsor: "Organization", producer: "Person", mentions: "Thing", identifier: "Object", image: "Object", potentialAction: "Action", mainEntityOfPage: "Object", owner: {name: "Array", arguments: [null]}, signature: {name: "Array", arguments: [null]}, reader: {name: "Array", arguments: [null]}, forwardingTable: "Object", atProperties: {name: "Array", arguments: [null]}}, {});

// Generated from Rollup.g4 by ANTLR 4.8
// jshint ignore: start
var antlr4 = require('antlr4/index');

// This class defines a complete listener for a parse tree produced by RollupParser.
function RollupListener() {
	antlr4.tree.ParseTreeListener.call(this);
	return this;
}

RollupListener.prototype = Object.create(antlr4.tree.ParseTreeListener.prototype);
RollupListener.prototype.constructor = RollupListener;

// Enter a parse tree produced by RollupParser#s.
RollupListener.prototype.enterS = function(ctx) {
};

// Exit a parse tree produced by RollupParser#s.
RollupListener.prototype.exitS = function(ctx) {
};


// Enter a parse tree produced by RollupParser#token.
RollupListener.prototype.enterToken = function(ctx) {
};

// Exit a parse tree produced by RollupParser#token.
RollupListener.prototype.exitToken = function(ctx) {
};


// Enter a parse tree produced by RollupParser#query.
RollupListener.prototype.enterQuery = function(ctx) {
};

// Exit a parse tree produced by RollupParser#query.
RollupListener.prototype.exitQuery = function(ctx) {
};


// Enter a parse tree produced by RollupParser#innerquery.
RollupListener.prototype.enterInnerquery = function(ctx) {
};

// Exit a parse tree produced by RollupParser#innerquery.
RollupListener.prototype.exitInnerquery = function(ctx) {
};


// Enter a parse tree produced by RollupParser#logical_or_math_operator.
RollupListener.prototype.enterLogical_or_math_operator = function(ctx) {
};

// Exit a parse tree produced by RollupParser#logical_or_math_operator.
RollupListener.prototype.exitLogical_or_math_operator = function(ctx) {
};



exports.RollupListener = RollupListener;
// Generated from Rollup.g4 by ANTLR 4.8
// jshint ignore: start
var antlr4 = require('antlr4/index');



var serializedATN = ["\u0003\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964",
    "\u0002\f`\b\u0001\u0004\u0002\t\u0002\u0004\u0003\t\u0003\u0004\u0004",
    "\t\u0004\u0004\u0005\t\u0005\u0004\u0006\t\u0006\u0004\u0007\t\u0007",
    "\u0004\b\t\b\u0004\t\t\t\u0004\n\t\n\u0004\u000b\t\u000b\u0003\u0002",
    "\u0006\u0002\u0019\n\u0002\r\u0002\u000e\u0002\u001a\u0003\u0002\u0003",
    "\u0002\u0006\u0002\u001f\n\u0002\r\u0002\u000e\u0002 \u0005\u0002#\n",
    "\u0002\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003",
    "\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0005\u0003.\n\u0003\u0003",
    "\u0004\u0003\u0004\u0003\u0004\u0003\u0004\u0003\u0004\u0005\u00045",
    "\n\u0004\u0003\u0005\u0003\u0005\u0003\u0006\u0003\u0006\u0003\u0006",
    "\u0003\u0006\u0003\u0006\u0003\u0006\u0003\u0006\u0003\u0006\u0003\u0006",
    "\u0003\u0006\u0003\u0006\u0003\u0006\u0003\u0006\u0003\u0006\u0005\u0006",
    "G\n\u0006\u0003\u0007\u0006\u0007J\n\u0007\r\u0007\u000e\u0007K\u0003",
    "\b\u0006\bO\n\b\r\b\u000e\bP\u0003\t\u0003\t\u0003\n\u0003\n\u0003\u000b",
    "\u0003\u000b\u0003\u000b\u0003\u000b\u0003\u000b\u0003\u000b\u0006\u000b",
    "]\n\u000b\r\u000b\u000e\u000b^\u0002\u0002\f\u0003\u0003\u0005\u0004",
    "\u0007\u0005\t\u0006\u000b\u0007\r\b\u000f\t\u0011\n\u0013\u000b\u0015",
    "\f\u0003\u0002\u0006\u0005\u0002,-//11\u0005\u0002\u000b\f\u000f\u000f",
    "\"\"\u0005\u000200C\\c|\u0003\u0002\"\"\u0002l\u0002\u0003\u0003\u0002",
    "\u0002\u0002\u0002\u0005\u0003\u0002\u0002\u0002\u0002\u0007\u0003\u0002",
    "\u0002\u0002\u0002\t\u0003\u0002\u0002\u0002\u0002\u000b\u0003\u0002",
    "\u0002\u0002\u0002\r\u0003\u0002\u0002\u0002\u0002\u000f\u0003\u0002",
    "\u0002\u0002\u0002\u0011\u0003\u0002\u0002\u0002\u0002\u0013\u0003\u0002",
    "\u0002\u0002\u0002\u0015\u0003\u0002\u0002\u0002\u0003\u0018\u0003\u0002",
    "\u0002\u0002\u0005-\u0003\u0002\u0002\u0002\u00074\u0003\u0002\u0002",
    "\u0002\t6\u0003\u0002\u0002\u0002\u000bF\u0003\u0002\u0002\u0002\rI",
    "\u0003\u0002\u0002\u0002\u000fN\u0003\u0002\u0002\u0002\u0011R\u0003",
    "\u0002\u0002\u0002\u0013T\u0003\u0002\u0002\u0002\u0015V\u0003\u0002",
    "\u0002\u0002\u0017\u0019\u00042;\u0002\u0018\u0017\u0003\u0002\u0002",
    "\u0002\u0019\u001a\u0003\u0002\u0002\u0002\u001a\u0018\u0003\u0002\u0002",
    "\u0002\u001a\u001b\u0003\u0002\u0002\u0002\u001b\"\u0003\u0002\u0002",
    "\u0002\u001c\u001e\u00070\u0002\u0002\u001d\u001f\u00042;\u0002\u001e",
    "\u001d\u0003\u0002\u0002\u0002\u001f \u0003\u0002\u0002\u0002 \u001e",
    "\u0003\u0002\u0002\u0002 !\u0003\u0002\u0002\u0002!#\u0003\u0002\u0002",
    "\u0002\"\u001c\u0003\u0002\u0002\u0002\"#\u0003\u0002\u0002\u0002#\u0004",
    "\u0003\u0002\u0002\u0002$%\u0007v\u0002\u0002%&\u0007t\u0002\u0002&",
    "\'\u0007w\u0002\u0002\'.\u0007g\u0002\u0002()\u0007h\u0002\u0002)*\u0007",
    "c\u0002\u0002*+\u0007n\u0002\u0002+,\u0007u\u0002\u0002,.\u0007g\u0002",
    "\u0002-$\u0003\u0002\u0002\u0002-(\u0003\u0002\u0002\u0002.\u0006\u0003",
    "\u0002\u0002\u0002/0\u0007C\u0002\u000201\u0007P\u0002\u000215\u0007",
    "F\u0002\u000223\u0007Q\u0002\u000235\u0007T\u0002\u00024/\u0003\u0002",
    "\u0002\u000242\u0003\u0002\u0002\u00025\b\u0003\u0002\u0002\u000267",
    "\t\u0002\u0002\u00027\n\u0003\u0002\u0002\u000289\u0007<\u0002\u0002",
    "9G\u0007>\u0002\u0002:;\u0007<\u0002\u0002;G\u0007@\u0002\u0002<=\u0007",
    "<\u0002\u0002=>\u0007>\u0002\u0002>G\u0007?\u0002\u0002?@\u0007<\u0002",
    "\u0002@A\u0007@\u0002\u0002AG\u0007?\u0002\u0002BC\u0007<\u0002\u0002",
    "CD\u0007#\u0002\u0002DG\u0007?\u0002\u0002EG\u0007<\u0002\u0002F8\u0003",
    "\u0002\u0002\u0002F:\u0003\u0002\u0002\u0002F<\u0003\u0002\u0002\u0002",
    "F?\u0003\u0002\u0002\u0002FB\u0003\u0002\u0002\u0002FE\u0003\u0002\u0002",
    "\u0002G\f\u0003\u0002\u0002\u0002HJ\t\u0003\u0002\u0002IH\u0003\u0002",
    "\u0002\u0002JK\u0003\u0002\u0002\u0002KI\u0003\u0002\u0002\u0002KL\u0003",
    "\u0002\u0002\u0002L\u000e\u0003\u0002\u0002\u0002MO\t\u0004\u0002\u0002",
    "NM\u0003\u0002\u0002\u0002OP\u0003\u0002\u0002\u0002PN\u0003\u0002\u0002",
    "\u0002PQ\u0003\u0002\u0002\u0002Q\u0010\u0003\u0002\u0002\u0002RS\u0007",
    "]\u0002\u0002S\u0012\u0003\u0002\u0002\u0002TU\u0007_\u0002\u0002U\u0014",
    "\u0003\u0002\u0002\u0002VW\u0007j\u0002\u0002WX\u0007v\u0002\u0002X",
    "Y\u0007v\u0002\u0002YZ\u0007r\u0002\u0002Z\\\u0003\u0002\u0002\u0002",
    "[]\n\u0005\u0002\u0002\\[\u0003\u0002\u0002\u0002]^\u0003\u0002\u0002",
    "\u0002^\\\u0003\u0002\u0002\u0002^_\u0003\u0002\u0002\u0002_\u0016\u0003",
    "\u0002\u0002\u0002\f\u0002\u001a \"-4FKP^\u0002"].join("");


var atn = new antlr4.atn.ATNDeserializer().deserialize(serializedATN);

var decisionsToDFA = atn.decisionToState.map( function(ds, index) { return new antlr4.dfa.DFA(ds, index); });

function RollupLexer(input) {
	antlr4.Lexer.call(this, input);
    this._interp = new antlr4.atn.LexerATNSimulator(this, atn, decisionsToDFA, new antlr4.PredictionContextCache());
    return this;
}

RollupLexer.prototype = Object.create(antlr4.Lexer.prototype);
RollupLexer.prototype.constructor = RollupLexer;

Object.defineProperty(RollupLexer.prototype, "atn", {
        get : function() {
                return atn;
        }
});

RollupLexer.EOF = antlr4.Token.EOF;
RollupLexer.NUMBER = 1;
RollupLexer.BOOLEAN = 2;
RollupLexer.LOGICAL_OPERATOR = 3;
RollupLexer.MATH_OPERATOR = 4;
RollupLexer.QUANTATIVE_OPERATOR = 5;
RollupLexer.WS = 6;
RollupLexer.KEY = 7;
RollupLexer.LEFT_BRACE = 8;
RollupLexer.RIGHT_BRACE = 9;
RollupLexer.VALUE = 10;

RollupLexer.prototype.channelNames = [ "DEFAULT_TOKEN_CHANNEL", "HIDDEN" ];

RollupLexer.prototype.modeNames = [ "DEFAULT_MODE" ];

RollupLexer.prototype.literalNames = [ null, null, null, null, null, null, 
                                       null, null, "'['", "']'" ];

RollupLexer.prototype.symbolicNames = [ null, "NUMBER", "BOOLEAN", "LOGICAL_OPERATOR", 
                                        "MATH_OPERATOR", "QUANTATIVE_OPERATOR", 
                                        "WS", "KEY", "LEFT_BRACE", "RIGHT_BRACE", 
                                        "VALUE" ];

RollupLexer.prototype.ruleNames = [ "NUMBER", "BOOLEAN", "LOGICAL_OPERATOR", 
                                    "MATH_OPERATOR", "QUANTATIVE_OPERATOR", 
                                    "WS", "KEY", "LEFT_BRACE", "RIGHT_BRACE", 
                                    "VALUE" ];

RollupLexer.prototype.grammarFileName = "Rollup.g4";


exports.RollupLexer = RollupLexer;


// Generated from Rollup.g4 by ANTLR 4.8
// jshint ignore: start
var antlr4 = require('antlr4/index');
var RollupListener = require('./RollupListener').RollupListener;
var grammarFileName = "Rollup.g4";


var serializedATN = ["\u0003\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964",
    "\u0003\fJ\u0004\u0002\t\u0002\u0004\u0003\t\u0003\u0004\u0004\t\u0004",
    "\u0004\u0005\t\u0005\u0004\u0006\t\u0006\u0003\u0002\u0003\u0002\u0005",
    "\u0002\u000f\n\u0002\u0003\u0002\u0005\u0002\u0012\n\u0002\u0003\u0002",
    "\u0003\u0002\u0005\u0002\u0016\n\u0002\u0003\u0002\u0003\u0002\u0005",
    "\u0002\u001a\n\u0002\u0007\u0002\u001c\n\u0002\f\u0002\u000e\u0002\u001f",
    "\u000b\u0002\u0003\u0003\u0003\u0003\u0003\u0003\u0005\u0003$\n\u0003",
    "\u0003\u0004\u0003\u0004\u0005\u0004(\n\u0004\u0003\u0004\u0003\u0004",
    "\u0005\u0004,\n\u0004\u0003\u0004\u0003\u0004\u0003\u0005\u0003\u0005",
    "\u0003\u0005\u0005\u00053\n\u0005\u0003\u0005\u0003\u0005\u0005\u0005",
    "7\n\u0005\u0003\u0005\u0005\u0005:\n\u0005\u0003\u0005\u0003\u0005\u0005",
    "\u0005>\n\u0005\u0003\u0005\u0007\u0005A\n\u0005\f\u0005\u000e\u0005",
    "D\u000b\u0005\u0003\u0006\u0003\u0006\u0005\u0006H\n\u0006\u0003\u0006",
    "\u0002\u0002\u0007\u0002\u0004\u0006\b\n\u0002\u0002\u0002S\u0002\f",
    "\u0003\u0002\u0002\u0002\u0004#\u0003\u0002\u0002\u0002\u0006%\u0003",
    "\u0002\u0002\u0002\b/\u0003\u0002\u0002\u0002\nG\u0003\u0002\u0002\u0002",
    "\f\u000e\u0005\u0004\u0003\u0002\r\u000f\u0007\b\u0002\u0002\u000e\r",
    "\u0003\u0002\u0002\u0002\u000e\u000f\u0003\u0002\u0002\u0002\u000f\u001d",
    "\u0003\u0002\u0002\u0002\u0010\u0012\u0007\b\u0002\u0002\u0011\u0010",
    "\u0003\u0002\u0002\u0002\u0011\u0012\u0003\u0002\u0002\u0002\u0012\u0013",
    "\u0003\u0002\u0002\u0002\u0013\u0015\u0005\n\u0006\u0002\u0014\u0016",
    "\u0007\b\u0002\u0002\u0015\u0014\u0003\u0002\u0002\u0002\u0015\u0016",
    "\u0003\u0002\u0002\u0002\u0016\u0017\u0003\u0002\u0002\u0002\u0017\u0019",
    "\u0005\u0004\u0003\u0002\u0018\u001a\u0007\b\u0002\u0002\u0019\u0018",
    "\u0003\u0002\u0002\u0002\u0019\u001a\u0003\u0002\u0002\u0002\u001a\u001c",
    "\u0003\u0002\u0002\u0002\u001b\u0011\u0003\u0002\u0002\u0002\u001c\u001f",
    "\u0003\u0002\u0002\u0002\u001d\u001b\u0003\u0002\u0002\u0002\u001d\u001e",
    "\u0003\u0002\u0002\u0002\u001e\u0003\u0003\u0002\u0002\u0002\u001f\u001d",
    "\u0003\u0002\u0002\u0002 $\u0007\u0003\u0002\u0002!$\u0005\u0006\u0004",
    "\u0002\"$\u0007\u0004\u0002\u0002# \u0003\u0002\u0002\u0002#!\u0003",
    "\u0002\u0002\u0002#\"\u0003\u0002\u0002\u0002$\u0005\u0003\u0002\u0002",
    "\u0002%\'\u0007\n\u0002\u0002&(\u0007\b\u0002\u0002\'&\u0003\u0002\u0002",
    "\u0002\'(\u0003\u0002\u0002\u0002()\u0003\u0002\u0002\u0002)+\u0005",
    "\b\u0005\u0002*,\u0007\b\u0002\u0002+*\u0003\u0002\u0002\u0002+,\u0003",
    "\u0002\u0002\u0002,-\u0003\u0002\u0002\u0002-.\u0007\u000b\u0002\u0002",
    ".\u0007\u0003\u0002\u0002\u0002/0\u0007\t\u0002\u000202\u0007\u0007",
    "\u0002\u000213\u0007\b\u0002\u000221\u0003\u0002\u0002\u000223\u0003",
    "\u0002\u0002\u000236\u0003\u0002\u0002\u000247\u0007\f\u0002\u00025",
    "7\u0007\u0003\u0002\u000264\u0003\u0002\u0002\u000265\u0003\u0002\u0002",
    "\u000279\u0003\u0002\u0002\u00028:\u0007\b\u0002\u000298\u0003\u0002",
    "\u0002\u00029:\u0003\u0002\u0002\u0002:B\u0003\u0002\u0002\u0002;=\u0007",
    "\u0005\u0002\u0002<>\u0007\b\u0002\u0002=<\u0003\u0002\u0002\u0002=",
    ">\u0003\u0002\u0002\u0002>?\u0003\u0002\u0002\u0002?A\u0005\b\u0005",
    "\u0002@;\u0003\u0002\u0002\u0002AD\u0003\u0002\u0002\u0002B@\u0003\u0002",
    "\u0002\u0002BC\u0003\u0002\u0002\u0002C\t\u0003\u0002\u0002\u0002DB",
    "\u0003\u0002\u0002\u0002EH\u0007\u0005\u0002\u0002FH\u0007\u0006\u0002",
    "\u0002GE\u0003\u0002\u0002\u0002GF\u0003\u0002\u0002\u0002H\u000b\u0003",
    "\u0002\u0002\u0002\u0010\u000e\u0011\u0015\u0019\u001d#\'+269=BG"].join("");


var atn = new antlr4.atn.ATNDeserializer().deserialize(serializedATN);

var decisionsToDFA = atn.decisionToState.map( function(ds, index) { return new antlr4.dfa.DFA(ds, index); });

var sharedContextCache = new antlr4.PredictionContextCache();

var literalNames = [ null, null, null, null, null, null, null, null, "'['", 
                     "']'" ];

var symbolicNames = [ null, "NUMBER", "BOOLEAN", "LOGICAL_OPERATOR", "MATH_OPERATOR", 
                      "QUANTATIVE_OPERATOR", "WS", "KEY", "LEFT_BRACE", 
                      "RIGHT_BRACE", "VALUE" ];

var ruleNames =  [ "s", "token", "query", "innerquery", "logical_or_math_operator" ];

function RollupParser (input) {
	antlr4.Parser.call(this, input);
    this._interp = new antlr4.atn.ParserATNSimulator(this, atn, decisionsToDFA, sharedContextCache);
    this.ruleNames = ruleNames;
    this.literalNames = literalNames;
    this.symbolicNames = symbolicNames;
    return this;
}

RollupParser.prototype = Object.create(antlr4.Parser.prototype);
RollupParser.prototype.constructor = RollupParser;

Object.defineProperty(RollupParser.prototype, "atn", {
	get : function() {
		return atn;
	}
});

RollupParser.EOF = antlr4.Token.EOF;
RollupParser.NUMBER = 1;
RollupParser.BOOLEAN = 2;
RollupParser.LOGICAL_OPERATOR = 3;
RollupParser.MATH_OPERATOR = 4;
RollupParser.QUANTATIVE_OPERATOR = 5;
RollupParser.WS = 6;
RollupParser.KEY = 7;
RollupParser.LEFT_BRACE = 8;
RollupParser.RIGHT_BRACE = 9;
RollupParser.VALUE = 10;

RollupParser.RULE_s = 0;
RollupParser.RULE_token = 1;
RollupParser.RULE_query = 2;
RollupParser.RULE_innerquery = 3;
RollupParser.RULE_logical_or_math_operator = 4;


function SContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = RollupParser.RULE_s;
    this.cLogic = null; // Logical_or_math_operatorContext
    return this;
}

SContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
SContext.prototype.constructor = SContext;

SContext.prototype.token = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(TokenContext);
    } else {
        return this.getTypedRuleContext(TokenContext,i);
    }
};

SContext.prototype.WS = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(RollupParser.WS);
    } else {
        return this.getToken(RollupParser.WS, i);
    }
};


SContext.prototype.logical_or_math_operator = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(Logical_or_math_operatorContext);
    } else {
        return this.getTypedRuleContext(Logical_or_math_operatorContext,i);
    }
};

SContext.prototype.enterRule = function(listener) {
    if(listener instanceof RollupListener ) {
        listener.enterS(this);
	}
};

SContext.prototype.exitRule = function(listener) {
    if(listener instanceof RollupListener ) {
        listener.exitS(this);
	}
};




RollupParser.SContext = SContext;

RollupParser.prototype.s = function() {

    var localctx = new SContext(this, this._ctx, this.state);
    this.enterRule(localctx, 0, RollupParser.RULE_s);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 10;
        this.token();
        this.state = 12;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,0,this._ctx);
        if(la_===1) {
            this.state = 11;
            this.match(RollupParser.WS);

        }
        this.state = 27;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << RollupParser.LOGICAL_OPERATOR) | (1 << RollupParser.MATH_OPERATOR) | (1 << RollupParser.WS))) !== 0)) {
            this.state = 15;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(_la===RollupParser.WS) {
                this.state = 14;
                this.match(RollupParser.WS);
            }

            this.state = 17;
            localctx.cLogic = this.logical_or_math_operator();
            this.state = 19;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(_la===RollupParser.WS) {
                this.state = 18;
                this.match(RollupParser.WS);
            }

            this.state = 21;
            this.token();
            this.state = 23;
            this._errHandler.sync(this);
            var la_ = this._interp.adaptivePredict(this._input,3,this._ctx);
            if(la_===1) {
                this.state = 22;
                this.match(RollupParser.WS);

            }
            this.state = 29;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function TokenContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = RollupParser.RULE_token;
    this.cNumber = null; // Token
    this.cBoolean = null; // Token
    return this;
}

TokenContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
TokenContext.prototype.constructor = TokenContext;

TokenContext.prototype.NUMBER = function() {
    return this.getToken(RollupParser.NUMBER, 0);
};

TokenContext.prototype.query = function() {
    return this.getTypedRuleContext(QueryContext,0);
};

TokenContext.prototype.BOOLEAN = function() {
    return this.getToken(RollupParser.BOOLEAN, 0);
};

TokenContext.prototype.enterRule = function(listener) {
    if(listener instanceof RollupListener ) {
        listener.enterToken(this);
	}
};

TokenContext.prototype.exitRule = function(listener) {
    if(listener instanceof RollupListener ) {
        listener.exitToken(this);
	}
};




RollupParser.TokenContext = TokenContext;

RollupParser.prototype.token = function() {

    var localctx = new TokenContext(this, this._ctx, this.state);
    this.enterRule(localctx, 2, RollupParser.RULE_token);
    try {
        this.state = 33;
        this._errHandler.sync(this);
        switch(this._input.LA(1)) {
        case RollupParser.NUMBER:
            this.enterOuterAlt(localctx, 1);
            this.state = 30;
            localctx.cNumber = this.match(RollupParser.NUMBER);
            break;
        case RollupParser.LEFT_BRACE:
            this.enterOuterAlt(localctx, 2);
            this.state = 31;
            this.query();
            break;
        case RollupParser.BOOLEAN:
            this.enterOuterAlt(localctx, 3);
            this.state = 32;
            localctx.cBoolean = this.match(RollupParser.BOOLEAN);
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function QueryContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = RollupParser.RULE_query;
    this.cQuery = null; // InnerqueryContext
    return this;
}

QueryContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
QueryContext.prototype.constructor = QueryContext;

QueryContext.prototype.LEFT_BRACE = function() {
    return this.getToken(RollupParser.LEFT_BRACE, 0);
};

QueryContext.prototype.RIGHT_BRACE = function() {
    return this.getToken(RollupParser.RIGHT_BRACE, 0);
};

QueryContext.prototype.innerquery = function() {
    return this.getTypedRuleContext(InnerqueryContext,0);
};

QueryContext.prototype.WS = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(RollupParser.WS);
    } else {
        return this.getToken(RollupParser.WS, i);
    }
};


QueryContext.prototype.enterRule = function(listener) {
    if(listener instanceof RollupListener ) {
        listener.enterQuery(this);
	}
};

QueryContext.prototype.exitRule = function(listener) {
    if(listener instanceof RollupListener ) {
        listener.exitQuery(this);
	}
};




RollupParser.QueryContext = QueryContext;

RollupParser.prototype.query = function() {

    var localctx = new QueryContext(this, this._ctx, this.state);
    this.enterRule(localctx, 4, RollupParser.RULE_query);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 35;
        this.match(RollupParser.LEFT_BRACE);
        this.state = 37;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if(_la===RollupParser.WS) {
            this.state = 36;
            this.match(RollupParser.WS);
        }

        this.state = 39;
        localctx.cQuery = this.innerquery();
        this.state = 41;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if(_la===RollupParser.WS) {
            this.state = 40;
            this.match(RollupParser.WS);
        }

        this.state = 43;
        this.match(RollupParser.RIGHT_BRACE);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function InnerqueryContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = RollupParser.RULE_innerquery;
    this.cKey = null; // Token
    this.cOperator = null; // Token
    this.cValue = null; // Token
    this.cNumber = null; // Token
    this.cLogic = null; // Token
    return this;
}

InnerqueryContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
InnerqueryContext.prototype.constructor = InnerqueryContext;

InnerqueryContext.prototype.KEY = function() {
    return this.getToken(RollupParser.KEY, 0);
};

InnerqueryContext.prototype.QUANTATIVE_OPERATOR = function() {
    return this.getToken(RollupParser.QUANTATIVE_OPERATOR, 0);
};

InnerqueryContext.prototype.WS = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(RollupParser.WS);
    } else {
        return this.getToken(RollupParser.WS, i);
    }
};


InnerqueryContext.prototype.VALUE = function() {
    return this.getToken(RollupParser.VALUE, 0);
};

InnerqueryContext.prototype.NUMBER = function() {
    return this.getToken(RollupParser.NUMBER, 0);
};

InnerqueryContext.prototype.innerquery = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(InnerqueryContext);
    } else {
        return this.getTypedRuleContext(InnerqueryContext,i);
    }
};

InnerqueryContext.prototype.LOGICAL_OPERATOR = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(RollupParser.LOGICAL_OPERATOR);
    } else {
        return this.getToken(RollupParser.LOGICAL_OPERATOR, i);
    }
};


InnerqueryContext.prototype.enterRule = function(listener) {
    if(listener instanceof RollupListener ) {
        listener.enterInnerquery(this);
	}
};

InnerqueryContext.prototype.exitRule = function(listener) {
    if(listener instanceof RollupListener ) {
        listener.exitInnerquery(this);
	}
};




RollupParser.InnerqueryContext = InnerqueryContext;

RollupParser.prototype.innerquery = function() {

    var localctx = new InnerqueryContext(this, this._ctx, this.state);
    this.enterRule(localctx, 6, RollupParser.RULE_innerquery);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 45;
        localctx.cKey = this.match(RollupParser.KEY);
        this.state = 46;
        localctx.cOperator = this.match(RollupParser.QUANTATIVE_OPERATOR);
        this.state = 48;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if(_la===RollupParser.WS) {
            this.state = 47;
            this.match(RollupParser.WS);
        }

        this.state = 52;
        this._errHandler.sync(this);
        switch(this._input.LA(1)) {
        case RollupParser.VALUE:
            this.state = 50;
            localctx.cValue = this.match(RollupParser.VALUE);
            break;
        case RollupParser.NUMBER:
            this.state = 51;
            localctx.cNumber = this.match(RollupParser.NUMBER);
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
        this.state = 55;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,10,this._ctx);
        if(la_===1) {
            this.state = 54;
            this.match(RollupParser.WS);

        }
        this.state = 64;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,12,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                this.state = 57;
                localctx.cLogic = this.match(RollupParser.LOGICAL_OPERATOR);
                this.state = 59;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                if(_la===RollupParser.WS) {
                    this.state = 58;
                    this.match(RollupParser.WS);
                }

                this.state = 61;
                this.innerquery(); 
            }
            this.state = 66;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,12,this._ctx);
        }

    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function Logical_or_math_operatorContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = RollupParser.RULE_logical_or_math_operator;
    this.cLogic = null; // Token
    this.cMath = null; // Token
    return this;
}

Logical_or_math_operatorContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Logical_or_math_operatorContext.prototype.constructor = Logical_or_math_operatorContext;

Logical_or_math_operatorContext.prototype.LOGICAL_OPERATOR = function() {
    return this.getToken(RollupParser.LOGICAL_OPERATOR, 0);
};

Logical_or_math_operatorContext.prototype.MATH_OPERATOR = function() {
    return this.getToken(RollupParser.MATH_OPERATOR, 0);
};

Logical_or_math_operatorContext.prototype.enterRule = function(listener) {
    if(listener instanceof RollupListener ) {
        listener.enterLogical_or_math_operator(this);
	}
};

Logical_or_math_operatorContext.prototype.exitRule = function(listener) {
    if(listener instanceof RollupListener ) {
        listener.exitLogical_or_math_operator(this);
	}
};




RollupParser.Logical_or_math_operatorContext = Logical_or_math_operatorContext;

RollupParser.prototype.logical_or_math_operator = function() {

    var localctx = new Logical_or_math_operatorContext(this, this._ctx, this.state);
    this.enterRule(localctx, 8, RollupParser.RULE_logical_or_math_operator);
    try {
        this.state = 69;
        this._errHandler.sync(this);
        switch(this._input.LA(1)) {
        case RollupParser.LOGICAL_OPERATOR:
            this.enterOuterAlt(localctx, 1);
            this.state = 67;
            localctx.cLogic = this.match(RollupParser.LOGICAL_OPERATOR);
            break;
        case RollupParser.MATH_OPERATOR:
            this.enterOuterAlt(localctx, 2);
            this.state = 68;
            localctx.cMath = this.match(RollupParser.MATH_OPERATOR);
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


exports.RollupParser = RollupParser;

var RelationType = function() {};
RelationType = stjs.extend(RelationType, null, [], function(constructor, prototype) {
    constructor.RELATION_TYPE = stjs.enumeration("IS_EQUIVALENT_TO", "NARROWS", "BROADENS", "REQUIRES", "IS_REQUIRED_BY");
}, {}, {});
var Node = function(nameId) {
    this.name = nameId;
    this.id = nameId;
};
Node = stjs.extend(Node, null, [], function(constructor, prototype) {
    prototype.name = null;
    prototype.id = null;
    prototype.description = null;
    prototype.getName = function() {
        return this.name;
    };
    prototype.setName = function(name) {
        this.name = name;
    };
    prototype.getId = function() {
        return this.id;
    };
    prototype.setId = function(id) {
        this.id = id;
    };
    prototype.getDescription = function() {
        return this.description;
    };
    prototype.setDescription = function(description) {
        this.description = description;
    };
    prototype.toString = function() {
        return "Node: \"" + this.id + "\"";
    };
}, {}, {});
var PapCompetencyPrediction = function() {};
PapCompetencyPrediction = stjs.extend(PapCompetencyPrediction, null, [], function(constructor, prototype) {
    prototype.competencyId = null;
    prototype.confidence = 0.0;
    prototype.conflictLevel = 0.0;
    prototype.conflictClass = null;
    prototype.getCompetencyId = function() {
        return this.competencyId;
    };
    prototype.setCompetencyId = function(competencyId) {
        this.competencyId = competencyId;
    };
    prototype.getConfidence = function() {
        return this.confidence;
    };
    prototype.setConfidence = function(confidence) {
        this.confidence = confidence;
    };
    prototype.getConflictLevel = function() {
        return this.conflictLevel;
    };
    prototype.setConflictLevel = function(conflictLevel) {
        this.conflictLevel = conflictLevel;
    };
    prototype.getConflictClass = function() {
        return this.conflictClass;
    };
    prototype.setConflictClass = function(conflictClass) {
        this.conflictClass = conflictClass;
    };
}, {}, {});
var NodeRelation = function(source, target, type) {
    this.source = source;
    this.target = target;
    this.type = type;
};
NodeRelation = stjs.extend(NodeRelation, null, [], function(constructor, prototype) {
    prototype.type = null;
    prototype.source = null;
    prototype.target = null;
    prototype.getSource = function() {
        return this.source;
    };
    prototype.setSource = function(source) {
        this.source = source;
    };
    prototype.getTarget = function() {
        return this.target;
    };
    prototype.setTarget = function(target) {
        this.target = target;
    };
    prototype.getType = function() {
        return this.type;
    };
    prototype.setType = function(type) {
        this.type = type;
    };
    prototype.toString = function() {
        return this.getSource().toString() + " >>" + this.getType() + "<< " + this.getTarget().toString();
    };
}, {type: {name: "Enum", arguments: ["RelationType.RELATION_TYPE"]}, source: "Node", target: "Node"}, {});
var RrS = function() {
    this.token = new Array();
    this.query = new Array();
};
RrS = stjs.extend(RrS, null, [], function(constructor, prototype) {
    prototype.token = null;
    prototype.query = null;
    prototype.addToken = function(rrToken) {
        this.token.push(rrToken);
    };
    prototype.addQuery = function(rrQuery) {
        this.query.push(rrQuery);
    };
}, {token: {name: "Array", arguments: ["RrToken"]}, query: {name: "Array", arguments: ["RrQuery"]}}, {});
var RrToken = function() {};
RrToken = stjs.extend(RrToken, null, [], function(constructor, prototype) {
    prototype.number = null;
    prototype.bool = null;
}, {}, {});
var RrQuery = function() {};
RrQuery = stjs.extend(RrQuery, null, [], function(constructor, prototype) {
    prototype.query = null;
}, {}, {});
var CgEdge = function(source, target, relation) {
    this.source = source;
    this.target = target;
    this.relation = relation;
};
CgEdge = stjs.extend(CgEdge, null, [], function(constructor, prototype) {
    prototype.source = null;
    prototype.target = null;
    prototype.relation = null;
    prototype.getSource = function() {
        return this.source;
    };
    prototype.setSource = function(source) {
        this.source = source;
    };
    prototype.getTarget = function() {
        return this.target;
    };
    prototype.setTarget = function(target) {
        this.target = target;
    };
    prototype.getRelation = function() {
        return this.relation;
    };
    prototype.setRelation = function(relation) {
        this.relation = relation;
    };
}, {}, {});
var SimpleAssertion = function(id, competencyId, confidence) {
    this.id = id;
    this.competencyId = competencyId;
    this.confidence = confidence;
};
SimpleAssertion = stjs.extend(SimpleAssertion, null, [], function(constructor, prototype) {
    prototype.id = null;
    prototype.subjectPem = null;
    prototype.competencyId = null;
    prototype.confidence = null;
    prototype.assertionDate = null;
    prototype.expirationDate = null;
    prototype.negative = null;
    prototype.getId = function() {
        return this.id;
    };
    prototype.setId = function(id) {
        this.id = id;
    };
    prototype.getSubjectPem = function() {
        return this.subjectPem;
    };
    prototype.setSubjectPem = function(subjectPem) {
        this.subjectPem = subjectPem;
    };
    prototype.getCompetencyId = function() {
        return this.competencyId;
    };
    prototype.setCompetencyId = function(competencyId) {
        this.competencyId = competencyId;
    };
    prototype.getConfidence = function() {
        return this.confidence;
    };
    prototype.setConfidence = function(confidence) {
        this.confidence = confidence;
    };
    prototype.getAssertionDate = function() {
        return this.assertionDate;
    };
    prototype.setAssertionDate = function(assertionDate) {
        this.assertionDate = assertionDate;
    };
    prototype.getExpirationDate = function() {
        return this.expirationDate;
    };
    prototype.setExpirationDate = function(expirationDate) {
        this.expirationDate = expirationDate;
    };
    prototype.isNegative = function() {
        return this.negative;
    };
    prototype.setNegative = function(negative) {
        this.negative = negative;
    };
}, {}, {});
/**
 *  Data structure used to hold data relevant to a request to determine the competence of an individual.
 *  (hereafter, "Inquiry")
 * 
 *  @author fritz.ray@eduworks.com
 *  @author tom.buskirk@eduworks.com
 *  @class InquiryPacket
 *  @module org.cassproject
 */
var InquiryPacket = /**
 *  Create an InquiryPacket.
 * 
 *  @param {EcPk[]}                  subject Public keys of the individual to retreive assertions about.
 *  @param {EcCompetency}            competency Competency that the inquiry is made about.
 *  @param {EcLevel}                 level Level of the competency.
 *  @param {EcFramework}             context Framework to provide boundaries for the inquiry within.
 *  @param {function(InquiryPacket)} success Method to call when a result has been reached.
 *  @param {function(string)}        failure Method to call if the inquiry fails.
 *  @param {string}                  rule For rollup rules, this is a search used to populate this inquiry packet.
 *  @param {IPType}                  type The type of this inquiry packet. May be competency, rollup rule, or relation.
 *  @constructor
 */
function(subject, competency, level, context, success, failure, rule, type) {
    this.positive = new Array();
    this.negative = new Array();
    this.equivalentPackets = new Array();
    this.subPackets = new Array();
    this.dateCreated = new Date().getTime();
    this.subject = subject;
    this.competency = new Array();
    if (competency != null) 
        this.competency.push(competency);
    this.level = new Array();
    if (level != null) 
        this.level.push(level);
    this.context = context;
    this.success = success;
    this.failure = failure;
    this.rule = rule;
    this.type = type;
    this.result = null;
    this.log = "";
};
InquiryPacket = stjs.extend(InquiryPacket, null, [], function(constructor, prototype) {
    prototype.root = false;
    /**
     *  One or more identifiers that identify an individual.
     * 
     *  @property subject
     *  @type EcPk[]
     */
    prototype.subject = null;
    /**
     *  Competency that this packet is inquiring about.
     *  May be multiple competencies that are either collapsed due to an inference loop, or are equivalent to one another.
     * 
     *  @property competency
     *  @type EcCompetency[]
     */
    prototype.competency = null;
    /**
     *  Framework that this inquiry is scoped to.
     * 
     *  @property context
     *  @type EcFramework
     */
    prototype.context = null;
    /**
     *  Callback when this and all child inquiries have successfully reached a conclusion.
     * 
     *  @property success
     *  @type function(InquiryPacket)
     */
    prototype.success = null;
    /**
     *  Callback if this inquiry requires additional information to proceed.
     * 
     *  @property ask
     *  @type string function(string)
     */
    prototype.ask = null;
    /**
     *  Callback if this inquiry fails.
     * 
     *  @property failure
     *  @type function(string)
     */
    prototype.failure = null;
    /**
     *  Level that the competency is being measured at.
     *  May have multiple levels referring to multiple competencies due to cycles or equivalence.
     * 
     *  @property level
     *  @type EcLevel[]
     */
    prototype.level = null;
    /**
     *  Packets that are equivalent to this packet. May be used when equivalence is best represented with additional packets.
     * 
     *  @property equivalentPackets
     *  @type InquiryPacket[]
     */
    prototype.equivalentPackets = null;
    /**
     *  Packets that assist in determining the state of this packet.
     * 
     *  @property subPackets
     *  @type InquiryPacket[]
     */
    prototype.subPackets = null;
    /**
     *  Datetime representing when this packet was created.
     * 
     *  @property dateCreated
     *  @internal
     *  @type number
     */
    prototype.dateCreated = 0.0;
    /**
     *  Mark true when assertions have been retrieved for this packet.
     * 
     *  @property hasCheckedAssertionsForCompetency
     *  @type boolean
     */
    prototype.hasCheckedAssertionsForCompetency = false;
    /**
     *  Mark true when rollup rules have been processed for this packet.
     * 
     *  @property hasCheckedRollupRulesForCompetency
     *  @type boolean
     */
    prototype.hasCheckedRollupRulesForCompetency = false;
    /**
     *  Mark true when relations have been processed for this packet.
     * 
     *  @property hasCheckedRelationshipsForCompetency
     *  @type boolean
     */
    prototype.hasCheckedRelationshipsForCompetency = false;
    /**
     *  Async counter to keep track of number of unresolved processes.
     * 
     *  @property numberOfQueriesRunning
     *  @type integer
     */
    prototype.numberOfQueriesRunning = 0;
    /**
     *  Local log for this inquiry packet.
     * 
     *  @property log
     *  @type string
     */
    prototype.log = null;
    /**
     *  Assertions (direct or indirect) that contribute to a positive result.
     * 
     *  @property positive
     *  @type EcAssertion[]
     */
    prototype.positive = null;
    /**
     *  Assertions (direct or indirect) that contribute to a negative result.
     * 
     *  @property negative
     *  @type EcAssertion[]
     */
    prototype.negative = null;
    /**
     *  Set to true if this packet has completed processing.
     * 
     *  @property finished
     *  @type boolean
     */
    prototype.finished = false;
    /**
     *  Set to true if this packet has finished stage one.
     * 
     *  @property stageOneFinished
     *  @type boolean
     */
    prototype.stageOneComplete = false;
    /**
     *  Type of inquiry packet. Inquiry packets can represent relational logic, rollup logic or competencies.
     * 
     *  @property type
     *  @type IPType
     */
    prototype.type = null;
    /**
     *  Rollup Rule search string. (if IPType == ROLLUPRULE)
     * 
     *  @property rule
     *  @type string
     */
    prototype.rule = null;
    /**
     *  Result as a ResultType. ResultType is an autogenerated Enum object, and result._name may match "TRUE", "FALSE", "UNKNOWN", "INDETERMINANT"
     * 
     *  @property result
     *  @type ResultType
     */
    prototype.result = null;
    prototype.getContext = function() {
        return this.context;
    };
    /**
     *  Returns true if any child packets have an indeterminate result.
     * 
     *  @return {boolean}
     *  @method anyIndeterminantChildPackets
     */
    prototype.anyIndeterminantChildPackets = function() {
        for (var i = 0; i < this.equivalentPackets.length; i++) {
            if (InquiryPacket.ResultType.INDETERMINANT.equals(this.equivalentPackets[i].result)) 
                return true;
        }
        for (var i = 0; i < this.subPackets.length; i++) {
            if (InquiryPacket.ResultType.INDETERMINANT.equals(this.subPackets[i].result)) 
                return true;
        }
        return false;
    };
    /**
     *  Returns true if all child packets have unknown results.
     * 
     *  @return {boolean}
     *  @method allChildPacketsUnknown
     */
    prototype.allChildPacketsUnknown = function() {
        for (var i = 0; i < this.equivalentPackets.length; i++) {
            if (!InquiryPacket.ResultType.UNKNOWN.equals(this.equivalentPackets[i].result)) 
                return false;
        }
        for (var i = 0; i < this.subPackets.length; i++) {
            if (!InquiryPacket.ResultType.UNKNOWN.equals(this.subPackets[i].result)) 
                return false;
        }
        return true;
    };
    /**
     *  Returns true if all child packets have unknown results.
     * 
     *  @return {boolean}
     *  @method allChildPacketsUnknown
     */
    prototype.allChildPacketsAreTrue = function() {
        for (var i = 0; i < this.equivalentPackets.length; i++) {
            if (!InquiryPacket.ResultType.TRUE.equals(this.equivalentPackets[i].result)) 
                return false;
        }
        for (var i = 0; i < this.subPackets.length; i++) {
            if (!InquiryPacket.ResultType.TRUE.equals(this.subPackets[i].result)) 
                return false;
        }
        return true;
    };
    /**
     *  Returns true if any child packets have false results.
     * 
     *  @return {boolean}
     *  @method anyChildPacketsAreFalse
     */
    prototype.anyChildPacketsAreFalse = function() {
        for (var i = 0; i < this.equivalentPackets.length; i++) {
            if (InquiryPacket.ResultType.FALSE.equals(this.equivalentPackets[i].result)) 
                return true;
        }
        for (var i = 0; i < this.subPackets.length; i++) {
            if (InquiryPacket.ResultType.FALSE.equals(this.subPackets[i].result)) 
                return true;
        }
        return false;
    };
    /**
     *  Returns true if any child packets have unknown results.
     * 
     *  @return {boolean}
     *  @method anyChildPacketsAreUnknown
     */
    prototype.anyChildPacketsAreUnknown = function() {
        for (var i = 0; i < this.equivalentPackets.length; i++) {
            if (InquiryPacket.ResultType.UNKNOWN.equals(this.equivalentPackets[i].result)) 
                return true;
        }
        for (var i = 0; i < this.subPackets.length; i++) {
            if (InquiryPacket.ResultType.UNKNOWN.equals(this.subPackets[i].result)) 
                return true;
        }
        return false;
    };
    /**
     *  Returns true if any child packets have true results.
     * 
     *  @return {boolean}
     *  @method anyChildPacketsAreTrue
     */
    prototype.anyChildPacketsAreTrue = function() {
        for (var i = 0; i < this.equivalentPackets.length; i++) {
            if (InquiryPacket.ResultType.TRUE.equals(this.equivalentPackets[i].result)) 
                return true;
        }
        for (var i = 0; i < this.subPackets.length; i++) {
            if (InquiryPacket.ResultType.TRUE.equals(this.subPackets[i].result)) 
                return true;
        }
        return false;
    };
    /**
     *  Returns true if all equivalent packets have unknown results.
     * 
     *  @return {boolean}
     *  @method allEquivalentPacketsUnknown
     */
    prototype.allEquivalentPacketsUnknown = function() {
        for (var i = 0; i < this.equivalentPackets.length; i++) {
            if (!InquiryPacket.ResultType.UNKNOWN.equals(this.equivalentPackets[i].result)) 
                return false;
        }
        return true;
    };
    /**
     *  Returns true if all equivalent packets have the true or unknown result.
     * 
     *  @return {boolean}
     *  @method allEquivalentPacketsTrueOrUnknown
     */
    prototype.allEquivalentPacketsTrueOrUnknown = function() {
        for (var i = 0; i < this.equivalentPackets.length; i++) {
            if (InquiryPacket.ResultType.FALSE.equals(this.equivalentPackets[i].result) || InquiryPacket.ResultType.INDETERMINANT.equals(this.equivalentPackets[i].result)) 
                return false;
        }
        return true;
    };
    /**
     *  Returns true if all sub packets have the true or unknown result.
     * 
     *  @return {boolean}
     *  @method allSubPacketsTrueOrUnknown
     */
    prototype.allSubPacketsTrueOrUnknown = function() {
        for (var i = 0; i < this.subPackets.length; i++) {
            if (InquiryPacket.ResultType.FALSE.equals(this.subPackets[i].result) || InquiryPacket.ResultType.INDETERMINANT.equals(this.subPackets[i].result)) 
                return false;
        }
        return true;
    };
    /**
     *  Returns true if all equivalent packets have the false or unknown result.
     * 
     *  @return {boolean}
     *  @method allEquivalentPacketsFalseOrUnknown
     */
    prototype.allEquivalentPacketsFalseOrUnknown = function() {
        for (var i = 0; i < this.equivalentPackets.length; i++) {
            if (InquiryPacket.ResultType.TRUE.equals(this.equivalentPackets[i].result) || InquiryPacket.ResultType.INDETERMINANT.equals(this.equivalentPackets[i].result)) 
                return false;
        }
        return true;
    };
    /**
     *  Returns true if all sub packets have the false or unknown result.
     * 
     *  @return
     */
    prototype.allSubPacketsFalseOrUnknown = function() {
        for (var i = 0; i < this.subPackets.length; i++) {
            if (InquiryPacket.ResultType.TRUE.equals(this.subPackets[i].result) || InquiryPacket.ResultType.INDETERMINANT.equals(this.subPackets[i].result)) 
                return false;
        }
        return true;
    };
    /**
     *  Returns true if the provided ID represents a competency in this packet.
     * 
     *  @param competencyId
     *  @return
     */
    prototype.hasId = function(competencyId) {
        for (var i = 0; i < this.competency.length; i++) 
            if (this.competency[i].isId(competencyId)) 
                return true;
        return false;
    };
    constructor.IPType = stjs.enumeration("COMPETENCY", "ROLLUPRULE", "RELATION_AND", "RELATION_OR", "RELATION_NARROWS", "RELATION_BROADENS", "RELATION_REQUIRES", "RELATION_ISREQUIREDBY");
    constructor.ResultType = stjs.enumeration("TRUE", "FALSE", "UNKNOWN", "INDETERMINANT");
}, {subject: {name: "Array", arguments: ["EcPk"]}, competency: {name: "Array", arguments: ["EcCompetency"]}, context: "EcFramework", success: {name: "Callback1", arguments: ["InquiryPacket"]}, ask: {name: "Function1", arguments: [null, null]}, failure: {name: "Callback1", arguments: [null]}, level: {name: "Array", arguments: ["EcLevel"]}, equivalentPackets: {name: "Array", arguments: ["InquiryPacket"]}, subPackets: {name: "Array", arguments: ["InquiryPacket"]}, positive: {name: "Array", arguments: ["EcAssertion"]}, negative: {name: "Array", arguments: ["EcAssertion"]}, type: {name: "Enum", arguments: ["InquiryPacket.IPType"]}, result: {name: "Enum", arguments: ["InquiryPacket.ResultType"]}}, {});
var PapSettings = function() {
    this.iterations = PapSettings.DEFAULT_ITERATIONS;
    this.abruptExpiration = PapSettings.DEFAULT_ABRUPT_EXP;
    this.gradualForgetting = PapSettings.DEFAULT_GRAD_FORGETTING;
    this.evidenceWeight = PapSettings.DEFAULT_EVIDENCE_WEIGHT;
    this.discount = PapSettings.DEFAULT_DISCOUNT;
    this.priorityQueueThreshold = PapSettings.DEFAULT_PRIORITY_QUEUE_THRESHOLD;
    this.betaPrecision = PapSettings.DEFAULT_BETA_PRECISION;
    this.betaMean = PapSettings.DEFAULT_BETA_MEAN;
};
PapSettings = stjs.extend(PapSettings, null, [], function(constructor, prototype) {
    constructor.DEFAULT_ITERATIONS = 200;
    constructor.DEFAULT_ABRUPT_EXP = false;
    constructor.DEFAULT_GRAD_FORGETTING = true;
    constructor.DEFAULT_EVIDENCE_WEIGHT = 1.0;
    constructor.DEFAULT_DISCOUNT = 1.0;
    constructor.DEFAULT_PRIORITY_QUEUE_THRESHOLD = 0.01;
    constructor.DEFAULT_BETA_PRECISION = 0.1;
    constructor.DEFAULT_BETA_MEAN = 0.2;
    prototype.iterations = null;
    prototype.abruptExpiration = false;
    prototype.gradualForgetting = false;
    prototype.evidenceWeight = null;
    prototype.discount = null;
    prototype.priorityQueueThreshold = null;
    prototype.betaPrecision = null;
    prototype.betaMean = null;
    prototype.getIterations = function() {
        return this.iterations;
    };
    prototype.setIterations = function(iterations) {
        this.iterations = iterations;
    };
    prototype.getAbruptExpiration = function() {
        return this.abruptExpiration;
    };
    prototype.setAbruptExpiration = function(abruptExpiration) {
        this.abruptExpiration = abruptExpiration;
    };
    prototype.getGradualForgetting = function() {
        return this.gradualForgetting;
    };
    prototype.setGradualForgetting = function(gradualForgetting) {
        this.gradualForgetting = gradualForgetting;
    };
    prototype.getEvidenceWeight = function() {
        return this.evidenceWeight;
    };
    prototype.setEvidenceWeight = function(evidenceWeight) {
        this.evidenceWeight = evidenceWeight;
    };
    prototype.getDiscount = function() {
        return this.discount;
    };
    prototype.setDiscount = function(discount) {
        this.discount = discount;
    };
    prototype.getPriorityQueueThreshold = function() {
        return this.priorityQueueThreshold;
    };
    prototype.setPriorityQueueThreshold = function(priorityQueueThreshold) {
        this.priorityQueueThreshold = priorityQueueThreshold;
    };
    prototype.getBetaPrecision = function() {
        return this.betaPrecision;
    };
    prototype.setBetaPrecision = function(betaPrecision) {
        this.betaPrecision = betaPrecision;
    };
    prototype.getBetaMean = function() {
        return this.betaMean;
    };
    prototype.setBetaMean = function(betaMean) {
        this.betaMean = betaMean;
    };
}, {}, {});
var ArrayUtil = function() {};
ArrayUtil = stjs.extend(ArrayUtil, null, [], function(constructor, prototype) {
    constructor.arrayContains = function(a, o) {
        for (var i = 0; i < a.length; i++) {
            if (a[i] == o) 
                return true;
        }
        return false;
    };
    constructor.arrayRemove = function(a, o) {
        var retArray = new Array();
        for (var i = 0; i < a.length; i++) {
            if (a[i] != o) 
                retArray.push(a[i]);
        }
        return retArray;
    };
    constructor.arrayLastIndexOf = function(a, o) {
        for (var i = (a.length - 1); i >= 0; i--) {
            if (a[i] == o) 
                return i;
        }
        return -1;
    };
    constructor.arrayToString = function(a) {
        if (a == null || a.length == 0) 
            return "<Emtpy>";
        var ret = "";
        for (var i = 0; i < a.length; i++) {
            if ((i + 1) < a.length) 
                ret = ret + a[i].toString() + ", ";
             else 
                ret = ret + a[i].toString();
        }
        return ret;
    };
}, {}, {});
var NodePacket = function() {
    this.nodeList = new Array();
    this.nodeMap = {};
};
NodePacket = stjs.extend(NodePacket, null, [], function(constructor, prototype) {
    prototype.nodeList = null;
    prototype.nodeMap = null;
    prototype.getNodeList = function() {
        return this.nodeList;
    };
    prototype.setNodeList = function(nodeList) {
        this.nodeList = nodeList;
    };
    prototype.getNodeCount = function() {
        return this.nodeList.length;
    };
    prototype.addNode = function(n) {
        if (this.nodeMap[n.getId()] == null) {
            this.nodeList.push(n);
            this.nodeMap[n.getId()] = n;
        }
    };
    prototype.toString = function() {
        var ret = "";
        ret = ret + "NodePacket: (";
        for (var i = 0; i < this.nodeList.length; i++) {
            if ((i + 1) < this.nodeList.length) 
                ret = ret + this.nodeList[i].toString() + ", ";
             else 
                ret = ret + this.nodeList[i].toString();
        }
        ret = ret + ")";
        return ret;
    };
}, {nodeList: {name: "Array", arguments: ["Node"]}, nodeMap: {name: "Map", arguments: [null, "Node"]}}, {});
var NodeRelationMap = function() {
    this.nodeList = new Array();
    this.relationMap = {};
};
NodeRelationMap = stjs.extend(NodeRelationMap, null, [], function(constructor, prototype) {
    prototype.nodeList = null;
    prototype.relationMap = null;
    prototype.addNodeRelations = function(n, rm) {
        this.nodeList.push(n);
        this.relationMap[n.getId()] = rm;
    };
    prototype.getRelationsForNode = function(n) {
        return this.relationMap[n.getId()];
    };
    prototype.getNodeList = function() {
        return this.nodeList;
    };
    prototype.setNodeList = function(nodeList) {
        this.nodeList = nodeList;
    };
    prototype.getRelationMap = function() {
        return this.relationMap;
    };
    prototype.setRelationMap = function(relationMap) {
        this.relationMap = relationMap;
    };
    prototype.toString = function() {
        var ret = "";
        var n;
        var nra;
        for (var i = 0; i < this.nodeList.length; i++) {
            n = this.nodeList[i];
            ret = ret + n.toString() + "\n";
            nra = this.relationMap[n.getId()];
            for (var j = 0; j < nra.length; j++) {
                ret = ret + "\t" + nra[j].toString() + "\n";
            }
        }
        return ret;
    };
}, {nodeList: {name: "Array", arguments: ["Node"]}, relationMap: {name: "Map", arguments: [null, {name: "Array", arguments: ["NodeRelation"]}]}}, {});
/**
 *  Created by fray on 5/30/17.
 */
var AssertionCoprocessor = function() {};
AssertionCoprocessor = stjs.extend(AssertionCoprocessor, null, [], function(constructor, prototype) {
    prototype.assertionProcessor = null;
    prototype.collectAssertions = function(ip, listOfCompetencies, success) {
        success(new Array());
    };
    prototype.mutateAssertions = function(ip, listOfCompetencies, success) {
        success();
    };
}, {assertionProcessor: "AssertionProcessor"}, {});
var PapDependencyDefinitionBase = function(depClass, reverse, weight, leak) {
    this.depClass = depClass;
    this.reverse = reverse;
    this.weight = weight;
    this.leak = leak;
};
PapDependencyDefinitionBase = stjs.extend(PapDependencyDefinitionBase, null, [], function(constructor, prototype) {
    prototype.depClass = null;
    prototype.reverse = false;
    prototype.weight = null;
    prototype.leak = null;
    prototype.getDepClass = function() {
        return this.depClass;
    };
    prototype.setDepClass = function(depClass) {
        this.depClass = depClass;
    };
    prototype.getReverse = function() {
        return this.reverse;
    };
    prototype.setReverse = function(reverse) {
        this.reverse = reverse;
    };
    prototype.getWeight = function() {
        return this.weight;
    };
    prototype.setWeight = function(weight) {
        this.weight = weight;
    };
    prototype.getLeak = function() {
        return this.leak;
    };
    prototype.setLeak = function(leak) {
        this.leak = leak;
    };
}, {}, {});
var PapDependencyParms = function() {};
PapDependencyParms = stjs.extend(PapDependencyParms, null, [], function(constructor, prototype) {
    prototype.parentIndex = null;
    prototype.childIndex = null;
    prototype.type = null;
    prototype.weight = null;
    prototype.leak = null;
    prototype.dependencyFirst = false;
    prototype.reverse = false;
    prototype.getParentIndex = function() {
        return this.parentIndex;
    };
    prototype.setParentIndex = function(parentIndex) {
        this.parentIndex = parentIndex;
    };
    prototype.getChildIndex = function() {
        return this.childIndex;
    };
    prototype.setChildIndex = function(childIndex) {
        this.childIndex = childIndex;
    };
    prototype.getType = function() {
        return this.type;
    };
    prototype.setType = function(type) {
        this.type = type;
    };
    prototype.getWeight = function() {
        return this.weight;
    };
    prototype.setWeight = function(weight) {
        this.weight = weight;
    };
    prototype.getLeak = function() {
        return this.leak;
    };
    prototype.setLeak = function(leak) {
        this.leak = leak;
    };
    prototype.getDependencyFirst = function() {
        return this.dependencyFirst;
    };
    prototype.setDependencyFirst = function(dependencyFirst) {
        this.dependencyFirst = dependencyFirst;
    };
    prototype.getReverse = function() {
        return this.reverse;
    };
    prototype.setReverse = function(reverse) {
        this.reverse = reverse;
    };
    prototype.swapParentChildIndexes = function() {
        var temp = this.parentIndex;
        this.parentIndex = this.childIndex;
        this.childIndex = temp;
    };
}, {}, {});
var PapUpdate = function(index, change, positive) {
    this.index = index;
    this.change = change;
    this.visited = new Array();
    this.positive = positive;
};
PapUpdate = stjs.extend(PapUpdate, null, [], function(constructor, prototype) {
    prototype.index = 0;
    prototype.visited = null;
    prototype.change = 0.0;
    prototype.positive = false;
    prototype.hasVisited = function(index) {
        for (var i = 0; i < this.visited.length; i++) {
            if (this.visited[i].intValue() == index) 
                return true;
        }
        return false;
    };
    prototype.updateChild = function(index, change) {
        var res = new PapUpdate(index, change, this.positive);
        res.setVisited(this.cloneVisited());
        res.getVisited().push(index);
        return res;
    };
    prototype.toString = function() {
        var sign = this.positive ? "+" : "-";
        return "<update " + this.index + " | " + sign + this.change + ">";
    };
    prototype.compare = function(other) {
        var diff = this.change - other.getChange();
        if (diff < 0) 
            return 1;
        if (diff > 0) 
            return -1;
        return 0;
    };
    prototype.cloneVisited = function() {
        var newVis = new Array();
        for (var i = 0; i < this.visited.length; i++) {
            newVis.push(this.visited[i]);
        }
        return newVis;
    };
    prototype.getIndex = function() {
        return this.index;
    };
    prototype.setIndex = function(index) {
        this.index = index;
    };
    prototype.getVisited = function() {
        return this.visited;
    };
    prototype.setVisited = function(visited) {
        this.visited = visited;
    };
    prototype.getChange = function() {
        return this.change;
    };
    prototype.setChange = function(change) {
        this.change = change;
    };
    prototype.getPositive = function() {
        return this.positive;
    };
    prototype.setPositive = function(positive) {
        this.positive = positive;
    };
}, {visited: {name: "Array", arguments: [null]}}, {});
var PacketRelation = function(source, target, type) {
    this.source = source;
    this.target = target;
    this.type = type;
};
PacketRelation = stjs.extend(PacketRelation, null, [], function(constructor, prototype) {
    prototype.type = null;
    prototype.source = null;
    prototype.target = null;
    prototype.getSource = function() {
        return this.source;
    };
    prototype.setSource = function(source) {
        this.source = source;
    };
    prototype.getTarget = function() {
        return this.target;
    };
    prototype.setTarget = function(target) {
        this.target = target;
    };
    prototype.getType = function() {
        return this.type;
    };
    prototype.setType = function(type) {
        this.type = type;
    };
    prototype.toString = function() {
        return this.getSource().toString() + " >>" + this.getType() + "<< " + this.getTarget().toString();
    };
}, {type: {name: "Enum", arguments: ["RelationType.RELATION_TYPE"]}, source: "NodePacket", target: "NodePacket"}, {});
var ExceptionReturn = function(errorMessage) {
    this.errorMessage = errorMessage;
};
ExceptionReturn = stjs.extend(ExceptionReturn, null, [], function(constructor, prototype) {
    prototype.errorMessage = null;
    prototype.getErrorMessage = function() {
        return this.errorMessage;
    };
    prototype.setErrorMessage = function(errorMessage) {
        this.errorMessage = errorMessage;
    };
    prototype.getJsonString = function() {
        return JSON.stringify(this);
    };
}, {}, {});
var RollupRuleInterface = function(input, processor) {
    var chars = new antlr4.InputStream(input);
    var lexer = new RollupLexer.RollupLexer(chars);
    var tokens = new antlr4.CommonTokenStream(lexer);
    this.parser = new RollupParser.RollupParser(tokens);
    this.parser.buildParseTrees = true;
    this.listener = new RollupListener.RollupListener();
    this.processor = processor;
    var me = this;
    this.listener.enterS = function(ctx) {
        me.processor.enterS(ctx);
    };
    this.listener.exitS = function(ctx) {
        me.processor.exitS(ctx);
        me.success(true);
    };
    this.listener.exitToken = function(ctx) {
        me.processor.exitToken(ctx);
    };
    this.listener.enterQuery = function(ctx) {
        me.processor.enterQuery(ctx);
    };
    this.listener.exitQuery = function(ctx) {
        me.processor.exitQuery(ctx);
    };
    this.listener.exitInnerquery = function(ctx) {
        me.processor.exitInnerquery(ctx);
    };
    this.listener.exitLogical_or_math_operator = function(ctx) {
        me.processor.exitLogical_or_math_operator(ctx);
    };
    this.parser.addParseListener(this.listener);
};
RollupRuleInterface = stjs.extend(RollupRuleInterface, null, [], function(constructor, prototype) {
    prototype.logFunction = null;
    prototype.success = null;
    prototype.failure = null;
    prototype.listener = null;
    prototype.parser = null;
    prototype.processor = null;
    prototype.go = function() {
        this.processor.logFunction = this.logFunction;
        this.processor.success = this.success;
        this.processor.failure = this.failure;
        this.parser.s();
    };
}, {logFunction: {name: "Callback1", arguments: ["Object"]}, success: {name: "Callback1", arguments: [null]}, failure: {name: "Callback1", arguments: [null]}, listener: "RollupListener.RollupListener", parser: "RollupParser.RollupParser", processor: "RollupRuleProcessor"}, {});
var PapCompetencyNetwork = function(dependencies, numberNodes, settings) {
    this.numberNodes = numberNodes;
    this.dependencies = dependencies;
    this.activations = new Array();
    this.alphas = new Array();
    this.betas = new Array();
    this.updated = new Array();
    for (var i = 0; i < numberNodes; i++) {
        var beta_prior = settings.getBetaPrecision();
        var beta_mean = settings.getBetaMean();
        this.alphas.push(beta_mean * beta_prior);
        this.betas.push((1.0 - beta_mean) * beta_prior);
        this.activations.push(beta_mean);
        this.updated.push(false);
    }
};
PapCompetencyNetwork = stjs.extend(PapCompetencyNetwork, null, [], function(constructor, prototype) {
    constructor.LOW_CONFLICT_CLASS = "low";
    constructor.MEDIUM_CONFLICT_CLASS = "medium";
    constructor.HIGH_CONFLICT_CLASS = "high";
    constructor.EMPTY_PREDICTION = 0.0;
    constructor.EMPTY_CONFLICT_LEVEL = 0.0;
    constructor.MEDIUM_CONFLICT_CLASS_QUALIFIER = 1.05;
    constructor.HIGH_CONFLICT_CLASS_QUALIFIER = 1.5;
    prototype.dependencies = null;
    prototype.activations = null;
    prototype.alphas = null;
    prototype.betas = null;
    prototype.updated = null;
    prototype.numberNodes = 0;
    prototype.update = function(nodeIndex, change, positive) {
        var a = this.alphas[nodeIndex];
        var b = this.betas[nodeIndex];
        if (positive) 
            this.alphas[nodeIndex] = a + change;
         else 
            this.betas[nodeIndex] = b + change;
        this.activations[nodeIndex] = (a + (positive ? change : 0)) / (a + b + change);
        this.updated[nodeIndex] = true;
    };
    prototype.getPrediction = function(index) {
        if (this.updated[index]) {
            return this.activations[index];
        } else 
            return PapCompetencyNetwork.EMPTY_PREDICTION;
    };
    prototype.getConflictLevel = function(index) {
        if (this.updated[index]) {
            var a = this.alphas[index];
            var b = this.betas[index];
            var act = this.activations[index];
            var stdev = Math.sqrt((a * b) / (a + b + 1)) / (a + b);
            return Math.min(act, 1.0 - act) / stdev;
        } else 
            return PapCompetencyNetwork.EMPTY_CONFLICT_LEVEL;
    };
    prototype.getConflictClass = function(index) {
        var level = this.getConflictLevel(index);
        var res = PapCompetencyNetwork.LOW_CONFLICT_CLASS;
        if (level >= PapCompetencyNetwork.MEDIUM_CONFLICT_CLASS_QUALIFIER) 
            res = PapCompetencyNetwork.MEDIUM_CONFLICT_CLASS;
        if (level >= PapCompetencyNetwork.HIGH_CONFLICT_CLASS_QUALIFIER) 
            res = PapCompetencyNetwork.HIGH_CONFLICT_CLASS;
        return res;
    };
    prototype.getDependencies = function() {
        return this.dependencies;
    };
    prototype.setDependencies = function(dependencies) {
        this.dependencies = dependencies;
    };
    prototype.getActivations = function() {
        return this.activations;
    };
    prototype.setActivations = function(activations) {
        this.activations = activations;
    };
    prototype.getAlphas = function() {
        return this.alphas;
    };
    prototype.setAlphas = function(alphas) {
        this.alphas = alphas;
    };
    prototype.getBetas = function() {
        return this.betas;
    };
    prototype.setBetas = function(betas) {
        this.betas = betas;
    };
    prototype.getUpdated = function() {
        return this.updated;
    };
    prototype.setUpdated = function(updated) {
        this.updated = updated;
    };
    prototype.getNumberNodes = function() {
        return this.numberNodes;
    };
    prototype.setNumberNodes = function(numberNodes) {
        this.numberNodes = numberNodes;
    };
}, {dependencies: {name: "Map", arguments: [null, {name: "Map", arguments: [null, {name: "Array", arguments: ["PapDependency"]}]}]}, activations: {name: "Array", arguments: [null]}, alphas: {name: "Array", arguments: [null]}, betas: {name: "Array", arguments: [null]}, updated: {name: "Array", arguments: [null]}}, {});
var PapAssertion = function(confidence, competencyIndex, assertionDate, expirationDate, result) {
    this.confidence = confidence;
    this.assertionDate = assertionDate;
    this.expirationDate = expirationDate;
    this.result = result;
    this.competencyIndex = competencyIndex;
};
PapAssertion = stjs.extend(PapAssertion, null, [], function(constructor, prototype) {
    prototype.confidence = null;
    prototype.competencyIndex = null;
    prototype.assertionDate = null;
    prototype.expirationDate = null;
    prototype.result = false;
    prototype.getConfidence = function() {
        return this.confidence;
    };
    prototype.setConfidence = function(confidence) {
        this.confidence = confidence;
    };
    prototype.getCompetencyIndex = function() {
        return this.competencyIndex;
    };
    prototype.setCompetencyIndex = function(competencyIndex) {
        this.competencyIndex = competencyIndex;
    };
    prototype.getAssertionDate = function() {
        return this.assertionDate;
    };
    prototype.setAssertionDate = function(assertionDate) {
        this.assertionDate = assertionDate;
    };
    prototype.getExpirationDate = function() {
        return this.expirationDate;
    };
    prototype.setExpirationDate = function(expirationDate) {
        this.expirationDate = expirationDate;
    };
    prototype.getResult = function() {
        return this.result;
    };
    prototype.setResult = function(result) {
        this.result = result;
    };
}, {}, {});
var EcGraphUtil = function() {};
EcGraphUtil = stjs.extend(EcGraphUtil, null, [], function(constructor, prototype) {
    constructor.buildIdSearchQueryForIdList = function(idList) {
        var searchQuery = "";
        if (idList.length > 1) 
            searchQuery = "(";
        for (var i = 0; i < idList.length; i++) {
            if (i > 0) 
                searchQuery += " OR ";
            searchQuery += "(\\*@id:\"" + idList[i] + "\")";
        }
        if (idList.length > 1) 
            searchQuery += ")";
        return searchQuery;
    };
}, {}, {});
var PapNetworkPrediction = function(predictionDate, subjectPem, competencyList, competencyNetwork) {
    this.predictionDate = predictionDate;
    this.subjectPem = subjectPem;
    this.predictions = new Array();
    var currentCompetency;
    var pcp;
    for (var i = 0; i < competencyList.length; i++) {
        currentCompetency = competencyList[i];
        pcp = new PapCompetencyPrediction();
        pcp.setCompetencyId(currentCompetency);
        pcp.setConfidence(competencyNetwork.getPrediction(i));
        pcp.setConflictLevel(competencyNetwork.getConflictLevel(i));
        pcp.setConflictClass(competencyNetwork.getConflictClass(i));
        this.predictions.push(pcp);
    }
};
PapNetworkPrediction = stjs.extend(PapNetworkPrediction, null, [], function(constructor, prototype) {
    prototype.predictionDate = null;
    prototype.subjectPem = null;
    prototype.predictions = null;
    prototype.getPredictionDate = function() {
        return this.predictionDate;
    };
    prototype.setPredictionDate = function(predictionDate) {
        this.predictionDate = predictionDate;
    };
    prototype.getSubjectPem = function() {
        return this.subjectPem;
    };
    prototype.setSubjectPem = function(subjectPem) {
        this.subjectPem = subjectPem;
    };
    prototype.getPredictions = function() {
        return this.predictions;
    };
    prototype.setPredictions = function(predictions) {
        this.predictions = predictions;
    };
    prototype.getJsonString = function() {
        return JSON.stringify(this);
    };
}, {predictions: {name: "Array", arguments: ["PapCompetencyPrediction"]}}, {});
var NodeGraph = function() {
    this.nodeList = new Array();
    this.relationList = new Array();
    this.nodeMap = {};
    this.relationMap = {};
};
NodeGraph = stjs.extend(NodeGraph, null, [], function(constructor, prototype) {
    prototype.nodeList = null;
    prototype.nodeMap = null;
    prototype.relationList = null;
    prototype.relationMap = null;
    prototype.addNode = function(n) {
        if (this.nodeMap[n.getId()] == null) {
            this.nodeList.push(n);
            this.nodeMap[n.getId()] = n;
        }
    };
    prototype.createImpliedRelations = function() {
        try {
            var relationsToAdd = new Array();
            var nr;
            for (var i = 0; i < this.relationList.length; i++) {
                nr = this.relationList[i];
                if (nr.getType() == RelationType.RELATION_TYPE.NARROWS) {
                    relationsToAdd.push(new NodeRelation(nr.getTarget(), nr.getSource(), RelationType.RELATION_TYPE.BROADENS));
                } else if (nr.getType() == RelationType.RELATION_TYPE.REQUIRES) {
                    relationsToAdd.push(new NodeRelation(nr.getTarget(), nr.getSource(), RelationType.RELATION_TYPE.IS_REQUIRED_BY));
                } else if (nr.getType() == RelationType.RELATION_TYPE.BROADENS) {
                    relationsToAdd.push(new NodeRelation(nr.getTarget(), nr.getSource(), RelationType.RELATION_TYPE.NARROWS));
                } else if (nr.getType() == RelationType.RELATION_TYPE.IS_REQUIRED_BY) {
                    relationsToAdd.push(new NodeRelation(nr.getTarget(), nr.getSource(), RelationType.RELATION_TYPE.REQUIRES));
                }
            }
            var nnr;
            for (var i = 0; i < relationsToAdd.length; i++) {
                nnr = relationsToAdd[i];
                this.addRelation(nnr.getSource(), nnr.getTarget(), nnr.getType());
            }
        }catch (e) {
             throw new Exception("createImpliedRelations: " + e.toString());
        }
    };
    prototype.addRelation = function(sourceNode, targetNode, relationType) {
        try {
            if (sourceNode == null || targetNode == null) 
                return;
            var nodeRelationList;
            if (this.nodeHasRelations(sourceNode)) 
                nodeRelationList = this.getRelationListForNode(sourceNode);
             else {
                nodeRelationList = new Array();
                this.relationMap[sourceNode.getId()] = nodeRelationList;
            }
            var newNodeRelation = new NodeRelation(sourceNode, targetNode, relationType);
            if (!this.doesRelationAlreadyExist(newNodeRelation, nodeRelationList)) {
                nodeRelationList.push(newNodeRelation);
                this.relationList.push(newNodeRelation);
            }
        }catch (e) {
             throw new Exception("addRelation: " + e.toString());
        }
    };
    prototype.getRelationListForNode = function(n) {
        return this.relationMap[n.getId()];
    };
    prototype.getNarrowsIsRequiredByEqualsRelationListForNode = function(n) {
        var retList = new Array();
        if (this.relationMap[n.getId()] != null) {
            var nra = this.relationMap[n.getId()];
            var nr;
            for (var i = 0; i < nra.length; i++) {
                nr = nra[i];
                if (nr.getType() == RelationType.RELATION_TYPE.IS_EQUIVALENT_TO || nr.getType() == RelationType.RELATION_TYPE.NARROWS || nr.getType() == RelationType.RELATION_TYPE.IS_REQUIRED_BY) {
                    retList.push(nr);
                }
            }
        }
        return retList;
    };
    prototype.getBroadensRequiresEqualsRelationListForNode = function(n) {
        var retList = new Array();
        if (this.relationMap[n.getId()] != null) {
            var nra = this.relationMap[n.getId()];
            var nr;
            for (var i = 0; i < nra.length; i++) {
                nr = nra[i];
                if (nr.getType() == RelationType.RELATION_TYPE.IS_EQUIVALENT_TO || nr.getType() == RelationType.RELATION_TYPE.BROADENS || nr.getType() == RelationType.RELATION_TYPE.REQUIRES) {
                    retList.push(nr);
                }
            }
        }
        return retList;
    };
    prototype.getNodeList = function() {
        return this.nodeList;
    };
    prototype.setNodeList = function(nodeList) {
        this.nodeList = nodeList;
    };
    prototype.getRelationList = function() {
        return this.relationList;
    };
    prototype.setRelationList = function(relationList) {
        this.relationList = relationList;
    };
    prototype.nodeHasRelations = function(n) {
        if (this.relationMap[n.getId()] == null) 
            return false;
        return true;
    };
    prototype.doesRelationAlreadyExist = function(nodeRelation, nodeRelationList) {
        var nr;
        for (var i = 0; i < nodeRelationList.length; i++) {
            nr = nodeRelationList[i];
            if (nodeRelation.getSource().getId() == nr.getSource().getId() && nodeRelation.getTarget().getId() == nr.getTarget().getId() && nodeRelation.getType() == nr.getType()) 
                return true;
        }
        return false;
    };
    prototype.toStringGraphAll = function() {
        var ret = "";
        var n;
        for (var i = 0; i < this.nodeList.length; i++) {
            n = this.nodeList[i];
            ret = ret + n.toString() + "\n";
        }
        var nr;
        for (var i = 0; i < this.relationList.length; i++) {
            nr = this.relationList[i];
            ret = ret + nr.toString() + "\n";
        }
        return ret;
    };
    prototype.toStringGraphByNode = function() {
        var ret = "";
        ret = ret + " - TEST HOWDY - \n";
        var n;
        var nra;
        var nr;
        for (var i = 0; i < this.nodeList.length; i++) {
            n = this.nodeList[i];
            ret = ret + "   --> " + n.toString() + "\n";
            if (this.nodeHasRelations(n)) {
                nra = this.getRelationListForNode(n);
                for (var j = 0; j < nra.length; j++) {
                    nr = nra[j];
                    ret = ret + "\t\t" + nr.toString() + "\n";
                }
            } else 
                ret = ret + "\t\t---------NO RELATIONSHIPS---------\n";
        }
        return ret;
    };
    prototype.toStringGraphByNodeSplit = function() {
        var ret = "";
        var n;
        var nra;
        var nr;
        for (var i = 0; i < this.nodeList.length; i++) {
            n = this.nodeList[i];
            ret = ret + "   --> " + n.toString() + "\n";
            if (this.nodeHasRelations(n)) {
                ret = ret + "\t\t=== Narrows/isRequiredBy ===\n";
                nra = this.getNarrowsIsRequiredByEqualsRelationListForNode(n);
                for (var j = 0; j < nra.length; j++) {
                    nr = nra[j];
                    ret = ret + "\t\t" + nr.toString() + "\n";
                }
                ret = ret + "\t\t=== Broadens/Requires ===\n";
                nra = this.getBroadensRequiresEqualsRelationListForNode(n);
                for (var j = 0; j < nra.length; j++) {
                    nr = nra[j];
                    ret = ret + "\t\t" + nr.toString() + "\n";
                }
            } else 
                ret = ret + "\t\t---------NO RELATIONSHIPS---------\n";
        }
        return ret;
    };
}, {nodeList: {name: "Array", arguments: ["Node"]}, nodeMap: {name: "Map", arguments: [null, "Node"]}, relationList: {name: "Array", arguments: ["NodeRelation"]}, relationMap: {name: "Map", arguments: [null, {name: "Array", arguments: ["NodeRelation"]}]}}, {});
var CompetencyGraph = function(includeAssertions) {
    this.nodes = new Array();
    this.edges = new Array();
    this.positiveAssertions = new Array();
    this.negativeAssertions = new Array();
    this.nodeMap = {};
    this.edgeMap = {};
    this.includeAssertions = includeAssertions;
};
CompetencyGraph = stjs.extend(CompetencyGraph, null, [], function(constructor, prototype) {
    constructor.NARROWS_RELATION_TEXT = "narrows";
    constructor.BROADENS_RELATION_TEXT = "broadens";
    constructor.REQUIRES_RELATION_TEXT = "requires";
    constructor.IS_REQUIRED_BY_RELATION_TEXT = "isRequiredBy";
    constructor.IS_EQUIVALENT_TO_RELATION_TEXT = "isEquivalentTo";
    constructor.EDGE_MAP_FIELD_DELIMETER = " -------||||||------- ";
    constructor.CleanGraph = function(nodes, edges) {
        this.nodes = nodes;
        this.edges = edges;
    };
    constructor.CleanGraph = stjs.extend(constructor.CleanGraph, null, [], function(constructor, prototype) {
        prototype.nodes = null;
        prototype.edges = null;
    }, {nodes: {name: "Array", arguments: [null]}, edges: {name: "Array", arguments: ["CgEdge"]}}, {});
    constructor.CleanGraphWithAssertions = function(nodes, edges, positiveAssertions, negativeAssertions) {
        this.nodes = nodes;
        this.edges = edges;
        this.positiveAssertions = positiveAssertions;
        this.negativeAssertions = negativeAssertions;
    };
    constructor.CleanGraphWithAssertions = stjs.extend(constructor.CleanGraphWithAssertions, null, [], function(constructor, prototype) {
        prototype.nodes = null;
        prototype.edges = null;
        prototype.positiveAssertions = null;
        prototype.negativeAssertions = null;
    }, {nodes: {name: "Array", arguments: [null]}, edges: {name: "Array", arguments: ["CgEdge"]}, positiveAssertions: {name: "Array", arguments: ["SimpleAssertion"]}, negativeAssertions: {name: "Array", arguments: ["SimpleAssertion"]}}, {});
    prototype.nodes = null;
    prototype.edges = null;
    prototype.positiveAssertions = null;
    prototype.negativeAssertions = null;
    prototype.nodeMap = null;
    prototype.edgeMap = null;
    prototype.includeAssertions = false;
    prototype.addNode = function(id) {
        if (!this.graphContainsNode(id)) {
            this.nodes.push(id);
            this.nodeMap[id] = id;
        }
    };
    prototype.getEdgeKey = function(source, target, relationType) {
        return source + CompetencyGraph.EDGE_MAP_FIELD_DELIMETER + target + CompetencyGraph.EDGE_MAP_FIELD_DELIMETER + relationType;
    };
    prototype.addEdge = function(source, target, relationType) {
        if (!this.graphContainsEdge(source, target, relationType)) {
            this.edges.push(new CgEdge(source, target, relationType));
            var edgeKey = this.getEdgeKey(source, target, relationType);
            this.edgeMap[edgeKey] = edgeKey;
        }
    };
    prototype.addPositiveAssertion = function(simpleAssertion) {
        if (simpleAssertion != null) 
            this.positiveAssertions.push(simpleAssertion);
    };
    prototype.addNegativeAssertion = function(simpleAssertion) {
        if (simpleAssertion != null) 
            this.negativeAssertions.push(simpleAssertion);
    };
    prototype.graphContainsNode = function(nodeId) {
        if (this.nodeMap[nodeId] == null) 
            return false;
        return true;
    };
    prototype.graphContainsEdge = function(source, target, relationType) {
        if (this.edgeMap[this.getEdgeKey(source, target, relationType)] == null) 
            return false;
        return true;
    };
    prototype.createImpliedRelationships = function() {
        var edgesToAdd = new Array();
        var e;
        for (var i = 0; i < this.edges.length; i++) {
            e = this.edges[i];
            if (e.getRelation().equalsIgnoreCase(CompetencyGraph.NARROWS_RELATION_TEXT)) {
                edgesToAdd.push(new CgEdge(e.getTarget(), e.getSource(), CompetencyGraph.BROADENS_RELATION_TEXT));
            } else if (e.getRelation().equalsIgnoreCase(CompetencyGraph.REQUIRES_RELATION_TEXT)) {
                edgesToAdd.push(new CgEdge(e.getTarget(), e.getSource(), CompetencyGraph.IS_REQUIRED_BY_RELATION_TEXT));
            } else if (e.getRelation().equalsIgnoreCase(CompetencyGraph.IS_EQUIVALENT_TO_RELATION_TEXT)) {
                edgesToAdd.push(new CgEdge(e.getTarget(), e.getSource(), CompetencyGraph.IS_EQUIVALENT_TO_RELATION_TEXT));
            }
        }
        var ne;
        for (var i = 0; i < edgesToAdd.length; i++) {
            ne = edgesToAdd[i];
            this.addEdge(ne.getSource(), ne.getTarget(), ne.getRelation());
        }
    };
    prototype.getJsonString = function() {
        if (this.includeAssertions) 
            return JSON.stringify(new CompetencyGraph.CleanGraphWithAssertions(this.nodes, this.edges, this.positiveAssertions, this.negativeAssertions));
         else 
            return JSON.stringify(new CompetencyGraph.CleanGraph(this.nodes, this.edges));
    };
    prototype.getNodes = function() {
        return this.nodes;
    };
    prototype.setNodes = function(nodes) {
        this.nodes = nodes;
    };
    prototype.getEdges = function() {
        return this.edges;
    };
    prototype.setEdges = function(edges) {
        this.edges = edges;
    };
    prototype.getPositiveAssertions = function() {
        return this.positiveAssertions;
    };
    prototype.setPositiveAssertions = function(positiveAssertions) {
        this.positiveAssertions = positiveAssertions;
    };
    prototype.getNegativeAssertions = function() {
        return this.negativeAssertions;
    };
    prototype.setNegativeAssertions = function(negativeAssertions) {
        this.negativeAssertions = negativeAssertions;
    };
}, {nodes: {name: "Array", arguments: [null]}, edges: {name: "Array", arguments: ["CgEdge"]}, positiveAssertions: {name: "Array", arguments: ["SimpleAssertion"]}, negativeAssertions: {name: "Array", arguments: ["SimpleAssertion"]}, nodeMap: {name: "Map", arguments: [null, null]}, edgeMap: {name: "Map", arguments: [null, null]}}, {});
var RollupRulePacketGenerator = function(ip, ep) {
    this.ip = ip;
    this.ep = ep;
    this.queries = new Array();
    this.queryOperations = new Array();
};
RollupRulePacketGenerator = stjs.extend(RollupRulePacketGenerator, null, [], function(constructor, prototype) {
    prototype.queries = null;
    prototype.queryOperations = null;
    prototype.ip = null;
    prototype.ep = null;
    constructor.main = function(args) {};
    prototype.addQuery = function(query) {
        this.queries.push(query);
    };
    prototype.addQueryOperation = function(operation) {
        this.queryOperations.push(operation);
    };
    prototype.hasOrOperation = function() {
        for (var i = 0; i < this.queryOperations.length; i++) {
            if (RollupRulePacketGenerator.OperationType.OR.equals(this.queryOperations[i])) 
                return true;
        }
        return false;
    };
    prototype.getIPType = function() {
        if (this.hasOrOperation()) 
            return InquiryPacket.IPType.RELATION_OR;
        return InquiryPacket.IPType.RELATION_AND;
    };
    prototype.generateComboAndPacket = function() {
        var meEp = this.ep;
        var meIp = this.ip;
        return new InquiryPacket(this.ip.subject, null, null, this.ip.context, function(p1) {
            if (meEp != null) 
                meEp.continueProcessingFirstPass(meIp);
        }, this.ip.failure, null, InquiryPacket.IPType.RELATION_AND);
    };
    prototype.generateRollupRulePacket = function(rule) {
        var meEp = this.ep;
        var meIp = this.ip;
        return new InquiryPacket(this.ip.subject, null, null, this.ip.context, function(p1) {
            if (meEp != null) 
                meEp.continueProcessingFirstPass(meIp);
        }, this.ip.failure, rule, InquiryPacket.IPType.ROLLUPRULE);
    };
    prototype.addAllQueries = function(rollupIp) {
        for (var i = 0; i < this.queries.length; i++) {
            rollupIp.subPackets.push(this.generateRollupRulePacket(this.queries[i]));
        }
    };
    prototype.buildQueryTree = function(rollupIp) {
        if (this.queryOperations.length <= 0) 
            return;
        var currentAndPacket = this.generateComboAndPacket();
        var priorOt;
        if (RollupRulePacketGenerator.OperationType.OR.equals(this.queryOperations[0])) 
            rollupIp.subPackets.push(this.generateRollupRulePacket(this.queries[0]));
         else 
            currentAndPacket.subPackets.push(this.generateRollupRulePacket(this.queries[0]));
        priorOt = this.queryOperations[0];
        for (var i = 1; i < this.queryOperations.length; i++) {
            if (RollupRulePacketGenerator.OperationType.OR.equals(this.queryOperations[i])) {
                if (RollupRulePacketGenerator.OperationType.OR.equals(priorOt)) 
                    rollupIp.subPackets.push(this.generateRollupRulePacket(this.queries[i]));
                 else {
                    currentAndPacket.subPackets.push(this.generateRollupRulePacket(this.queries[i]));
                    rollupIp.subPackets.push(currentAndPacket);
                }
            } else {
                if (RollupRulePacketGenerator.OperationType.OR.equals(priorOt)) {
                    currentAndPacket = this.generateComboAndPacket();
                    currentAndPacket.subPackets.push(this.generateRollupRulePacket(this.queries[i]));
                } else 
                    currentAndPacket.subPackets.push(this.generateRollupRulePacket(this.queries[i]));
            }
            priorOt = this.queryOperations[i];
        }
        if (RollupRulePacketGenerator.OperationType.OR.equals(priorOt)) 
            rollupIp.subPackets.push(this.generateRollupRulePacket(this.queries[this.queries.length - 1]));
         else {
            currentAndPacket.subPackets.push(this.generateRollupRulePacket(this.queries[this.queries.length - 1]));
            rollupIp.subPackets.push(currentAndPacket);
        }
    };
    prototype.generatePacket = function() {
        var ipt = this.getIPType();
        var meEp = this.ep;
        var meIp = this.ip;
        var rollupIp = new InquiryPacket(this.ip.subject, null, null, this.ip.context, function(p1) {
            if (meEp != null) 
                meEp.continueProcessingFirstPass(meIp);
        }, this.ip.failure, null, ipt);
        if (InquiryPacket.IPType.RELATION_AND.equals(ipt)) 
            this.addAllQueries(rollupIp);
         else 
            this.buildQueryTree(rollupIp);
        return rollupIp;
    };
    constructor.OperationType = stjs.enumeration("AND", "OR");
}, {queries: {name: "Array", arguments: [null]}, queryOperations: {name: "Array", arguments: [{name: "Enum", arguments: ["RollupRulePacketGenerator.OperationType"]}]}, ip: "InquiryPacket", ep: "AssertionProcessor"}, {});
if (!stjs.mainCallDisabled) 
    RollupRulePacketGenerator.main();
var RollupRuleGenerator = function(ip) {
    this.ip = ip;
    this.rule = "";
    this.outerRule = "";
};
RollupRuleGenerator = stjs.extend(RollupRuleGenerator, null, [], function(constructor, prototype) {
    prototype.failure = null;
    prototype.success = null;
    prototype.rule = null;
    prototype.outerRule = null;
    prototype.ip = null;
    prototype.go = function() {
        var me = this;
        if (this.ip.getContext().relation == null) 
            this.success(null);
         else 
            for (var i = 0; i < this.ip.getContext().relation.length; i++) {
                this.ip.numberOfQueriesRunning++;
                EcAlignment.get(this.ip.getContext().relation[i], function(p1) {
                    me.ip.numberOfQueriesRunning--;
                    if (!p1.source.equals(me.ip.competency) && !p1.target.equals(me.ip.competency)) 
                        return;
                    if (p1.source.equals(me.ip.competency)) {
                        if (p1.relationType.equals(EcAlignment.REQUIRES)) {
                            if (me.rule != null && me.rule != "") 
                                me.rule += " AND ";
                            me.rule += "[notNegative competency:\"" + p1.target + "\"]";
                        }
                        if (p1.relationType.equals(EcAlignment.NARROWS)) {
                            if (me.outerRule != null && me.outerRule != "") 
                                me.outerRule += " OR ";
                            me.outerRule += "[competency:\"" + p1.target + "\"]";
                        }
                    }
                }, function(p1) {
                    me.ip.numberOfQueriesRunning--;
                });
            }
    };
}, {failure: {name: "Callback1", arguments: [null]}, success: {name: "Callback1", arguments: [null]}, ip: "InquiryPacket"}, {});
/**
 *  Creates child packets for an InquiryPacket based on its context.
 * 
 *  @author fritz.ray@eduworks.com
 *  @author tom.buskirk@eduworks.com
 *  @class RelationshipPacketGenerator
 *  @module org.cassproject
 */
var RelationshipPacketGenerator = /**
 *  Constructor for the RelationshipPacketGenerator
 * 
 *  @param {InquiryPacket}      ip Inquiry Packet to generate and fill with relationship packets.
 *  @param {AssertionProcessor} ep Assertion processor to tell to resume when complete.
 *  @param {object}             processedAlignments An object to fill with keys to ensure that relations are not processed twice.
 *  @constructor
 */
function(ip, ep, processedAlignments) {
    this.ip = ip;
    this.ep = ep;
    this.processedAlignments = processedAlignments;
    this.narrowsPackets = new Array();
    this.broadensPackets = new Array();
    this.requiredPackets = new Array();
    this.isRequiredByPackets = new Array();
};
RelationshipPacketGenerator = stjs.extend(RelationshipPacketGenerator, null, [], function(constructor, prototype) {
    /**
     *  Method to call when any operation fails.
     * 
     *  @property failure
     *  @type function(string)
     */
    prototype.failure = null;
    /**
     *  Method to call when the operation succeeds.
     * 
     *  @property success
     *  @type function()
     */
    prototype.success = null;
    /**
     *  Method to call when the generator has log statements to emit.
     * 
     *  @property logFunction
     *  @type function(any)
     */
    prototype.logFunction = null;
    /**
     *  List of packets representing the narrows relation.
     * 
     *  @property narrowsPackets
     *  @type InquiryPacket[]
     */
    prototype.narrowsPackets = null;
    /**
     *  List of packets representing the broadens relation.
     * 
     *  @property broadensPackets
     *  @type InquiryPacket[]
     */
    prototype.broadensPackets = null;
    /**
     *  List of packets representing the required relation.
     * 
     *  @property requiredPackets
     *  @type InquiryPacket[]
     */
    prototype.requiredPackets = null;
    /**
     *  List of packets representing the isRequiredBy relation.
     * 
     *  @property isRequiredByPackets
     *  @type InquiryPacket[]
     */
    prototype.isRequiredByPackets = null;
    prototype.relationLookup = null;
    /**
     *  Async counter to keep track of number of outstanding requests.
     * 
     *  @property numberOfRelationsToProcess
     *  @type integer
     */
    prototype.numberOfRelationsToProcess = 0;
    /**
     *  Number of relations that have been processed.
     * 
     *  @property numberOfRelationsProcessed
     *  @type integer
     */
    prototype.numberOfRelationsProcessed = 0;
    /**
     *  Alignments to ignore, as they have already been processed.
     * 
     *  @property processedAlignments;
     *  @type Object (Map<String,String>)
     */
    prototype.processedAlignments = null;
    /**
     *  Assertion Processor that invoked this generator.
     * 
     *  @property ep
     *  @type AssertionProcessor
     */
    prototype.ep = null;
    /**
     *  Inquiry Packet that this generator is creating relationships for.
     * 
     *  @property ip
     *  @type InquiryPacket
     */
    prototype.ip = null;
    prototype.log = function(string) {
        if (this.logFunction != null) 
            this.logFunction("" + new Date().getTime() % 100000 + ": " + string);
    };
    prototype.processEventFailure = function(message, ip) {
        ip.numberOfQueriesRunning--;
        this.failure(message);
    };
    prototype.pushRequiredPacketsToIp = function() {
        if (this.requiredPackets.length > 0) {
            var meEp = this.ep;
            var meIp = this.ip;
            var rootRequiredPacket = new InquiryPacket(this.ip.subject, null, null, this.ip.context, function(p1) {
                if (meEp != null) 
                    meEp.continueProcessingFirstPass(meIp);
            }, this.ip.failure, null, InquiryPacket.IPType.RELATION_REQUIRES);
            rootRequiredPacket.subPackets = this.requiredPackets;
            this.ip.subPackets.push(rootRequiredPacket);
        }
    };
    prototype.pushIsRequiredByPacketsToIp = function() {
        if (this.isRequiredByPackets.length > 0) {
            var meEp = this.ep;
            var meIp = this.ip;
            var rootRequiredPacket = new InquiryPacket(this.ip.subject, null, null, this.ip.context, function(p1) {
                if (meEp != null) 
                    meEp.continueProcessingFirstPass(meIp);
            }, this.ip.failure, null, InquiryPacket.IPType.RELATION_ISREQUIREDBY);
            rootRequiredPacket.subPackets = this.isRequiredByPackets;
            this.ip.subPackets.push(rootRequiredPacket);
        }
    };
    prototype.pushNarrowsPacketsToIp = function() {
        if (this.narrowsPackets.length > 0) {
            var meEp = this.ep;
            var meIp = this.ip;
            var rootNarrowsPacket = new InquiryPacket(this.ip.subject, null, null, this.ip.context, function(p1) {
                if (meEp != null) 
                    meEp.continueProcessingFirstPass(meIp);
            }, this.ip.failure, null, InquiryPacket.IPType.RELATION_NARROWS);
            rootNarrowsPacket.subPackets = this.narrowsPackets;
            this.ip.subPackets.push(rootNarrowsPacket);
        }
    };
    prototype.pushBroadensPacketsToIp = function() {
        if (this.broadensPackets.length > 0) {
            var meEp = this.ep;
            var meIp = this.ip;
            var rootBroadensPacket = new InquiryPacket(this.ip.subject, null, null, this.ip.context, function(p1) {
                if (meEp != null) 
                    meEp.continueProcessingFirstPass(meIp);
            }, this.ip.failure, null, InquiryPacket.IPType.RELATION_BROADENS);
            rootBroadensPacket.subPackets = this.broadensPackets;
            this.ip.subPackets.push(rootBroadensPacket);
        }
    };
    prototype.finishRelationProcessing = function() {
        this.pushRequiredPacketsToIp();
        this.pushIsRequiredByPacketsToIp();
        this.pushNarrowsPacketsToIp();
        this.pushBroadensPacketsToIp();
        this.success();
    };
    prototype.processGetRelatedCompetencySuccess = function(relatedCompetency, alignment) {
        this.numberOfRelationsProcessed++;
        var meEp = this.ep;
        var meIp = this.ip;
        if (this.processedAlignments[alignment.shortId()] != null) {
            this.ip.numberOfQueriesRunning--;
            this.checkForFinish();
            return;
        }
        this.processedAlignments[alignment.shortId()] = "done";
        this.log("Adding new " + alignment.relationType + " relationship packet");
        if (EcAlignment.IS_EQUIVALENT_TO.equals(alignment.relationType)) {
            var ip2 = null;
            this.ip.equivalentPackets.push(ip2 = new InquiryPacket(this.ip.subject, relatedCompetency, null, this.ip.context, function(p1) {
                if (meEp != null) 
                    meEp.continueProcessingFirstPass(meIp);
            }, this.ip.failure, null, InquiryPacket.IPType.COMPETENCY));
        } else if (EcAlignment.REQUIRES.equals(alignment.relationType)) {
            if (this.ip.hasId(alignment.source)) 
                this.requiredPackets.push(new InquiryPacket(this.ip.subject, relatedCompetency, null, this.ip.context, function(p1) {
                    if (meEp != null) 
                        meEp.continueProcessingFirstPass(meIp);
                }, this.ip.failure, null, InquiryPacket.IPType.COMPETENCY));
             else 
                this.isRequiredByPackets.push(new InquiryPacket(this.ip.subject, relatedCompetency, null, this.ip.context, function(p1) {
                    if (meEp != null) 
                        meEp.continueProcessingFirstPass(meIp);
                }, this.ip.failure, null, InquiryPacket.IPType.COMPETENCY));
        } else if (EcAlignment.NARROWS.equals(alignment.relationType)) {
            if (this.ip.hasId(alignment.source)) 
                this.narrowsPackets.push(new InquiryPacket(this.ip.subject, relatedCompetency, null, this.ip.context, function(p1) {
                    if (meEp != null) 
                        meEp.continueProcessingFirstPass(meIp);
                }, this.ip.failure, null, InquiryPacket.IPType.COMPETENCY));
             else 
                this.broadensPackets.push(new InquiryPacket(this.ip.subject, relatedCompetency, null, this.ip.context, function(p1) {
                    if (meEp != null) 
                        meEp.continueProcessingFirstPass(meIp);
                }, this.ip.failure, null, InquiryPacket.IPType.COMPETENCY));
        }
        this.ip.numberOfQueriesRunning--;
        this.checkForFinish();
    };
    prototype.checkForFinish = function() {
        if (this.numberOfRelationsProcessed >= this.numberOfRelationsToProcess) 
            this.finishRelationProcessing();
    };
    prototype.processFindCompetencyRelationshipSuccess = function(alignment, ip) {
        ip.numberOfQueriesRunning--;
        var relatedCompetencyId = null;
        if (ip.hasId(alignment.source) && ip.hasId(alignment.target)) {
            this.numberOfRelationsProcessed++;
            this.checkForFinish();
            return;
        } else if (ip.hasId(alignment.source)) 
            relatedCompetencyId = alignment.target;
         else if (ip.hasId(alignment.target)) 
            relatedCompetencyId = alignment.source;
         else {
            this.numberOfRelationsProcessed++;
            this.checkForFinish();
            return;
        }
        this.log("Relationship found (" + alignment.relationType + ") source: " + alignment.source + " target: " + alignment.target);
        ip.numberOfQueriesRunning++;
        var rpg = this;
        if (!ip.context.isId(alignment.source) && !ip.context.isId(alignment.target)) {
            EcCompetency.get(relatedCompetencyId, function(p1) {
                rpg.processGetRelatedCompetencySuccess(p1, alignment);
            }, function(p1) {
                rpg.processEventFailure(p1, ip);
            });
        } else {
            this.numberOfRelationsProcessed++;
            ip.numberOfQueriesRunning--;
            this.checkForFinish();
        }
    };
    /**
     *  Method to invoke to begin relation processing.
     * 
     *  @method go
     */
    prototype.go = function() {
        var rpg = this;
        if (this.ip.getContext().relation == null) 
            this.success();
         else {
            this.numberOfRelationsToProcess = 0;
            for (var i = 0; i < this.ip.competency.length; i++) {
                var relationsRelatedToThisCompetency = (this.relationLookup)[this.ip.competency[i].shortId()];
                if (relationsRelatedToThisCompetency == null) 
                    relationsRelatedToThisCompetency = new Array();
                this.numberOfRelationsToProcess += relationsRelatedToThisCompetency.length;
                this.numberOfRelationsProcessed = 0;
                for (var j = 0; j < relationsRelatedToThisCompetency.length; j++) {
                    this.ip.numberOfQueriesRunning++;
                    rpg.processFindCompetencyRelationshipSuccess(relationsRelatedToThisCompetency[j], rpg.ip);
                }
                if (relationsRelatedToThisCompetency.length == 0) {
                    this.checkForFinish();
                }
            }
        }
    };
}, {failure: {name: "Callback1", arguments: [null]}, success: "Callback0", logFunction: {name: "Callback1", arguments: ["Object"]}, narrowsPackets: {name: "Array", arguments: ["InquiryPacket"]}, broadensPackets: {name: "Array", arguments: ["InquiryPacket"]}, requiredPackets: {name: "Array", arguments: ["InquiryPacket"]}, isRequiredByPackets: {name: "Array", arguments: ["InquiryPacket"]}, relationLookup: "Object", processedAlignments: {name: "Map", arguments: [null, null]}, ep: "AssertionProcessor", ip: "InquiryPacket"}, {});
/**
 *  Processor used in Assertion Processing. Can estimate or determine competence
 *  of individuals.
 * 
 *  @author fritz.ray@eduworks.com
 *  @author tom.buskirk@eduworks.com
 *  @class AssertionProcessor
 *  @module org.cassproject
 */
var AssertionProcessor = function() {
    this.repositories = new Array();
    this.coprocessors = new Array();
    this.step = AssertionProcessor.DEF_STEP;
    this.profileMode = false;
};
AssertionProcessor = stjs.extend(AssertionProcessor, null, [], function(constructor, prototype) {
    constructor.DEF_STEP = false;
    prototype.repositories = null;
    prototype.step = false;
    prototype.profileMode = false;
    prototype.logFunction = null;
    prototype.assertions = null;
    prototype.coprocessors = null;
    prototype.processedEquivalencies = null;
    prototype.context = null;
    prototype.assertionsCollected = false;
    prototype.log = function(ip, string) {
        if (this.logFunction != null) {
            var id = "";
            if (ip.competency != null && ip.competency.length > 0) 
                id = ip.competency[0].shortId() + ":";
            this.logFunction(new Date().getTime() % 100000 + ": " + string);
        }
        ip.log += "\n" + string;
    };
    /**
     *  Asynchronously processes and provides an answer to the question: Does an
     *  individual hold a competency?
     * 
     *  @param {EcPk[]}                  subject Public keys that identify the subject.
     *  @param {EcCompetency}            competency The Competency being inquired about.
     *  @param {EcLevel}                 level The Level of the Competency at which the question
     *                                   is being asked.
     *  @param {EcFramework}             context The Framework in which to scope the inquiry.
     *  @param {EbacSignature[]}         additionalSignatures Additional signatures
     *                                   provided by an authority, used to request additional access on a one-time
     *                                   basis.
     *  @param {function(InquiryPacket)} success The method that is invoked when
     *                                   a decision has been reached.
     *  @param {string                   function(string)} ask The method that is invoked when the
     *                                   assertion processor detects that it needs information. (Usernames,
     *                                   passwords, etc)
     *  @param {function(string)}        failure The method that is invoked when the
     *                                   assertion processor has failed.
     *  @method has
     */
    prototype.has = function(subject, competency, level, context, additionalSignatures, success, ask, failure) {
        var ip = new InquiryPacket(subject, competency, level, context, success, failure, null, InquiryPacket.IPType.COMPETENCY);
        ip.root = true;
        this.processedEquivalencies = {};
        this.assertions = null;
        this.context = context;
        this.log(ip, "Created new inquiry.");
        var me = this;
        this.continueProcessingFirstPass(ip);
    };
    prototype.collectAssertionsForSecondPass = function(ip, success) {
        this.assertionsCollected = true;
        var listOfActivatedCompetencies = new Array();
        this.collectCompetencies(ip, listOfActivatedCompetencies, new Array());
        var me = this;
        listOfActivatedCompetencies.sort(function(a, b) {
            return b.compareTo(a);
        });
        var eah = new EcAsyncHelper();
        eah.each(this.repositories, function(currentRepository, callback0) {
            var searchQuery = me.buildAssertionsSearchQuery(ip, listOfActivatedCompetencies);
            me.log(ip, "Querying repositories for subject assertions on " + listOfActivatedCompetencies.length + " competencies: " + searchQuery);
            var params = new Object();
            (params)["size"] = 5000;
            EcAssertion.search(currentRepository, searchQuery, function(p1) {
                me.log(ip, p1.length + " assertions found.");
                me.assertions = new Object();
                for (var i = 0; i < p1.length; i++) {
                    var a = p1[i];
                    var competency = EcRemoteLinkedData.trimVersionFromUrl(a.competency);
                    if ((me.assertions)[competency] == null) 
                        (me.assertions)[competency] = new Array();
                    var as = (me.assertions)[competency];
                    as.push(a);
                }
                callback0();
            }, function(p1) {
                callback0();
            }, params);
        }, function(strings) {
            var eah2 = new EcAsyncHelper();
            eah2.each(me.coprocessors, function(ac, callback00) {
                ac.assertionProcessor = me;
                ac.collectAssertions(ip, listOfActivatedCompetencies, function(assertions) {
                    for (var i = 0; i < assertions.length; i++) {
                        var a = assertions[i];
                        var competency = EcRemoteLinkedData.trimVersionFromUrl(a.competency);
                        if ((me.assertions)[competency] == null) 
                            (me.assertions)[competency] = new Array();
                        var as = (me.assertions)[competency];
                        as.push(a);
                    }
                    callback00();
                });
            }, function(strings) {
                var eah3 = new EcAsyncHelper();
                eah3.each(me.coprocessors, function(ac, callback000) {
                    ac.assertionProcessor = me;
                    ac.mutateAssertions(ip, listOfActivatedCompetencies, callback000);
                }, function(strings) {
                    success(ip);
                });
            });
        });
    };
    prototype.isIn = function(ip, alreadyDone) {
        for (var i = 0; i < alreadyDone.length; i++) 
            if (ip == alreadyDone[i]) 
                return true;
        return false;
    };
    prototype.continueProcessingSecondPass = function(ip) {
        if (!ip.hasCheckedAssertionsForCompetency) 
            if (this.findSubjectAssertionsForCompetency(ip)) 
                if (EcRemote.async) 
                    return true;
        if (this.processChildPacketsSecondPass(ip.equivalentPackets)) 
            if (EcRemote.async) 
                return true;
        if (this.processChildPacketsSecondPass(ip.subPackets)) 
            if (EcRemote.async) 
                return true;
        if (ip.result == null) {
            this.determineResult(ip);
            this.log(ip, "Determined Result:" + ip.result);
            this.log(ip, "Success:" + ip.success);
            if (ip.result != null && ip.success != null) {
                this.log(ip, "Running success:" + ip.result);
                ip.success(ip);
            }
            if (EcRemote.async) 
                return true;
        }
        return false;
    };
    prototype.continueProcessingFirstPass = function(ip) {
        if (!ip.finished) {
            if (!ip.hasCheckedRelationshipsForCompetency) {
                this.findCompetencyRelationships(ip);
                if (EcRemote.async) 
                    return true;
            }
            if (!ip.hasCheckedRollupRulesForCompetency) {
                this.findRollupRulesForCompetency(ip);
                if (EcRemote.async) 
                    return true;
            }
            if (this.processChildPackets(ip.equivalentPackets)) 
                return true;
            if (this.processChildPackets(ip.subPackets)) 
                return true;
            ip.finished = true;
            if (!this.assertionsCollected) 
                if (ip.root) {
                    var me = this;
                    this.collectAssertionsForSecondPass(ip, function(p1) {
                        me.continueProcessingSecondPass(ip);
                    });
                    if (EcRemote.async) 
                        return true;
                } else 
                    ip.success(ip);
        }
        if (ip.finished) 
            if (this.assertions != null) 
                return this.continueProcessingSecondPass(ip);
        return false;
    };
    prototype.determineResult = function(ip) {};
    prototype.findCompetencyRelationships = function(ip) {};
    prototype.findSubjectAssertionsForCompetency = function(ip) {};
    prototype.processChildPackets = function(childPackets) {
        if (childPackets != null) 
            for (var i = 0; i < childPackets.length; i++) 
                if (this.continueProcessingFirstPass(childPackets[i])) 
                    return true;
        return false;
    };
    prototype.checkStep = function(ip) {
        this.log(ip, "Checkstep First Pass: " + ip.numberOfQueriesRunning);
        if (ip.numberOfQueriesRunning == 0) 
            if (!this.step && EcRemote.async) 
                this.continueProcessingFirstPass(ip);
    };
    prototype.processChildPacketsSecondPass = function(childPackets) {
        if (childPackets != null) 
            for (var i = 0; i < childPackets.length; i++) 
                if (this.continueProcessingSecondPass(childPackets[i])) 
                    return true;
        return false;
    };
    prototype.checkStepSecondPass = function(ip) {
        this.log(ip, "Checkstep Second Pass: " + ip.numberOfQueriesRunning);
        if (ip.numberOfQueriesRunning == 0) 
            if (!this.step && EcRemote.async) 
                this.continueProcessingSecondPass(ip);
    };
    prototype.processEventFailure = function(message, ip) {
        this.log(ip, "Event failed: " + message);
        ip.numberOfQueriesRunning--;
        ip.failure(message);
    };
    prototype.logFoundAssertion = function(a, ip) {
        this.log(ip, "No issues found with assertion.");
        this.log(ip, "Record Id: " + a.shortId());
        this.log(ip, "Confidence: " + a.confidence);
        this.log(ip, "Number of pieces of evidence: " + a.getEvidenceCount());
        this.log(ip, "Recording in inquiry.");
    };
    prototype.buildAssertionSearchQuery = function(ip, competency) {
        var result = null;
        if (InquiryPacket.IPType.ROLLUPRULE.equals(ip.type)) {
            if (ip.rule.indexOf("AND ") == 0) 
                ip.rule = ip.rule.replace("AND ", "");
            result = "(" + new EcAssertion().getSearchStringByType() + ") AND (" + ip.rule + ")";
        } else if (InquiryPacket.IPType.COMPETENCY.equals(ip.type)) 
            result = new EcAssertion().getSearchStringByTypeAndCompetency(competency);
        for (var i = 0; i < ip.subject.length; i++) 
            result += " AND (\\*reader:\"" + ip.subject[i].toPem() + "\")";
        this.log(ip, "Search Query: " + result);
        if (result != null) 
            return result;
         throw new RuntimeException("Trying to build an assertion search query on an unsupported type: " + ip.type);
    };
    prototype.buildAssertionsSearchQuery = function(ip, competencies) {
        var result = null;
        if (InquiryPacket.IPType.ROLLUPRULE.equals(ip.type)) {
            ip.failure("NOT SUPPOSED TO BE HERE.");
             throw new RuntimeException("Collecting assertions when root node is a rollup rule. Not supported.");
        } else if (InquiryPacket.IPType.COMPETENCY.equals(ip.type)) {
            result = "(";
            for (var i = 0; i < competencies.length; i++) {
                if (i != 0) 
                    result += " OR ";
                result += "competency:\"" + competencies[i] + "\"";
            }
            result += ")";
        }
        for (var i = 0; i < ip.subject.length; i++) 
            result += " AND (\\*reader:\"" + ip.subject[i].toPem() + "\")";
        if (result != null) 
            return result;
         throw new RuntimeException("Trying to build an assertion search query on an unsupported type: " + ip.type);
    };
    prototype.processRelationshipPacketsGenerated = function(ip, competency) {
        this.log(ip, "Relationships succesfully processed for: " + competency.id);
        ip.numberOfQueriesRunning--;
        this.checkStep(ip);
    };
    prototype.processRollupRuleInterpretSuccess = function(status, ip) {
        this.log(ip, "Rollup rule successfully interpreted.");
        ip.numberOfQueriesRunning--;
        this.checkStep(ip);
    };
    prototype.processRollupRuleInterpretSkipped = function(ip) {
        this.log(ip, "Rollup rule skipped.");
        ip.numberOfQueriesRunning--;
        this.checkStep(ip);
    };
    prototype.findRollupRulesForCompetency = function(ip) {
        ip.hasCheckedRollupRulesForCompetency = true;
        if (!InquiryPacket.IPType.COMPETENCY.equals(ip.type)) {
            this.log(ip, "No rollup rules for combinator types");
            this.checkStep(ip);
            return;
        }
        var ep = this;
        if (ip.getContext().rollupRule == null) {
            if (EcRemote.async) 
                this.continueProcessingFirstPass(ip);
        } else 
            for (var i = 0; i < ip.getContext().rollupRule.length; i++) {
                ip.numberOfQueriesRunning++;
                EcRollupRule.get(ip.getContext().rollupRule[i], function(rr) {
                    ep.processFindRollupRuleSuccess(rr, ip);
                }, function(p1) {
                    ep.processEventFailure(p1, ip);
                });
            }
    };
    prototype.processFindRollupRuleSuccess = function(rr, ip) {};
    prototype.collectCompetencies = function(ip, listOfActivatedCompetencies, listOfVisitedPackets) {
        if (this.profileMode) {
            for (var i = 0; i < this.context.competency.length; i++) 
                listOfActivatedCompetencies.push(this.context.competency[i]);
            return;
        }
        for (var i = 0; i < listOfVisitedPackets.length; i++) 
            if (ip == listOfVisitedPackets[i]) 
                return;
        listOfVisitedPackets.push(ip);
        for (var i = 0; i < ip.competency.length; i++) {
            for (var j = 0; j < listOfActivatedCompetencies.length; j++) 
                if (ip.competency[i].shortId() == listOfActivatedCompetencies[j]) 
                    continue;
            listOfActivatedCompetencies.push(ip.competency[i].shortId());
        }
        for (var i = 0; i < ip.equivalentPackets.length; i++) 
            this.collectCompetencies(ip.equivalentPackets[i], listOfActivatedCompetencies, listOfVisitedPackets);
        for (var i = 0; i < ip.subPackets.length; i++) 
            this.collectCompetencies(ip.subPackets[i], listOfActivatedCompetencies, listOfVisitedPackets);
    };
}, {repositories: {name: "Array", arguments: ["EcRepository"]}, logFunction: {name: "Callback1", arguments: ["Object"]}, assertions: "Object", coprocessors: {name: "Array", arguments: ["AssertionCoprocessor"]}, processedEquivalencies: {name: "Map", arguments: [null, null]}, context: "EcFramework"}, {});
var PapDependencyDefinitions = function() {
    this.dependencyDefinitionMap = {};
};
PapDependencyDefinitions = stjs.extend(PapDependencyDefinitions, null, [], function(constructor, prototype) {
    constructor.DEFAULT_WEIGHT = 1.0;
    constructor.DEFAULT_LEAK = 0.0;
    constructor.DEFAULT_REVERSE = false;
    constructor.DEFAULT_NARROWS_BASE_CLASS = "broadens";
    constructor.DEFAULT_NARROWS_REVERSE = true;
    constructor.DEFAULT_NARROWS_WEIGHT = 0.9;
    constructor.DEFAULT_NARROWS_LEAK = 0.0;
    constructor.DEFAULT_NARROWS_KEY = "narrows";
    constructor.DEFAULT_ENABLES_BASE_CLASS = "isSufficientFor";
    constructor.DEFAULT_ENABLES_REVERSE = true;
    constructor.DEFAULT_ENABLES_WEIGHT = 0.9;
    constructor.DEFAULT_ENABLES_LEAK = 0.0;
    constructor.DEFAULT_ENABLES_KEY = "enables";
    constructor.DEFAULT_REQUIRES_BASE_CLASS = "isRequiredBy";
    constructor.DEFAULT_REQUIRES_REVERSE = false;
    constructor.DEFAULT_REQUIRES_WEIGHT = 0.9;
    constructor.DEFAULT_REQUIRES_LEAK = 0.0;
    constructor.DEFAULT_REQUIRES_KEY = "requires";
    prototype.dependencyDefinitionMap = null;
    /**
     *  Pulled default values from CruncherAssertionProcessor
     *      dependencyDefs = new JSONObject();
     * 
     *      JSONObject narrows = new JSONObject();
     *      narrows.put("class","broadens");
     *      narrows.put("reverse",true);
     *      narrows.put("weight",0.9);
     *      dependencyDefs.put("narrows",narrows);
     * 
     *      JSONObject enables = new JSONObject();
     *      enables.put("class","isSufficientFor");
     *      enables.put("weight",0.9);
     *      enables.put("reverse",true);
     *      dependencyDefs.put("enables",enables);
     * 
     *      JSONObject requires = new JSONObject();
     *      requires.put("class","isRequiredBy");
     *      requires.put("weight",0.9);
     *      dependencyDefs.put("requires",requires);
     */
    prototype.initDefaultDefinitions = function() {
        var narrowsDepDef = new PapDependencyDefinitionBase(PapDependencyDefinitions.DEFAULT_NARROWS_BASE_CLASS, PapDependencyDefinitions.DEFAULT_NARROWS_REVERSE, PapDependencyDefinitions.DEFAULT_NARROWS_WEIGHT, PapDependencyDefinitions.DEFAULT_NARROWS_LEAK);
        var enablesDepDef = new PapDependencyDefinitionBase(PapDependencyDefinitions.DEFAULT_ENABLES_BASE_CLASS, PapDependencyDefinitions.DEFAULT_ENABLES_REVERSE, PapDependencyDefinitions.DEFAULT_ENABLES_WEIGHT, PapDependencyDefinitions.DEFAULT_ENABLES_LEAK);
        var requiresDepDef = new PapDependencyDefinitionBase(PapDependencyDefinitions.DEFAULT_REQUIRES_BASE_CLASS, PapDependencyDefinitions.DEFAULT_REQUIRES_REVERSE, PapDependencyDefinitions.DEFAULT_REQUIRES_WEIGHT, PapDependencyDefinitions.DEFAULT_REQUIRES_LEAK);
        this.addDependencyDefinition(PapDependencyDefinitions.DEFAULT_NARROWS_KEY, narrowsDepDef);
        this.addDependencyDefinition(PapDependencyDefinitions.DEFAULT_ENABLES_KEY, enablesDepDef);
        this.addDependencyDefinition(PapDependencyDefinitions.DEFAULT_REQUIRES_KEY, requiresDepDef);
    };
    prototype.getWeightForType = function(depType) {
        var base = this.dependencyDefinitionMap[depType];
        if (base == null) 
            return PapDependencyDefinitions.DEFAULT_WEIGHT;
         else 
            return base.getWeight();
    };
    prototype.getLeakForType = function(depType) {
        var base = this.dependencyDefinitionMap[depType];
        if (base == null) 
            return PapDependencyDefinitions.DEFAULT_LEAK;
         else 
            return base.getLeak();
    };
    prototype.getReverseForType = function(depType) {
        var base = this.dependencyDefinitionMap[depType];
        if (base == null) 
            return PapDependencyDefinitions.DEFAULT_REVERSE;
         else 
            return base.getReverse();
    };
    prototype.addDependencyDefinition = function(relationshipName, definition) {
        this.getDependencyDefinitionMap()[relationshipName] = definition;
    };
    prototype.getDependencyDefinitionMap = function() {
        return this.dependencyDefinitionMap;
    };
    prototype.setDependencyDefinitionMap = function(dependencyDefinitionMap) {
        this.dependencyDefinitionMap = dependencyDefinitionMap;
    };
}, {dependencyDefinitionMap: {name: "Map", arguments: [null, "PapDependencyDefinitionBase"]}}, {});
var TrustCoprocessor = function() {
    AssertionCoprocessor.call(this);
};
TrustCoprocessor = stjs.extend(TrustCoprocessor, AssertionCoprocessor, [], function(constructor, prototype) {
    prototype.agent = null;
    prototype.multiplier = 1.0;
    prototype.removeNoConfidence = false;
    prototype.mutateAssertions = function(ip, listOfCompetencies, success) {
        var keys = EcObject.keys(this.assertionProcessor.assertions);
        for (var keyIndex = 0; keyIndex < keys.length; keyIndex++) {
            var ary = (this.assertionProcessor.assertions)[keys[keyIndex]];
            for (var i = 0; i < ary.length; i++) {
                var a = ary[i];
                if (a.getAgent().toPem() == this.agent.toPem()) {
                    a.confidence = a.confidence * this.multiplier;
                    if (this.removeNoConfidence && a.confidence == 0.0) 
                        ary.splice(i--, 1);
                }
            }
        }
        success();
    };
}, {agent: "EcPk", assertionProcessor: "AssertionProcessor"}, {});
var OpenBadgeCoprocessor = function() {
    AssertionCoprocessor.call(this);
};
OpenBadgeCoprocessor = stjs.extend(OpenBadgeCoprocessor, AssertionCoprocessor, [], function(constructor, prototype) {
    prototype.email = null;
    prototype.badgePluginIdentifier = null;
    prototype.confidenceOfBadges = 1.0;
    prototype.collectAssertions = function(ip, listOfCompetencies, success) {
        if (listOfCompetencies.length == 0) {
            AssertionCoprocessor.prototype.collectAssertions.call(this, ip, listOfCompetencies, success);
            return;
        }
        var assertions = new Array();
        var me = this;
        var eah = new EcAsyncHelper();
        eah.each(me.assertionProcessor.repositories, function(currentRepository, callback0) {
            var searchQuery = "@type:\"BadgeClass\"";
            for (var i = 0; i < listOfCompetencies.length; i++) {
                if (i == 0) 
                    searchQuery += " AND (";
                if (i > 0) 
                    searchQuery += " OR ";
                searchQuery += "alignment.targetUrl:\"" + listOfCompetencies[i] + "\"";
            }
            if (listOfCompetencies.length > 0) 
                searchQuery += ")";
            me.assertionProcessor.log(ip, "Querying repositories for badges regarding " + listOfCompetencies.length + " query: " + searchQuery);
            var params = new Object();
            (params)["size"] = 5000;
            currentRepository.searchWithParams(searchQuery, params, null, function(p1) {
                me.assertionProcessor.log(ip, p1.length + " badgeClasses found.");
                var badgeClassHelper = new EcAsyncHelper();
                badgeClassHelper.each(p1, function(badgeClass, badgeClassDone) {
                    currentRepository.search("@context:\"https://w3id.org/openbadges/v2\" AND @type:Assertion AND badge:\"" + badgeClass.id + "\"", null, function(badgeAssertions) {
                        for (var j = 0; j < badgeAssertions.length; j++) {
                            var hash = EcCrypto.sha256(me.email + ((badgeAssertions[j])["recipient"])["salt"]);
                            if ("sha256$" + hash.toLowerCase() != ((badgeAssertions[j])["recipient"])["identity"]) {
                                me.assertionProcessor.log(ip, me.email + " hashed with salt != " + ((badgeAssertions[j])["recipient"])["identity"]);
                                badgeAssertions.splice(j--, 1);
                            } else 
                                me.assertionProcessor.log(ip, me.email + " hashed with salt == " + ((badgeAssertions[j])["recipient"])["identity"]);
                        }
                        for (var j = 0; j < badgeAssertions.length; j++) {
                            var alignments = (badgeClass)["alignment"];
                            if (alignments != null) 
                                for (var k = 0; k < alignments.length; k++) {
                                    var alignment = alignments[k];
                                    var a = new Assertion();
                                    a.addOwner(ip.subject[0]);
                                    a.setSubject(ip.subject[0]);
                                    a.setAgent(me.badgePluginIdentifier);
                                    a.competency = (alignment)["targetUrl"];
                                    me.assertionProcessor.log(ip, "Generating Assertion for competency: " + (alignment)["targetUrl"]);
                                    a.framework = (alignment)["targetFramework"];
                                    a.confidence = me.confidenceOfBadges;
                                    var evidence = new Array();
                                    evidence.push(badgeAssertions[j].id);
                                    a.setEvidence(evidence);
                                    a.setAssertionDate(new Date((badgeAssertions[j])["issuedOn"]).getTime());
                                    assertions.push(a);
                                }
                        }
                        badgeClassDone();
                    }, ip.failure);
                }, function(strings) {
                    callback0();
                });
            }, ip.failure);
        }, function(strings) {
            success(assertions);
        });
    };
}, {badgePluginIdentifier: "EcPk", assertionProcessor: "AssertionProcessor"}, {});
var PapDependency = function(depParms) {
    PapDependencyParms.call(this);
    if (depParms.getDependencyFirst()) {
        this.setParentIndex(depParms.getParentIndex());
        this.setChildIndex(depParms.getChildIndex());
    } else {
        this.setChildIndex(depParms.getParentIndex());
        this.setParentIndex(depParms.getChildIndex());
    }
    this.setType(depParms.getType());
    this.setWeight(depParms.getWeight());
    this.setLeak(depParms.getLeak());
};
PapDependency = stjs.extend(PapDependency, PapDependencyParms, [], function(constructor, prototype) {
    constructor.NECESSARY_TYPE = "NECESSARY";
    constructor.SUFFICIENT_TYPE = "SUFFICIENT";
    constructor.EQUIVALENCE_TYPE = "EQUIVALENCE";
    constructor.BROADENS_TYPE = "BROADENS";
    constructor.NULL_TYPE = "NULL";
    constructor.HASH_CODE_MULTIPLIER = 41;
    constructor.HASH_CODE_PERCENTAGE_MULTIPLIER = 97;
    constructor.getDependencyTypes = function() {
        var dt = new Array();
        dt.push(PapDependency.NECESSARY_TYPE);
        dt.push(PapDependency.SUFFICIENT_TYPE);
        dt.push(PapDependency.EQUIVALENCE_TYPE);
        dt.push(PapDependency.BROADENS_TYPE);
        dt.push(PapDependency.NULL_TYPE);
        return dt;
    };
    prototype.toString = function() {
        return "Dependency: [" + this.getType().toString() + "] " + this.getParentIndex() + " <-- " + this.getChildIndex();
    };
    prototype.equals = function(other) {
        return (this.getParentIndex() == (other).getParentIndex()) && (this.getChildIndex() == (other).getChildIndex()) && (this.getType() == (other).getType());
    };
    prototype.hashCode = function() {
        var temp = 0;
        if (PapDependency.NECESSARY_TYPE.equalsIgnoreCase(this.getType())) 
            temp = 1;
         else if (PapDependency.EQUIVALENCE_TYPE.equalsIgnoreCase(this.getType())) 
            temp = 2;
         else if (PapDependency.SUFFICIENT_TYPE.equalsIgnoreCase(this.getType())) 
            temp = 3;
         else if (PapDependency.BROADENS_TYPE.equalsIgnoreCase(this.getType())) 
            temp = 4;
        temp *= PapDependency.HASH_CODE_MULTIPLIER;
        temp += this.getParentIndex();
        temp *= PapDependency.HASH_CODE_MULTIPLIER;
        temp += this.getChildIndex();
        return temp + (stjs.trunc((100 * this.getWeight())) % PapDependency.HASH_CODE_PERCENTAGE_MULTIPLIER);
    };
}, {}, {});
var NodePacketGraph = function() {
    this.nodePacketList = new Array();
    this.nodePacketMap = {};
    this.relationList = new Array();
};
NodePacketGraph = stjs.extend(NodePacketGraph, null, [], function(constructor, prototype) {
    prototype.nodePacketList = null;
    prototype.nodePacketMap = null;
    prototype.relationList = null;
    prototype.initNodePacketGraph = function(nodes) {
        var np;
        var n;
        this.nodePacketList = new Array();
        this.nodePacketMap = {};
        this.relationList = new Array();
        for (var i = 0; i < nodes.length; i++) {
            n = nodes[i];
            np = new NodePacket();
            np.addNode(n);
            this.nodePacketList.push(np);
            this.nodePacketMap[n.getId()] = np;
        }
    };
    prototype.getNodePacketForNode = function(n) {
        return this.nodePacketMap[n.getId()];
    };
    prototype.mergeNodePackets = function(packet1, packet2) {
        if (packet1 != packet2) {
            var n;
            var na = packet2.getNodeList();
            for (var i = 0; i < na.length; i++) {
                n = na[i];
                packet1.addNode(n);
                this.nodePacketMap[n.getId()] = packet1;
            }
            this.nodePacketList = ArrayUtil.arrayRemove(this.nodePacketList, packet2);
        }
    };
    prototype.getNodePacketList = function() {
        return this.nodePacketList;
    };
    prototype.setNodePacketList = function(nodePacketList) {
        this.nodePacketList = nodePacketList;
    };
    prototype.getRelationList = function() {
        return this.relationList;
    };
    prototype.setRelationList = function(relationList) {
        this.relationList = relationList;
    };
    prototype.addNodePacket = function(np) {
        this.nodePacketList.push(np);
    };
    prototype.addRelation = function(sourceNodePacket, targetNodePacket, relationType) {
        var newPacketRelation = new PacketRelation(sourceNodePacket, targetNodePacket, relationType);
        this.relationList.push(newPacketRelation);
    };
    prototype.buildPacketRelationsFromNodeRelations = function(nodeRelationList) {
        var sourceNodePacket;
        var targetNodePacket;
        var nr;
        for (var i = 0; i < nodeRelationList.length; i++) {
            nr = nodeRelationList[i];
            sourceNodePacket = this.getNodePacketForNode(nr.getSource());
            targetNodePacket = this.getNodePacketForNode(nr.getTarget());
            if (sourceNodePacket != targetNodePacket) 
                this.addRelation(sourceNodePacket, targetNodePacket, nr.getType());
        }
    };
    prototype.toStringGraphAll = function() {
        var ret = "";
        ret = ret + ">> Packets: \n";
        var np;
        for (var i = 0; i < this.nodePacketList.length; i++) {
            np = this.nodePacketList[i];
            ret = ret + "   " + np.toString() + "\n";
        }
        var pr;
        if (this.relationList.length > 0) {
            ret = ret + ">>Relationships: >\n";
            for (var i = 0; i < this.relationList.length; i++) {
                pr = this.relationList[i];
                ret = ret + "   " + pr.toString() + "\n";
            }
        } else {
            ret = ret + ">>NO RELATIONS EXIST!";
        }
        return ret;
    };
}, {nodePacketList: {name: "Array", arguments: ["NodePacket"]}, nodePacketMap: {name: "Map", arguments: [null, "NodePacket"]}, relationList: {name: "Array", arguments: ["PacketRelation"]}}, {});
/**
 *  Graph for working with a framework. Additional computed data (such as profile data) can be overlaid on the graph through the use of "metaverticies" and "metaedges" that hold additional information.
 * 
 *  @author fritz.ray@eduworks.com
 *  @author tom.buskirk@eduworks.com
 *  @class EcFrameworkGraph
 */
var EcFrameworkGraph = function() {
    EcDirectedGraph.call(this);
    this.metaVerticies = new Object();
    this.metaEdges = new Object();
    this.competencyMap = new Object();
    this.edgeMap = new Object();
    this.dontTryAnyMore = new Object();
    this.frameworks = new Array();
};
EcFrameworkGraph = stjs.extend(EcFrameworkGraph, EcDirectedGraph, [], function(constructor, prototype) {
    prototype.metaVerticies = null;
    prototype.metaEdges = null;
    prototype.competencyMap = null;
    prototype.edgeMap = null;
    prototype.dontTryAnyMore = null;
    prototype.frameworks = null;
    prototype.addFrameworkSuccessCallback = null;
    prototype.addFrameworkFailureCallback = null;
    prototype.repo = null;
    /**
     *  Adds a framework to the graph, and creates the edges to connect the competencies in the framework.
     * 
     *  @param {EcFramework}     framework Framework to add to the graph.
     *  @param {EcRepository}    repo Repository to fetch data from that exists in the framework.
     *  @param {function()}      success Method to invoke when done adding the framework.
     *  @param {function(error)} failure Method to invoke when things go badly.
     *  @method addFramework
     *  @memberOf EcFrameworkGraph
     */
    prototype.addFramework = function(framework, repo, success, failure) {
        this.frameworks.push(framework);
        var me = this;
        if (framework.competency == null) 
            framework.competency = new Array();
        if (framework.relation == null) 
            framework.relation = new Array();
        repo.multiget(framework.competency, function(data) {
            var eah = new EcAsyncHelper();
            eah.each(data, function(d, callback0) {
                me.handleCacheElement(d, callback0, framework);
            }, function(strings) {
                repo.multiget(framework.relation, function(data) {
                    var eah2 = new EcAsyncHelper();
                    eah2.each(data, function(d2, callback2) {
                        me.handleCacheElement(d2, callback2, framework);
                    }, function(strings2) {
                        success();
                    });
                }, failure);
            });
        }, failure);
    };
    prototype.handleCacheElement = function(d, callback0, framework) {
        var competencyTemplate = new EcCompetency();
        var alignmentTemplate = new EcAlignment();
        var encryptedTemplate = new EcEncryptedValue();
        var me = this;
        if (d.isAny(encryptedTemplate.getTypes())) {
            EcEncryptedValue.fromEncryptedValueAsync(d, function(ecRemoteLinkedData) {
                me.handleCacheElement(ecRemoteLinkedData, callback0, framework);
            }, callback0);
            return;
        }
        if (d.isAny(competencyTemplate.getTypes())) {
            EcCompetency.get(d.id, function(c) {
                me.addToMetaStateArray(me.getMetaStateCompetency(c), "framework", framework);
                me.addCompetency(c);
                callback0();
            }, callback0);
        } else if (d.isAny(alignmentTemplate.getTypes())) {
            EcAlignment.get(d.id, function(alignment) {
                me.addRelation(alignment);
                me.addToMetaStateArray(me.getMetaStateAlignment(alignment), "framework", framework);
                callback0();
            }, callback0);
        } else 
            callback0();
    };
    prototype.fetchFrameworkAlignments = function(framework) {
        var me = this;
        EcAlignment.search(this.repo, EcGraphUtil.buildIdSearchQueryForIdList(framework.relation), function(ecaa) {
            for (var i = 0; i < ecaa.length; i++) {
                var a = ecaa[i];
                me.addRelation(a);
                me.addToMetaStateArray(me.getMetaStateAlignment(a), "framework", framework);
            }
            me.addFrameworkSuccessCallback();
        }, me.addFrameworkFailureCallback, null);
    };
    /**
     *  Helper method to populate the graph with assertion data, based on propagation rules implicit in the relations (see devs.cassproject.org, Relations). Does not draw conclusions. Must be able to decrypt 'negative' value.
     * 
     *  @param {Assertion[]}     assertions Assertion candidates to use to populate the graph.
     *  @param {function()}      success Method to invoke when the operation completes successfully.
     *  @param {function(error)} failure Error method.
     */
    prototype.processAssertionsBoolean = function(assertions, success, failure) {
        var me = this;
        var eah = new EcAsyncHelper();
        eah.each(assertions, function(assertion, done) {
            var competency = me.getCompetency(assertion.competency);
            if (competency == null || !me.containsVertex(competency)) {
                done();
                return;
            }
            assertion.getNegativeAsync(function(negative) {
                me.processAssertionsBooleanPerAssertion(assertion, negative, competency, done, new Array());
            }, eah.failWithCallback(failure, done));
        }, function(strings) {
            success();
        });
    };
    prototype.processAssertionsBooleanPerAssertion = function(assertion, negative, competency, done, visited) {
        var me = this;
        if (EcArray.has(visited, competency)) {
            done();
            return;
        }
        visited.push(competency);
        if (negative) {
            var metaState = this.getMetaStateCompetency(competency);
            this.addToMetaStateArray(metaState, "negativeAssertion", assertion);
            new EcAsyncHelper().each(me.getOutEdges(competency), function(alignment, callback0) {
                var c = me.getCompetency(alignment.target);
                me.processAssertionBooleanOutward(alignment, callback0, c, me, assertion, negative, visited);
            }, function(strings) {
                new EcAsyncHelper().each(me.getInEdges(competency), function(alignment, callback0) {
                    var c = me.getCompetency(alignment.source);
                    me.processAssertionBooleanInward(alignment, callback0, c, me, assertion, negative, visited);
                }, function(strings) {
                    done();
                });
            });
        } else {
            var metaState = this.getMetaStateCompetency(competency);
            this.addToMetaStateArray(metaState, "positiveAssertion", assertion);
            new EcAsyncHelper().each(me.getInEdges(competency), function(alignment, callback0) {
                var c = me.getCompetency(alignment.source);
                me.processAssertionBooleanOutward(alignment, callback0, c, me, assertion, negative, visited);
            }, function(strings) {
                new EcAsyncHelper().each(me.getOutEdges(competency), function(alignment, callback0) {
                    var c = me.getCompetency(alignment.target);
                    me.processAssertionBooleanInward(alignment, callback0, c, me, assertion, negative, visited);
                }, function(strings) {
                    done();
                });
            });
        }
    };
    prototype.processAssertionBooleanOutward = function(alignment, callback0, c, me, assertion, negative, visited) {
        if (alignment.relationType == Relation.NARROWS) 
            me.processAssertionsBooleanPerAssertion(assertion, negative, c, callback0, visited);
         else if (alignment.relationType == Relation.IS_EQUIVALENT_TO) 
            me.processAssertionsBooleanPerAssertion(assertion, negative, c, callback0, visited);
         else 
            callback0();
    };
    prototype.processAssertionBooleanInward = function(alignment, callback0, c, me, assertion, negative, visited) {
        if (alignment.relationType == Relation.REQUIRES) 
            me.processAssertionsBooleanPerAssertion(assertion, negative, c, callback0, visited);
         else if (alignment.relationType == Relation.IS_EQUIVALENT_TO) 
            me.processAssertionsBooleanPerAssertion(assertion, negative, c, callback0, visited);
         else 
            callback0();
    };
    prototype.addToMetaStateArray = function(metaState, key, value) {
        if (metaState == null) 
            return;
        if ((metaState)[key] == null) 
            (metaState)[key] = new Array();
        ((metaState)[key]).push(value);
    };
    /**
     *  Fetches the Meta Competency (additional state information used to compute profiles or other data) for a competency.
     * 
     *  @param {EcCompetency} c Competency to fetch meta state for.
     *  @return Meta state (empty object by default)
     *  @method getMetaStateCompetency
     *  @memberOf EcFrameworkGraph
     */
    prototype.getMetaStateCompetency = function(c) {
        var result = this.metaVerticies[c.shortId()];
        if (result == null) {
            if (this.containsVertex(c) == false) 
                return null;
            if (this.metaVerticies[c.shortId()] == null) 
                this.metaVerticies[c.shortId()] = result = new Object();
        }
        return result;
    };
    prototype.getMetaStateAlignment = function(a) {
        var result = this.metaEdges[a.shortId()];
        if (result == null) {
            if (this.containsEdge(a) == false) 
                return null;
            if (this.metaEdges[a.shortId()] == null) 
                this.metaEdges[a.shortId()] = result = new Object();
        }
        return result;
    };
    prototype.containsVertex = function(competency) {
        return (this.competencyMap)[competency.shortId()] != null;
    };
    prototype.containsEdge = function(competency) {
        return (this.edgeMap)[competency.shortId()] != null;
    };
    prototype.getCompetency = function(competencyId) {
        var c = null;
        c = (this.competencyMap)[competencyId];
        if (c == null) 
            c = EcCompetency.getBlocking(competencyId);
        return c;
    };
    prototype.addCompetency = function(competency) {
        if (competency == null) 
            return false;
        if (this.containsVertex(competency)) 
            return false;
        (this.competencyMap)[competency.shortId()] = competency;
        (this.competencyMap)[competency.id] = competency;
        return this.addVertex(competency);
    };
    prototype.addRelation = function(alignment) {
        if (alignment == null) 
            return false;
        if (this.containsEdge(alignment)) 
            return false;
        var source = (this.competencyMap)[EcRemoteLinkedData.trimVersionFromUrl(alignment.source)];
        if (source == null && (this.dontTryAnyMore)[alignment.source] != null) 
            return false;
        if (source == null) 
            source = this.getCompetency(alignment.source);
        if (source == null) 
            (this.dontTryAnyMore)[alignment.source] = "";
        var target = (this.competencyMap)[alignment.target];
        if (target == null && (this.dontTryAnyMore)[alignment.target] != null) 
            return false;
        if (target == null) 
            target = this.getCompetency(alignment.target);
        if (target == null) 
            (this.dontTryAnyMore)[alignment.target] = "";
        if (source == null || target == null) 
            return false;
        return this.addEdgeUnsafely(alignment, source, target);
    };
    prototype.addHyperEdge = function(edge, vertices) {
         throw new RuntimeException("Don't do this.");
    };
    prototype.getEdgeType = function(edge) {
        return edge.relationType;
    };
    prototype.getDefaultEdgeType = function() {
        return EcAlignment.NARROWS;
    };
}, {metaVerticies: {name: "Map", arguments: [null, "Object"]}, metaEdges: {name: "Map", arguments: [null, "Object"]}, competencyMap: "Object", edgeMap: "Object", dontTryAnyMore: "Object", frameworks: {name: "Array", arguments: ["EcFramework"]}, addFrameworkSuccessCallback: "Callback0", addFrameworkFailureCallback: {name: "Callback1", arguments: [null]}, repo: "EcRepository", edges: {name: "Array", arguments: [{name: "Triple", arguments: ["V", "V", "E"]}]}, verticies: {name: "Array", arguments: ["V"]}}, {});
var TestGraphBuilder = function() {};
TestGraphBuilder = stjs.extend(TestGraphBuilder, null, [], function(constructor, prototype) {
    constructor.buildTest0 = function(graph) {
        var nodeA = new Node("A");
        var nodeB = new Node("B");
        var nodeC = new Node("C");
        graph.addNode(nodeA);
        graph.addNode(nodeB);
        graph.addNode(nodeC);
        graph.addRelation(nodeA, nodeB, RelationType.RELATION_TYPE.NARROWS);
        graph.addRelation(nodeB, nodeC, RelationType.RELATION_TYPE.NARROWS);
        graph.addRelation(nodeC, nodeA, RelationType.RELATION_TYPE.NARROWS);
    };
    constructor.buildTest1 = function(graph) {
        var nodeA = new Node("A");
        var nodeB = new Node("B");
        var nodeC = new Node("C");
        var nodeD = new Node("D");
        var nodeE = new Node("E");
        graph.addNode(nodeA);
        graph.addNode(nodeB);
        graph.addNode(nodeC);
        graph.addNode(nodeD);
        graph.addNode(nodeE);
        graph.addRelation(nodeA, nodeB, RelationType.RELATION_TYPE.NARROWS);
        graph.addRelation(nodeB, nodeC, RelationType.RELATION_TYPE.NARROWS);
        graph.addRelation(nodeC, nodeD, RelationType.RELATION_TYPE.NARROWS);
        graph.addRelation(nodeD, nodeB, RelationType.RELATION_TYPE.NARROWS);
        graph.addRelation(nodeC, nodeE, RelationType.RELATION_TYPE.NARROWS);
    };
    constructor.buildTest2 = function(graph) {
        var nodeA = new Node("A");
        var nodeB = new Node("B");
        var nodeC = new Node("C");
        var nodeD = new Node("D");
        var nodeE = new Node("E");
        var nodeF = new Node("F");
        var nodeG = new Node("G");
        graph.addNode(nodeA);
        graph.addNode(nodeB);
        graph.addNode(nodeC);
        graph.addNode(nodeD);
        graph.addNode(nodeE);
        graph.addNode(nodeF);
        graph.addNode(nodeG);
        graph.addRelation(nodeA, nodeB, RelationType.RELATION_TYPE.IS_EQUIVALENT_TO);
        graph.addRelation(nodeB, nodeC, RelationType.RELATION_TYPE.NARROWS);
        graph.addRelation(nodeC, nodeD, RelationType.RELATION_TYPE.IS_REQUIRED_BY);
        graph.addRelation(nodeD, nodeF, RelationType.RELATION_TYPE.IS_REQUIRED_BY);
        graph.addRelation(nodeF, nodeB, RelationType.RELATION_TYPE.NARROWS);
        graph.addRelation(nodeD, nodeE, RelationType.RELATION_TYPE.IS_REQUIRED_BY);
        graph.addRelation(nodeE, nodeG, RelationType.RELATION_TYPE.REQUIRES);
    };
    constructor.buildTest3 = function(graph) {
        var nodeA = new Node("A");
        var nodeB = new Node("B");
        var nodeC = new Node("C");
        var nodeD = new Node("D");
        var nodeE = new Node("E");
        var nodeF = new Node("F");
        var nodeG = new Node("G");
        var nodeH = new Node("H");
        var nodeI = new Node("I");
        graph.addNode(nodeA);
        graph.addNode(nodeB);
        graph.addNode(nodeC);
        graph.addNode(nodeD);
        graph.addNode(nodeE);
        graph.addNode(nodeF);
        graph.addNode(nodeG);
        graph.addNode(nodeH);
        graph.addNode(nodeI);
        graph.addRelation(nodeA, nodeB, RelationType.RELATION_TYPE.NARROWS);
        graph.addRelation(nodeB, nodeC, RelationType.RELATION_TYPE.NARROWS);
        graph.addRelation(nodeC, nodeD, RelationType.RELATION_TYPE.IS_REQUIRED_BY);
        graph.addRelation(nodeD, nodeI, RelationType.RELATION_TYPE.IS_REQUIRED_BY);
        graph.addRelation(nodeI, nodeB, RelationType.RELATION_TYPE.IS_REQUIRED_BY);
        graph.addRelation(nodeD, nodeE, RelationType.RELATION_TYPE.IS_REQUIRED_BY);
        graph.addRelation(nodeE, nodeF, RelationType.RELATION_TYPE.IS_REQUIRED_BY);
        graph.addRelation(nodeF, nodeG, RelationType.RELATION_TYPE.IS_REQUIRED_BY);
        graph.addRelation(nodeG, nodeH, RelationType.RELATION_TYPE.IS_REQUIRED_BY);
        graph.addRelation(nodeH, nodeE, RelationType.RELATION_TYPE.IS_REQUIRED_BY);
    };
    constructor.buildTest4 = function(graph) {
        var nodeA = new Node("A");
        var nodeB = new Node("B");
        var nodeC = new Node("C");
        var nodeD = new Node("D");
        var nodeE = new Node("E");
        var nodeF = new Node("F");
        var nodeG = new Node("G");
        var nodeH = new Node("H");
        var nodeI = new Node("I");
        graph.addNode(nodeA);
        graph.addNode(nodeB);
        graph.addNode(nodeC);
        graph.addNode(nodeD);
        graph.addNode(nodeE);
        graph.addNode(nodeF);
        graph.addNode(nodeG);
        graph.addNode(nodeH);
        graph.addNode(nodeI);
        graph.addRelation(nodeD, nodeE, RelationType.RELATION_TYPE.IS_REQUIRED_BY);
        graph.addRelation(nodeA, nodeB, RelationType.RELATION_TYPE.NARROWS);
        graph.addRelation(nodeB, nodeC, RelationType.RELATION_TYPE.NARROWS);
        graph.addRelation(nodeF, nodeG, RelationType.RELATION_TYPE.IS_REQUIRED_BY);
        graph.addRelation(nodeG, nodeH, RelationType.RELATION_TYPE.IS_REQUIRED_BY);
        graph.addRelation(nodeI, nodeB, RelationType.RELATION_TYPE.IS_REQUIRED_BY);
        graph.addRelation(nodeE, nodeF, RelationType.RELATION_TYPE.IS_REQUIRED_BY);
        graph.addRelation(nodeC, nodeD, RelationType.RELATION_TYPE.IS_REQUIRED_BY);
        graph.addRelation(nodeD, nodeI, RelationType.RELATION_TYPE.IS_REQUIRED_BY);
        graph.addRelation(nodeH, nodeE, RelationType.RELATION_TYPE.IS_REQUIRED_BY);
        graph.addRelation(nodeG, nodeB, RelationType.RELATION_TYPE.NARROWS);
    };
    constructor.buildTest5 = function(graph) {
        var nodeA = new Node("A");
        var nodeB = new Node("B");
        var nodeC = new Node("C");
        var nodeD = new Node("D");
        var nodeE = new Node("E");
        var nodeF = new Node("F");
        var nodeG = new Node("G");
        var nodeH = new Node("H");
        var nodeI = new Node("I");
        graph.addNode(nodeA);
        graph.addNode(nodeB);
        graph.addNode(nodeC);
        graph.addNode(nodeD);
        graph.addNode(nodeE);
        graph.addNode(nodeF);
        graph.addNode(nodeG);
        graph.addNode(nodeH);
        graph.addNode(nodeI);
        graph.addRelation(nodeA, nodeB, RelationType.RELATION_TYPE.NARROWS);
        graph.addRelation(nodeB, nodeC, RelationType.RELATION_TYPE.NARROWS);
        graph.addRelation(nodeC, nodeD, RelationType.RELATION_TYPE.IS_REQUIRED_BY);
        graph.addRelation(nodeD, nodeI, RelationType.RELATION_TYPE.IS_REQUIRED_BY);
        graph.addRelation(nodeI, nodeB, RelationType.RELATION_TYPE.BROADENS);
        graph.addRelation(nodeD, nodeE, RelationType.RELATION_TYPE.BROADENS);
        graph.addRelation(nodeE, nodeF, RelationType.RELATION_TYPE.BROADENS);
        graph.addRelation(nodeF, nodeG, RelationType.RELATION_TYPE.BROADENS);
        graph.addRelation(nodeG, nodeH, RelationType.RELATION_TYPE.REQUIRES);
        graph.addRelation(nodeH, nodeE, RelationType.RELATION_TYPE.NARROWS);
    };
    constructor.buildTest6 = function(graph) {
        var nodeA = new Node("A");
        var nodeB = new Node("B");
        var nodeC = new Node("C");
        var nodeD = new Node("D");
        var nodeE = new Node("E");
        var nodeF = new Node("F");
        var nodeG = new Node("G");
        var nodeH = new Node("H");
        var nodeI = new Node("I");
        graph.addNode(nodeA);
        graph.addNode(nodeB);
        graph.addNode(nodeC);
        graph.addNode(nodeD);
        graph.addNode(nodeE);
        graph.addNode(nodeF);
        graph.addNode(nodeG);
        graph.addNode(nodeH);
        graph.addNode(nodeI);
        graph.addRelation(nodeA, nodeB, RelationType.RELATION_TYPE.NARROWS);
        graph.addRelation(nodeB, nodeC, RelationType.RELATION_TYPE.NARROWS);
        graph.addRelation(nodeC, nodeD, RelationType.RELATION_TYPE.IS_REQUIRED_BY);
        graph.addRelation(nodeD, nodeI, RelationType.RELATION_TYPE.IS_REQUIRED_BY);
        graph.addRelation(nodeI, nodeB, RelationType.RELATION_TYPE.IS_REQUIRED_BY);
        graph.addRelation(nodeD, nodeE, RelationType.RELATION_TYPE.REQUIRES);
        graph.addRelation(nodeE, nodeF, RelationType.RELATION_TYPE.BROADENS);
        graph.addRelation(nodeF, nodeG, RelationType.RELATION_TYPE.BROADENS);
        graph.addRelation(nodeG, nodeH, RelationType.RELATION_TYPE.REQUIRES);
        graph.addRelation(nodeH, nodeE, RelationType.RELATION_TYPE.REQUIRES);
    };
    constructor.buildTest7 = function(graph) {
        var nodeA = new Node("A");
        var nodeB = new Node("B");
        var nodeC = new Node("C");
        var nodeD = new Node("D");
        var nodeE = new Node("E");
        var nodeF = new Node("F");
        graph.addNode(nodeA);
        graph.addNode(nodeB);
        graph.addNode(nodeC);
        graph.addNode(nodeD);
        graph.addNode(nodeE);
        graph.addNode(nodeF);
        graph.addRelation(nodeA, nodeB, RelationType.RELATION_TYPE.NARROWS);
        graph.addRelation(nodeB, nodeC, RelationType.RELATION_TYPE.NARROWS);
        graph.addRelation(nodeC, nodeD, RelationType.RELATION_TYPE.IS_REQUIRED_BY);
        graph.addRelation(nodeD, nodeB, RelationType.RELATION_TYPE.IS_REQUIRED_BY);
        graph.addRelation(nodeB, nodeF, RelationType.RELATION_TYPE.BROADENS);
        graph.addRelation(nodeF, nodeE, RelationType.RELATION_TYPE.REQUIRES);
        graph.addRelation(nodeE, nodeB, RelationType.RELATION_TYPE.REQUIRES);
    };
    constructor.buildTestGraph = function() {
        var graph = new NodeGraph();
        TestGraphBuilder.buildTest7(graph);
        graph.createImpliedRelations();
        return graph;
    };
}, {}, {});
var CompetencyGraphBuilder = function() {
    this.repositories = new Array();
    this.subjects = new Array();
};
CompetencyGraphBuilder = stjs.extend(CompetencyGraphBuilder, null, [], function(constructor, prototype) {
    constructor.SIZE_OF_ASSERTION_QUERY = 5000;
    prototype.success = null;
    prototype.failure = null;
    prototype.includeAssertions = true;
    prototype.frameworkId = null;
    prototype.rootCompetencyId = null;
    prototype.repositories = null;
    prototype.subjects = null;
    prototype.createImpliedEdges = true;
    prototype.competencyGraph = null;
    prototype.frameworkRelationMap = null;
    prototype.frameworkRelationList = null;
    prototype.assertionList = null;
    prototype.assertionMap = null;
    prototype.relationshipsToProcess = 0;
    prototype.relationshipsProcessed = 0;
    prototype.repositoriesToQuery = 0;
    prototype.repostioriesQueried = 0;
    prototype.assertionsToFillIn = 0;
    prototype.assertionsFilledIn = 0;
    prototype.getRelationsForCompetency = function(competencyId) {
        var competencyRelations = this.frameworkRelationMap[competencyId];
        if (competencyRelations == null) {
            competencyRelations = new Array();
            this.frameworkRelationMap[competencyId] = competencyRelations;
        }
        return competencyRelations;
    };
    prototype.addRelationToCompetencyMap = function(competencyId, relation) {
        var competencyRelations;
        competencyRelations = this.getRelationsForCompetency(competencyId);
        competencyRelations.push(relation);
        this.frameworkRelationMap[competencyId] = competencyRelations;
    };
    prototype.buildFrameworkRelationsMap = function() {
        var relation;
        for (var i = 0; i < this.frameworkRelationList.length; i++) {
            relation = this.frameworkRelationList[i];
            this.addRelationToCompetencyMap(relation.source, relation);
            this.addRelationToCompetencyMap(relation.target, relation);
        }
    };
    prototype.addCompetencyTreeToGraph = function(competencyId) {
        this.competencyGraph.addNode(competencyId);
        var competencyRelations = this.frameworkRelationMap[competencyId];
        if (competencyRelations != null && competencyRelations.length > 0) {
            var relation;
            for (var i = 0; i < competencyRelations.length; i++) {
                relation = competencyRelations[i];
                if (!this.competencyGraph.graphContainsEdge(relation.source, relation.target, relation.relationType)) {
                    this.competencyGraph.addEdge(relation.source, relation.target, relation.relationType);
                }
                if (!this.competencyGraph.graphContainsNode(relation.target)) {
                    this.addCompetencyTreeToGraph(relation.target);
                }
                if (!this.competencyGraph.graphContainsNode(relation.source)) {
                    this.addCompetencyTreeToGraph(relation.source);
                }
            }
        }
    };
    prototype.returnGraph = function() {
        this.success(this.competencyGraph);
    };
    prototype.addAssertionsToGraph = function() {
        var sa;
        var a;
        for (var i = 0; i < this.assertionList.length; i++) {
            a = this.assertionList[i];
            sa = this.assertionMap[a.id];
            if (sa != null) {
                if (sa.isNegative()) 
                    this.competencyGraph.addNegativeAssertion(sa);
                 else 
                    this.competencyGraph.addPositiveAssertion(sa);
            }
        }
    };
    prototype.checkAssertionDetailsFetched = function() {
        if (this.assertionsFilledIn >= this.assertionsToFillIn) {
            this.addAssertionsToGraph();
            this.returnGraph();
        }
    };
    prototype.fetchAssertionDetailsNegativeStatus = function(a, sa) {
        var cgb = this;
        a.getNegativeAsync(function(negative) {
            if (negative != null && negative) 
                sa.setNegative(true);
             else 
                sa.setNegative(false);
            cgb.assertionMap[sa.getId()] = sa;
            cgb.assertionsFilledIn++;
            cgb.checkAssertionDetailsFetched();
        }, function(s) {
            sa.setNegative(false);
            cgb.assertionMap[sa.getId()] = sa;
            cgb.assertionsFilledIn++;
            cgb.checkAssertionDetailsFetched();
        });
    };
    prototype.fetchAssertionDetailsExpirationDate = function(a, sa) {
        var cgb = this;
        a.getExpirationDateAsync(function(expirationDate) {
            if (expirationDate == null || expirationDate <= stjs.trunc(new Date().getTime())) {
                cgb.assertionsFilledIn++;
                cgb.checkAssertionDetailsFetched();
            } else {
                sa.setExpirationDate(expirationDate);
                cgb.fetchAssertionDetailsNegativeStatus(a, sa);
            }
        }, function(s) {
            cgb.failure(new ExceptionReturn("Failed fetchAssertionDetailsExpirationDate: " + s));
        });
    };
    prototype.fetchAssertionDetailsAssertionDate = function(a, sa) {
        var cgb = this;
        a.getAssertionDateAsync(function(assertionDate) {
            if (assertionDate == null || assertionDate > stjs.trunc(new Date().getTime())) {
                cgb.assertionsFilledIn++;
                cgb.checkAssertionDetailsFetched();
            } else {
                sa.setAssertionDate(assertionDate);
                cgb.fetchAssertionDetailsExpirationDate(a, sa);
            }
        }, function(s) {
            cgb.failure(new ExceptionReturn("Failed fetchAssertionDetailsAssertionDate: " + s));
        });
    };
    prototype.isASubject = function(pk) {
        if (this.subjects == null || this.subjects.length == 0) 
            return true;
        var sub;
        for (var i = 0; i < this.subjects.length; i++) {
            sub = this.subjects[i];
            if (sub.toPem().trim() == pk.toPem().trim()) 
                return true;
        }
        return false;
    };
    prototype.fetchAssertionDetailsSubject = function(a, sa) {
        var cgb = this;
        a.getSubjectAsync(function(sub) {
            if (sub == null || !cgb.isASubject(sub)) {
                cgb.assertionsFilledIn++;
                cgb.checkAssertionDetailsFetched();
            } else {
                sa.setSubjectPem(sub.toPem());
                cgb.fetchAssertionDetailsAssertionDate(a, sa);
            }
        }, function(s) {
            cgb.failure(new ExceptionReturn("Failed fetchAssertionDetailsSubject: " + s));
        });
    };
    prototype.fillInAssertions = function() {
        this.assertionsToFillIn = this.assertionList.length;
        this.assertionsFilledIn = 0;
        if (this.assertionsToFillIn == 0) 
            this.returnGraph();
        var a;
        var sa;
        for (var i = 0; i < this.assertionList.length; i++) {
            a = this.assertionList[i];
            sa = new SimpleAssertion(a.id, a.competency, a.confidence);
            this.fetchAssertionDetailsSubject(a, sa);
        }
    };
    prototype.checkNumberOfReposQueried = function() {
        if (this.repostioriesQueried >= this.repositoriesToQuery) {
            this.fillInAssertions();
        }
    };
    prototype.addAssertionsToList = function(repoAssertions) {
        for (var i = 0; i < repoAssertions.length; i++) {
            this.assertionList.push(repoAssertions[i]);
        }
        this.repostioriesQueried++;
    };
    prototype.buildAssertionSearchQuery = function() {
        var query = "(";
        for (var i = 0; i < this.competencyGraph.getNodes().length; i++) {
            if (i != 0) 
                query += " OR ";
            query += "competency:\"" + this.competencyGraph.getNodes()[i] + "\"";
        }
        query += ")";
        if (this.subjects != null) {
            for (var i = 0; i < this.subjects.length; i++) {
                query += " AND (\\*reader:\"" + this.subjects[i].toPem() + "\")";
            }
        }
        return query;
    };
    prototype.processCompetencyAssertions = function() {
        this.repositoriesToQuery = this.repositories.length;
        this.repostioriesQueried = 0;
        var currentRepository;
        var params = new Object();
        (params)["size"] = CompetencyGraphBuilder.SIZE_OF_ASSERTION_QUERY;
        var searchQuery = this.buildAssertionSearchQuery();
        var cgb = this;
        for (var i = 0; i < this.repositories.length; i++) {
            currentRepository = this.repositories[i];
            EcAssertion.search(currentRepository, searchQuery, function(assertions) {
                cgb.addAssertionsToList(assertions);
                cgb.checkNumberOfReposQueried();
            }, function(s) {
                cgb.failure(new ExceptionReturn("Error fetching assertions: " + s));
            }, params);
        }
    };
    prototype.assembleGraphComponents = function() {
        try {
            this.buildFrameworkRelationsMap();
            this.addCompetencyTreeToGraph(this.rootCompetencyId);
            if (this.createImpliedEdges) 
                this.competencyGraph.createImpliedRelationships();
            if (this.includeAssertions) 
                this.processCompetencyAssertions();
             else 
                this.returnGraph();
        }catch (e) {
            this.failure(new ExceptionReturn("Exception buildAndReturnCompetencyGraph: " + e.toString()));
        }
    };
    prototype.checkNumberOfRelationsProcessed = function() {
        if (this.relationshipsProcessed >= this.relationshipsToProcess) {
            this.assembleGraphComponents();
        }
    };
    prototype.addRelationshipToList = function(a) {
        this.frameworkRelationList.push(a);
        this.relationshipsProcessed++;
    };
    prototype.fetchFrameworkRelations = function(f) {
        this.relationshipsToProcess = f.relation.length;
        this.relationshipsProcessed = 0;
        var cgb = this;
        if (this.relationshipsToProcess == 0) {
            this.competencyGraph.addNode(this.rootCompetencyId);
            this.success(this.competencyGraph);
        } else {
            for (var i = 0; i < this.relationshipsToProcess; i++) {
                EcAlignment.get(f.relation[i], function(a) {
                    cgb.addRelationshipToList(a);
                    cgb.checkNumberOfRelationsProcessed();
                }, function(s) {
                    cgb.failure(new ExceptionReturn("Error fetching relationship: " + s));
                });
            }
        }
    };
    prototype.fetchFrameworkAndGo = function() {
        var cgb = this;
        EcFramework.get(this.frameworkId, function(f) {
            cgb.fetchFrameworkRelations(f);
        }, function(s) {
            cgb.failure(new ExceptionReturn("Error fetching framework(" + cgb.frameworkId + "): " + s));
        });
    };
    prototype.validateInput = function() {
        if (this.includeAssertions && (this.repositories == null || this.repositories.length == 0)) {
            this.failure(new ExceptionReturn("Assertion repository information not provided."));
        } else if (this.success == null) {
            this.failure(new ExceptionReturn("Success callback required."));
        } else if (this.frameworkId == null) {
            this.failure(new ExceptionReturn("Framework ID required."));
        } else if (this.rootCompetencyId == null) {
            this.failure(new ExceptionReturn("Root Competency ID required."));
        }
    };
    prototype.initBuilder = function(createImpliedEdges) {
        this.createImpliedEdges = createImpliedEdges;
        this.competencyGraph = new CompetencyGraph(this.includeAssertions);
        this.assertionMap = {};
        this.frameworkRelationMap = {};
        this.frameworkRelationList = new Array();
        this.assertionList = new Array();
    };
    prototype.buildCompetencyGraph = function(createImpliedEdges) {
        this.validateInput();
        this.initBuilder(createImpliedEdges);
        this.fetchFrameworkAndGo();
    };
}, {success: {name: "Callback1", arguments: ["CompetencyGraph"]}, failure: {name: "Callback1", arguments: ["ExceptionReturn"]}, repositories: {name: "Array", arguments: ["EcRepository"]}, subjects: {name: "Array", arguments: ["EcPk"]}, competencyGraph: "CompetencyGraph", frameworkRelationMap: {name: "Map", arguments: [null, {name: "Array", arguments: ["EcAlignment"]}]}, frameworkRelationList: {name: "Array", arguments: ["EcAlignment"]}, assertionList: {name: "Array", arguments: ["EcAssertion"]}, assertionMap: {name: "Map", arguments: [null, "SimpleAssertion"]}}, {});
var RollupRuleProcessor = function(ip, ep) {
    this.ip = ip;
    this.rollupRulePacketGenerator = new RollupRulePacketGenerator(ip, ep);
};
RollupRuleProcessor = stjs.extend(RollupRuleProcessor, null, [], function(constructor, prototype) {
    prototype.success = null;
    prototype.failure = null;
    prototype.logFunction = null;
    prototype.positive = null;
    prototype.negative = null;
    prototype.onQueryExitResult = null;
    prototype.query = null;
    prototype.rollupRulePacketGenerator = null;
    prototype.s = null;
    prototype.tok = null;
    prototype.que = null;
    prototype.ip = null;
    prototype.log = function(string) {
        if (this.logFunction != null) 
            this.logFunction(string);
    };
    prototype.enterS = function(ctx) {
        if (this.s != null) 
             throw new RuntimeException("We found another S in our S.");
        this.s = new RrS();
    };
    prototype.exitS = function(ctx) {
        this.ip.subPackets.push(this.rollupRulePacketGenerator.generatePacket());
    };
    prototype.enterToken = function(ctx) {
        this.s.addToken(this.tok = new RrToken());
    };
    prototype.exitToken = function(ctx) {};
    prototype.enterQuery = function(ctx) {
        this.s.addQuery(this.que = new RrQuery());
        this.query = "";
        this.onQueryExitResult = null;
    };
    prototype.exitQuery = function(ctx) {
        this.que.query = this.query.trim();
        this.log("ADDING QUERY: " + this.query.trim());
        this.rollupRulePacketGenerator.addQuery(this.query.trim());
    };
    prototype.exitInnerquery = function(ctx) {
        if (ctx.cLogic != null) 
            this.query += " " + ctx.cLogic.text + " ";
        if (ctx.cValue != null) {
            this.query += ctx.cKey.text + "" + ctx.cOperator.text + "\"" + ctx.cValue.text + "\" ";
        }
        if (ctx.cNumber != null) {
            this.query += ctx.cKey.text + "" + ctx.cOperator.text + "" + ctx.cNumber.text + " ";
        }
    };
    prototype.exitLogical_or_math_operator = function(ctx) {
        if (ctx.cLogic != null) {
            if ("AND" == ctx.cLogic.text.toUpperCase()) {
                this.log("ADDING OPERATION: " + RollupRulePacketGenerator.OperationType.AND);
                this.rollupRulePacketGenerator.addQueryOperation(RollupRulePacketGenerator.OperationType.AND);
            } else if ("OR" == ctx.cLogic.text.toUpperCase()) {
                this.log("ADDING OPERATION: " + RollupRulePacketGenerator.OperationType.OR);
                this.rollupRulePacketGenerator.addQueryOperation(RollupRulePacketGenerator.OperationType.OR);
            }
        }
    };
}, {success: {name: "Callback1", arguments: [null]}, failure: {name: "Callback1", arguments: [null]}, logFunction: {name: "Callback1", arguments: ["Object"]}, positive: {name: "Array", arguments: ["EcAssertion"]}, negative: {name: "Array", arguments: ["EcAssertion"]}, rollupRulePacketGenerator: "RollupRulePacketGenerator", s: "RrS", tok: "RrToken", que: "RrQuery", ip: "InquiryPacket"}, {});
var PredictiveAssertionProcessor = function() {};
PredictiveAssertionProcessor = stjs.extend(PredictiveAssertionProcessor, null, [], function(constructor, prototype) {
    constructor.LOG_ENABLED = false;
    constructor.ABRUBT_EXP_RETENTION = 0.0;
    constructor.DEFAULT_RETENTION = 1.0;
    constructor.STEP_SIZE_NUMERATOR = 1.0;
    constructor.INITIAL_VALUE = 0.0;
    constructor.INIT_PARENT_IDX_DEP_PARM = -1;
    constructor.INIT_CHILD_IDX_DEP_PARM = -1;
    constructor.INIT_WEIGHT_DEP_PARM = 0.0;
    constructor.INIT_LEAK_DEP_PARM = 0.0;
    constructor.INIT_REVERSE_DEP_PARM = false;
    constructor.DEFAULT_PROB_LEARN_UNMET_REQS = 0.0;
    constructor.DEFAULT_PROB_INSUFF = 0.0;
    constructor.DEFAULT_DISCOUNT = 1.0;
    prototype.competencyIndex = null;
    prototype.values = null;
    prototype.dependencies = null;
    prototype.assertions = null;
    prototype.dependencyDefs = null;
    prototype.settings = null;
    prototype.inputGraph = null;
    prototype.subjectPem = null;
    prototype.predictionDate = null;
    prototype.competencyNetwork = null;
    prototype.stepSize = 0.0;
    prototype.priorityQueueThreshold = 0.0;
    prototype.competencePrediction = null;
    prototype.log = function(s) {
        if (PredictiveAssertionProcessor.LOG_ENABLED) {
            console.log(s);
        }
    };
    prototype.verifyDependencyDefs = function() {
        if (this.dependencyDefs == null) {
            this.dependencyDefs = new PapDependencyDefinitions();
            this.dependencyDefs.initDefaultDefinitions();
        }
    };
    prototype.processInputParameters = function(inputGraph, subjectPem, predictionDate, dependencyDefs, settings) {
        this.dependencyDefs = dependencyDefs;
        this.verifyDependencyDefs();
        this.settings = settings;
        if (this.settings == null) 
            this.settings = new PapSettings();
        this.inputGraph = inputGraph;
        this.subjectPem = subjectPem;
        if (this.subjectPem != null) 
            this.subjectPem = this.subjectPem.trim();
        this.predictionDate = predictionDate;
        if (this.predictionDate == null) 
            this.predictionDate = stjs.trunc((new Date()).getTime());
        this.stepSize = PredictiveAssertionProcessor.STEP_SIZE_NUMERATOR / this.settings.getIterations();
        this.priorityQueueThreshold = this.settings.getPriorityQueueThreshold() / this.settings.getIterations();
    };
    prototype.initDependenciesMap = function() {
        this.dependencies = {};
        var type;
        for (var i = 0; i < PapDependency.getDependencyTypes().length; i++) {
            type = PapDependency.getDependencyTypes()[i];
            var dependencySubMap = {};
            this.dependencies[type] = dependencySubMap;
        }
    };
    prototype.initAssertionsMap = function() {
        this.assertions = {};
        for (var i = 0; i < this.inputGraph.getNodes().length; i++) {
            this.assertions[String.valueOf(i)] = new Array();
        }
    };
    prototype.buildValuesCompetencyIndexAndDependencies = function() {
        this.competencyIndex = {};
        this.values = new Array();
        for (var i = 0; i < this.inputGraph.getNodes().length; i++) {
            this.values.push(PredictiveAssertionProcessor.INITIAL_VALUE);
            this.competencyIndex[this.inputGraph.getNodes()[i]] = i;
            var type;
            for (var j = 0; j < PapDependency.getDependencyTypes().length; j++) {
                type = PapDependency.getDependencyTypes()[j];
                this.dependencies[type][String.valueOf(i)] = new Array();
            }
        }
    };
    prototype.initDataStructures = function() {
        this.initDependenciesMap();
        this.initAssertionsMap();
        this.buildValuesCompetencyIndexAndDependencies();
    };
    prototype.getDefaultPapDependencyParms = function() {
        var depParms = new PapDependencyParms();
        depParms.setType(PapDependency.NULL_TYPE);
        depParms.setParentIndex(PredictiveAssertionProcessor.INIT_PARENT_IDX_DEP_PARM);
        depParms.setChildIndex(PredictiveAssertionProcessor.INIT_CHILD_IDX_DEP_PARM);
        depParms.setWeight(PredictiveAssertionProcessor.INIT_WEIGHT_DEP_PARM);
        depParms.setLeak(PredictiveAssertionProcessor.INIT_LEAK_DEP_PARM);
        depParms.setReverse(PredictiveAssertionProcessor.INIT_REVERSE_DEP_PARM);
        return depParms;
    };
    prototype.getDependencyParmsForEdge = function(edge) {
        var depType = edge.getRelation();
        var depClass = this.dependencyDefs.getDependencyDefinitionMap()[depType].getDepClass();
        var depParms = this.getDefaultPapDependencyParms();
        switch (depClass.toLowerCase()) {
            case "isrequiredby":
                depParms.setChildIndex(this.competencyIndex[edge.getSource()]);
                depParms.setParentIndex(this.competencyIndex[edge.getTarget()]);
                depParms.setType(PapDependency.NECESSARY_TYPE);
                depParms.setWeight(this.dependencyDefs.getWeightForType(depType));
                depParms.setLeak(this.dependencyDefs.getLeakForType(depType));
                depParms.setReverse(this.dependencyDefs.getReverseForType(depType));
                break;
            case "issufficientfor":
                depParms.setChildIndex(this.competencyIndex[edge.getSource()]);
                depParms.setParentIndex(this.competencyIndex[edge.getTarget()]);
                depParms.setType(PapDependency.SUFFICIENT_TYPE);
                depParms.setWeight(this.dependencyDefs.getWeightForType(depType));
                depParms.setLeak(this.dependencyDefs.getLeakForType(depType));
                depParms.setReverse(this.dependencyDefs.getReverseForType(depType));
                break;
            case "isequivalentto":
                depParms.setParentIndex(this.competencyIndex[edge.getSource()]);
                depParms.setChildIndex(this.competencyIndex[edge.getTarget()]);
                depParms.setType(PapDependency.EQUIVALENCE_TYPE);
                depParms.setWeight(this.dependencyDefs.getWeightForType(depType));
                break;
            case "broadens":
                depParms.setParentIndex(this.competencyIndex[edge.getSource()]);
                depParms.setChildIndex(this.competencyIndex[edge.getTarget()]);
                depParms.setType(PapDependency.BROADENS_TYPE);
                depParms.setWeight(this.dependencyDefs.getWeightForType(depType));
                depParms.setReverse(this.dependencyDefs.getReverseForType(depType));
                break;
        }
        return depParms;
    };
    prototype.dependencyExists = function(type, index, dependency) {
        var dependencyArray = this.dependencies[type][index];
        if (dependencyArray == null) {
            return true;
        }
        var currentDep;
        for (var i = 0; i < dependencyArray.length; i++) {
            currentDep = dependencyArray[i];
            if (currentDep.equals(dependency)) 
                return true;
        }
        return false;
    };
    prototype.processEdges = function() {
        for (var i = 0; i < this.inputGraph.getEdges().length; i++) {
            var edge = this.inputGraph.getEdges()[i];
            var depParms = this.getDependencyParmsForEdge(edge);
            var newDep;
            if (PapDependency.EQUIVALENCE_TYPE.equals(depParms.getType())) {
                depParms.setDependencyFirst(true);
                newDep = new PapDependency(depParms);
                if (!this.dependencyExists(depParms.getType(), String.valueOf(depParms.getParentIndex()), newDep)) {
                    this.dependencies[depParms.getType()][String.valueOf(depParms.getParentIndex())].push(newDep);
                }
                depParms.swapParentChildIndexes();
                newDep = new PapDependency(depParms);
                if (!this.dependencyExists(depParms.getType(), String.valueOf(depParms.getParentIndex()), newDep)) {
                    this.dependencies[depParms.getType()][String.valueOf(depParms.getParentIndex())].push(newDep);
                }
            } else if (edge.getRelation() != null && edge.getRelation().trim().length > 0) {
                depParms.setDependencyFirst(!depParms.getReverse());
                newDep = new PapDependency(depParms);
                if (!this.dependencyExists(depParms.getType(), String.valueOf(depParms.getParentIndex()), newDep)) {
                    this.dependencies[depParms.getType()][String.valueOf(depParms.getParentIndex())].push(newDep);
                }
            }
        }
    };
    prototype.addAssertions = function(assertionList) {
        var sa;
        var pa;
        for (var i = 0; i < assertionList.length; i++) {
            sa = assertionList[i];
            if (sa.getAssertionDate() <= this.predictionDate && ((!this.settings.getAbruptExpiration()) || this.predictionDate <= sa.getExpirationDate())) {
                var index = this.competencyIndex[sa.getCompetencyId()];
                pa = new PapAssertion(sa.getConfidence(), index, sa.getAssertionDate(), sa.getExpirationDate(), !sa.isNegative());
                this.assertions[String.valueOf(index)].push(pa);
            }
        }
    };
    prototype.processAssertions = function() {
        if (this.subjectPem == null || this.subjectPem.length <= 0) {
            this.addAssertions(this.inputGraph.getNegativeAssertions());
            this.addAssertions(this.inputGraph.getPositiveAssertions());
        } else {
            var sa;
            var matchingAssertionList = new Array();
            for (var i = 0; i < this.inputGraph.getNegativeAssertions().length; i++) {
                sa = this.inputGraph.getNegativeAssertions()[i];
                if (this.subjectPem.equals(sa.getSubjectPem())) 
                    matchingAssertionList.push(sa);
            }
            this.addAssertions(matchingAssertionList);
            matchingAssertionList = new Array();
            for (var i = 0; i < this.inputGraph.getPositiveAssertions().length; i++) {
                sa = this.inputGraph.getPositiveAssertions()[i];
                if (this.subjectPem.equals(sa.getSubjectPem())) 
                    matchingAssertionList.push(sa);
            }
            this.addAssertions(matchingAssertionList);
        }
    };
    prototype.getTimeFactor = function(assertionDate, expirationDate) {
        var range = expirationDate - assertionDate;
        var timeUntilPrediction = this.predictionDate - assertionDate;
        var rate = (timeUntilPrediction) / range;
        return rate;
    };
    prototype.getRetention = function(assertionDate, expirationDate) {
        if (this.settings.getAbruptExpiration() && this.predictionDate > (expirationDate)) 
            return PredictiveAssertionProcessor.ABRUBT_EXP_RETENTION;
         else {
            if (this.settings.getGradualForgetting()) {
                var factor = this.getTimeFactor(assertionDate, expirationDate);
                return Math.exp(-factor);
            } else 
                return PredictiveAssertionProcessor.DEFAULT_RETENTION;
        }
    };
    prototype.addAssertionsToUpdateQueue = function(updateQueue) {
        var assertionList;
        var assertion;
        var val;
        for (var i = 0; i < this.inputGraph.getNodes().length; i++) {
            assertionList = this.assertions[String.valueOf(i)];
            for (var j = 0; j < assertionList.length; j++) {
                assertion = assertionList[j];
                val = this.stepSize * assertion.getConfidence() * this.settings.getEvidenceWeight() * this.getRetention(assertion.getAssertionDate(), assertion.getExpirationDate());
                if (val > this.priorityQueueThreshold) {
                    updateQueue.push(new PapUpdate(assertion.getCompetencyIndex(), val, assertion.getResult()));
                }
            }
        }
    };
    prototype.processNecessaryNetworkDependencies = function(update, updateQueue) {
        var updateDependencies = this.competencyNetwork.getDependencies()[PapDependency.NECESSARY_TYPE][String.valueOf(update.getIndex())];
        if (updateDependencies != null) {
            var probabilityLearnUnmetRequirements = PredictiveAssertionProcessor.DEFAULT_PROB_LEARN_UNMET_REQS;
            if (updateDependencies.length > 0) {
                probabilityLearnUnmetRequirements = updateDependencies[0].getLeak();
            }
            var totalRes = (1 - probabilityLearnUnmetRequirements);
            var dep;
            for (var i = 0; i < updateDependencies.length; i++) {
                dep = updateDependencies[i];
                totalRes *= (1 - dep.getWeight() * this.competencyNetwork.getActivations()[dep.getChildIndex()]);
            }
            var gradient;
            for (var i = 0; i < updateDependencies.length; i++) {
                dep = updateDependencies[i];
                if (!update.hasVisited(dep.getChildIndex())) {
                    gradient = update.getChange() * totalRes / (1 - dep.getWeight() * this.competencyNetwork.getActivations()[dep.getChildIndex()]) * dep.getWeight() * this.settings.getDiscount();
                    if (gradient > this.priorityQueueThreshold) {
                        updateQueue.push(update.updateChild(dep.getChildIndex(), gradient));
                    }
                }
            }
        }
    };
    prototype.processSufficientNetworkDependencies = function(update, updateQueue) {
        var updateDependencies = this.competencyNetwork.getDependencies()[PapDependency.SUFFICIENT_TYPE][String.valueOf(update.getIndex())];
        if (updateDependencies != null) {
            var probabilityInsufficient = PredictiveAssertionProcessor.DEFAULT_PROB_INSUFF;
            if (updateDependencies.length > 0) {
                probabilityInsufficient = updateDependencies[0].getLeak();
            }
            var totalRes = (1 - probabilityInsufficient);
            var dep;
            for (var i = 0; i < updateDependencies.length; i++) {
                dep = updateDependencies[i];
                totalRes *= (1.0 - (1.0 - this.competencyNetwork.getActivations()[dep.getChildIndex()]) * dep.getWeight());
            }
            var gradient;
            for (var i = 0; i < updateDependencies.length; i++) {
                dep = updateDependencies[i];
                if (!update.hasVisited(dep.getChildIndex())) {
                    gradient = update.getChange() * (1.0 - totalRes / (1.0 - dep.getWeight() * (1.0 - this.competencyNetwork.getActivations()[dep.getChildIndex()]))) * this.settings.getDiscount();
                    if (gradient > this.priorityQueueThreshold) {
                        updateQueue.push(update.updateChild(dep.getChildIndex(), gradient));
                    }
                }
            }
        }
    };
    prototype.processEquivalenceNetworkDependencies = function(update, updateQueue) {
        var updateDependencies = this.competencyNetwork.getDependencies()[PapDependency.EQUIVALENCE_TYPE][String.valueOf(update.getIndex())];
        if (updateDependencies != null) {
            var dep;
            var gradient;
            for (var i = 0; i < updateDependencies.length; i++) {
                dep = updateDependencies[i];
                if (!update.hasVisited(dep.getChildIndex())) {
                    gradient = update.getChange() * dep.getWeight() * this.settings.getDiscount();
                    if (Math.abs(gradient) > this.priorityQueueThreshold) {
                        updateQueue.push(update.updateChild(dep.getChildIndex(), gradient));
                    }
                }
            }
        }
    };
    prototype.processBroadensNetworkDependencies = function(update, updateQueue) {
        var updateDependencies = this.competencyNetwork.getDependencies()[PapDependency.BROADENS_TYPE][String.valueOf(update.getIndex())];
        if (updateDependencies != null) {
            var dep;
            var gradient;
            for (var i = 0; i < updateDependencies.length; i++) {
                dep = updateDependencies[i];
                if (!update.hasVisited(dep.getChildIndex())) {
                    gradient = update.getChange() * this.settings.getDiscount() * dep.getWeight();
                    if (gradient > this.priorityQueueThreshold) {
                        updateQueue.push(update.updateChild(dep.getChildIndex(), gradient));
                    }
                }
            }
        }
    };
    prototype.predictCompetence = function() {
        this.competencyNetwork = new PapCompetencyNetwork(this.dependencies, this.inputGraph.getNodes().length, this.settings);
        var updateQueue;
        var currentUpdate;
        for (var iteration = 0; iteration < this.settings.getIterations(); iteration++) {
            updateQueue = new Array();
            this.addAssertionsToUpdateQueue(updateQueue);
             while (updateQueue.length > 0){
                currentUpdate = updateQueue.pop();
                this.competencyNetwork.update(currentUpdate.getIndex(), currentUpdate.getChange(), currentUpdate.getPositive());
                this.processNecessaryNetworkDependencies(currentUpdate, updateQueue);
                this.processSufficientNetworkDependencies(currentUpdate, updateQueue);
                this.processEquivalenceNetworkDependencies(currentUpdate, updateQueue);
                this.processBroadensNetworkDependencies(currentUpdate, updateQueue);
            }
        }
    };
    prototype.buildCompetencePrediction = function() {
        this.competencePrediction = new PapNetworkPrediction(this.predictionDate, this.subjectPem, this.inputGraph.getNodes(), this.competencyNetwork);
    };
    prototype.predictAll = function(inputGraph, subjectPem, predictionDate, dependencyDefs, settings) {
        this.processInputParameters(inputGraph, subjectPem, predictionDate, dependencyDefs, settings);
        this.initDataStructures();
        this.processEdges();
        this.processAssertions();
        this.predictCompetence();
        this.buildCompetencePrediction();
        return this.competencePrediction;
    };
}, {competencyIndex: {name: "Map", arguments: [null, null]}, values: {name: "Array", arguments: [null]}, dependencies: {name: "Map", arguments: [null, {name: "Map", arguments: [null, {name: "Array", arguments: ["PapDependency"]}]}]}, assertions: {name: "Map", arguments: [null, {name: "Array", arguments: ["PapAssertion"]}]}, dependencyDefs: "PapDependencyDefinitions", settings: "PapSettings", inputGraph: "CompetencyGraph", competencyNetwork: "PapCompetencyNetwork", competencePrediction: "PapNetworkPrediction"}, {});
var CyclicGraphCollapser = function() {};
CyclicGraphCollapser = stjs.extend(CyclicGraphCollapser, null, [], function(constructor, prototype) {
    prototype.nodesProcessed = null;
    prototype.visitedNodes = null;
    prototype.buildNarrowsIsRequiredByEqualsMap = function(graph) {
        var relationMap = new NodeRelationMap();
        var n;
        var nodeList = graph.getNodeList();
        for (var i = 0; i < nodeList.length; i++) {
            n = nodeList[i];
            relationMap.addNodeRelations(n, graph.getNarrowsIsRequiredByEqualsRelationListForNode(n));
        }
        return relationMap;
    };
    prototype.buildBroadensRequiresEqualsMap = function(graph) {
        var relationMap = new NodeRelationMap();
        var n;
        var nodeList = graph.getNodeList();
        for (var i = 0; i < nodeList.length; i++) {
            n = nodeList[i];
            relationMap.addNodeRelations(n, graph.getBroadensRequiresEqualsRelationListForNode(n));
        }
        return relationMap;
    };
    prototype.mergeEquivalentNodes = function(relationMap, npg) {
        var nodeList = relationMap.getNodeList();
        var nodeRelations;
        var nr;
        for (var i = 0; i < nodeList.length; i++) {
            nodeRelations = relationMap.getRelationsForNode(nodeList[i]);
            for (var j = 0; j < nodeRelations.length; j++) {
                nr = nodeRelations[j];
                if (nr.getType() == RelationType.RELATION_TYPE.IS_EQUIVALENT_TO) {
                    npg.mergeNodePackets(npg.getNodePacketForNode(nr.getSource()), npg.getNodePacketForNode(nr.getTarget()));
                }
            }
        }
    };
    prototype.mergeCyclicNodes = function(startCycleNode, npg) {
        var startingIdx = ArrayUtil.arrayLastIndexOf(this.visitedNodes, startCycleNode);
        var partOfCycleNode;
        for (var i = startingIdx + 1; i < this.visitedNodes.length; i++) {
            partOfCycleNode = this.visitedNodes[i];
            if (partOfCycleNode != startCycleNode) {
                npg.mergeNodePackets(npg.getNodePacketForNode(startCycleNode), npg.getNodePacketForNode(partOfCycleNode));
            }
        }
    };
    prototype.findCycles = function(n, relationMap, npg) {
        if (ArrayUtil.arrayContains(this.visitedNodes, n)) {
            this.mergeCyclicNodes(n, npg);
        } else {
            this.nodesProcessed.push(n);
            var relationsToVisit = relationMap.getRelationsForNode(n);
            if (relationsToVisit == null || relationsToVisit.length == 0) 
                return;
             else {
                this.visitedNodes.push(n);
                var nr;
                for (var i = 0; i < relationsToVisit.length; i++) {
                    nr = relationsToVisit[i];
                    this.findCycles(nr.getTarget(), relationMap, npg);
                }
                this.visitedNodes = ArrayUtil.arrayRemove(this.visitedNodes, n);
            }
        }
    };
    prototype.startFindCycles = function(relationMap, npg) {
        var nodeList = relationMap.getNodeList();
        for (var i = 0; i < nodeList.length; i++) {
            this.visitedNodes = new Array();
            this.findCycles(nodeList[i], relationMap, npg);
        }
    };
    prototype.buildNodePacketGraph = function(relationMap) {
        var npg = new NodePacketGraph();
        npg.initNodePacketGraph(relationMap.getNodeList());
        this.mergeEquivalentNodes(relationMap, npg);
        this.nodesProcessed = new Array();
        this.startFindCycles(relationMap, npg);
        return npg;
    };
    prototype.mergeNodePacketGraphs = function(nirbeNpg, breNpg) {
        var mergedNpg = nirbeNpg;
        var np;
        var nodePacketList = breNpg.getNodePacketList();
        for (var i = 0; i < nodePacketList.length; i++) {
            np = nodePacketList[i];
            if (np.getNodeCount() > 1) {
                var targetNodePacket = mergedNpg.getNodePacketForNode(np.getNodeList()[0]);
                for (var j = 1; j < np.getNodeList().length; j++) {
                    mergedNpg.mergeNodePackets(targetNodePacket, mergedNpg.getNodePacketForNode(np.getNodeList()[j]));
                }
            }
        }
        return mergedNpg;
    };
    prototype.collapseGraph = function(graph) {
        try {
            var nirbeNrm = this.buildNarrowsIsRequiredByEqualsMap(graph);
            var nirbeNpg = this.buildNodePacketGraph(nirbeNrm);
            var breNrm = this.buildBroadensRequiresEqualsMap(graph);
            var breNpg = this.buildNodePacketGraph(breNrm);
            var finalNodePacketGraph = this.mergeNodePacketGraphs(nirbeNpg, breNpg);
            finalNodePacketGraph.buildPacketRelationsFromNodeRelations(graph.getRelationList());
            return finalNodePacketGraph;
        }catch (e) {
             throw e;
        }
    };
}, {nodesProcessed: {name: "Array", arguments: ["Node"]}, visitedNodes: {name: "Array", arguments: ["Node"]}}, {});
/**
 *  Processor used in determining all the competencies a for which a user has assertions.
 *  Utilizes EcFrameworkGraph
 * 
 *  @author fritz.ray@eduworks.com
 *  @author tom.buskirk@eduworks.com
 *  @class ProfileProcessor
 *  @module org.cassproject
 */
var ProfileProcessor = function() {};
ProfileProcessor = stjs.extend(ProfileProcessor, null, [], function(constructor, prototype) {
    constructor.DEBUG = true;
    prototype.profilePkPems = null;
    prototype.repo = null;
    prototype.successCallback = null;
    prototype.failureCallback = null;
    prototype.frameworksToProcess = 0;
    prototype.frameworksProcessed = 0;
    prototype.assertedFrameworkGraphs = null;
    prototype.unfilteredAssertionList = null;
    prototype.profileAssertions = null;
    prototype.addedAssertionIds = null;
    prototype.assertionCompetencies = null;
    prototype.debugMessage = function(o) {
        if (ProfileProcessor.DEBUG) 
            console.log(o);
    };
    prototype.checkAllFrameworkGraphAssertionsHaveProcessed = function() {
        this.debugMessage("checkAllFrameworkGraphAssertionsHaveProcessed");
        this.debugMessage("frameworksProcessed: " + this.frameworksProcessed);
        if (this.frameworksProcessed >= this.frameworksToProcess) {
            this.debugMessage("All profile assertion framework graphs processed");
            this.successCallback();
        }
    };
    prototype.processFrameworkGraphAssertions = function(efg, framework) {
        this.debugMessage("(" + Date.now() + ") Processing framework graph assertions for:");
        this.debugMessage(framework.shortId());
        this.debugMessage(framework.getName());
        var me = this;
        efg.processAssertionsBoolean(this.profileAssertions, function() {
            me.frameworksProcessed++;
            me.assertedFrameworkGraphs.push(efg);
            me.checkAllFrameworkGraphAssertionsHaveProcessed();
        }, function(err) {
            me.handleFailedFrameworkGraphOperation("Process Graph: " + err);
        });
    };
    prototype.handleFailedFrameworkGraphOperation = function(err) {
        this.debugMessage("handleFailedFrameworkGraphOperation: " + err);
        this.frameworksProcessed++;
        this.checkAllFrameworkGraphAssertionsHaveProcessed();
    };
    prototype.buildProfileAssertionFrameworkGraph = function(framework) {
        this.debugMessage("(" + Date.now() + ") Generating framework graph for:");
        this.debugMessage(framework.shortId());
        this.debugMessage(framework.getName());
        var me = this;
        var efg = new EcFrameworkGraph();
        efg.addFramework(framework, this.repo, function() {
            me.processFrameworkGraphAssertions(efg, framework);
        }, function(err) {
            me.handleFailedFrameworkGraphOperation("Build Graph: " + err);
        });
    };
    prototype.generateProfileAssertionFrameworkGraphs = function(profileAssertionFrameworks) {
        if (profileAssertionFrameworks.length <= 0) 
            this.successCallback();
         else {
            this.frameworksToProcess = profileAssertionFrameworks.length;
            this.debugMessage("Generating framework graphs...");
            this.debugMessage(profileAssertionFrameworks);
            for (var i = 0; i < profileAssertionFrameworks.length; i++) {
                this.buildProfileAssertionFrameworkGraph(profileAssertionFrameworks[i]);
            }
        }
    };
    prototype.buildAssertionCompetencyList = function() {
        this.assertionCompetencies = new Array();
        for (var i = 0; i < this.profileAssertions.length; i++) {
            var asr = this.profileAssertions[i];
            if (!EcArray.has(this.assertionCompetencies, asr.competency)) {
                this.assertionCompetencies.push(asr.competency);
            }
        }
    };
    prototype.getFrameworkSearchQueryForAssertionCompetencies = function() {
        var searchQuery = "";
        if (this.assertionCompetencies.length > 1) 
            searchQuery = "(";
        for (var i = 0; i < this.assertionCompetencies.length; i++) {
            if (i > 0) 
                searchQuery += " OR ";
            searchQuery += "(competency:\"" + this.assertionCompetencies[i] + "\")";
        }
        if (this.assertionCompetencies.length > 1) 
            searchQuery += ")";
        this.debugMessage("Framework search query: " + searchQuery);
        return searchQuery;
    };
    prototype.findFrameworksForProfileAssertions = function() {
        this.unfilteredAssertionList = null;
        this.buildAssertionCompetencyList();
        this.debugMessage("Fetching Assertion Frameworks...");
        var me = this;
        EcFramework.search(this.repo, this.getFrameworkSearchQueryForAssertionCompetencies(), function(arrayOfEcFrameworks) {
            me.debugMessage("Assertion Frameworks Fetched");
            me.generateProfileAssertionFrameworkGraphs(arrayOfEcFrameworks);
        }, me.failureCallback, null);
    };
    prototype.filterAssertionList = function() {
        if (this.unfilteredAssertionList.length == 0) 
            this.successCallback();
         else {
            var me = this;
            var eah = new EcAsyncHelper();
            eah.each(this.unfilteredAssertionList, function(assertion, done) {
                assertion.getSubjectAsync(function(subject) {
                    if (subject != null) {
                        if (EcArray.has(me.profilePkPems, subject.toPem())) {
                            if (!EcArray.has(me.addedAssertionIds, assertion.shortId())) {
                                me.profileAssertions.push(assertion);
                                me.addedAssertionIds.push(assertion.shortId());
                            }
                        }
                    }
                    done();
                }, eah.failWithCallback(me.failureCallback, done));
            }, function(aa) {
                me.debugMessage("Assertions filtered");
                me.debugMessage(me.profileAssertions);
                me.findFrameworksForProfileAssertions();
            });
        }
    };
    prototype.isEnvelopeOwnedByProfileUser = function(asrEnv) {
        if (asrEnv.owner == null) 
            return false;
        for (var i = 0; i < asrEnv.owner.length; i++) {
            if (EcArray.has(this.profilePkPems, asrEnv.owner[i])) 
                return true;
        }
        return false;
    };
    prototype.isEncryptedAssertionEnvelope = function(asrEnv) {
        return true;
    };
    prototype.processPotentialAssertionEnvelope = function(potAsrEnv) {
        this.debugMessage("processPotentialAssertionEnvelope: " + potAsrEnv.shortId());
        if (this.isEncryptedAssertionEnvelope(potAsrEnv) && this.isEnvelopeOwnedByProfileUser(potAsrEnv)) {
            var nv = new EcEncryptedValue();
            nv.copyFrom(potAsrEnv);
            var aed = nv.decryptIntoObject();
            var realAsrEnv = new AssertionEnvelope();
            realAsrEnv.copyFrom(aed);
            for (var i = 0; i < realAsrEnv.assertion.length; i++) {
                var eca = new EcAssertion();
                eca.copyFrom(realAsrEnv.getAssertion(i));
                this.unfilteredAssertionList.push(eca);
            }
        }
    };
    prototype.processAssertionEnvelopes = function(ecRldArray) {
        this.debugMessage("Processing Assertion Envelopes...");
        if (ecRldArray != null && ecRldArray.length > 0) {
            for (var i = 0; i < ecRldArray.length; i++) {
                this.processPotentialAssertionEnvelope(ecRldArray[i]);
            }
        }
        this.filterAssertionList();
    };
    prototype.fetchAssertionEnvelopes = function() {
        this.debugMessage("Fetching Assertion Envelopes...");
        var me = this;
        this.repo.searchWithParams(new AssertionEnvelope().getSearchStringByType(), null, null, function(ecRldArray) {
            me.debugMessage("Assertion Envelopes Fetched");
            me.processAssertionEnvelopes(ecRldArray);
        }, me.failureCallback);
    };
    prototype.getAssertionSearchQueryForProfilePkPems = function() {
        var searchQuery = "";
        if (this.profilePkPems.length > 1) 
            searchQuery = "(";
        for (var i = 0; i < this.profilePkPems.length; i++) {
            if (i > 0) 
                searchQuery += " OR ";
            searchQuery += "(\\*reader:\"" + this.profilePkPems[i] + "\")";
        }
        if (this.profilePkPems.length > 1) 
            searchQuery += ")";
        this.debugMessage("Assertion search query: " + searchQuery);
        return searchQuery;
    };
    prototype.fetchProfileAssertions = function() {
        this.debugMessage("Fetching Assertions...");
        var me = this;
        EcAssertion.search(this.repo, this.getAssertionSearchQueryForProfilePkPems(), function(arrayOfEcAssertions) {
            me.debugMessage("Assertions Fetched");
            if (arrayOfEcAssertions != null && arrayOfEcAssertions.length > 0) {
                me.unfilteredAssertionList = arrayOfEcAssertions;
            }
            me.fetchAssertionEnvelopes();
        }, me.failureCallback, null);
    };
    prototype.processProfileAssertions = function(repo, profilePkPems, success, failure) {
        this.profilePkPems = profilePkPems;
        this.repo = repo;
        this.successCallback = success;
        this.failureCallback = failure;
        this.assertedFrameworkGraphs = new Array();
        this.profileAssertions = new Array();
        this.unfilteredAssertionList = new Array();
        this.addedAssertionIds = new Array();
        this.fetchProfileAssertions();
    };
}, {profilePkPems: {name: "Array", arguments: [null]}, repo: "EcRepository", successCallback: "Callback0", failureCallback: {name: "Callback1", arguments: [null]}, assertedFrameworkGraphs: {name: "Array", arguments: ["EcFrameworkGraph"]}, unfilteredAssertionList: {name: "Array", arguments: ["EcAssertion"]}, profileAssertions: {name: "Array", arguments: ["EcAssertion"]}, addedAssertionIds: {name: "Array", arguments: [null]}, assertionCompetencies: {name: "Array", arguments: [null]}}, {});
var CombinatorAssertionProcessor = function() {
    AssertionProcessor.call(this);
};
CombinatorAssertionProcessor = stjs.extend(CombinatorAssertionProcessor, AssertionProcessor, [], function(constructor, prototype) {
    constructor.relationLookup = null;
    prototype.processFoundAssertion = function(a, ip, success, failure) {
        var eah = new EcAsyncHelper();
        var me = this;
        eah.each(ip.subject, function(p1, p2) {
            me.checkSubject(a, p1, ip, p2, function(p1) {
                failure(p1);
            });
        }, function(p1) {
            success();
        });
    };
    prototype.checkSubject = function(a, currentSubject, ip, success, failure) {
        var me = this;
        a.getSubjectAsync(function(sub) {
            if (sub.equals(currentSubject)) {
                me.log(ip, "Matching Assertion found.");
                a.getAssertionDateAsync(function(assertionDate) {
                    if (assertionDate != null) 
                        if (assertionDate > stjs.trunc(new Date().getTime())) {
                            me.log(ip, "Assertion is made for a future date.");
                            success();
                            return;
                        }
                    a.getExpirationDateAsync(function(expirationDate) {
                        if (expirationDate != null) 
                            if (expirationDate <= stjs.trunc(new Date().getTime())) {
                                me.log(ip, "Assertion is expired. Skipping.");
                                success();
                                return;
                            }
                        me.logFoundAssertion(a, ip);
                        a.getNegativeAsync(function(p1) {
                            if (p1 != null && p1) {
                                me.log(ip, "Found valid negative assertion");
                                ip.negative.push(a);
                            } else {
                                me.log(ip, "Found valid positive assertion");
                                ip.positive.push(a);
                            }
                            success();
                        }, function(p1) {
                            me.log(ip, "Found valid positive assertion");
                            ip.positive.push(a);
                            success();
                        });
                    }, failure);
                }, failure);
            } else 
                failure("Incorrect subject.");
        }, failure);
    };
    prototype.processFindAssertionsSuccess = function(data, ip) {
        if (data.length == 0) 
            this.log(ip, "No results found.");
         else 
            this.log(ip, "Total number of assertions found: " + data.length);
        ip.numberOfQueriesRunning--;
        this.checkStepSecondPass(ip);
    };
    prototype.findSubjectAssertionsForCompetency = function(ip) {
        if (this.assertions == null) 
            return true;
        ip.hasCheckedAssertionsForCompetency = true;
        if (!InquiryPacket.IPType.COMPETENCY.equals(ip.type) && !InquiryPacket.IPType.ROLLUPRULE.equals(ip.type)) {
            this.log(ip, "No assertions for combinator types");
            return false;
        }
        var me = this;
        if (InquiryPacket.IPType.COMPETENCY.equals(ip.type)) {
            for (var h = 0; h < ip.competency.length; h++) {
                ip.numberOfQueriesRunning++;
                var competency = ip.competency[h];
                var assertionsForThisCompetency = (this.assertions)[competency.shortId()];
                if (assertionsForThisCompetency == null) 
                    assertionsForThisCompetency = new Array();
                var eah = new EcAsyncHelper();
                eah.each(assertionsForThisCompetency, function(p1, p2) {
                    me.processFoundAssertion(p1, ip, p2, function(p1) {
                        p2();
                    });
                }, function(p1) {
                    me.processFindAssertionsSuccess(p1, ip);
                });
            }
            return true;
        } else 
            for (var i = 0; i < this.repositories.length; i++) {
                var currentRepository = this.repositories[i];
                if (InquiryPacket.IPType.ROLLUPRULE.equals(ip.type)) {
                    ip.numberOfQueriesRunning++;
                    this.log(ip, "Searching: " + currentRepository.selectedServer);
                    currentRepository.search(this.buildAssertionSearchQuery(ip, null), function(p1) {}, function(p1) {
                        var eah = new EcAsyncHelper();
                        eah.each(p1, function(p1, p2) {
                            var a = new EcAssertion();
                            a.copyFrom(p1);
                            me.processFoundAssertion(a, ip, p2, function(p1) {
                                p2();
                            });
                        }, function(p1) {
                            me.processFindAssertionsSuccess(p1, ip);
                        });
                    }, function(p1) {
                        me.processEventFailure(p1, ip);
                    });
                }
            }
        return true;
    };
    prototype.findCompetencyRelationships = function(ip) {
        ip.hasCheckedRelationshipsForCompetency = true;
        if (!InquiryPacket.IPType.COMPETENCY.equals(ip.type)) {
            this.log(ip, "No relationships for combinator types");
            this.checkStep(ip);
            return;
        }
        var ep = this;
        var relationLookup = this.constructor.relationLookup;
        if (relationLookup == null) {
            relationLookup = new Object();
            if (ep.context != null && ep.context.relation != null) 
                for (var i = 0; i < ep.context.relation.length; i++) {
                    var a = EcAlignment.getBlocking(ep.context.relation[i]);
                    if (a == null) 
                        continue;
                    if ((relationLookup)[a.source] == null) 
                        (relationLookup)[a.source] = new Array();
                    ((relationLookup)[a.source]).push(a);
                    if ((relationLookup)[a.target] == null) 
                        (relationLookup)[a.target] = new Array();
                    ((relationLookup)[a.target]).push(a);
                }
            if (this.profileMode) 
                this.constructor.relationLookup = relationLookup;
        }
        for (var i = 0; i < ip.competency.length; i++) {
            this.log(ip, "Finding relationships for competency: " + ip.competency[i]);
            this.findCompetencyRelationship(ip, ep, ip.competency[i], relationLookup);
        }
    };
    prototype.findCompetencyRelationship = function(ip, ep, c, relationLookup) {
        var rpg = new RelationshipPacketGenerator(ip, ep, this.processedEquivalencies);
        rpg.failure = ip.failure;
        rpg.logFunction = this.logFunction;
        rpg.relationLookup = relationLookup;
        rpg.success = function() {
            ep.processRelationshipPacketsGenerated(ip, c);
        };
        this.log(ip, "Executing relationship packet generator");
        ip.numberOfQueriesRunning++;
        rpg.go();
    };
    prototype.processFindRollupRuleSuccess = function(rr, ip) {
        var ep = this;
        if (!ip.hasId(rr.competency)) {
            ep.processRollupRuleInterpretSkipped(ip);
            return;
        }
        this.log(ip, "Found rollup rule: " + rr.rule);
        var rrp = new RollupRuleProcessor(ip, this);
        rrp.positive = ip.positive;
        rrp.negative = ip.negative;
        var rri = new RollupRuleInterface(rr.rule, rrp);
        rri.logFunction = this.logFunction;
        rri.success = function(p1) {
            ep.processRollupRuleInterpretSuccess(p1, ip);
        };
        rri.failure = ip.failure;
        this.log(ip, "Executing rollup rule interpreter");
        rri.go();
    };
}, {relationLookup: "Object", repositories: {name: "Array", arguments: ["EcRepository"]}, logFunction: {name: "Callback1", arguments: ["Object"]}, assertions: "Object", coprocessors: {name: "Array", arguments: ["AssertionCoprocessor"]}, processedEquivalencies: {name: "Map", arguments: [null, null]}, context: "EcFramework"}, {});
var FrameworkCollapser = function() {};
FrameworkCollapser = stjs.extend(FrameworkCollapser, null, [], function(constructor, prototype) {
    prototype.repo = null;
    prototype.framework = null;
    prototype.createImpliedRelations = false;
    prototype.competencyArray = null;
    prototype.competencyNodeMap = null;
    prototype.relationArray = null;
    prototype.frameworkNodeGraph = null;
    prototype.collapsedFrameworkNodePacketGraph = null;
    prototype.successCallback = null;
    prototype.failureCallback = null;
    prototype.addCompetenciesToFrameworkNodeGraph = function() {
        var cmp;
        var n;
        this.competencyNodeMap = {};
        for (var i = 0; i < this.competencyArray.length; i++) {
            cmp = this.competencyArray[i];
            n = new Node(cmp.shortId());
            n.setName(cmp.getName());
            n.setDescription(cmp.getDescription());
            this.frameworkNodeGraph.addNode(n);
            this.competencyNodeMap[cmp.shortId()] = n;
        }
    };
    prototype.getRelationType = function(rs) {
        if ("requires".equalsIgnoreCase(rs)) 
            return RelationType.RELATION_TYPE.REQUIRES;
         else if ("narrows".equalsIgnoreCase(rs)) 
            return RelationType.RELATION_TYPE.NARROWS;
         else if ("isEquivalentTo".equalsIgnoreCase(rs)) 
            return RelationType.RELATION_TYPE.IS_EQUIVALENT_TO;
         else 
            return null;
    };
    prototype.addRelationshipsToFrameworkNodeGraph = function() {
        var rel;
        var type;
        var sourceNode = null;
        var targetNode = null;
        for (var i = 0; i < this.relationArray.length; i++) {
            rel = this.relationArray[i];
            type = this.getRelationType(rel.relationType);
            if (type == null) 
                continue;
            if (rel.source == null || rel.source == "" || rel.target == null || rel.target == "") 
                continue;
            sourceNode = this.competencyNodeMap[rel.source];
            targetNode = this.competencyNodeMap[rel.target];
            if (sourceNode == null || targetNode == null) 
                continue;
            this.frameworkNodeGraph.addRelation(sourceNode, targetNode, type);
        }
    };
    prototype.generateFrameworkNodeGraph = function() {
        this.frameworkNodeGraph = new NodeGraph();
        this.addCompetenciesToFrameworkNodeGraph();
        this.addRelationshipsToFrameworkNodeGraph();
        if (this.createImpliedRelations) 
            this.frameworkNodeGraph.createImpliedRelations();
    };
    prototype.collapseFrameworkNodeGraph = function() {
        var cgc = new CyclicGraphCollapser();
        this.collapsedFrameworkNodePacketGraph = cgc.collapseGraph(this.frameworkNodeGraph);
    };
    prototype.continueFrameworkCollapse = function() {
        try {
            this.generateFrameworkNodeGraph();
            try {
                this.collapseFrameworkNodeGraph();
                this.successCallback(this.framework.shortId(), this.collapsedFrameworkNodePacketGraph);
            }catch (e2) {
                this.failureCallback("Framework collapse failed: " + e2.toString());
            }
        }catch (e) {
            this.failureCallback("Framework node graph generation failed: " + e.toString());
        }
    };
    prototype.fetchFrameworkAlignments = function(framework) {
        var me = this;
        if (framework.relation != null) 
            this.repo.multiget(framework.relation, function(ecaa) {
                for (var i = 0; i < ecaa.length; i++) {
                    ecaa[i] = EcAlignment.getBlocking(ecaa[i].shortId());
                }
                me.relationArray = ecaa;
                me.continueFrameworkCollapse();
            }, me.failureCallback);
         else 
            me.continueFrameworkCollapse();
    };
    prototype.collapseFramework = function(repo, framework, createImpliedRelations, success, failure) {
        if (framework == null) 
            failure("Framework is null or undefined");
         else if (framework.competency == null || framework.competency.length < 1) 
            failure("Framework has no competencies");
         else if (repo == null) 
            failure("Repo is null or undefined");
         else {
            this.repo = repo;
            this.framework = framework;
            this.createImpliedRelations = createImpliedRelations;
            this.successCallback = success;
            this.failureCallback = failure;
            var me = this;
            var fwkParam = framework;
            if (framework.competency != null) 
                repo.multiget(framework.competency, function(ecca) {
                    for (var i = 0; i < ecca.length; i++) {
                        ecca[i] = EcCompetency.getBlocking(ecca[i].shortId());
                    }
                    me.competencyArray = ecca;
                    me.fetchFrameworkAlignments(fwkParam);
                }, me.failureCallback);
             else 
                me.fetchFrameworkAlignments(fwkParam);
        }
    };
}, {repo: "EcRepository", framework: "EcFramework", competencyArray: {name: "Array", arguments: ["EcCompetency"]}, competencyNodeMap: {name: "Map", arguments: [null, "Node"]}, relationArray: {name: "Array", arguments: ["EcAlignment"]}, frameworkNodeGraph: "NodeGraph", collapsedFrameworkNodePacketGraph: "NodePacketGraph", successCallback: {name: "Callback2", arguments: [null, "NodePacketGraph"]}, failureCallback: {name: "Callback1", arguments: [null]}}, {});
var OptimisticQuadnaryAssertionProcessor = function() {
    CombinatorAssertionProcessor.call(this);
};
OptimisticQuadnaryAssertionProcessor = stjs.extend(OptimisticQuadnaryAssertionProcessor, CombinatorAssertionProcessor, [], function(constructor, prototype) {
    prototype.transferIndeterminateOptimistically = true;
    prototype.determineCombinatorAndResult = function(ip) {
        if (ip.anyChildPacketsAreFalse()) {
            ip.result = InquiryPacket.ResultType.FALSE;
        } else if (ip.anyIndeterminantChildPackets()) {
            ip.result = InquiryPacket.ResultType.INDETERMINANT;
        } else if (ip.anyChildPacketsAreUnknown()) {
            ip.result = InquiryPacket.ResultType.UNKNOWN;
        } else {
            ip.result = InquiryPacket.ResultType.TRUE;
        }
    };
    prototype.determineCombinatorNarrowsResult = function(ip) {
        if (ip.anyChildPacketsAreTrue()) {
            ip.result = InquiryPacket.ResultType.TRUE;
        } else if (this.transferIndeterminateOptimistically && ip.anyIndeterminantChildPackets()) {
            ip.result = InquiryPacket.ResultType.FALSE;
        } else {
            ip.result = InquiryPacket.ResultType.UNKNOWN;
        }
    };
    prototype.determineCombinatorBroadensResult = function(ip) {
        if (ip.anyChildPacketsAreFalse()) {
            ip.result = InquiryPacket.ResultType.FALSE;
        } else if (this.transferIndeterminateOptimistically && ip.anyIndeterminantChildPackets()) {
            ip.result = InquiryPacket.ResultType.TRUE;
        } else if (!(ip.anyChildPacketsAreFalse() || ip.anyChildPacketsAreUnknown())) {
            ip.result = InquiryPacket.ResultType.TRUE;
        } else {
            ip.result = InquiryPacket.ResultType.UNKNOWN;
        }
    };
    prototype.determineCombinatorRequiresResult = function(ip) {
        if (ip.anyChildPacketsAreFalse()) {
            ip.result = InquiryPacket.ResultType.FALSE;
        } else if (this.transferIndeterminateOptimistically && ip.anyIndeterminantChildPackets()) {
            ip.result = InquiryPacket.ResultType.TRUE;
        } else {
            ip.result = InquiryPacket.ResultType.UNKNOWN;
        }
    };
    prototype.determineCombinatorIsRequiredByResult = function(ip) {
        if (ip.anyChildPacketsAreTrue()) {
            ip.result = InquiryPacket.ResultType.TRUE;
        } else if (this.transferIndeterminateOptimistically && ip.anyIndeterminantChildPackets()) {
            ip.result = InquiryPacket.ResultType.FALSE;
        } else {
            ip.result = InquiryPacket.ResultType.UNKNOWN;
        }
    };
    prototype.determineCombinatorOrResult = function(ip) {
        if (ip.anyChildPacketsAreTrue()) {
            ip.result = InquiryPacket.ResultType.TRUE;
        } else if (ip.anyIndeterminantChildPackets()) {
            ip.result = InquiryPacket.ResultType.INDETERMINANT;
        } else if (ip.allChildPacketsUnknown()) {
            ip.result = InquiryPacket.ResultType.UNKNOWN;
        } else {
            ip.result = InquiryPacket.ResultType.FALSE;
        }
    };
    prototype.getPacketAssertionResult = function(ip) {
        if (ip.positive.length > 0 && ip.negative.length == 0) {
            return InquiryPacket.ResultType.TRUE;
        } else if (ip.positive.length == 0 && ip.negative.length > 0) {
            return InquiryPacket.ResultType.FALSE;
        } else if (ip.positive.length > 0 && ip.negative.length > 0) {
            return InquiryPacket.ResultType.INDETERMINANT;
        } else {
            return InquiryPacket.ResultType.UNKNOWN;
        }
    };
    prototype.determineResultForUnknownAssertionResult = function(ip) {
        if (ip.allChildPacketsUnknown()) {
            ip.result = InquiryPacket.ResultType.UNKNOWN;
        } else if (ip.allEquivalentPacketsUnknown()) {
            if (ip.allSubPacketsTrueOrUnknown()) {
                ip.result = InquiryPacket.ResultType.TRUE;
            } else if (ip.allSubPacketsFalseOrUnknown()) {
                ip.result = InquiryPacket.ResultType.FALSE;
            } else {
                ip.result = InquiryPacket.ResultType.INDETERMINANT;
            }
        } else if (ip.allEquivalentPacketsTrueOrUnknown()) {
            if (ip.allSubPacketsTrueOrUnknown()) {
                ip.result = InquiryPacket.ResultType.TRUE;
            } else {
                ip.result = InquiryPacket.ResultType.INDETERMINANT;
            }
        } else if (ip.allEquivalentPacketsFalseOrUnknown()) {
            if (ip.allSubPacketsFalseOrUnknown()) {
                ip.result = InquiryPacket.ResultType.FALSE;
            } else {
                ip.result = InquiryPacket.ResultType.INDETERMINANT;
            }
        } else {
            ip.result = InquiryPacket.ResultType.INDETERMINANT;
        }
    };
    prototype.determineResultForTrueAssertionResult = function(ip) {
        if (ip.allEquivalentPacketsTrueOrUnknown()) {
            if (ip.allSubPacketsTrueOrUnknown()) {
                ip.result = InquiryPacket.ResultType.TRUE;
            } else {
                ip.result = InquiryPacket.ResultType.INDETERMINANT;
            }
        } else {
            ip.result = InquiryPacket.ResultType.INDETERMINANT;
        }
    };
    prototype.determineResultForFalseAssertionResult = function(ip) {
        if (ip.allEquivalentPacketsFalseOrUnknown()) {
            if (ip.allSubPacketsFalseOrUnknown()) {
                ip.result = InquiryPacket.ResultType.FALSE;
            } else {
                ip.result = InquiryPacket.ResultType.INDETERMINANT;
            }
        } else {
            ip.result = InquiryPacket.ResultType.INDETERMINANT;
        }
    };
    /**
     *  IF IP type is COMPETENCY|ROLLUPRULE: assertionResult = ( IF number of
     *  positive assertions > 0 && number of negative assertions = 0 THEN
     *  assertionResult = TRUE IF number of positive assertions = 0 && number of
     *  negative assertions > 0 THEN assertionResult = FALSE IF number of
     *  positive assertions > 0 && number of negative assertions > 0 THEN
     *  assertionResult = INDETERMINANT IF number of positive assertions = 0 &&
     *  number of negative assertions = 0 THEN assertionResult = UNKNOWN )
     *  <p>
     *  IF assertionResult = INDETERMINANT THEN INDETERMINANT ELSE IF any
     *  equivalent packets = INDETERMINANT THEN INDETERMINANT ELSE IF any sub
     *  packets = INDETERMINANT THEN INDETERMINANT
     *  <p>
     *  ELSE IF assertionResult = UNKNOWN: IF all equivalent packets = UNKNOWN IF
     *  all sub packets = UNKNOWN THEN UNKNOWN IF all sub packets = TRUE|UNKNOWN
     *  THEN TRUE IF all sub packets = FALSE|UNKNOWN THEN FALSE ELSE
     *  INDETERMINANT
     *  <p>
     *  ELSE IF all equivalent packets = TRUE|UNKNOWN IF all sub packets =
     *  TRUE|UNKNOWN THEN TRUE ELSE INDETERMINANT
     *  <p>
     *  ELSE IF all equivalent packets = FALSE|UNKNOWN IF all sub packets =
     *  FALSE|UNKNOWN THEN FALSE ELSE INDETERMINANT
     *  <p>
     *  ELSE INDETERMINANT
     *  <p>
     *  <p>
     *  ELSE IF assertionResult = TRUE: IF all equivalent packets = TRUE|UNKNOWN
     *  IF all sub packets = TRUE|UNKNOWN THEN TRUE ELSE INDETERMINANT
     *  <p>
     *  ELSE INDETERMINANT
     *  <p>
     *  ELSE IF assertionResult = FALSE: IF all equivalent packets =
     *  FALSE|UNKNOWN IF all sub packets = FALSE|UNKNOWN THEN FALSE ELSE
     *  INDETERMINANT
     *  <p>
     *  ELSE INDETERMINANT
     */
    prototype.determineCompetencyOrRollupRuleResult = function(ip) {
        var assertionResult = this.getPacketAssertionResult(ip);
        if (InquiryPacket.ResultType.INDETERMINANT.equals(assertionResult) || ip.anyIndeterminantChildPackets()) {
            ip.result = InquiryPacket.ResultType.INDETERMINANT;
        } else if (InquiryPacket.ResultType.UNKNOWN.equals(assertionResult)) {
            this.determineResultForUnknownAssertionResult(ip);
        } else if (InquiryPacket.ResultType.TRUE.equals(assertionResult)) {
            this.determineResultForTrueAssertionResult(ip);
        } else {
            this.determineResultForFalseAssertionResult(ip);
        }
    };
    prototype.determineResult = function(ip) {
        if (ip.numberOfQueriesRunning == 0) {
            if (InquiryPacket.IPType.RELATION_AND.equals(ip.type)) {
                this.determineCombinatorAndResult(ip);
            } else if (InquiryPacket.IPType.RELATION_OR.equals(ip.type)) {
                this.determineCombinatorOrResult(ip);
            } else if (InquiryPacket.IPType.RELATION_NARROWS.equals(ip.type)) {
                this.determineCombinatorNarrowsResult(ip);
            } else if (InquiryPacket.IPType.RELATION_BROADENS.equals(ip.type)) {
                this.determineCombinatorBroadensResult(ip);
            } else if (InquiryPacket.IPType.RELATION_REQUIRES.equals(ip.type)) {
                this.determineCombinatorRequiresResult(ip);
            } else if (InquiryPacket.IPType.RELATION_ISREQUIREDBY.equals(ip.type)) {
                this.determineCombinatorIsRequiredByResult(ip);
            } else {
                this.determineCompetencyOrRollupRuleResult(ip);
            }
        } else {
            this.log(ip, "We are not finished accumulating data to answer this query. Error: " + ip.numberOfQueriesRunning);
        }
    };
}, {relationLookup: "Object", repositories: {name: "Array", arguments: ["EcRepository"]}, logFunction: {name: "Callback1", arguments: ["Object"]}, assertions: "Object", coprocessors: {name: "Array", arguments: ["AssertionCoprocessor"]}, processedEquivalencies: {name: "Map", arguments: [null, null]}, context: "EcFramework"}, {});
var PessimisticQuadnaryAssertionProcessor = function() {
    CombinatorAssertionProcessor.call(this);
};
PessimisticQuadnaryAssertionProcessor = stjs.extend(PessimisticQuadnaryAssertionProcessor, CombinatorAssertionProcessor, [], function(constructor, prototype) {
    prototype.transferIndeterminateOptimistically = true;
    prototype.determineCombinatorAndResult = function(ip) {
        if (ip.anyChildPacketsAreFalse()) 
            ip.result = InquiryPacket.ResultType.FALSE;
         else if (ip.anyIndeterminantChildPackets()) 
            ip.result = InquiryPacket.ResultType.INDETERMINANT;
         else if (ip.anyChildPacketsAreUnknown()) 
            ip.result = InquiryPacket.ResultType.UNKNOWN;
         else 
            ip.result = InquiryPacket.ResultType.TRUE;
    };
    prototype.determineCombinatorNarrowsResult = function(ip) {
        if (ip.anyChildPacketsAreTrue()) 
            ip.result = InquiryPacket.ResultType.TRUE;
         else if (this.transferIndeterminateOptimistically && ip.anyIndeterminantChildPackets()) 
            ip.result = InquiryPacket.ResultType.TRUE;
         else 
            ip.result = InquiryPacket.ResultType.UNKNOWN;
    };
    prototype.determineCombinatorBroadensResult = function(ip) {
        if (ip.anyChildPacketsAreFalse()) 
            ip.result = InquiryPacket.ResultType.FALSE;
         else if (ip.anyIndeterminantChildPackets()) 
            ip.result = InquiryPacket.ResultType.FALSE;
         else 
            ip.result = InquiryPacket.ResultType.UNKNOWN;
    };
    prototype.determineCombinatorRequiresResult = function(ip) {
        if (ip.anyChildPacketsAreFalse()) 
            ip.result = InquiryPacket.ResultType.FALSE;
         else if (ip.anyIndeterminantChildPackets()) 
            ip.result = InquiryPacket.ResultType.FALSE;
         else 
            ip.result = InquiryPacket.ResultType.UNKNOWN;
    };
    prototype.determineCombinatorIsRequiredByResult = function(ip) {
        if (ip.anyChildPacketsAreTrue()) 
            ip.result = InquiryPacket.ResultType.TRUE;
         else if (this.transferIndeterminateOptimistically && ip.anyIndeterminantChildPackets()) 
            ip.result = InquiryPacket.ResultType.TRUE;
         else 
            ip.result = InquiryPacket.ResultType.UNKNOWN;
    };
    prototype.determineCombinatorOrResult = function(ip) {
        if (ip.anyChildPacketsAreTrue()) 
            ip.result = InquiryPacket.ResultType.TRUE;
         else if (ip.anyIndeterminantChildPackets()) 
            ip.result = InquiryPacket.ResultType.INDETERMINANT;
         else if (ip.allChildPacketsUnknown()) 
            ip.result = InquiryPacket.ResultType.UNKNOWN;
         else 
            ip.result = InquiryPacket.ResultType.FALSE;
    };
    prototype.getPacketAssertionResult = function(ip) {
        if (ip.positive.length > 0 && ip.negative.length == 0) 
            return InquiryPacket.ResultType.TRUE;
         else if (ip.positive.length == 0 && ip.negative.length > 0) 
            return InquiryPacket.ResultType.FALSE;
         else if (ip.positive.length > 0 && ip.negative.length > 0) 
            return InquiryPacket.ResultType.INDETERMINANT;
         else 
            return InquiryPacket.ResultType.UNKNOWN;
    };
    prototype.determineResultForUnknownAssertionResult = function(ip) {
        if (ip.allChildPacketsUnknown()) 
            ip.result = InquiryPacket.ResultType.UNKNOWN;
         else if (ip.allEquivalentPacketsUnknown()) {
            if (ip.allSubPacketsTrueOrUnknown()) 
                ip.result = InquiryPacket.ResultType.TRUE;
             else if (ip.allSubPacketsFalseOrUnknown()) 
                ip.result = InquiryPacket.ResultType.FALSE;
             else 
                ip.result = InquiryPacket.ResultType.INDETERMINANT;
        } else if (ip.allEquivalentPacketsTrueOrUnknown()) {
            if (ip.allSubPacketsTrueOrUnknown()) 
                ip.result = InquiryPacket.ResultType.TRUE;
             else 
                ip.result = InquiryPacket.ResultType.INDETERMINANT;
        } else if (ip.allEquivalentPacketsFalseOrUnknown()) {
            if (ip.allSubPacketsFalseOrUnknown()) 
                ip.result = InquiryPacket.ResultType.FALSE;
             else 
                ip.result = InquiryPacket.ResultType.INDETERMINANT;
        } else 
            ip.result = InquiryPacket.ResultType.INDETERMINANT;
    };
    prototype.determineResultForTrueAssertionResult = function(ip) {
        if (ip.allEquivalentPacketsTrueOrUnknown()) {
            if (ip.allSubPacketsTrueOrUnknown()) 
                ip.result = InquiryPacket.ResultType.TRUE;
             else 
                ip.result = InquiryPacket.ResultType.INDETERMINANT;
        } else 
            ip.result = InquiryPacket.ResultType.INDETERMINANT;
    };
    prototype.determineResultForFalseAssertionResult = function(ip) {
        if (ip.allEquivalentPacketsFalseOrUnknown()) {
            if (ip.allSubPacketsFalseOrUnknown()) 
                ip.result = InquiryPacket.ResultType.FALSE;
             else 
                ip.result = InquiryPacket.ResultType.INDETERMINANT;
        } else 
            ip.result = InquiryPacket.ResultType.INDETERMINANT;
    };
    /**
     *  IF IP type is COMPETENCY|ROLLUPRULE: assertionResult = ( IF number of
     *  positive assertions > 0 && number of negative assertions = 0 THEN
     *  assertionResult = TRUE IF number of positive assertions = 0 && number of
     *  negative assertions > 0 THEN assertionResult = FALSE IF number of
     *  positive assertions > 0 && number of negative assertions > 0 THEN
     *  assertionResult = INDETERMINANT IF number of positive assertions = 0 &&
     *  number of negative assertions = 0 THEN assertionResult = UNKNOWN )
     *  <p>
     *  IF assertionResult = INDETERMINANT THEN INDETERMINANT ELSE IF any
     *  equivalent packets = INDETERMINANT THEN INDETERMINANT ELSE IF any sub
     *  packets = INDETERMINANT THEN INDETERMINANT
     *  <p>
     *  ELSE IF assertionResult = UNKNOWN: IF all equivalent packets = UNKNOWN IF
     *  all sub packets = UNKNOWN THEN UNKNOWN IF all sub packets = TRUE|UNKNOWN
     *  THEN TRUE IF all sub packets = FALSE|UNKNOWN THEN FALSE ELSE
     *  INDETERMINANT
     *  <p>
     *  ELSE IF all equivalent packets = TRUE|UNKNOWN IF all sub packets =
     *  TRUE|UNKNOWN THEN TRUE ELSE INDETERMINANT
     *  <p>
     *  ELSE IF all equivalent packets = FALSE|UNKNOWN IF all sub packets =
     *  FALSE|UNKNOWN THEN FALSE ELSE INDETERMINANT
     *  <p>
     *  ELSE INDETERMINANT
     *  <p>
     *  <p>
     *  ELSE IF assertionResult = TRUE: IF all equivalent packets = TRUE|UNKNOWN
     *  IF all sub packets = TRUE|UNKNOWN THEN TRUE ELSE INDETERMINANT
     *  <p>
     *  ELSE INDETERMINANT
     *  <p>
     *  ELSE IF assertionResult = FALSE: IF all equivalent packets =
     *  FALSE|UNKNOWN IF all sub packets = FALSE|UNKNOWN THEN FALSE ELSE
     *  INDETERMINANT
     *  <p>
     *  ELSE INDETERMINANT
     */
    prototype.determineCompetencyOrRollupRuleResult = function(ip) {
        var assertionResult = this.getPacketAssertionResult(ip);
        if (InquiryPacket.ResultType.INDETERMINANT.equals(assertionResult) || ip.anyIndeterminantChildPackets()) 
            ip.result = InquiryPacket.ResultType.INDETERMINANT;
         else if (InquiryPacket.ResultType.UNKNOWN.equals(assertionResult)) 
            this.determineResultForUnknownAssertionResult(ip);
         else if (InquiryPacket.ResultType.TRUE.equals(assertionResult)) 
            this.determineResultForTrueAssertionResult(ip);
         else 
            this.determineResultForFalseAssertionResult(ip);
    };
    prototype.determineResult = function(ip) {
        if (ip.numberOfQueriesRunning == 0) {
            if (InquiryPacket.IPType.RELATION_AND.equals(ip.type)) 
                this.determineCombinatorAndResult(ip);
             else if (InquiryPacket.IPType.RELATION_OR.equals(ip.type)) 
                this.determineCombinatorOrResult(ip);
             else if (InquiryPacket.IPType.RELATION_NARROWS.equals(ip.type)) 
                this.determineCombinatorNarrowsResult(ip);
             else if (InquiryPacket.IPType.RELATION_BROADENS.equals(ip.type)) 
                this.determineCombinatorBroadensResult(ip);
             else if (InquiryPacket.IPType.RELATION_REQUIRES.equals(ip.type)) 
                this.determineCombinatorRequiresResult(ip);
             else if (InquiryPacket.IPType.RELATION_ISREQUIREDBY.equals(ip.type)) 
                this.determineCombinatorIsRequiredByResult(ip);
             else 
                this.determineCompetencyOrRollupRuleResult(ip);
        } else {
            this.log(ip, "We are not finished accumulating data to answer this query. Error: " + ip.numberOfQueriesRunning);
        }
    };
}, {relationLookup: "Object", repositories: {name: "Array", arguments: ["EcRepository"]}, logFunction: {name: "Callback1", arguments: ["Object"]}, assertions: "Object", coprocessors: {name: "Array", arguments: ["AssertionCoprocessor"]}, processedEquivalencies: {name: "Map", arguments: [null, null]}, context: "EcFramework"}, {});

/**
 *  Base class for all importers, can hold helper functions
 *  that are useful for all importers
 * 
 *  @author devlin.junker@eduworks.com
 *  @module org.cassproject
 *  @class Importer
 *  @abstract
 */
var Importer = function() {};
Importer = stjs.extend(Importer, null, [], function(constructor, prototype) {
    constructor.isObject = function(obj) {
        return Object.prototype.toString.call(obj) == "[object Object]";
    };
    constructor.isArray = function(obj) {
        return Object.prototype.toString.call(obj) == "[object Array]";
    };
}, {}, {});
/**
 *  Base class for all exporters, can hold helper functions
 *  that are useful for all exporters
 * 
 *  @author devlin.junker@eduworks.com
 *  @module org.cassproject
 *  @class Exporter
 *  @abstract
 */
var Exporter = function() {};
Exporter = stjs.extend(Exporter, null, [], null, {}, {});
var PapaParseParams = function() {};
PapaParseParams = stjs.extend(PapaParseParams, null, [], function(constructor, prototype) {
    prototype.complete = null;
    prototype.header = null;
    prototype.error = null;
    prototype.encoding = null;
}, {complete: {name: "Callback1", arguments: ["Object"]}, error: {name: "Callback1", arguments: ["Object"]}}, {});
/**
 *  Import methods to handle an ASN JSON file containing a framework,
 *  competencies and relationships, and store them in a CASS instance
 * 
 *  @author devlin.junker@eduworks.com
 *  @author fritz.ray@eduworks.com
 *  @module org.cassproject
 *  @class ASNImport
 *  @static
 *  @extends Importer
 */
var ASNImport = function() {
    Importer.call(this);
};
ASNImport = stjs.extend(ASNImport, Importer, [], function(constructor, prototype) {
    constructor.INCREMENTAL_STEP = 5;
    constructor.jsonFramework = null;
    constructor.frameworkUrl = null;
    constructor.jsonCompetencies = null;
    constructor.competencyCount = 0;
    constructor.relationCount = 0;
    constructor.importedFramework = null;
    constructor.competencies = null;
    constructor.progressObject = null;
    constructor.savedCompetencies = 0;
    constructor.savedRelations = 0;
    /**
     *  Recursive function that looks through the file and saves each
     *  competency object in a map for use during importing. It also counts
     *  the number of competencies and relationships that it finds
     * 
     *  @param {Object} obj
     *                  The current JSON object we're examining for comepetencies and reationships
     *  @param {String} key
     *                  The ASN identifier of the current object
     *  @memberOf ASNImport
     *  @method asnJsonPrime
     *  @private
     *  @static
     */
    constructor.asnJsonPrime = function(obj, key) {
        var value = (obj)[key];
        if (Importer.isObject(value)) {
            if ((value)["http://www.w3.org/1999/02/22-rdf-syntax-ns#type"] != null) {
                var stringVal = (((value)["http://www.w3.org/1999/02/22-rdf-syntax-ns#type"])["0"])["value"];
                if (stringVal == "http://purl.org/ASN/schema/core/Statement") {
                    ASNImport.jsonCompetencies[key] = value;
                    ASNImport.competencyCount++;
                    var children = (value)["http://purl.org/gem/qualifiers/hasChild"];
                    if (children != null) 
                        for (var j = 0; j < children.length; j++) {
                            ASNImport.relationCount++;
                            ASNImport.asnJsonPrime(obj, (children[j])["value"]);
                        }
                }
            }
        }
    };
    /**
     *  Does the actual legwork of looking for competencies and relationships.
     *  <p>
     *  This function finds the framework information, and pulls out the competency
     *  objects array to be scanned by asnJsonPrime
     * 
     *  @param {Object} obj
     *                  ASN JSON Object from file that contains framework information and competencies/relationships
     *  @memberOf ASNImport
     *  @method lookThroughSource
     *  @private
     *  @static
     */
    constructor.lookThroughSource = function(obj) {
        ASNImport.competencyCount = 0;
        ASNImport.relationCount = 0;
        for (var key in (obj)) {
            var value = (obj)[key];
            if (Importer.isObject(value)) {
                if ((value)["http://www.w3.org/1999/02/22-rdf-syntax-ns#type"] != null) {
                    var stringVal = (((value)["http://www.w3.org/1999/02/22-rdf-syntax-ns#type"])["0"])["value"];
                    if (stringVal == "http://purl.org/ASN/schema/core/StandardDocument") {
                        ASNImport.jsonFramework = value;
                        ASNImport.frameworkUrl = key;
                        var children = (value)["http://purl.org/gem/qualifiers/hasChild"];
                        if (children != null) 
                            for (var j = 0; j < children.length; j++) {
                                ASNImport.asnJsonPrime(obj, (children[j])["value"]);
                            }
                    }
                }
            }
        }
    };
    /**
     *  Analyzes an ASN File for competencies and relationships.
     *  <p>
     *  This should be called before import, the success callback returns an object
     *  indicating the number of competencies and relationships found.
     * 
     *  @param {Object}            file
     *                             ASN JSON file
     *  @param {Callback1<Object>} success
     *                             Callback triggered on successful analysis of file
     *  @param {Callback1<Object>} [failure]
     *                             Callback triggered if there is an error during analysis of the file
     *  @memberOf ASNImport
     *  @method analyzeFile
     *  @static
     */
    constructor.analyzeFile = function(file, success, failure) {
        if (file == null) {
            failure("No file to analyze");
            return;
        }
        if ((file)["name"] == null) {
            failure("Invalid file");
            return;
        } else if (!((file)["name"]).endsWith(".json")) {
            failure("Invalid file type");
            return;
        }
        var reader = new FileReader();
        reader.onload = function(e) {
            var result = ((e)["target"])["result"];
            var jsonObj = JSON.parse(result);
            ASNImport.jsonCompetencies = {};
            ASNImport.jsonFramework = null;
            ASNImport.frameworkUrl = "";
            ASNImport.lookThroughSource(jsonObj);
            if (ASNImport.jsonFramework == null) {
                failure("Could not find StandardDocument.");
            } else {
                success(ASNImport.jsonCompetencies);
            }
        };
        reader.readAsText(file, "UTF-8");
    };
    /**
     *  Method to import the competencies from an ASN JSON file,
     *  should be called after analyzing the file
     * 
     *  @param {String}                        serverUrl
     *                                         URL Prefix for the competencies to be imported
     *  @param {EcIdentity}                    owner
     *                                         EcIdentity that will own the new competencies
     *  @param {boolean}                       createFramework
     *                                         Flag to create a framework and include the competencies and relationships created
     *  @param {Callback2<Array<EcCompetency>, EcFramework>} success
     *                                         Callback triggered after the competencies (and framework?) are created
     *  @param {Callback1<Object>}             failure
     *                                         Callback triggered if an error occurs while creating the competencies
     *  @param {Callback1<Object>}             [incremental]
     *                                         Callback triggered incrementally during the creation of competencies to indicate progress,
     *                                         returns an object indicating the number of competencies (and relationships?) created so far
     *  @memberOf ASNImport
     *  @method importCompetencies
     *  @static
     */
    constructor.importCompetencies = function(serverUrl, owner, createFramework, success, failure, incremental, repo) {
        ASNImport.competencies = {};
        if (createFramework) {
            ASNImport.importedFramework = new EcFramework();
            ASNImport.importedFramework.competency = [];
            ASNImport.importedFramework.relation = [];
        } else {
            ASNImport.importedFramework = null;
        }
        ASNImport.progressObject = null;
        ASNImport.createCompetencies(serverUrl, owner, function() {
            ASNImport.createRelationships(serverUrl, owner, ASNImport.jsonFramework, null, function() {
                if (createFramework) {
                    ASNImport.createFramework(serverUrl, owner, success, failure, repo);
                } else {
                    var compList = [];
                    for (var key in ASNImport.competencies) {
                        compList.push(ASNImport.competencies[key]);
                    }
                    if (success != null) 
                        success(compList, null);
                }
            }, failure, incremental, repo);
        }, failure, incremental, repo);
    };
    /**
     *  Handles creating the competencies found during analysis, iterates through the
     *  competency ASN objects saved and creates them in the CASS repository at the URL given.
     * 
     *  @param {String}            serverUrl
     *                             URL Prefix for the competencies to be imported
     *  @param {EcIdentity}        owner
     *                             EcIdentity that will own the new competencies
     *  @param {Callback0}         success
     *                             Callback triggered after the competencies are created
     *  @param {Callback1<Object>} failure
     *                             Callback triggered if an error occurs while creating the competencies
     *  @param {Callback1<Object>} [incremental]
     *                             Callback triggered incrementally during the creation of competencies to indicate progress
     *  @memberOf ASNImport
     *  @method createCompetencies
     *  @private
     *  @static
     */
    constructor.createCompetencies = function(serverUrl, owner, success, failure, incremental, repo) {
        ASNImport.savedCompetencies = 0;
        for (var key in ASNImport.jsonCompetencies) {
            var comp = new EcCompetency();
            var jsonComp = ASNImport.jsonCompetencies[key];
            if ((jsonComp)["http://purl.org/dc/elements/1.1/title"] == null) 
                comp.name = (((jsonComp)["http://purl.org/dc/terms/description"])["0"])["value"];
             else 
                comp.name = (((jsonComp)["http://purl.org/dc/elements/1.1/title"])["0"])["value"];
            if ((jsonComp)["http://purl.org/dc/terms/description"] != null) 
                comp.description = (((jsonComp)["http://purl.org/dc/terms/description"])["0"])["value"];
            comp.id = key;
            if (comp.id == null) {
                if (repo == null || repo.selectedServer.indexOf(serverUrl) != -1) 
                    comp.generateId(serverUrl);
                 else 
                    comp.generateShortId(serverUrl);
            }
            if (owner != null) 
                comp.addOwner(owner.ppk.toPk());
            if (ASNImport.importedFramework != null) 
                ASNImport.importedFramework.addCompetency(comp.shortId());
            ASNImport.competencies[key] = comp;
            ASNImport.saveCompetency(success, failure, incremental, comp, repo);
        }
    };
    constructor.saveCompetency = function(success, failure, incremental, comp, repo) {
        Task.asyncImmediate(function(o) {
            var keepGoing = o;
            comp.save(function(p1) {
                ASNImport.savedCompetencies++;
                if (ASNImport.savedCompetencies % ASNImport.INCREMENTAL_STEP == 0) {
                    if (ASNImport.progressObject == null) 
                        ASNImport.progressObject = new Object();
                    (ASNImport.progressObject)["competencies"] = ASNImport.savedCompetencies;
                    incremental(ASNImport.progressObject);
                }
                if (ASNImport.savedCompetencies == ASNImport.competencyCount) {
                    if (ASNImport.progressObject == null) 
                        ASNImport.progressObject = new Object();
                    (ASNImport.progressObject)["competencies"] = ASNImport.savedCompetencies;
                    incremental(ASNImport.progressObject);
                    success();
                }
                keepGoing();
            }, function(p1) {
                failure("Failed to save competency");
                keepGoing();
            }, repo);
        });
    };
    /**
     *  Handles creating the relationships from the file analyzed earlier.
     *  Recursively travels through looking for the hasChild field and creates
     *  relationships based off of that.
     * 
     *  @param {String}            serverUrl
     *                             URL Prefix for the relationships to be imported
     *  @param {EcIdentity}        owner
     *                             EcIdentity that will own the new relationships
     *  @param {Object}            node
     *  @param {String}            nodeId
     *  @param {Callback0}         success
     *                             Callback triggered after the relationships are created
     *  @param {Callback1<Object>} failure
     *                             Callback triggered if an error occurs while creating the relationships
     *  @param {Callback1<Object>} incremental
     *                             Callback triggered incrementally during the creation of relationships to indicate progress
     *  @memberOf ASNImport
     *  @method createRelationships
     *  @private
     *  @static
     */
    constructor.createRelationships = function(serverUrl, owner, node, nodeId, success, failure, incremental, repo) {
        ASNImport.savedRelations = 0;
        if (ASNImport.relationCount == 0) {
            success();
        }
        var children = (node)["http://purl.org/gem/qualifiers/hasChild"];
        if (children != null) 
            for (var j = 0; j < children.length; j++) {
                if (nodeId != null) {
                    var relation = new EcAlignment();
                    relation.target = ASNImport.competencies[nodeId].id;
                    relation.source = ASNImport.competencies[(children[j])["value"]].id;
                    relation.relationType = "narrows";
                    relation.name = "";
                    relation.description = "";
                    if (repo == null || repo.selectedServer.indexOf(serverUrl) != -1) 
                        relation.generateId(serverUrl);
                     else 
                        relation.generateShortId(serverUrl);
                    if (owner != null) 
                        relation.addOwner(owner.ppk.toPk());
                    if (ASNImport.importedFramework != null) 
                        ASNImport.importedFramework.addRelation(relation.shortId());
                    ASNImport.saveRelation(success, failure, incremental, relation, repo);
                }
                ASNImport.createRelationships(serverUrl, owner, ASNImport.jsonCompetencies[(children[j])["value"]], (children[j])["value"], success, failure, incremental, repo);
            }
    };
    constructor.saveRelation = function(success, failure, incremental, relation, repo) {
        Task.asyncImmediate(function(o) {
            var keepGoing = o;
            relation.save(function(p1) {
                ASNImport.savedRelations++;
                if (ASNImport.savedRelations % ASNImport.INCREMENTAL_STEP == 0) {
                    if (ASNImport.progressObject == null) 
                        ASNImport.progressObject = new Object();
                    (ASNImport.progressObject)["relations"] = ASNImport.savedRelations;
                    incremental(ASNImport.progressObject);
                }
                if (ASNImport.savedRelations == ASNImport.relationCount) {
                    success();
                }
                keepGoing();
            }, function(p1) {
                failure("Failed to save Relationship");
                keepGoing();
            }, repo);
        });
    };
    /**
     *  Handles creating the framework if the createFramework flag was set
     * 
     *  @param {String}                        serverUrl
     *                                         URL Prefix for the framework to be imported
     *  @param {EcIdentity}                    owner
     *                                         EcIdentity that will own the new framework
     *  @param {Callback2<Array<EcCompetency>, EcFramework>} success
     *                                         Callback triggered after the framework is created
     *  @param {Callback1<Object>}             failure
     *                                         Callback triggered if there is an error during the creation of framework
     *  @meberOf ASNImport
     *  @method createFramework
     *  @private
     *  @static
     */
    constructor.createFramework = function(serverUrl, owner, success, failure, repo) {
        ASNImport.importedFramework.name = (((ASNImport.jsonFramework)["http://purl.org/dc/elements/1.1/title"])["0"])["value"];
        ASNImport.importedFramework.description = (((ASNImport.jsonFramework)["http://purl.org/dc/terms/description"])["0"])["value"];
        ASNImport.importedFramework.id = ASNImport.frameworkUrl;
        if (ASNImport.importedFramework.id == null) {
            if (repo == null || repo.selectedServer.indexOf(serverUrl) != -1) 
                ASNImport.importedFramework.generateId(serverUrl);
             else 
                ASNImport.importedFramework.generateShortId(serverUrl);
        }
        if (owner != null) 
            ASNImport.importedFramework.addOwner(owner.ppk.toPk());
        ASNImport.importedFramework.save(function(p1) {
            var compList = [];
            for (var key in ASNImport.competencies) {
                compList.push(ASNImport.competencies[key]);
            }
            if (success != null) 
                success(compList, ASNImport.importedFramework);
        }, function(p1) {
            failure("Failed to save framework");
        }, repo);
    };
}, {jsonFramework: "Object", jsonCompetencies: {name: "Map", arguments: [null, "Object"]}, importedFramework: "EcFramework", competencies: {name: "Map", arguments: [null, "EcCompetency"]}, progressObject: "Object"}, {});
/**
 *  Importer methods to create competencies based on a
 *  Medbiquitous competency XML file
 * 
 *  @author devlin.junker@eduworks.com
 *  @author fritz.ray@eduworks.com
 *  @module org.cassproject
 *  @class MedbiqImport
 *  @static
 *  @extends Importer
 */
var MedbiqImport = function() {
    Importer.call(this);
};
MedbiqImport = stjs.extend(MedbiqImport, Importer, [], function(constructor, prototype) {
    constructor.INCREMENTAL_STEP = 5;
    constructor.medbiqXmlCompetencies = null;
    constructor.progressObject = null;
    constructor.saved = 0;
    /**
     *  Does the legwork of looking for competencies in the XML
     * 
     *  @param {Object} obj
     *                  Parsed XML Object
     *  @memberOf MedbiqImport
     *  @method medbiqXmlLookForCompetencyObject
     *  @private
     *  @static
     */
    constructor.medbiqXmlLookForCompetencyObject = function(obj) {
        if (Importer.isObject(obj) || Importer.isArray(obj)) 
            for (var key in (obj)) {
                if (key == "CompetencyObject") 
                    MedbiqImport.medbiqXmlParseCompetencyObject((obj)[key]);
                 else 
                    MedbiqImport.medbiqXmlLookForCompetencyObject((obj)[key]);
            }
    };
    /**
     *  Does the legwork of parsing the competencies out of the parsed XML
     * 
     *  @param {Object} obj
     *                  Parsed XML Object
     *  @memberOf MedbiqImport
     *  @method medbiqXmlParseCompetencyObject
     *  @private
     *  @static
     */
    constructor.medbiqXmlParseCompetencyObject = function(obj) {
        if (Importer.isArray(obj)) {
            for (var key in (obj)) {
                MedbiqImport.medbiqXmlParseCompetencyObject((obj)[key]);
            }
        } else {
            var newCompetency = new EcCompetency();
            if ((obj)["lom"] != null && ((obj)["lom"])["general"] != null) {
                newCompetency.name = ((((obj)["lom"])["general"])["title"])["string"].toString();
                if ((((obj)["lom"])["general"])["description"] != null) 
                    newCompetency.description = ((((obj)["lom"])["general"])["description"])["string"].toString();
                if ((((obj)["lom"])["general"])["identifier"] != null) 
                    newCompetency.url = ((((obj)["lom"])["general"])["identifier"])["entry"].toString();
                if (newCompetency.description == null) 
                    newCompetency.description = "";
                MedbiqImport.medbiqXmlCompetencies.push(newCompetency);
            }
        }
    };
    /**
     *  Analyzes a Medbiquitous XML file for competencies and saves them for use in the import process
     * 
     *  @param {Object}                         file
     *                                          Medbiquitous XML file
     *  @param {Callback1<Array<EcCompetency>>} success
     *                                          Callback triggered on succesfully analyzing competencies,
     *                                          returns an array of all of the competencies found
     *  @param {Callback1<String>}              [failure]
     *                                          Callback triggered on error analyzing file
     *  @memberOf MedbiqImport
     *  @method analyzeFile
     *  @static
     */
    constructor.analyzeFile = function(file, success, failure) {
        if (file == null) {
            failure("No file to analyze");
            return;
        }
        if ((file)["name"] == null) {
            failure("Invalid file");
            return;
        } else if (!((file)["name"]).endsWith(".xml")) {
            failure("Invalid file type");
            return;
        }
        var reader = new FileReader();
        reader.onload = function(e) {
            var result = ((e)["target"])["result"];
            var jsonObject = new X2JS().xml_str2json(result);
            MedbiqImport.medbiqXmlCompetencies = [];
            MedbiqImport.medbiqXmlLookForCompetencyObject(jsonObject);
            success(MedbiqImport.medbiqXmlCompetencies);
        };
        reader.onerror = function(p1) {
            failure("Error Reading File");
        };
        reader.readAsText(file, "UTF-8");
    };
    /**
     *  Method for actually creating the competencies in the CASS repository after a
     *  Medbiquitous XML file has been parsed. Must be called after analyzeFile
     * 
     *  @param {String}                         serverUrl
     *                                          URL Prefix for the created competencies (and relationships?)
     *  @param {EcIdentity}                     owner
     *                                          EcIdentity that will own the created competencies (and relationships?)
     *  @param {Callback1<Array<EcCompetency>>} success
     *                                          Callback triggered after successfully creating the competencies from the XML file
     *  @param {Callback1<Object>}              [failure]
     *                                          Callback triggered if there is an error while creating the competencies
     *  @param {Callback1<Object>}              [incremental]
     *                                          Callback triggered incrementally while the competencies are being created to show progress,
     *                                          returns an object indicating the number of competencies created so far
     *  @memberOf MedbiqImport
     *  @method importCompetencies
     *  @static
     */
    constructor.importCompetencies = function(serverUrl, owner, success, failure, incremental, repo) {
        MedbiqImport.progressObject = null;
        MedbiqImport.saved = 0;
        for (var i = 0; i < MedbiqImport.medbiqXmlCompetencies.length; i++) {
            var comp = MedbiqImport.medbiqXmlCompetencies[i];
            if (repo == null || repo.selectedServer.indexOf(serverUrl) != -1) 
                comp.generateId(serverUrl);
             else 
                comp.generateShortId(serverUrl);
            if (owner != null) 
                comp.addOwner(owner.ppk.toPk());
            MedbiqImport.saveCompetency(success, failure, incremental, comp, repo);
        }
    };
    constructor.saveCompetency = function(success, failure, incremental, comp, repo) {
        Task.asyncImmediate(function(o) {
            var keepGoing = o;
            var scs = function(p1) {
                MedbiqImport.saved++;
                if (MedbiqImport.saved % MedbiqImport.INCREMENTAL_STEP == 0) {
                    if (MedbiqImport.progressObject == null) 
                        MedbiqImport.progressObject = new Object();
                    (MedbiqImport.progressObject)["competencies"] = MedbiqImport.saved;
                    incremental(MedbiqImport.progressObject);
                }
                if (MedbiqImport.saved == MedbiqImport.medbiqXmlCompetencies.length) {
                    if (MedbiqImport.progressObject == null) 
                        MedbiqImport.progressObject = new Object();
                    (MedbiqImport.progressObject)["competencies"] = MedbiqImport.saved;
                    incremental(MedbiqImport.progressObject);
                    success(MedbiqImport.medbiqXmlCompetencies);
                }
                keepGoing();
            };
            var err = function(p1) {
                failure("Failed to Save Competency");
                keepGoing();
            };
            comp.save(scs, err, repo);
        });
    };
}, {medbiqXmlCompetencies: {name: "Array", arguments: ["EcCompetency"]}, progressObject: "Object"}, {});
var TabStructuredImport = function() {};
TabStructuredImport = stjs.extend(TabStructuredImport, null, [], function(constructor, prototype) {
    /**
     *  Method to create competencies (and relationships if the parameters are passed in)
     *  based on a CSV file and references to which columns correspond to which pieces
     *  of data.
     * 
     *  @param {Object}                        text
     *                                         Text to extract competencies from
     *  @param {String}                        serverUrl
     *                                         URL Prefix for the created competencies (and relationships?)
     *  @param {EcIdentity}                    owner
     *                                         EcIdentity that will own the created competencies (and relationships?)
     *  @param {Callback2<Array<EcCompetency>, Array<EcAlignment>>} success
     *                                         Callback triggered after the competencies (and relationships?) have been created
     *  @param {Callback1<Object>}             [failure]
     *                                         Callback triggered if an error during creating the competencies
     *  @param {Callback1<Object>}             [incremental]
     *                                         Callback triggered incrementally during creation of competencies to indicate progress,
     *                                         returns an object indicating the number of competencies (and relationships?) created so far
     *  @param {EcRepository}                  repo
     *                                         Repository to save any new data to, or to use to generate IDs.
     *  @memberOf TabStructuredImport
     *  @method importCompetencies
     *  @static
     */
    constructor.importCompetencies = function(text, serverUrl, owner, success, failure, incremental, repo, hashNameForId) {
        var lines = text.split("\n");
        var competencies = new Array();
        var alignments = new Array();
        for (var i = 0; i < lines.length; i++) 
            TabStructuredImport.parseLinesIntoHierarchy(lines, competencies, alignments, i, serverUrl, hashNameForId, repo);
        success(competencies, alignments);
    };
    constructor.parseLinesIntoHierarchy = function(lines, competencies, alignments, index, serverUrl, hashNameForId, repo) {
        var parentI = -1;
        for (var i = index - 1; i >= 0; i--) {
            if (TabStructuredImport.tabs(lines[i]) < TabStructuredImport.tabs(lines[index])) {
                parentI = i;
                break;
            }
        }
        var c = null;
        for (var i = 0; i < competencies.length; i++) {
            if (competencies[i].getName().trim() == lines[index].trim()) {
                c = competencies[i];
                break;
            }
        }
        if (c == null) {
            c = new EcCompetency();
            if (hashNameForId) 
                c.assignId(serverUrl, EcCrypto.md5(lines[index].trim()));
             else if (serverUrl != repo.selectedServer) 
                c.generateShortId(serverUrl);
             else 
                c.generateId(serverUrl);
            c.setName(lines[index]);
            competencies.push(c);
        }
        if (parentI != -1) {
            var parent = null;
            for (var i = 0; i < competencies.length; i++) {
                if (competencies[i].getName().trim() == lines[parentI].trim()) {
                    parent = competencies[i];
                    break;
                }
            }
            if (parent != null && parent.shortId() != c.shortId()) {
                var a = new EcAlignment();
                if (serverUrl != repo.selectedServer) 
                    a.generateShortId(serverUrl);
                 else 
                    a.generateId(serverUrl);
                a.relationType = EcAlignment.NARROWS;
                a.source = c.shortId();
                a.target = parent.shortId();
                alignments.push(a);
            }
        }
    };
    constructor.tabs = function(line) {
        var tabs = 0;
        for (var i = 0; i < line.length; i++) {
            var c = line.charAt(i);
            if (c == '\t' || c == ' ') 
                tabs++;
             else 
                return tabs;
        }
        return tabs;
    };
}, {}, {});
/**
 *  Importer methods to copy or link to competencies that already
 *  exist in another framework in a CASS instance.
 * 
 *  @author devlin.junker@eduworks.com
 *  @module org.cassproject
 *  @class FrameworkImport
 *  @static
 *  @extends Importer
 */
var FrameworkImport = function() {};
FrameworkImport = stjs.extend(FrameworkImport, null, [], function(constructor, prototype) {
    constructor.savedComp = 0;
    constructor.savedRel = 0;
    constructor.targetUsable = null;
    constructor.competencies = null;
    constructor.relations = null;
    constructor.compMap = null;
    /**
     *  Copies or links competencies that exist in one framework in a CASS instance,
     *  to another different framework in the same CASS instance.
     * 
     *  @param {EcFramework}                    source
     *                                          Framework to copy or link the competencies from
     *  @param {EcFramework}                    target
     *                                          Framework to add the copied or linked competencies to
     *  @param {boolean}                        copy
     *                                          Flag indicating whether or not to copy or link the competencies in the source framework
     *  @param {String}                         serverUrl
     *                                          URL Prefix for the created competencies if copied
     *  @param {EcIdentity}                     owner
     *                                          EcIdentity that will own the created competencies if copied
     *  @param {Callback1<Array<EcCompetency>>} success
     *                                          Callback triggered after succesfully copying or linking all of the competencies,
     *                                          returns an array of the new or linked competencies
     *  @param {Callback1<Object>}              [failure]
     *                                          Callback triggered if an error occurred while creating the competencies
     *  @memberOf FrameworkImport
     *  @method importCompetencies
     *  @static
     */
    constructor.importCompetencies = function(source, target, copy, serverUrl, owner, success, failure, repo) {
        if (source == null) {
            failure("Source Framework not set");
            return;
        }
        if (target == null) {
            failure("Target Framework not Set");
            return;
        }
        FrameworkImport.targetUsable = target;
        if (source.competency == null || source.competency.length == 0) {
            failure("Source Has No Competencies");
            return;
        }
        FrameworkImport.competencies = [];
        FrameworkImport.relations = [];
        if (copy) {
            FrameworkImport.compMap = {};
            FrameworkImport.savedComp = 0;
            FrameworkImport.savedRel = 0;
            for (var i = 0; i < source.competency.length; i++) {
                var id = source.competency[i];
                EcCompetency.get(id, function(comp) {
                    var competency = new EcCompetency();
                    competency.copyFrom(comp);
                    if (repo == null || repo.selectedServer.indexOf(serverUrl) != -1) 
                        competency.generateId(serverUrl);
                     else 
                        competency.generateShortId(serverUrl);
                    FrameworkImport.compMap[comp.shortId()] = competency.shortId();
                    if (owner != null) 
                        competency.addOwner(owner.ppk.toPk());
                    var id = competency.id;
                    Task.asyncImmediate(function(o) {
                        var keepGoing = o;
                        competency.save(function(str) {
                            FrameworkImport.savedComp++;
                            FrameworkImport.targetUsable.addCompetency(id);
                            if (FrameworkImport.savedComp == FrameworkImport.competencies.length) {
                                FrameworkImport.targetUsable.save(function(p1) {
                                    for (var i = 0; i < source.relation.length; i++) {
                                        var id = source.relation[i];
                                        EcAlignment.get(id, function(rel) {
                                            var relation = new EcAlignment();
                                            relation.copyFrom(rel);
                                            if (repo == null || repo.selectedServer.indexOf(serverUrl) != -1) 
                                                relation.generateId(serverUrl);
                                             else 
                                                relation.generateShortId(serverUrl);
                                            relation.source = FrameworkImport.compMap[rel.source];
                                            relation.target = FrameworkImport.compMap[rel.target];
                                            if (owner != null) 
                                                relation.addOwner(owner.ppk.toPk());
                                            var id = relation.id;
                                            Task.asyncImmediate(function(o) {
                                                var keepGoing2 = o;
                                                relation.save(function(str) {
                                                    FrameworkImport.savedRel++;
                                                    FrameworkImport.targetUsable.addRelation(id);
                                                    if (FrameworkImport.savedRel == FrameworkImport.relations.length) {
                                                        FrameworkImport.targetUsable.save(function(p1) {
                                                            success(FrameworkImport.competencies, FrameworkImport.relations);
                                                        }, function(p1) {
                                                            failure(p1);
                                                        }, repo);
                                                    }
                                                    keepGoing2();
                                                }, function(str) {
                                                    failure("Trouble Saving Copied Competency");
                                                    keepGoing2();
                                                }, repo);
                                            });
                                            FrameworkImport.relations.push(relation);
                                        }, function(str) {
                                            failure(str);
                                        });
                                    }
                                }, function(p1) {
                                    failure(p1);
                                }, repo);
                            }
                            keepGoing();
                        }, function(str) {
                            failure("Trouble Saving Copied Competency");
                            keepGoing();
                        }, repo);
                    });
                    FrameworkImport.competencies.push(competency);
                }, function(str) {
                    failure(str);
                });
            }
        } else {
            for (var i = 0; i < source.competency.length; i++) {
                if (target.competency == null || (target.competency.indexOf(source.competency[i]) == -1 && target.competency.indexOf(EcRemoteLinkedData.trimVersionFromUrl(source.competency[i])) == -1)) {
                    EcCompetency.get(source.competency[i], function(comp) {
                        FrameworkImport.competencies.push(comp);
                        FrameworkImport.targetUsable.addCompetency(comp.id);
                        if (FrameworkImport.competencies.length == source.competency.length) {
                            delete (FrameworkImport.targetUsable)["competencyObjects"];
                            FrameworkImport.targetUsable.save(function(p1) {
                                for (var i = 0; i < source.relation.length; i++) {
                                    if (target.relation == null || (target.relation.indexOf(source.relation[i]) == -1 && target.relation.indexOf(EcRemoteLinkedData.trimVersionFromUrl(source.competency[i])) == -1)) {
                                        EcAlignment.get(source.relation[i], function(relation) {
                                            FrameworkImport.relations.push(relation);
                                            FrameworkImport.targetUsable.addRelation(relation.id);
                                            if (FrameworkImport.relations.length == source.relation.length) {
                                                delete (FrameworkImport.targetUsable)["competencyObjects"];
                                                Task.asyncImmediate(function(o) {
                                                    var keepGoing = o;
                                                    FrameworkImport.targetUsable.save(function(p1) {
                                                        success(FrameworkImport.competencies, FrameworkImport.relations);
                                                        keepGoing();
                                                    }, function(p1) {
                                                        failure(p1);
                                                        keepGoing();
                                                    }, repo);
                                                });
                                            }
                                        }, function(p1) {
                                            failure(p1);
                                        });
                                    }
                                }
                            }, function(p1) {
                                failure(p1);
                            }, repo);
                        }
                    }, function(p1) {
                        failure(p1);
                    });
                }
            }
        }
    };
}, {targetUsable: "EcFramework", competencies: {name: "Array", arguments: ["EcCompetency"]}, relations: {name: "Array", arguments: ["EcAlignment"]}, compMap: {name: "Map", arguments: [null, null]}}, {});
/**
 *  Export methods to handle exporting two CSV file , one of competencies
 *  and one of relationships representing a framework
 * 
 *  @author devlin.junker@eduworks.com
 *  @author fritz.ray@eduworks.com
 *  @module org.cassproject
 *  @class CSVExport
 *  @static
 *  @extends Exporter
 */
var CSVExport = function() {
    Exporter.call(this);
};
CSVExport = stjs.extend(CSVExport, Exporter, [], function(constructor, prototype) {
    constructor.frameworkCompetencies = null;
    constructor.frameworkRelations = null;
    constructor.exportObjects = function(objects, fileName, piped) {
        var compExport = new CSVExport.CSVExportProcess();
        compExport.buildExport(objects, piped);
        compExport.downloadCSV(fileName);
    };
    constructor.exportCTDLASN = function(json, name) {
        var objects = [];
        CSVExport.findGraphs(json, objects);
        CSVExport.exportObjects(objects, name + ".csv", true);
    };
    constructor.findGraphs = function(json, objects) {
        var jsonArray;
        if (!EcArray.isArray(json)) {
            jsonArray = [json];
        } else {
            jsonArray = json;
        }
        for (var j = 0; j < jsonArray.length; j++) {
            var framework = jsonArray[j];
            var graph = (framework)["@graph"];
            if (graph != null) {
                for (var i = 0; i < graph.length; i++) {
                    var rld = new EcRemoteLinkedData("https://credreg.net/ctdlasn/schema/context/json", (graph[i])["@type"]);
                    rld.copyFrom(graph[i]);
                    objects.push(rld);
                    if ((graph[i])["@graph"] != null) {
                        CSVExport.findGraphs(graph[i], objects);
                    }
                }
            }
        }
    };
    /**
     *  Method to export the CSV files of competencies and relationships for a framework
     * 
     *  @param {String}            frameworkId
     *                             Id of the framework to export
     *  @param {Callback0}         success
     *                             Callback triggered after both files have been successfully exported
     *  @param {Callback1<String>} failure
     *                             Callback triggered if an error occurs during export
     *  @memberOf CSVExport
     *  @method export
     *  @static
     */
    constructor.exportFramework = function(frameworkId, success, failure) {
        if (frameworkId == null) {
            failure("Framework not selected.");
            return;
        }
        CSVExport.frameworkCompetencies = [];
        CSVExport.frameworkRelations = [];
        EcRepository.get(frameworkId, function(data) {
            if (data.isAny(new EcFramework().getTypes())) {
                var fw = new EcFramework();
                fw.copyFrom(data);
                if (fw.competency == null || fw.competency.length == 0) 
                    failure("No Competencies in Framework");
                for (var i = 0; i < fw.competency.length; i++) {
                    var competencyUrl = fw.competency[i];
                    EcRepository.get(competencyUrl, function(competency) {
                        CSVExport.frameworkCompetencies.push(competency);
                        if (CSVExport.frameworkCompetencies.length == fw.competency.length) {
                            var compExport = new CSVExport.CSVExportProcess();
                            compExport.buildExport(CSVExport.frameworkCompetencies, false);
                            compExport.downloadCSV(fw.getName() + " - Competencies.csv");
                        }
                    }, function(s) {
                        CSVExport.frameworkCompetencies.push(null);
                        if (CSVExport.frameworkCompetencies.length == fw.competency.length) {
                            var compExport = new CSVExport.CSVExportProcess();
                            compExport.buildExport(CSVExport.frameworkCompetencies, false);
                            compExport.downloadCSV(fw.getName() + " - Competencies.csv");
                        }
                    });
                }
                for (var i = 0; i < fw.relation.length; i++) {
                    var relationUrl = fw.relation[i];
                    EcRepository.get(relationUrl, function(relation) {
                        CSVExport.frameworkRelations.push(relation);
                        if (CSVExport.frameworkRelations.length == fw.relation.length) {
                            var compExport = new CSVExport.CSVExportProcess();
                            compExport.buildExport(CSVExport.frameworkRelations, false);
                            compExport.downloadCSV(fw.getName() + " - Relations.csv");
                            if (success != null && success != undefined) 
                                success();
                        }
                    }, function(s) {
                        CSVExport.frameworkRelations.push(null);
                        if (CSVExport.frameworkRelations.length == fw.relation.length) {
                            var compExport = new CSVExport.CSVExportProcess();
                            compExport.buildExport(CSVExport.frameworkRelations, false);
                            compExport.downloadCSV(fw.getName() + " - Relations.csv");
                            if (success != null && success != undefined) 
                                success();
                        }
                    });
                }
            }
        }, failure);
    };
    constructor.CSVExportProcess = function() {
        this.csvOutput = [];
    };
    constructor.CSVExportProcess = stjs.extend(constructor.CSVExportProcess, null, [], function(constructor, prototype) {
        prototype.csvOutput = null;
        prototype.flattenObject = function(flattenedObject, object, prefix, piped) {
            var data = new EcRemoteLinkedData((object)["@context"], (object)["@type"]);
            data.copyFrom(object);
            var tempObj = JSON.parse(data.toJson());
            var props = (tempObj);
            for (var prop in props) {
                var id;
                if (prefix != null && prefix != undefined && !piped) 
                    id = prefix + "." + prop;
                 else 
                    id = prop;
                if (props[prop] != null && props[prop] != "" && stjs.isInstanceOf(props[prop].constructor, Object) && !piped) {
                    this.flattenObject(flattenedObject, props[prop], id, false);
                } else if (props[prop] != null && props[prop] != "" && (stjs.isInstanceOf(props[prop].constructor, Object) || EcArray.isArray(props[prop])) && piped) {
                    var display = "";
                    var props2 = (props[prop]);
                    for (var prop2 in props2) {
                        display += props2[prop2] + "|";
                    }
                    display = display.substring(0, display.length - 1);
                    (flattenedObject)[id] = display;
                } else {
                    var display = Thing.getDisplayStringFrom(props[prop]);
                    (flattenedObject)[id] = display;
                }
            }
        };
        prototype.addCSVRow = function(object, piped) {
            var flattenedObject = new EcRemoteLinkedData(object.context, object.type);
            this.flattenObject(flattenedObject, object, null, piped);
            this.csvOutput.push(JSON.parse(flattenedObject.toJson()));
            var props = (JSON.parse(flattenedObject.toJson()));
            for (var prop in props) {
                if (props[prop] != null && props[prop] != "") {
                    for (var i = 0; i < this.csvOutput.length; i++) {
                        var row = this.csvOutput[i];
                        if (!(row).hasOwnProperty(prop)) {
                            (row)[prop] = "";
                        }
                    }
                }
            }
        };
        prototype.buildExport = function(objects, piped) {
            for (var i = 0; i < objects.length; i++) 
                if (objects[i] != null) {
                    var object = objects[i];
                    this.addCSVRow(object, piped);
                }
        };
        prototype.downloadCSV = function(name) {
            var csv = Papa.unparse(this.csvOutput);
            var pom = window.document.createElement("a");
            pom.setAttribute("href", "data:text/csv;charset=utf-8," + encodeURIComponent(csv));
            pom.setAttribute("download", name);
            if ((window.document)["createEvent"] != null) {
                var event = ((window.document)["createEvent"]).call(window.document, "MouseEvents");
                ((event)["initEvent"]).call(event, "click", true, true);
                pom.dispatchEvent(event);
            } else {
                ((pom)["click"]).call(pom);
            }
        };
    }, {csvOutput: {name: "Array", arguments: ["Object"]}}, {});
}, {frameworkCompetencies: {name: "Array", arguments: ["EcRemoteLinkedData"]}, frameworkRelations: {name: "Array", arguments: ["EcRemoteLinkedData"]}}, {});
/**
 *  Import methods to handle an CSV file of competencies and a
 *  CSV file of relationships and store them in a CASS instance
 * 
 *  @author devlin.junker@eduworks.com
 *  @author fritz.ray@eduworks.com
 *  @module org.cassproject
 *  @class CSVImport
 *  @static
 *  @extends Importer
 */
var CSVImport = function() {};
CSVImport = stjs.extend(CSVImport, null, [], function(constructor, prototype) {
    constructor.INCREMENTAL_STEP = 5;
    constructor.importCsvLookup = null;
    constructor.saved = 0;
    constructor.progressObject = null;
    /**
     *  Analyzes a CSV File to return the column names to the user for specifying
     *  which columns contain which data. This should be called before import.
     * 
     *  @param {Object}            file
     *                             CSV file to be analyzed
     *  @param {Callback1<Object>} success
     *                             Callback triggered after successfully analyzing the CSV file
     *  @param {Callback1<Object>} [failure]
     *                             Callback triggered if there is an error analyzing the CSV file
     *  @memberOf CSVImport
     *  @method analyzeFile
     *  @static
     */
    constructor.analyzeFile = function(file, success, failure) {
        if (file == null) {
            failure("No file to analyze");
            return;
        }
        if ((file)["name"] == null) {
            failure("Invalid file");
        } else if (!((file)["name"]).endsWith(".csv")) {
            failure("Invalid file type");
        }
        Papa.parse(file, {encoding: "UTF-8", complete: function(results) {
            var tabularData = (results)["data"];
            success(tabularData);
        }, error: failure});
    };
    /**
     *  Helper function to transform a competencies oldID to match the new server url
     * 
     *  @param {String}             oldId
     *                              Old ID found in the CSV file
     *  @param {EcRemoteLinkedData} newObject
     *                              New competency being created
     *  @param {String}             selectedServer
     *                              New URL Prefix that the new competency's ID should match
     *  @memberOf CSVImport
     *  @method transformId
     *  @private
     *  @static
     */
    constructor.transformId = function(oldId, newObject, selectedServer, repo) {
        if (oldId == null || oldId == "" || oldId.toLowerCase().indexOf("http") == -1) 
            newObject.assignId(selectedServer, oldId);
         else {
            newObject.id = oldId;
        }
    };
    /**
     *  Method to create competencies (and relationships if the parameters are passed in)
     *  based on a CSV file and references to which columns correspond to which pieces
     *  of data.
     * 
     *  @param {Object}                        file
     *                                         CSV File to import competencies from
     *  @param {String}                        serverUrl
     *                                         URL Prefix for the created competencies (and relationships?)
     *  @param {EcIdentity}                    owner
     *                                         EcIdentity that will own the created competencies (and relationships?)
     *  @param {int}                           nameIndex
     *                                         Index of the column that contains the competency names
     *  @param {int}                           descriptionIndex
     *                                         Index of the column that contains the competency descriptions
     *  @param {int}                           scopeIndex
     *                                         Index of the column that contains the competency scopes
     *  @param {int}                           idIndex
     *                                         Index of the column that contains the old competency ID (Optional, if not exists pass null or negative)
     *  @param {Object}                        [relations]
     *                                         CSV File to import relationships from (Optional, if not exists pass null)
     *  @param {int}                           [sourceIndex]
     *                                         Index (in relation file) of the column containing the relationship source competency ID (Optional, if not exists pass null or negative)
     *  @param {int}                           [relationTypeIndex]
     *                                         Index (in relation file) of the column containing the relationship type (Optional, if not exists pass null or negative)
     *  @param {int}                           [destIndex]
     *                                         Index (in relation file) of the column containing the relationship destination competency ID (Optional, if not exists pass null or negative)
     *  @param {Callback2<Array<EcCompetency>, Array<EcAlignment>>} success
     *                                         Callback triggered after the competencies (and relationships?) have been created
     *  @param {Callback1<Object>}             [failure]
     *                                         Callback triggered if an error during creating the competencies
     *  @param {Callback1<Object>}             [incremental]
     *                                         Callback triggered incrementally during creation of competencies to indicate progress,
     *                                         returns an object indicating the number of competencies (and relationships?) created so far
     *  @memberOf CSVImport
     *  @method importCompetencies
     *  @static
     */
    constructor.importCompetencies = function(file, serverUrl, owner, nameIndex, descriptionIndex, scopeIndex, idIndex, relations, sourceIndex, relationTypeIndex, destIndex, success, failure, incremental, uniquify, repo) {
        CSVImport.progressObject = null;
        CSVImport.importCsvLookup = new Object();
        if (nameIndex < 0) {
            failure("Name Index not Set");
            return;
        }
        var competencies = [];
        Papa.parse(file, {encoding: "UTF-8", complete: function(results) {
            var tabularData = (results)["data"];
            var colNames = tabularData[0];
            for (var i = 1; i < tabularData.length; i++) {
                if (tabularData[i].length == 0 || (tabularData[i].length == 1 && (tabularData[i][0] == null || tabularData[i][0] == undefined || tabularData[i][0] == ""))) {
                    continue;
                }
                if (tabularData[i][nameIndex] == null || tabularData[i][nameIndex] == undefined || tabularData[i][nameIndex] == "") {
                    continue;
                }
                var competency = new EcCompetency();
                competency.name = tabularData[i][nameIndex];
                if (descriptionIndex >= 0) 
                    competency.description = tabularData[i][descriptionIndex];
                if (scopeIndex >= 0) 
                    competency.scope = tabularData[i][scopeIndex];
                if ((uniquify == undefined || uniquify == null || uniquify == false) && idIndex != null && idIndex >= 0) {
                    competency.id = tabularData[i][idIndex];
                    CSVImport.transformId(tabularData[i][idIndex], competency, serverUrl, repo);
                } else {
                    if (repo == null || repo.selectedServer.indexOf(serverUrl) != -1) 
                        competency.generateId(serverUrl);
                     else 
                        competency.generateShortId(serverUrl);
                }
                if (owner != undefined && owner != null) 
                    competency.addOwner(owner.ppk.toPk());
                var shortId = null;
                if (idIndex != null && idIndex != undefined && idIndex >= 0) {
                    var oldId = tabularData[i][idIndex];
                    shortId = EcRemoteLinkedData.trimVersionFromUrl(oldId);
                    (CSVImport.importCsvLookup)[shortId] = competency.shortId();
                }
                if (idIndex != null && idIndex != undefined && idIndex >= 0 && tabularData[i][idIndex] != null && tabularData[i][idIndex] != "") {
                    if ((CSVImport.importCsvLookup)[tabularData[i][idIndex]] == null) 
                        (CSVImport.importCsvLookup)[tabularData[i][idIndex]] = competency.shortId();
                }
                (CSVImport.importCsvLookup)[competency.getName()] = competency.shortId();
                for (var idx = 0; idx < tabularData[i].length; idx++) {
                    var name = colNames[idx];
                    if (name == null || name.trim() == "" || name.startsWith("@") || name.indexOf(".") != -1 || tabularData[i][idx].trim() == "" || idx == nameIndex || idx == descriptionIndex || idx == scopeIndex || idx == idIndex) {
                        continue;
                    } else {
                        (competency)[colNames[idx]] = tabularData[i][idx];
                    }
                }
                competencies.push(competency);
            }
            CSVImport.saved = 0;
            for (var i = 0; i < competencies.length; i++) {
                var comp = competencies[i];
                CSVImport.saveCompetency(comp, incremental, competencies, relations, success, serverUrl, owner, sourceIndex, relationTypeIndex, destIndex, failure, repo);
            }
        }, error: failure});
    };
    constructor.saveCompetency = function(comp, incremental, competencies, relations, success, serverUrl, owner, sourceIndex, relationTypeIndex, destIndex, failure, repo) {
        Task.asyncImmediate(function(o) {
            var keepGoing = o;
            var saveDone = function(results) {
                CSVImport.saved++;
                if (CSVImport.saved % CSVImport.INCREMENTAL_STEP == 0) {
                    if (CSVImport.progressObject == null) 
                        CSVImport.progressObject = new Object();
                    (CSVImport.progressObject)["competencies"] = CSVImport.saved;
                    incremental(CSVImport.progressObject);
                }
                if (CSVImport.saved == competencies.length) {
                    if (relations == null) 
                        success(competencies, new Array());
                     else 
                        CSVImport.importRelations(serverUrl, owner, relations, sourceIndex, relationTypeIndex, destIndex, competencies, success, failure, incremental, repo);
                }
                keepGoing();
            };
            comp.save(saveDone, saveDone, repo);
        });
    };
    /**
     *  Handles actually importing the relationships from the relationship CSV file
     * 
     *  @param {String}                        serverUrl
     *                                         URL Prefix for the created competencies (and relationships?)
     *  @param {EcIdentity}                    owner
     *                                         EcIdentity that will own the created competencies (and relationships?)
     *  @param {Object}                        file
     *                                         CSV File to import competencies from
     *  @param {int}                           sourceIndex
     *                                         Index (in relation file) of the column containing the relationship source competency ID
     *  @param {int}                           relationTypeIndex
     *                                         Index (in relation file) of the column containing the relationship type
     *  @param {int}                           destIndex
     *                                         Index (in relation file) of the column containing the relationship destination competency ID
     *  @param {Array<EcCompetency>}           competencies
     *                                         Array of newly created competencies
     *  @param {Callback2<Array<EcCompetency>, Array<EcAlignment>>} success
     *                                         Callback triggered after the relationships have been created
     *  @param {Callback1<Object>}             failure
     *                                         Callback triggered if an error during creating the relationships
     *  @param {Callback1<Object>}             incremental
     *                                         Callback triggered incrementally during creation to indicate progress
     *  @memberOf CSVImport
     *  @method importRelations
     *  @private
     *  @static
     */
    constructor.importRelations = function(serverUrl, owner, file, sourceIndex, relationTypeIndex, destIndex, competencies, success, failure, incremental, repo) {
        var relations = new Array();
        if (sourceIndex == null || sourceIndex < 0) {
            failure("Source Index not Set");
            return;
        }
        if (relationTypeIndex == null || relationTypeIndex < 0) {
            failure("Relation Type Index not Set");
            return;
        }
        if (destIndex == null || destIndex < 0) {
            failure("Destination Index not Set");
            return;
        }
        Papa.parse(file, {encoding: "UTF-8", complete: function(results) {
            var tabularData = (results)["data"];
            for (var i = 1; i < tabularData.length; i++) {
                if (tabularData[i].length == 0 || (tabularData[i].length == 1 && (tabularData[i][0] == null || tabularData[i][0] == undefined || tabularData[i][0] == ""))) {
                    continue;
                }
                var alignment = new EcAlignment();
                var sourceKey = tabularData[i][sourceIndex];
                var relationTypeKey = tabularData[i][relationTypeIndex];
                var destKey = tabularData[i][destIndex];
                if ((CSVImport.importCsvLookup)[sourceKey] == null) 
                    alignment.source = sourceKey;
                 else 
                    alignment.source = (CSVImport.importCsvLookup)[sourceKey];
                if ((CSVImport.importCsvLookup)[destKey] == null) 
                    alignment.target = destKey;
                 else 
                    alignment.target = (CSVImport.importCsvLookup)[destKey];
                alignment.relationType = relationTypeKey;
                if (owner != null) 
                    alignment.addOwner(owner.ppk.toPk());
                if (repo == null || repo.selectedServer.indexOf(serverUrl) != -1) 
                    alignment.generateId(serverUrl);
                 else 
                    alignment.generateShortId(serverUrl);
                relations.push(alignment);
            }
            CSVImport.saved = 0;
            for (var i = 0; i < relations.length; i++) {
                var relation = relations[i];
                CSVImport.saveRelation(relation, incremental, relations, success, competencies, failure, repo);
            }
            if (CSVImport.saved == 0 && CSVImport.saved == relations.length) {
                success(competencies, relations);
            }
        }, error: failure});
    };
    constructor.saveRelation = function(relation, incremental, relations, success, competencies, failure, repo) {
        Task.asyncImmediate(function(o) {
            var keepGoing = o;
            relation.save(function(results) {
                CSVImport.saved++;
                if (CSVImport.saved % CSVImport.INCREMENTAL_STEP == 0) {
                    if (CSVImport.progressObject == null) 
                        CSVImport.progressObject = new Object();
                    (CSVImport.progressObject)["relations"] = CSVImport.saved;
                    incremental(CSVImport.progressObject);
                    incremental(CSVImport.saved);
                }
                if (CSVImport.saved == relations.length) {
                    success(competencies, relations);
                }
                keepGoing();
            }, function(results) {
                failure("Failed to save competency or relation");
                for (var j = 0; j < competencies.length; j++) {
                    competencies[j]._delete(null, null, null);
                }
                for (var j = 0; j < relations.length; j++) {
                    relations[j]._delete(null, null);
                }
                keepGoing();
            }, repo);
        });
    };
    constructor.hasContextColumn = function(colNames) {
        for (var idx = 0; idx < colNames.length; idx++) {
            if (colNames[idx] == "@context") {
                return idx;
            }
        }
        return -1;
    };
    constructor.hasTypeColumn = function(colNames) {
        for (var idx = 0; idx < colNames.length; idx++) {
            if (colNames[idx] == "@type") {
                return idx;
            }
        }
        return -1;
    };
    constructor.expandObject = function(nestedFields, nestedObj, value) {
        if (nestedFields.length == 0) {
            return;
        } else if (nestedFields.length == 1) {
            (nestedObj)[nestedFields[0]] = value;
        } else {
            var key = nestedFields[0];
            if ((nestedObj)[key] == null || (nestedObj)[key] == undefined) 
                (nestedObj)[key] = new Object();
            nestedFields.splice(0, 1);
            CSVImport.expandObject(nestedFields, (nestedObj)[key], value);
        }
    };
    constructor.transformReferences = function(data) {
        var props = (data);
        for (var prop in props) {
            if (props[prop] == null || props[prop] == undefined || Object.prototype.toString.call(props[prop]).indexOf("String") == -1) {
                if (EcObject.isObject(props[prop])) {
                    var nested = props[prop];
                    CSVImport.transformReferences(nested);
                    (data)[prop] = nested;
                }
                continue;
            }
            var oldVal = props[prop];
            if ((CSVImport.importCsvLookup)[oldVal] != null && (CSVImport.importCsvLookup)[oldVal] != undefined && (CSVImport.importCsvLookup)[oldVal] != "") {
                (data)[prop] = (CSVImport.importCsvLookup)[oldVal];
            }
        }
    };
    constructor.importData = function(file, serverUrl, owner, success, failure, incremental, idIndex, assignedContext, assignedType, repo) {
        var objects = [];
        var hasAssignedContext = assignedContext != undefined && assignedContext != null && assignedContext.trim() != "";
        var hasAssignedType = assignedType != undefined && assignedType != null && assignedType.trim() != "";
        CSVImport.importCsvLookup = new Object();
        Papa.parse(file, {encoding: "UTF-8", complete: function(results) {
            var tabularData = (results)["data"];
            var colNames = tabularData[0];
            var contextIdx = -1;
            var typeIdx = -1;
            if (!hasAssignedContext && (contextIdx = CSVImport.hasContextColumn(colNames)) == -1) {
                failure("Was not passed and cannot find column with data context");
            } else if (!hasAssignedType && (typeIdx = CSVImport.hasTypeColumn(colNames)) == 1) {
                failure("Was not passed and cannot find column with data type");
            }
            for (var i = 1; i < tabularData.length; i++) {
                if (tabularData[i].length == 0 || (tabularData[i].length == 1 && (tabularData[i][0] == null || tabularData[i][0] == undefined || tabularData[i][0] == ""))) {
                    continue;
                }
                var context = null;
                var type = null;
                if (hasAssignedContext) 
                    context = assignedContext;
                 else 
                    context = tabularData[i][contextIdx];
                if (hasAssignedType) 
                    type = assignedType;
                 else 
                    type = tabularData[i][typeIdx];
                var data = new EcRemoteLinkedData(context, type);
                var nestedObjs = {};
                for (var idx = 0; idx < tabularData[i].length; idx++) {
                    var name = colNames[idx];
                    if (name == "@id" || name == "id") {
                        data.id = tabularData[i][idx];
                        continue;
                    } else if (name == null || name.trim() == "" || name.startsWith("@") || tabularData[i][idx].trim() == "" || idx == contextIdx || idx == typeIdx) {
                        continue;
                    } else if (name.indexOf(".") != -1) {
                        var split = (name.split("."));
                        if (split.length > 1) {
                            var key = split[0];
                            if (nestedObjs[key] == null || nestedObjs[key] == undefined) 
                                nestedObjs[key] = new Object();
                            split.splice(0, 1);
                            CSVImport.expandObject(split, nestedObjs[key], tabularData[i][idx]);
                            continue;
                        }
                        name = split[0];
                    }
                    var val = tabularData[i][idx];
                    (data)[name] = val;
                }
                for (var key in nestedObjs) {
                    (data)[key] = nestedObjs[key];
                }
                if (owner != null) 
                    data.addOwner(owner.ppk.toPk());
                var fileId = data.id;
                if (idIndex != undefined && idIndex != null && idIndex >= 0) {
                    data.id = tabularData[i][idIndex];
                    CSVImport.transformId(tabularData[i][idIndex], data, serverUrl, repo);
                } else {
                    if (repo == null || repo.selectedServer.indexOf(serverUrl) != -1) 
                        data.generateId(serverUrl);
                     else 
                        data.generateShortId(serverUrl);
                }
                var shortId;
                if (idIndex != null && idIndex != undefined && idIndex >= 0) {
                    var oldId = tabularData[i][idIndex];
                    shortId = EcRemoteLinkedData.trimVersionFromUrl(oldId);
                    (CSVImport.importCsvLookup)[shortId] = data.shortId();
                }
                if (idIndex != null && idIndex != undefined && idIndex >= 0 && tabularData[i][idIndex] != null && tabularData[i][idIndex] != "") {
                    if ((CSVImport.importCsvLookup)[tabularData[i][idIndex]] == null) 
                        (CSVImport.importCsvLookup)[tabularData[i][idIndex]] = data.shortId();
                } else if (fileId != null && fileId != undefined && fileId != "") {
                    if ((CSVImport.importCsvLookup)[fileId] == null) 
                        (CSVImport.importCsvLookup)[fileId] = data.shortId();
                    shortId = EcRemoteLinkedData.trimVersionFromUrl(fileId);
                    if ((CSVImport.importCsvLookup)[shortId] == null) 
                        (CSVImport.importCsvLookup)[shortId] = data.shortId();
                }
                objects.push(data);
            }
            CSVImport.saved = 0;
            for (var i = 0; i < objects.length; i++) {
                var data = objects[i];
                CSVImport.transformReferences(data);
                CSVImport.saveTransformedData(data, incremental, objects, success, failure, repo);
            }
        }, error: failure});
    };
    constructor.saveTransformedData = function(data, incremental, objects, success, failure, repo) {
        Task.asyncImmediate(function(o) {
            var keepGoing = o;
            var scs = function(results) {
                CSVImport.saved++;
                if (CSVImport.saved % CSVImport.INCREMENTAL_STEP == 0) 
                    incremental(CSVImport.saved);
                if (CSVImport.saved == objects.length) 
                    success(objects);
                keepGoing();
            };
            var err = function(results) {
                failure("Failed to save object");
                keepGoing();
            };
            if (repo == null) 
                EcRepository.save(data, scs, err);
             else 
                repo.saveTo(data, scs, err);
        });
    };
}, {importCsvLookup: "Object", progressObject: "Object"}, {});
var CTDLASNCSVImport = function() {};
CTDLASNCSVImport = stjs.extend(CTDLASNCSVImport, null, [], function(constructor, prototype) {
    constructor.analyzeFile = function(file, success, failure) {
        if (file == null) {
            failure("No file to analyze");
            return;
        }
        if ((file)["name"] == null) {
            failure("Invalid file");
        } else if (!((file)["name"]).endsWith(".csv")) {
            failure("Invalid file type");
        }
        Papa.parse(file, {encoding: "UTF-8", complete: function(results) {
            var tabularData = (results)["data"];
            var colNames = tabularData[0];
            var nameToCol = new Object();
            for (var i = 0; i < colNames.length; i++) 
                (nameToCol)[colNames[i]] = i;
            var frameworkCounter = 0;
            var competencyCounter = 0;
            var typeCol = (nameToCol)["@type"];
            if (typeCol == null) {
                this.error("No @type in CSV.");
                return;
            }
            for (var i = 0; i < tabularData.length; i++) {
                if (i == 0) 
                    continue;
                var col = tabularData[i];
                if (col[typeCol] != null && col[typeCol].trim() == "ceasn:CompetencyFramework") 
                    frameworkCounter++;
                 else if (col[typeCol] != null && col[typeCol].trim() == "ceasn:Competency") 
                    competencyCounter++;
                 else if (col[typeCol] == null || col[typeCol] == "") 
                    continue;
                 else {
                    this.error("Found unknown type:" + col[typeCol]);
                    return;
                }
            }
            success(frameworkCounter, competencyCounter);
        }, error: failure});
    };
    constructor.importFrameworksAndCompetencies = function(repo, file, success, failure, ceo, endpoint) {
        if (file == null) {
            failure("No file to analyze");
            return;
        }
        if ((file)["name"] == null) {
            failure("Invalid file");
        } else if (!((file)["name"]).endsWith(".csv")) {
            failure("Invalid file type");
        }
        Papa.parse(file, {header: true, encoding: "UTF-8", complete: function(results) {
            var tabularData = (results)["data"];
            var frameworks = new Object();
            var frameworkArray = new Array();
            var frameworkRows = new Object();
            var competencies = new Array();
            var competencyRows = new Object();
            var relations = new Array();
            var relationById = new Object();
            new EcAsyncHelper().each(tabularData, function(pretranslatedE, callback0) {
                if ((pretranslatedE)["@type"] == "ceasn:CompetencyFramework") {
                    var translator = new EcLinkedData(null, null);
                    translator.copyFrom(pretranslatedE);
                    CTDLASNCSVImport.cleanUpTranslator(translator, endpoint, repo);
                    translator.recast("https://schema.cassproject.org/0.4/ceasn2cass", "https://schema.cassproject.org/0.4", function(e) {
                        var f = new EcFramework();
                        f.copyFrom(e);
                        if (EcFramework.template != null) {
                            for (var key in (EcFramework.template)) {
                                if (key.equals("@owner")) {
                                    (f)["owner"] = (EcFramework.template)[key];
                                } else {
                                    (f)[key] = (EcFramework.template)[key];
                                }
                            }
                        }
                        if ((e)["owner"] != null) {
                            var id = new EcIdentity();
                            id.ppk = EcPpk.fromPem((e)["owner"]);
                            f.addOwner(id.ppk.toPk());
                            EcIdentityManager.addIdentityQuietly(id);
                        }
                        if (ceo != null) 
                            f.addOwner(ceo.ppk.toPk());
                        if (EcFramework.template != null && (EcFramework.template)[("schema:dateCreated")] != null) {
                            CTDLASNCSVImport.setDateCreated(e, f);
                        }
                        (frameworks)[f.shortId()] = f;
                        (frameworkRows)[f.shortId()] = e;
                        (f)["ceasn:hasChild"] = null;
                        (f)["ceasn:hasTopChild"] = null;
                        frameworkArray.push(f);
                        f.competency = new Array();
                        f.relation = new Array();
                        callback0();
                    }, failure);
                } else if ((pretranslatedE)["@type"] == "ceasn:Competency") {
                    var translator = new EcLinkedData(null, null);
                    translator.copyFrom(pretranslatedE);
                    CTDLASNCSVImport.cleanUpTranslator(translator, endpoint, repo);
                    translator.recast("https://schema.cassproject.org/0.4/ceasn2cass", "https://schema.cassproject.org/0.4", function(e) {
                        var f = new EcCompetency();
                        f.copyFrom(e);
                        if ((e)["id"] == null) {
                            callback0();
                            return;
                        }
                        if ((e)["ceasn:isPartOf"] != null) {
                            ((frameworks)[(e)["ceasn:isPartOf"]]).competency.push(f.shortId());
                        } else {
                            var parent = e;
                            var done = false;
                             while (!done && parent != null){
                                if ((parent)["ceasn:isChildOf"] != null && (parent)["ceasn:isChildOf"] != "") {
                                    parent = (competencyRows)[(parent)["ceasn:isChildOf"]];
                                } else if ((parent)["ceasn:isTopChildOf"] != null && (parent)["ceasn:isTopChildOf"] != "") {
                                    parent = (frameworkRows)[(parent)["ceasn:isTopChildOf"]];
                                    done = true;
                                }
                            }
                            if (!done) {
                                failure("Could not find framework:" + (e)["type"]);
                                return;
                            }
                            if (parent != null) {
                                if ((parent)["type"] == "Framework") {
                                    (e)["ceasn:isPartOf"] = EcRemoteLinkedData.trimVersionFromUrl((parent)["id"]);
                                    ((frameworks)[EcRemoteLinkedData.trimVersionFromUrl((parent)["id"])]).competency.push(f.shortId());
                                } else {
                                    failure("Object cannot trace to framework:" + (e)["type"]);
                                    return;
                                }
                            } else {
                                failure("Object has no framework:" + (e)["type"]);
                                return;
                            }
                        }
                        if (EcCompetency.template != null && (EcCompetency.template)["@owner"] != null) {
                            (f)["owner"] = (EcCompetency.template)["@owner"];
                        }
                        if ((e)["owner"] == null) {
                            if (((frameworkRows)[(e)["ceasn:isPartOf"]])["owner"] != null) 
                                (e)["owner"] = ((frameworkRows)[(e)["ceasn:isPartOf"]])["owner"];
                        }
                        var id = new EcIdentity();
                        if ((e)["owner"] != null) {
                            id.ppk = EcPpk.fromPem((e)["owner"]);
                            if (id.ppk != null) 
                                f.addOwner(id.ppk.toPk());
                            EcIdentityManager.addIdentityQuietly(id);
                        }
                        if (ceo != null) 
                            f.addOwner(ceo.ppk.toPk());
                        if (EcCompetency.template != null && (EcCompetency.template)[("schema:dateCreated")] != null) {
                            CTDLASNCSVImport.setDateCreated(e, f);
                        }
                        if ((e)["ceasn:isChildOf"] != null) {
                            CTDLASNCSVImport.createEachRelation(e, "ceasn:isChildOf", Relation.NARROWS, repo, ceo, id, relations, relationById, frameworks, -1, endpoint);
                        }
                        if ((e)["ceasn:broadAlignment"] != null) {
                            CTDLASNCSVImport.createRelations(e, "ceasn:broadAlignment", Relation.NARROWS, repo, ceo, id, relations, relationById, frameworks, endpoint);
                        }
                        if ((e)["ceasn:narrowAlignment"] != null) {
                            CTDLASNCSVImport.createRelations(e, "ceasn:narrowAlignment", Relation.NARROWS, repo, ceo, id, relations, relationById, frameworks, endpoint);
                        }
                        if ((e)["sameAs"] != null) {
                            CTDLASNCSVImport.createRelations(e, "sameAs", Relation.IS_EQUIVALENT_TO, repo, ceo, id, relations, relationById, frameworks, endpoint);
                        }
                        if ((e)["ceasn:majorAlignment"] != null) {
                            CTDLASNCSVImport.createRelations(e, "ceasn:majorAlignment", "majorRelated", repo, ceo, id, relations, relationById, frameworks, endpoint);
                        }
                        if ((e)["ceasn:minorAlignment"] != null) {
                            CTDLASNCSVImport.createRelations(e, "ceasn:minorAlignment", "minorRelated", repo, ceo, id, relations, relationById, frameworks, endpoint);
                        }
                        if ((e)["ceasn:prerequisiteAlignment"] != null) {
                            CTDLASNCSVImport.createRelations(e, "ceasn:prerequisiteAlignment", Relation.REQUIRES, repo, ceo, id, relations, relationById, frameworks, endpoint);
                        }
                        (f)["ceasn:isTopChildOf"] = null;
                        (f)["ceasn:isChildOf"] = null;
                        (f)["ceasn:isPartOf"] = null;
                        (f)["ceasn:broadAlignment"] = null;
                        (f)["ceasn:narrowAlignment"] = null;
                        (f)["sameAs"] = null;
                        (f)["ceasn:majorAlignment"] = null;
                        (f)["ceasn:minorAlignment"] = null;
                        (f)["ceasn:prerequisiteAlignment"] = null;
                        (f)["ceasn:hasChild"] = null;
                        competencies.push(f);
                        (competencyRows)[f.shortId()] = e;
                        callback0();
                    }, failure);
                } else if ((pretranslatedE)["@type"] == null || (pretranslatedE)["@type"] == "") {
                    callback0();
                    return;
                } else {
                    failure("Found unknown type:" + (pretranslatedE)["@type"]);
                    callback0();
                    return;
                }
            }, function(strings) {
                success(frameworkArray, competencies, relations);
            });
        }, error: failure});
    };
    constructor.getIdFromCtid = function(ctid, endpoint, repo, context, type, key) {
        if (key != "id") {
            if (key == "ceasn:isPartOf" || key == "ceasn:isTopChildOf") {
                if (type == "Competency") {
                    type = "Framework";
                } else if (type == "Concept") {
                    type = "ConceptScheme";
                }
            } else {
                if (type == "Framework") {
                    type = "Competency";
                } else if (type == "ConceptScheme") {
                    type = "Concept";
                }
            }
        }
        if (endpoint != null) {
            if (endpoint.indexOf("ce-") != -1) {
                ctid = ctid.substring(3);
            }
            return endpoint + ctid;
        } else {
            ctid = ctid.substring(3);
            var obj = new EcRemoteLinkedData(context, type);
            obj.assignId(repo.selectedServer, ctid);
            if (key == "id") {
                return obj.id;
            } else {
                return obj.shortId();
            }
        }
    };
    constructor.cleanUpTranslator = function(translator, endpoint, repo) {
        var context = null;
        var type = null;
        if ((translator)["type"] == "ceasn:CompetencyFramework") {
            context = "https://schema.cassproject.org/0.4/";
            type = "Framework";
        } else if ((translator)["type"] == "ceasn:Competency") {
            context = "https://schema.cassproject.org/0.4/";
            type = "Competency";
        } else if ((translator)["type"] == "ceasn:ConceptScheme") {
            context = "https://schema.cassproject.org/0.4/skos/";
            type = "ConceptScheme";
        } else if ((translator)["type"] == "ceasn:Concept") {
            context = "https://schema.cassproject.org/0.4/skos/";
            type = "Concept";
        }
        for (var key in (translator)) {
            if ((translator)[key] == "") {
                (translator)[key] = null;
            } else if ((translator)[key] != null) {
                var thisKey = (translator)[key];
                if ((typeof thisKey) == "string") {
                    if (((translator)[key]).trim().length == 0) {
                        (translator)[key] = null;
                    } else if ((thisKey).indexOf("|") != -1) {
                        thisKey = (thisKey).split("|");
                        (translator)[key] = thisKey;
                        for (var i = 0; i < (thisKey).length; i++) {
                            if ((thisKey)[i] != (thisKey)[i].trim()) {
                                var thisVal = (thisKey)[i].trim();
                                (thisKey)[i] = thisVal;
                            }
                        }
                    } else if ((thisKey).startsWith("ce-") && key != "ceterms:ctid") {
                        var id = CTDLASNCSVImport.getIdFromCtid(thisKey, endpoint, repo, context, type, key);
                        (translator)[key] = id;
                    }
                } else if (EcArray.isArray(thisKey)) {
                    for (var i = 0; i < (thisKey).length; i++) {
                        if ((typeof (thisKey)[i]) == "string" && ((thisKey)[i]).startsWith("ce-")) {
                            var id = CTDLASNCSVImport.getIdFromCtid((thisKey)[i], endpoint, repo, context, type, key);
                            (thisKey)[i] = id;
                        }
                    }
                }
                if (key != key.trim()) {
                    var trimKey = key.trim();
                    (translator)[trimKey] = (translator)[key];
                    (translator)[key] = null;
                }
            }
        }
    };
    constructor.createRelations = function(e, field, type, repo, ceo, id, relations, relationById, frameworks, endpoint) {
        if (!EcArray.isArray((e)[field])) {
            var makeArray = Array((e)[field]);
            (e)[field] = makeArray;
        }
        for (var i = 0; i < ((e)[field]).length; i++) {
            CTDLASNCSVImport.createEachRelation(e, field, type, repo, ceo, id, relations, relationById, frameworks, i, endpoint);
        }
    };
    constructor.createEachRelation = function(e, field, type, repo, ceo, id, relations, relationById, frameworks, i, endpoint) {
        var r = new EcAlignment();
        if (endpoint != null) {
            r.generateShortId(endpoint);
        } else {
            r.generateId(repo.selectedServer);
        }
        if (ceo != null) 
            r.addOwner(ceo.ppk.toPk());
        if (id.ppk != null) 
            r.addOwner(id.ppk.toPk());
        r.relationType = type;
        if (field == "ceasn:narrowAlignment") {
            var sourceId = ((e)[field])[i];
            if (sourceId.startsWith("ce-")) {
                sourceId = CTDLASNCSVImport.getIdFromCtid(sourceId, endpoint, repo, "https://schema.cassproject.org/0.4/", "Competency", field);
            }
            r.source = EcRemoteLinkedData.trimVersionFromUrl(sourceId);
            r.target = EcRemoteLinkedData.trimVersionFromUrl((e)["id"]);
        } else {
            r.source = EcRemoteLinkedData.trimVersionFromUrl((e)["id"]);
            if (i != -1) {
                var targetId = ((e)[field])[i];
                if (targetId.startsWith("ce-")) {
                    targetId = CTDLASNCSVImport.getIdFromCtid(targetId, endpoint, repo, "https://schema.cassproject.org/0.4/", "Competency", field);
                }
                r.target = EcRemoteLinkedData.trimVersionFromUrl(targetId);
            } else {
                var targetId = ((e)[field]);
                if (targetId.startsWith("ce-")) {
                    targetId = CTDLASNCSVImport.getIdFromCtid(targetId, endpoint, repo, "https://schema.cassproject.org/0.4/", "Competency", field);
                }
                r.target = EcRemoteLinkedData.trimVersionFromUrl(targetId);
            }
        }
        relations.push(r);
        (relationById)[r.shortId()] = r;
        ((frameworks)[(e)["ceasn:isPartOf"]]).relation.push(r.shortId());
    };
    constructor.setDateCreated = function(importObject, object) {
        if ((importObject)["ceasn:dateCreated"] == null && (importObject)["schema:dateCreated"] == null) {
            var timestamp = object.getTimestamp();
            var date;
            if (timestamp != null) {
                date = new Date(parseInt(timestamp)).toISOString();
            } else {
                date = new Date().toISOString();
            }
            (object)["schema:dateCreated"] = date;
        }
    };
}, {}, {});
var CTDLASNCSVConceptImport = function() {};
CTDLASNCSVConceptImport = stjs.extend(CTDLASNCSVConceptImport, null, [], function(constructor, prototype) {
    constructor.analyzeFile = function(file, success, failure) {
        if (file == null) {
            failure("No file to analyze");
            return;
        }
        if ((file)["name"] == null) {
            failure("Invalid file");
        } else if (!((file)["name"]).endsWith(".csv")) {
            failure("Invalid file type");
        }
        Papa.parse(file, {encoding: "UTF-8", complete: function(results) {
            var tabularData = (results)["data"];
            var colNames = tabularData[0];
            var nameToCol = new Object();
            for (var i = 0; i < colNames.length; i++) 
                (nameToCol)[colNames[i]] = i;
            var conceptSchemeCounter = 0;
            var conceptCounter = 0;
            var typeCol = (nameToCol)["@type"];
            if (typeCol == null) {
                this.error("No @type in CSV.");
                return;
            }
            for (var i = 0; i < tabularData.length; i++) {
                if (i == 0) 
                    continue;
                var col = tabularData[i];
                if (col[typeCol] == "skos:ConceptScheme") 
                    conceptSchemeCounter++;
                 else if (col[typeCol] == "skos:Concept") 
                    conceptCounter++;
                 else if (col[typeCol] == null || col[typeCol] == "") 
                    continue;
                 else {
                    this.error("Found unknown type:" + col[typeCol]);
                    return;
                }
            }
            success(conceptSchemeCounter, conceptCounter);
        }, error: failure});
    };
    constructor.importFrameworksAndCompetencies = function(repo, file, success, failure, ceo, endpoint) {
        if (file == null) {
            failure("No file to analyze");
            return;
        }
        if ((file)["name"] == null) {
            failure("Invalid file");
        } else if (!((file)["name"]).endsWith(".csv")) {
            failure("Invalid file type");
        }
        Papa.parse(file, {header: true, encoding: "UTF-8", complete: function(results) {
            var tabularData = (results)["data"];
            var schemeArray = new Array();
            var concepts = new Array();
            new EcAsyncHelper().each(tabularData, function(pretranslatedE, callback0) {
                if ((pretranslatedE)["@type"] == "skos:ConceptScheme") {
                    var translator = new EcLinkedData(null, null);
                    translator.copyFrom(pretranslatedE);
                    CTDLASNCSVImport.cleanUpTranslator(translator, endpoint, repo);
                    if ((translator)["ceasn:name"] != null) {
                        var name = (translator)["ceasn:name"];
                        var nameWithLanguage = new Object();
                        (nameWithLanguage)["en-US"] = name;
                        (translator)["ceasn:name"] = nameWithLanguage;
                    }
                    translator.recast("https://schema.cassproject.org/0.4/ceasn2cassConcepts", "https://schema.cassproject.org/0.4/skos", function(e) {
                        var f = new EcConceptScheme();
                        f.copyFrom(e);
                        if (EcConceptScheme.template != null) {
                            for (var key in (EcConceptScheme.template)) {
                                if (key.equals("@owner")) {
                                    (f)["owner"] = (EcConceptScheme.template)[key];
                                } else {
                                    (f)[key] = (EcConceptScheme.template)[key];
                                }
                            }
                        }
                        if ((e)["owner"] != null) {
                            var id = new EcIdentity();
                            id.ppk = EcPpk.fromPem((e)["owner"]);
                            f.addOwner(id.ppk.toPk());
                            EcIdentityManager.addIdentityQuietly(id);
                        }
                        if (ceo != null) 
                            f.addOwner(ceo.ppk.toPk());
                        (f)["schema:dateModified"] = new Date().toISOString();
                        if (EcConceptScheme.template != null && (EcConceptScheme.template)[("schema:dateCreated")] != null) {
                            CTDLASNCSVImport.setDateCreated(e, f);
                        }
                        schemeArray.push(f);
                        callback0();
                    }, failure);
                } else if ((pretranslatedE)["@type"] == "skos:Concept") {
                    var translator = new EcLinkedData(null, null);
                    translator.copyFrom(pretranslatedE);
                    CTDLASNCSVImport.cleanUpTranslator(translator, endpoint, repo);
                    if ((translator)["skos:prefLabel"] != null) {
                        var name = (translator)["skos:prefLabel"];
                        var nameWithLanguage = new Object();
                        (nameWithLanguage)["en-US"] = name;
                        (translator)["skos:prefLabel"] = nameWithLanguage;
                    }
                    translator.recast("https://schema.cassproject.org/0.4/ceasn2cassConcepts", "https://schema.cassproject.org/0.4/skos", function(e) {
                        var f = new EcConcept();
                        f.copyFrom(e);
                        if ((e)["id"] == null) {
                            callback0();
                            return;
                        }
                        if (EcConcept.template != null && (EcConcept.template)["@owner"] != null) {
                            (f)["owner"] = (EcConcept.template)["@owner"];
                        }
                        if ((e)["owner"] != null) {
                            var id = new EcIdentity();
                            id.ppk = EcPpk.fromPem((e)["owner"]);
                            if (id.ppk != null) 
                                f.addOwner(id.ppk.toPk());
                            EcIdentityManager.addIdentityQuietly(id);
                        }
                        if (ceo != null) 
                            f.addOwner(ceo.ppk.toPk());
                        if (EcConcept.template != null && (EcConcept.template)[("schema:dateCreated")] != null) {
                            CTDLASNCSVImport.setDateCreated(e, f);
                        }
                        if ((e)["skos:narrower"] != null) {
                            var relation = (e)["skos:narrower"];
                            if (!EcArray.isArray(relation)) {
                                var array = [relation];
                                (f)["skos:narrower"] = array;
                            }
                        }
                        if ((e)["skos:broader"] != null) {
                            var relation = (e)["skos:broader"];
                            if (!EcArray.isArray(relation)) {
                                var array = [relation];
                                (f)["skos:broader"] = array;
                            }
                        }
                        if ((e)["skos:broadMatch"] != null) {
                            var relation = (e)["skos:broadMatch"];
                            if (!EcArray.isArray(relation)) {
                                var array = [relation];
                                (f)["skos:broadMatch"] = array;
                            }
                        }
                        if ((e)["skos:closeMatch"] != null) {
                            var relation = (e)["skos:closeMatch"];
                            if (!EcArray.isArray(relation)) {
                                var array = [relation];
                                (f)["skos:closeMatch"] = array;
                            }
                        }
                        if ((e)["skos:exactMatch"] != null) {
                            var relation = (e)["skos:exactMatch"];
                            if (!EcArray.isArray(relation)) {
                                var array = [relation];
                                (f)["skos:exactMatch"] = array;
                            }
                        }
                        if ((e)["skos:narrowMatch"] != null) {
                            var relation = (e)["skos:narrowMatch"];
                            if (!EcArray.isArray(relation)) {
                                var array = [relation];
                                (f)["skos:narrowMatch"] = array;
                            }
                        }
                        if ((e)["skos:related"] != null) {
                            var relation = (e)["skos:related"];
                            if (!EcArray.isArray(relation)) {
                                var array = [relation];
                                (f)["skos:related"] = array;
                            }
                        }
                        if ((e)["skos:topConceptOf"] != null) {
                            var scheme = (e)["skos:topConceptOf"];
                            for (var i = 0; i < schemeArray.length; i++) {
                                var schemeObj = schemeArray[i];
                                if (scheme == (schemeObj)["id"]) {
                                    if ((schemeObj)["skos:hasTopConcept"] == null) {
                                        var hasTopConcept = new Array();
                                        (schemeObj)["skos:hasTopConcept"] = hasTopConcept;
                                    }
                                    var conceptId = f.shortId();
                                    EcArray.setAdd((schemeObj)["skos:hasTopConcept"], conceptId);
                                }
                            }
                        }
                        (f)["schema:dateModified"] = new Date().toISOString();
                        concepts.push(f);
                        callback0();
                    }, failure);
                } else if ((pretranslatedE)["@type"] == null || (pretranslatedE)["@type"] == "") {
                    callback0();
                    return;
                } else {
                    this.error("Found unknown type:" + (pretranslatedE)["@type"]);
                    callback0();
                    return;
                }
            }, function(strings) {
                success(schemeArray, concepts);
            });
        }, error: failure});
    };
}, {}, {});


global.Callback5 = Callback5
global.Hypergraph = Hypergraph
global.EcDate = EcDate
global.EcArray = EcArray
global.Triple = Triple
global.EcRemote = EcRemote
global.EcBrowserDetection = EcBrowserDetection
global.EcLocalStorage = EcLocalStorage
global.Graph = Graph
global.EcObject = EcObject
global.Task = Task
global.EcDirectedGraph = EcDirectedGraph
global.EcAsyncHelper = EcAsyncHelper
global.CryptoKey = CryptoKey
global.AlgorithmIdentifier = AlgorithmIdentifier
global.jwk = jwk
global.EcPk = EcPk
global.EcAes = EcAes
global.EcCrypto = EcCrypto
global.EcAesParameters = EcAesParameters
global.SubtleCrypto = SubtleCrypto
global.EcPpk = EcPpk
global.EcRsaOaep = EcRsaOaep
global.EcAesCtr = EcAesCtr
global.EcRsaOaepAsyncWorker = EcRsaOaepAsyncWorker
global.EcAesCtrAsyncWorker = EcAesCtrAsyncWorker
global.EcRsaOaepAsync = EcRsaOaepAsync
global.EcAesCtrAsync = EcAesCtrAsync
global.EcLinkedData = EcLinkedData
global.Ebac = Ebac
global.General = General
global.EcRemoteLinkedData = EcRemoteLinkedData
global.Thing = Thing
global.SchemaEvent = SchemaEvent
global.Place = Place
global.Person = Person
global.Action = Action
global.Organization = Organization
global.Intangible = Intangible
global.Product = Product
global.CreativeWork = CreativeWork
global.BusinessEvent = BusinessEvent
global.SaleEvent = SaleEvent
global.TheaterEvent = TheaterEvent
global.EducationEvent = EducationEvent
global.SocialEvent = SocialEvent
global.LiteraryEvent = LiteraryEvent
global.DanceEvent = DanceEvent
global.UserInteraction = UserInteraction
global.DeliveryEvent = DeliveryEvent
global.PublicationEvent = PublicationEvent
global.ScreeningEvent = ScreeningEvent
global.ChildrensEvent = ChildrensEvent
global.VisualArtsEvent = VisualArtsEvent
global.MusicEvent = MusicEvent
global.Festival = Festival
global.CourseInstance = CourseInstance
global.ComedyEvent = ComedyEvent
global.SportsEvent = SportsEvent
global.ExhibitionEvent = ExhibitionEvent
global.FoodEvent = FoodEvent
global.AdministrativeArea = AdministrativeArea
global.CivicStructure = CivicStructure
global.TouristAttraction = TouristAttraction
global.LandmarksOrHistoricalBuildings = LandmarksOrHistoricalBuildings
global.Accommodation = Accommodation
global.Landform = Landform
global.Residence = Residence
global.UpdateAction = UpdateAction
global.TradeAction = TradeAction
global.TransferAction = TransferAction
global.MoveAction = MoveAction
global.InteractAction = InteractAction
global.PlayAction = PlayAction
global.OrganizeAction = OrganizeAction
global.ControlAction = ControlAction
global.AssessAction = AssessAction
global.ConsumeAction = ConsumeAction
global.SearchAction = SearchAction
global.CreateAction = CreateAction
global.AchieveAction = AchieveAction
global.FindAction = FindAction
global.SportsOrganization = SportsOrganization
global.PerformingGroup = PerformingGroup
global.GovernmentOrganization = GovernmentOrganization
global.Corporation = Corporation
global.Airline = Airline
global.EducationalOrganization = EducationalOrganization
global.MedicalOrganization = MedicalOrganization
global.NGO = NGO
global.LocalBusiness = LocalBusiness
global.JobPosting = JobPosting
global.Demand = Demand
global.BedDetails = BedDetails
global.Language = Language
global.Quantity = Quantity
global.DigitalDocumentPermission = DigitalDocumentPermission
global.OrderItem = OrderItem
global.EntryPoint = EntryPoint
global.Invoice = Invoice
global.StructuredValue = StructuredValue
global.Flight = Flight
global.Rating = Rating
global.Order = Order
global.Audience = Audience
global.ComputerLanguage = ComputerLanguage
global.Seat = Seat
global.ItemList = ItemList
global.ParcelDelivery = ParcelDelivery
global.Role = Role
global.AlignmentObject = AlignmentObject
global.Enumeration = Enumeration
global.DataFeedItem = DataFeedItem
global.BusTrip = BusTrip
global.ServiceChannel = ServiceChannel
global.ListItem = ListItem
global.Service = Service
global.GameServer = GameServer
global.TrainTrip = TrainTrip
global.ProgramMembership = ProgramMembership
global.PropertyValueSpecification = PropertyValueSpecification
global.Ticket = Ticket
global.MenuItem = MenuItem
global.BroadcastChannel = BroadcastChannel
global.Permit = Permit
global.Brand = Brand
global.Offer = Offer
global.Reservation = Reservation
global.SomeProducts = SomeProducts
global.ProductModel = ProductModel
global.Vehicle = Vehicle
global.IndividualProduct = IndividualProduct
global.DigitalDocument = DigitalDocument
global.Season = Season
global.Clip = Clip
global.SchemaMap = SchemaMap
global.Menu = Menu
global.Code = Code
global.Painting = Painting
global.Game = Game
global.WebSite = WebSite
global.SoftwareApplication = SoftwareApplication
global.Question = Question
global.Dataset = Dataset
global.VisualArtwork = VisualArtwork
global.Article = Article
global.TVSeries = TVSeries
global.MusicPlaylist = MusicPlaylist
global.Recipe = Recipe
global.MenuSection = MenuSection
global.Sculpture = Sculpture
global.Blog = Blog
global.MusicRecording = MusicRecording
global.SoftwareSourceCode = SoftwareSourceCode
global.WebPageElement = WebPageElement
global.Comment = Comment
global.DataCatalog = DataCatalog
global.MusicComposition = MusicComposition
global.Movie = Movie
global.Message = Message
global.Photograph = Photograph
global.PublicationVolume = PublicationVolume
global.Review = Review
global.Episode = Episode
global.TVSeason = TVSeason
global.MediaObject = MediaObject
global.Conversation = Conversation
global.PublicationIssue = PublicationIssue
global.Course = Course
global.WebPage = WebPage
global.CreativeWorkSeries = CreativeWorkSeries
global.Book = Book
global.CreativeWorkSeason = CreativeWorkSeason
global.Series = Series
global.UserComments = UserComments
global.UserCheckins = UserCheckins
global.UserLikes = UserLikes
global.UserBlocks = UserBlocks
global.UserPlays = UserPlays
global.UserPlusOnes = UserPlusOnes
global.UserPageVisits = UserPageVisits
global.UserDownloads = UserDownloads
global.UserTweets = UserTweets
global.BroadcastEvent = BroadcastEvent
global.OnDemandEvent = OnDemandEvent
global.State = State
global.Country = Country
global.City = City
global.TaxiStand = TaxiStand
global.Hospital = Hospital
global.Museum = Museum
global.RVPark = RVPark
global.Aquarium = Aquarium
global.Airport = Airport
global.Beach = Beach
global.EventVenue = EventVenue
global.ParkingFacility = ParkingFacility
global.GovernmentBuilding = GovernmentBuilding
global.Campground = Campground
global.MovieTheater = MovieTheater
global.PlaceOfWorship = PlaceOfWorship
global.BusStop = BusStop
global.FireStation = FireStation
global.Bridge = Bridge
global.Cemetery = Cemetery
global.BusStation = BusStation
global.Crematorium = Crematorium
global.TrainStation = TrainStation
global.PoliceStation = PoliceStation
global.Zoo = Zoo
global.PerformingArtsTheater = PerformingArtsTheater
global.MusicVenue = MusicVenue
global.Playground = Playground
global.Park = Park
global.SubwayStation = SubwayStation
global.Apartment = Apartment
global.Room = Room
global.House = House
global.Suite = Suite
global.CampingPitch = CampingPitch
global.Continent = Continent
global.BodyOfWater = BodyOfWater
global.Volcano = Volcano
global.Mountain = Mountain
global.ApartmentComplex = ApartmentComplex
global.GatedResidenceCommunity = GatedResidenceCommunity
global.AddAction = AddAction
global.ReplaceAction = ReplaceAction
global.DeleteAction = DeleteAction
global.DonateAction = DonateAction
global.OrderAction = OrderAction
global.SellAction = SellAction
global.BuyAction = BuyAction
global.TipAction = TipAction
global.PayAction = PayAction
global.RentAction = RentAction
global.QuoteAction = QuoteAction
global.GiveAction = GiveAction
global.ReceiveAction = ReceiveAction
global.BorrowAction = BorrowAction
global.DownloadAction = DownloadAction
global.SendAction = SendAction
global.TakeAction = TakeAction
global.LendAction = LendAction
global.ReturnAction = ReturnAction
global.DepartAction = DepartAction
global.TravelAction = TravelAction
global.ArriveAction = ArriveAction
global.BefriendAction = BefriendAction
global.MarryAction = MarryAction
global.SubscribeAction = SubscribeAction
global.UnRegisterAction = UnRegisterAction
global.RegisterAction = RegisterAction
global.FollowAction = FollowAction
global.LeaveAction = LeaveAction
global.JoinAction = JoinAction
global.CommunicateAction = CommunicateAction
global.PerformAction = PerformAction
global.ExerciseAction = ExerciseAction
global.ApplyAction = ApplyAction
global.BookmarkAction = BookmarkAction
global.AllocateAction = AllocateAction
global.PlanAction = PlanAction
global.ActivateAction = ActivateAction
global.DeactivateAction = DeactivateAction
global.ResumeAction = ResumeAction
global.SuspendAction = SuspendAction
global.ReviewAction = ReviewAction
global.IgnoreAction = IgnoreAction
global.ChooseAction = ChooseAction
global.ReactAction = ReactAction
global.UseAction = UseAction
global.ReadAction = ReadAction
global.DrinkAction = DrinkAction
global.ViewAction = ViewAction
global.WatchAction = WatchAction
global.InstallAction = InstallAction
global.ListenAction = ListenAction
global.EatAction = EatAction
global.CookAction = CookAction
global.PaintAction = PaintAction
global.PhotographAction = PhotographAction
global.FilmAction = FilmAction
global.WriteAction = WriteAction
global.DrawAction = DrawAction
global.WinAction = WinAction
global.LoseAction = LoseAction
global.TieAction = TieAction
global.CheckAction = CheckAction
global.TrackAction = TrackAction
global.DiscoverAction = DiscoverAction
global.SportsTeam = SportsTeam
global.DanceGroup = DanceGroup
global.TheaterGroup = TheaterGroup
global.MusicGroup = MusicGroup
global.Preschool = Preschool
global.MiddleSchool = MiddleSchool
global.ElementarySchool = ElementarySchool
global.HighSchool = HighSchool
global.CollegeOrUniversity = CollegeOrUniversity
global.School = School
global.Dentist = Dentist
global.Pharmacy = Pharmacy
global.Physician = Physician
global.GovernmentOffice = GovernmentOffice
global.SelfStorage = SelfStorage
global.RealEstateAgent = RealEstateAgent
global.FoodEstablishment = FoodEstablishment
global.TouristInformationCenter = TouristInformationCenter
global.EmploymentAgency = EmploymentAgency
global.ChildCare = ChildCare
global.SportsActivityLocation = SportsActivityLocation
global.LegalService = LegalService
global.HealthAndBeautyBusiness = HealthAndBeautyBusiness
global.TelevisionStation = TelevisionStation
global.LodgingBusiness = LodgingBusiness
global.FinancialService = FinancialService
global.Store = Store
global.ShoppingCenter = ShoppingCenter
global.AutomotiveBusiness = AutomotiveBusiness
global.EntertainmentBusiness = EntertainmentBusiness
global.Library = Library
global.RecyclingCenter = RecyclingCenter
global.InternetCafe = InternetCafe
global.AnimalShelter = AnimalShelter
global.EmergencyService = EmergencyService
global.HomeAndConstructionBusiness = HomeAndConstructionBusiness
global.TravelAgency = TravelAgency
global.RadioStation = RadioStation
global.DryCleaningOrLaundry = DryCleaningOrLaundry
global.ProfessionalService = ProfessionalService
global.Mass = Mass
global.Energy = Energy
global.Duration = Duration
global.Distance = Distance
global.GeoCoordinates = GeoCoordinates
global.PropertyValue = PropertyValue
global.NutritionInformation = NutritionInformation
global.QuantitativeValue = QuantitativeValue
global.WarrantyPromise = WarrantyPromise
global.InteractionCounter = InteractionCounter
global.OwnershipInfo = OwnershipInfo
global.PriceSpecification = PriceSpecification
global.GeoShape = GeoShape
global.OpeningHoursSpecification = OpeningHoursSpecification
global.DatedMoneySpecification = DatedMoneySpecification
global.ContactPoint = ContactPoint
global.MonetaryAmount = MonetaryAmount
global.TypeAndQuantityNode = TypeAndQuantityNode
global.EngineSpecification = EngineSpecification
global.AggregateRating = AggregateRating
global.BusinessAudience = BusinessAudience
global.EducationalAudience = EducationalAudience
global.PeopleAudience = PeopleAudience
global.OfferCatalog = OfferCatalog
global.BreadcrumbList = BreadcrumbList
global.PerformanceRole = PerformanceRole
global.OrganizationRole = OrganizationRole
global.ItemListOrderType = ItemListOrderType
global.DayOfWeek = DayOfWeek
global.RestrictedDiet = RestrictedDiet
global.ReservationStatusType = ReservationStatusType
global.PaymentStatusType = PaymentStatusType
global.ActionStatusType = ActionStatusType
global.MapCategoryType = MapCategoryType
global.GenderType = GenderType
global.BusinessFunction = BusinessFunction
global.PaymentMethod = PaymentMethod
global.MusicAlbumProductionType = MusicAlbumProductionType
global.ItemAvailability = ItemAvailability
global.OrderStatus = OrderStatus
global.RsvpResponseType = RsvpResponseType
global.EventStatusType = EventStatusType
global.ContactPointOption = ContactPointOption
global.Specialty = Specialty
global.MusicReleaseFormatType = MusicReleaseFormatType
global.DeliveryMethod = DeliveryMethod
global.MusicAlbumReleaseType = MusicAlbumReleaseType
global.WarrantyScope = WarrantyScope
global.DigitalDocumentPermissionType = DigitalDocumentPermissionType
global.OfferItemCondition = OfferItemCondition
global.GameServerStatus = GameServerStatus
global.BoardingPolicyType = BoardingPolicyType
global.QualitativeValue = QualitativeValue
global.BusinessEntityType = BusinessEntityType
global.BookFormatType = BookFormatType
global.GamePlayMode = GamePlayMode
global.CableOrSatelliteService = CableOrSatelliteService
global.TaxiService = TaxiService
global.GovernmentService = GovernmentService
global.FoodService = FoodService
global.BroadcastService = BroadcastService
global.FinancialProduct = FinancialProduct
global.Taxi = Taxi
global.RadioChannel = RadioChannel
global.TelevisionChannel = TelevisionChannel
global.GovernmentPermit = GovernmentPermit
global.AggregateOffer = AggregateOffer
global.BusReservation = BusReservation
global.FlightReservation = FlightReservation
global.RentalCarReservation = RentalCarReservation
global.TrainReservation = TrainReservation
global.FoodEstablishmentReservation = FoodEstablishmentReservation
global.LodgingReservation = LodgingReservation
global.ReservationPackage = ReservationPackage
global.EventReservation = EventReservation
global.TaxiReservation = TaxiReservation
global.Car = Car
global.SpreadsheetDigitalDocument = SpreadsheetDigitalDocument
global.NoteDigitalDocument = NoteDigitalDocument
global.PresentationDigitalDocument = PresentationDigitalDocument
global.TextDigitalDocument = TextDigitalDocument
global.MovieClip = MovieClip
global.VideoGameClip = VideoGameClip
global.RadioClip = RadioClip
global.TVClip = TVClip
global.WebApplication = WebApplication
global.MobileApplication = MobileApplication
global.VideoGame = VideoGame
global.DataFeed = DataFeed
global.NewsArticle = NewsArticle
global.TechArticle = TechArticle
global.SocialMediaPosting = SocialMediaPosting
global.Report = Report
global.ScholarlyArticle = ScholarlyArticle
global.MusicRelease = MusicRelease
global.MusicAlbum = MusicAlbum
global.Table = Table
global.WPSideBar = WPSideBar
global.WPAdBlock = WPAdBlock
global.WPHeader = WPHeader
global.SiteNavigationElement = SiteNavigationElement
global.WPFooter = WPFooter
global.Answer = Answer
global.EmailMessage = EmailMessage
global.ClaimReview = ClaimReview
global.RadioEpisode = RadioEpisode
global.TVEpisode = TVEpisode
global.DataDownload = DataDownload
global.MusicVideoObject = MusicVideoObject
global.AudioObject = AudioObject
global.ImageObject = ImageObject
global.VideoObject = VideoObject
global.ItemPage = ItemPage
global.ContactPage = ContactPage
global.CheckoutPage = CheckoutPage
global.QAPage = QAPage
global.CollectionPage = CollectionPage
global.SearchResultsPage = SearchResultsPage
global.ProfilePage = ProfilePage
global.AboutPage = AboutPage
global.BookSeries = BookSeries
global.VideoGameSeries = VideoGameSeries
global.MovieSeries = MovieSeries
global.Periodical = Periodical
global.RadioSeries = RadioSeries
global.RadioSeason = RadioSeason
global.CityHall = CityHall
global.DefenceEstablishment = DefenceEstablishment
global.LegislativeBuilding = LegislativeBuilding
global.Courthouse = Courthouse
global.Embassy = Embassy
global.HinduTemple = HinduTemple
global.Synagogue = Synagogue
global.Church = Church
global.BuddhistTemple = BuddhistTemple
global.Mosque = Mosque
global.CatholicChurch = CatholicChurch
global.MeetingRoom = MeetingRoom
global.HotelRoom = HotelRoom
global.SingleFamilyResidence = SingleFamilyResidence
global.LakeBodyOfWater = LakeBodyOfWater
global.RiverBodyOfWater = RiverBodyOfWater
global.OceanBodyOfWater = OceanBodyOfWater
global.Reservoir = Reservoir
global.SeaBodyOfWater = SeaBodyOfWater
global.Canal = Canal
global.Pond = Pond
global.Waterfall = Waterfall
global.InsertAction = InsertAction
global.CommentAction = CommentAction
global.AskAction = AskAction
global.CheckOutAction = CheckOutAction
global.ShareAction = ShareAction
global.InformAction = InformAction
global.CheckInAction = CheckInAction
global.ReplyAction = ReplyAction
global.InviteAction = InviteAction
global.RejectAction = RejectAction
global.AcceptAction = AcceptAction
global.AuthorizeAction = AuthorizeAction
global.AssignAction = AssignAction
global.ScheduleAction = ScheduleAction
global.CancelAction = CancelAction
global.ReserveAction = ReserveAction
global.VoteAction = VoteAction
global.DisagreeAction = DisagreeAction
global.DislikeAction = DislikeAction
global.EndorseAction = EndorseAction
global.AgreeAction = AgreeAction
global.WantAction = WantAction
global.LikeAction = LikeAction
global.WearAction = WearAction
global.PostOffice = PostOffice
global.CafeOrCoffeeShop = CafeOrCoffeeShop
global.Bakery = Bakery
global.IceCreamShop = IceCreamShop
global.Brewery = Brewery
global.FastFoodRestaurant = FastFoodRestaurant
global.BarOrPub = BarOrPub
global.Restaurant = Restaurant
global.Winery = Winery
global.StadiumOrArena = StadiumOrArena
global.SportsClub = SportsClub
global.GolfCourse = GolfCourse
global.ExerciseGym = ExerciseGym
global.BowlingAlley = BowlingAlley
global.TennisComplex = TennisComplex
global.SkiResort = SkiResort
global.PublicSwimmingPool = PublicSwimmingPool
global.Attorney = Attorney
global.Notary = Notary
global.HairSalon = HairSalon
global.TattooParlor = TattooParlor
global.HealthClub = HealthClub
global.NailSalon = NailSalon
global.BeautySalon = BeautySalon
global.DaySpa = DaySpa
global.Motel = Motel
global.Hostel = Hostel
global.BedAndBreakfast = BedAndBreakfast
global.Hotel = Hotel
global.Resort = Resort
global.InsuranceAgency = InsuranceAgency
global.AccountingService = AccountingService
global.BankOrCreditUnion = BankOrCreditUnion
global.AutomatedTeller = AutomatedTeller
global.JewelryStore = JewelryStore
global.PawnShop = PawnShop
global.MovieRentalStore = MovieRentalStore
global.HardwareStore = HardwareStore
global.WholesaleStore = WholesaleStore
global.TireShop = TireShop
global.MensClothingStore = MensClothingStore
global.HomeGoodsStore = HomeGoodsStore
global.LiquorStore = LiquorStore
global.BikeStore = BikeStore
global.ToyStore = ToyStore
global.OfficeEquipmentStore = OfficeEquipmentStore
global.SportingGoodsStore = SportingGoodsStore
global.MobilePhoneStore = MobilePhoneStore
global.FurnitureStore = FurnitureStore
global.OutletStore = OutletStore
global.GardenStore = GardenStore
global.Florist = Florist
global.GroceryStore = GroceryStore
global.HobbyShop = HobbyShop
global.ElectronicsStore = ElectronicsStore
global.ShoeStore = ShoeStore
global.AutoPartsStore = AutoPartsStore
global.MusicStore = MusicStore
global.DepartmentStore = DepartmentStore
global.PetStore = PetStore
global.ConvenienceStore = ConvenienceStore
global.ComputerStore = ComputerStore
global.BookStore = BookStore
global.ClothingStore = ClothingStore
global.AutoRepair = AutoRepair
global.GasStation = GasStation
global.AutoRental = AutoRental
global.MotorcycleRepair = MotorcycleRepair
global.MotorcycleDealer = MotorcycleDealer
global.AutoWash = AutoWash
global.AutoDealer = AutoDealer
global.AutoBodyShop = AutoBodyShop
global.NightClub = NightClub
global.AdultEntertainment = AdultEntertainment
global.ComedyClub = ComedyClub
global.Casino = Casino
global.AmusementPark = AmusementPark
global.ArtGallery = ArtGallery
global.GeneralContractor = GeneralContractor
global.Plumber = Plumber
global.RoofingContractor = RoofingContractor
global.MovingCompany = MovingCompany
global.HVACBusiness = HVACBusiness
global.Electrician = Electrician
global.Locksmith = Locksmith
global.HousePainter = HousePainter
global.LocationFeatureSpecification = LocationFeatureSpecification
global.CompoundPriceSpecification = CompoundPriceSpecification
global.DeliveryChargeSpecification = DeliveryChargeSpecification
global.PaymentChargeSpecification = PaymentChargeSpecification
global.UnitPriceSpecification = UnitPriceSpecification
global.GeoCircle = GeoCircle
global.PostalAddress = PostalAddress
global.ParentAudience = ParentAudience
global.EmployeeRole = EmployeeRole
global.LockerDelivery = LockerDelivery
global.ParcelService = ParcelService
global.SteeringPositionValue = SteeringPositionValue
global.DriveWheelConfigurationValue = DriveWheelConfigurationValue
global.PaymentCard = PaymentCard
global.LoanOrCredit = LoanOrCredit
global.InvestmentOrDeposit = InvestmentOrDeposit
global.PaymentService = PaymentService
global.BankAccount = BankAccount
global.CurrencyConversionService = CurrencyConversionService
global.APIReference = APIReference
global.BlogPosting = BlogPosting
global.DiscussionForumPosting = DiscussionForumPosting
global.Barcode = Barcode
global.ImageGallery = ImageGallery
global.VideoGallery = VideoGallery
global.AppendAction = AppendAction
global.PrependAction = PrependAction
global.RsvpAction = RsvpAction
global.ConfirmAction = ConfirmAction
global.CreditCard = CreditCard
global.DepositAccount = DepositAccount
global.LiveBlogPosting = LiveBlogPosting
global.Collection = Collection
global.ConceptScheme = ConceptScheme
global.Concept = Concept
global.OrderedCollection = OrderedCollection
global.EbacEncryptedValue = EbacEncryptedValue
global.EbacContactGrant = EbacContactGrant
global.EbacContact = EbacContact
global.EbacEncryptedSecret = EbacEncryptedSecret
global.EbacSignature = EbacSignature
global.EbacCredential = EbacCredential
global.EbacCredentialRequest = EbacCredentialRequest
global.EbacCredentials = EbacCredentials
global.EbacCredentialCommit = EbacCredentialCommit
global.Cass = Cass
global.AssertionCodebook = AssertionCodebook
global.Competency = Competency
global.Relation = Relation
global.Framework = Framework
global.Directory = Directory
global.Level = Level
global.RollupRule = RollupRule
global.Assertion = Assertion
global.AssertionEnvelope = AssertionEnvelope
global.EcAnswer = EcAnswer
global.EcPerson = EcPerson
global.EcCreativeWork = EcCreativeWork
global.EcComment = EcComment
global.EcQuiz = EcQuiz
global.EcQuestion = EcQuestion
global.EcOrganization = EcOrganization
global.RemoteIdentityManagerInterface = RemoteIdentityManagerInterface
global.EcRekeyRequest = EcRekeyRequest
global.EcContact = EcContact
global.EcIdentity = EcIdentity
global.EcIdentityManager = EcIdentityManager
global.OAuth2FileBasedRemoteIdentityManager = OAuth2FileBasedRemoteIdentityManager
global.EcRemoteIdentityManager = EcRemoteIdentityManager
global.EcContactGrant = EcContactGrant
global.EcEncryptedValue = EcEncryptedValue
global.GeneralFile = GeneralFile
global.EcRepository = EcRepository
global.EcFile = EcFile
global.EcDirectory = EcDirectory
global.EcRollupRule = EcRollupRule
global.EcAlignment = EcAlignment
global.EcConceptScheme = EcConceptScheme
global.EcConcept = EcConcept
global.EcAssertion = EcAssertion
global.EcLevel = EcLevel
global.EcCompetency = EcCompetency
global.EcFramework = EcFramework
global.RelationType = RelationType
global.Node = Node
global.PapCompetencyPrediction = PapCompetencyPrediction
global.NodeRelation = NodeRelation
global.RrS = RrS
global.RrToken = RrToken
global.RrQuery = RrQuery
global.CgEdge = CgEdge
global.SimpleAssertion = SimpleAssertion
global.InquiryPacket = InquiryPacket
global.PapSettings = PapSettings
global.ArrayUtil = ArrayUtil
global.NodePacket = NodePacket
global.NodeRelationMap = NodeRelationMap
global.AssertionCoprocessor = AssertionCoprocessor
global.PapDependencyDefinitionBase = PapDependencyDefinitionBase
global.PapDependencyParms = PapDependencyParms
global.PapUpdate = PapUpdate
global.PacketRelation = PacketRelation
global.ExceptionReturn = ExceptionReturn
global.RollupRuleInterface = RollupRuleInterface
global.PapCompetencyNetwork = PapCompetencyNetwork
global.PapAssertion = PapAssertion
global.EcGraphUtil = EcGraphUtil
global.PapNetworkPrediction = PapNetworkPrediction
global.NodeGraph = NodeGraph
global.CompetencyGraph = CompetencyGraph
global.RollupRulePacketGenerator = RollupRulePacketGenerator
global.RollupRuleGenerator = RollupRuleGenerator
global.RelationshipPacketGenerator = RelationshipPacketGenerator
global.AssertionProcessor = AssertionProcessor
global.PapDependencyDefinitions = PapDependencyDefinitions
global.TrustCoprocessor = TrustCoprocessor
global.OpenBadgeCoprocessor = OpenBadgeCoprocessor
global.PapDependency = PapDependency
global.NodePacketGraph = NodePacketGraph
global.EcFrameworkGraph = EcFrameworkGraph
global.TestGraphBuilder = TestGraphBuilder
global.CompetencyGraphBuilder = CompetencyGraphBuilder
global.RollupRuleProcessor = RollupRuleProcessor
global.PredictiveAssertionProcessor = PredictiveAssertionProcessor
global.CyclicGraphCollapser = CyclicGraphCollapser
global.ProfileProcessor = ProfileProcessor
global.CombinatorAssertionProcessor = CombinatorAssertionProcessor
global.FrameworkCollapser = FrameworkCollapser
global.OptimisticQuadnaryAssertionProcessor = OptimisticQuadnaryAssertionProcessor
global.PessimisticQuadnaryAssertionProcessor = PessimisticQuadnaryAssertionProcessor
global.Importer = Importer
global.Exporter = Exporter
global.PapaParseParams = PapaParseParams
global.ASNImport = ASNImport
global.MedbiqImport = MedbiqImport
global.TabStructuredImport = TabStructuredImport
global.FrameworkImport = FrameworkImport
global.CSVExport = CSVExport
global.CSVImport = CSVImport
global.CTDLASNCSVImport = CTDLASNCSVImport
global.CTDLASNCSVConceptImport = CTDLASNCSVConceptImport


var decls = "";

for (var j = 0; j < results.length; j++)
	for (var i = 0; i < results[j].body.length; i++)
		if (results[j].body[i].declarations != null)
			decls += "\nglobal." + results[j].body[i].declarations[0].id.name + " = " + results[j].body[i].declarations[0].id.name;

eval(decls);

global.forge = forge;
global.FormData = FormData;
global.antlr4 = antlr4;
global.pemJwk = pemJwk;
global.stjs = stjs;
global.base64 = base64;
global.jsonld = require('jsonld');
global.UUID = require('pure-uuid');